var LibP2PBundle = (() => {
  var __create = Object.create;
  var __defProp = Object.defineProperty;
  var __getOwnPropDesc = Object.getOwnPropertyDescriptor;
  var __getOwnPropNames = Object.getOwnPropertyNames;
  var __getProtoOf = Object.getPrototypeOf;
  var __hasOwnProp = Object.prototype.hasOwnProperty;
  var __commonJS = (cb, mod2) => function __require() {
    return mod2 || (0, cb[__getOwnPropNames(cb)[0]])((mod2 = { exports: {} }).exports, mod2), mod2.exports;
  };
  var __export = (target, all3) => {
    for (var name3 in all3)
      __defProp(target, name3, { get: all3[name3], enumerable: true });
  };
  var __copyProps = (to, from3, except, desc) => {
    if (from3 && typeof from3 === "object" || typeof from3 === "function") {
      for (let key of __getOwnPropNames(from3))
        if (!__hasOwnProp.call(to, key) && key !== except)
          __defProp(to, key, { get: () => from3[key], enumerable: !(desc = __getOwnPropDesc(from3, key)) || desc.enumerable });
    }
    return to;
  };
  var __toESM = (mod2, isNodeMode, target) => (target = mod2 != null ? __create(__getProtoOf(mod2)) : {}, __copyProps(
    // If the importer is in node compatibility mode or this is not an ESM
    // file that has been converted to a CommonJS file using a Babel-
    // compatible transform (i.e. "__esModule" has not been set), then set
    // "default" to the CommonJS "module.exports" for node compatibility.
    isNodeMode || !mod2 || !mod2.__esModule ? __defProp(target, "default", { value: mod2, enumerable: true }) : target,
    mod2
  ));
  var __toCommonJS = (mod2) => __copyProps(__defProp({}, "__esModule", { value: true }), mod2);

  // scripts/browser-shims.js
  var require_browser_shims = __commonJS({
    "scripts/browser-shims.js"(exports, module) {
      var Buffer2 = globalThis.Buffer || /* @__PURE__ */ (() => {
        class Buffer3 extends Uint8Array {
          static from(data) {
            if (typeof data === "string") {
              const encoder = new TextEncoder();
              return new Buffer3(encoder.encode(data));
            }
            return new Buffer3(data);
          }
          static isBuffer(obj) {
            return obj instanceof Buffer3;
          }
          toString() {
            const decoder = new TextDecoder();
            return decoder.decode(this);
          }
        }
        return Buffer3;
      })();
      var process2 = {
        env: {},
        nextTick: (fn) => queueMicrotask(fn),
        version: "v16.0.0",
        versions: {},
        browser: true
      };
      globalThis.Buffer = Buffer2;
      globalThis.process = process2;
      module.exports = { Buffer: Buffer2, process: process2 };
    }
  });

  // node_modules/eventemitter3/index.js
  var require_eventemitter3 = __commonJS({
    "node_modules/eventemitter3/index.js"(exports, module) {
      "use strict";
      var import_browser_shims438 = __toESM(require_browser_shims());
      var has = Object.prototype.hasOwnProperty;
      var prefix = "~";
      function Events() {
      }
      if (Object.create) {
        Events.prototype = /* @__PURE__ */ Object.create(null);
        if (!new Events().__proto__) prefix = false;
      }
      function EE(fn, context, once) {
        this.fn = fn;
        this.context = context;
        this.once = once || false;
      }
      function addListener(emitter, event, fn, context, once) {
        if (typeof fn !== "function") {
          throw new TypeError("The listener must be a function");
        }
        var listener = new EE(fn, context || emitter, once), evt = prefix ? prefix + event : event;
        if (!emitter._events[evt]) emitter._events[evt] = listener, emitter._eventsCount++;
        else if (!emitter._events[evt].fn) emitter._events[evt].push(listener);
        else emitter._events[evt] = [emitter._events[evt], listener];
        return emitter;
      }
      function clearEvent(emitter, evt) {
        if (--emitter._eventsCount === 0) emitter._events = new Events();
        else delete emitter._events[evt];
      }
      function EventEmitter2() {
        this._events = new Events();
        this._eventsCount = 0;
      }
      EventEmitter2.prototype.eventNames = function eventNames() {
        var names2 = [], events, name3;
        if (this._eventsCount === 0) return names2;
        for (name3 in events = this._events) {
          if (has.call(events, name3)) names2.push(prefix ? name3.slice(1) : name3);
        }
        if (Object.getOwnPropertySymbols) {
          return names2.concat(Object.getOwnPropertySymbols(events));
        }
        return names2;
      };
      EventEmitter2.prototype.listeners = function listeners(event) {
        var evt = prefix ? prefix + event : event, handlers = this._events[evt];
        if (!handlers) return [];
        if (handlers.fn) return [handlers.fn];
        for (var i = 0, l = handlers.length, ee = new Array(l); i < l; i++) {
          ee[i] = handlers[i].fn;
        }
        return ee;
      };
      EventEmitter2.prototype.listenerCount = function listenerCount(event) {
        var evt = prefix ? prefix + event : event, listeners = this._events[evt];
        if (!listeners) return 0;
        if (listeners.fn) return 1;
        return listeners.length;
      };
      EventEmitter2.prototype.emit = function emit(event, a1, a2, a3, a4, a5) {
        var evt = prefix ? prefix + event : event;
        if (!this._events[evt]) return false;
        var listeners = this._events[evt], len = arguments.length, args, i;
        if (listeners.fn) {
          if (listeners.once) this.removeListener(event, listeners.fn, void 0, true);
          switch (len) {
            case 1:
              return listeners.fn.call(listeners.context), true;
            case 2:
              return listeners.fn.call(listeners.context, a1), true;
            case 3:
              return listeners.fn.call(listeners.context, a1, a2), true;
            case 4:
              return listeners.fn.call(listeners.context, a1, a2, a3), true;
            case 5:
              return listeners.fn.call(listeners.context, a1, a2, a3, a4), true;
            case 6:
              return listeners.fn.call(listeners.context, a1, a2, a3, a4, a5), true;
          }
          for (i = 1, args = new Array(len - 1); i < len; i++) {
            args[i - 1] = arguments[i];
          }
          listeners.fn.apply(listeners.context, args);
        } else {
          var length4 = listeners.length, j;
          for (i = 0; i < length4; i++) {
            if (listeners[i].once) this.removeListener(event, listeners[i].fn, void 0, true);
            switch (len) {
              case 1:
                listeners[i].fn.call(listeners[i].context);
                break;
              case 2:
                listeners[i].fn.call(listeners[i].context, a1);
                break;
              case 3:
                listeners[i].fn.call(listeners[i].context, a1, a2);
                break;
              case 4:
                listeners[i].fn.call(listeners[i].context, a1, a2, a3);
                break;
              default:
                if (!args) for (j = 1, args = new Array(len - 1); j < len; j++) {
                  args[j - 1] = arguments[j];
                }
                listeners[i].fn.apply(listeners[i].context, args);
            }
          }
        }
        return true;
      };
      EventEmitter2.prototype.on = function on(event, fn, context) {
        return addListener(this, event, fn, context, false);
      };
      EventEmitter2.prototype.once = function once(event, fn, context) {
        return addListener(this, event, fn, context, true);
      };
      EventEmitter2.prototype.removeListener = function removeListener(event, fn, context, once) {
        var evt = prefix ? prefix + event : event;
        if (!this._events[evt]) return this;
        if (!fn) {
          clearEvent(this, evt);
          return this;
        }
        var listeners = this._events[evt];
        if (listeners.fn) {
          if (listeners.fn === fn && (!once || listeners.once) && (!context || listeners.context === context)) {
            clearEvent(this, evt);
          }
        } else {
          for (var i = 0, events = [], length4 = listeners.length; i < length4; i++) {
            if (listeners[i].fn !== fn || once && !listeners[i].once || context && listeners[i].context !== context) {
              events.push(listeners[i]);
            }
          }
          if (events.length) this._events[evt] = events.length === 1 ? events[0] : events;
          else clearEvent(this, evt);
        }
        return this;
      };
      EventEmitter2.prototype.removeAllListeners = function removeAllListeners(event) {
        var evt;
        if (event) {
          evt = prefix ? prefix + event : event;
          if (this._events[evt]) clearEvent(this, evt);
        } else {
          this._events = new Events();
          this._eventsCount = 0;
        }
        return this;
      };
      EventEmitter2.prototype.off = EventEmitter2.prototype.removeListener;
      EventEmitter2.prototype.addListener = EventEmitter2.prototype.on;
      EventEmitter2.prefixed = prefix;
      EventEmitter2.EventEmitter = EventEmitter2;
      if ("undefined" !== typeof module) {
        module.exports = EventEmitter2;
      }
    }
  });

  // node_modules/hashlru/index.js
  var require_hashlru = __commonJS({
    "node_modules/hashlru/index.js"(exports, module) {
      var import_browser_shims438 = __toESM(require_browser_shims());
      module.exports = function(max) {
        if (!max) throw Error("hashlru must have a max value, of type number, greater than 0");
        var size = 0, cache4 = /* @__PURE__ */ Object.create(null), _cache = /* @__PURE__ */ Object.create(null);
        function update(key, value) {
          cache4[key] = value;
          size++;
          if (size >= max) {
            size = 0;
            _cache = cache4;
            cache4 = /* @__PURE__ */ Object.create(null);
          }
        }
        return {
          has: function(key) {
            return cache4[key] !== void 0 || _cache[key] !== void 0;
          },
          remove: function(key) {
            if (cache4[key] !== void 0)
              cache4[key] = void 0;
            if (_cache[key] !== void 0)
              _cache[key] = void 0;
          },
          get: function(key) {
            var v = cache4[key];
            if (v !== void 0) return v;
            if ((v = _cache[key]) !== void 0) {
              update(key, v);
              return v;
            }
          },
          set: function(key, value) {
            if (cache4[key] !== void 0) cache4[key] = value;
            else update(key, value);
          },
          clear: function() {
            cache4 = /* @__PURE__ */ Object.create(null);
            _cache = /* @__PURE__ */ Object.create(null);
          }
        };
      };
    }
  });

  // node_modules/netmask/lib/netmask.js
  var require_netmask = __commonJS({
    "node_modules/netmask/lib/netmask.js"(exports) {
      var import_browser_shims438 = __toESM(require_browser_shims());
      (function() {
        var Netmask2, atob, chr, chr0, chrA, chra, ip2long, long2ip;
        long2ip = function(long) {
          var a, b, c, d2;
          a = (long & 255 << 24) >>> 24;
          b = (long & 255 << 16) >>> 16;
          c = (long & 255 << 8) >>> 8;
          d2 = long & 255;
          return [a, b, c, d2].join(".");
        };
        ip2long = function(ip) {
          var b, c, i, j, n, ref;
          b = [];
          for (i = j = 0; j <= 3; i = ++j) {
            if (ip.length === 0) {
              break;
            }
            if (i > 0) {
              if (ip[0] !== ".") {
                throw new Error("Invalid IP");
              }
              ip = ip.substring(1);
            }
            ref = atob(ip), n = ref[0], c = ref[1];
            ip = ip.substring(c);
            b.push(n);
          }
          if (ip.length !== 0) {
            throw new Error("Invalid IP");
          }
          switch (b.length) {
            case 1:
              if (b[0] > 4294967295) {
                throw new Error("Invalid IP");
              }
              return b[0] >>> 0;
            case 2:
              if (b[0] > 255 || b[1] > 16777215) {
                throw new Error("Invalid IP");
              }
              return (b[0] << 24 | b[1]) >>> 0;
            case 3:
              if (b[0] > 255 || b[1] > 255 || b[2] > 65535) {
                throw new Error("Invalid IP");
              }
              return (b[0] << 24 | b[1] << 16 | b[2]) >>> 0;
            case 4:
              if (b[0] > 255 || b[1] > 255 || b[2] > 255 || b[3] > 255) {
                throw new Error("Invalid IP");
              }
              return (b[0] << 24 | b[1] << 16 | b[2] << 8 | b[3]) >>> 0;
            default:
              throw new Error("Invalid IP");
          }
        };
        chr = function(b) {
          return b.charCodeAt(0);
        };
        chr0 = chr("0");
        chra = chr("a");
        chrA = chr("A");
        atob = function(s2) {
          var base3, dmax, i, n, start2;
          n = 0;
          base3 = 10;
          dmax = "9";
          i = 0;
          if (s2.length > 1 && s2[i] === "0") {
            if (s2[i + 1] === "x" || s2[i + 1] === "X") {
              i += 2;
              base3 = 16;
            } else if ("0" <= s2[i + 1] && s2[i + 1] <= "9") {
              i++;
              base3 = 8;
              dmax = "7";
            }
          }
          start2 = i;
          while (i < s2.length) {
            if ("0" <= s2[i] && s2[i] <= dmax) {
              n = n * base3 + (chr(s2[i]) - chr0) >>> 0;
            } else if (base3 === 16) {
              if ("a" <= s2[i] && s2[i] <= "f") {
                n = n * base3 + (10 + chr(s2[i]) - chra) >>> 0;
              } else if ("A" <= s2[i] && s2[i] <= "F") {
                n = n * base3 + (10 + chr(s2[i]) - chrA) >>> 0;
              } else {
                break;
              }
            } else {
              break;
            }
            if (n > 4294967295) {
              throw new Error("too large");
            }
            i++;
          }
          if (i === start2) {
            throw new Error("empty octet");
          }
          return [n, i];
        };
        Netmask2 = function() {
          function Netmask3(net, mask) {
            var error, i, j, ref;
            if (typeof net !== "string") {
              throw new Error("Missing `net' parameter");
            }
            if (!mask) {
              ref = net.split("/", 2), net = ref[0], mask = ref[1];
            }
            if (!mask) {
              mask = 32;
            }
            if (typeof mask === "string" && mask.indexOf(".") > -1) {
              try {
                this.maskLong = ip2long(mask);
              } catch (error1) {
                error = error1;
                throw new Error("Invalid mask: " + mask);
              }
              for (i = j = 32; j >= 0; i = --j) {
                if (this.maskLong === 4294967295 << 32 - i >>> 0) {
                  this.bitmask = i;
                  break;
                }
              }
            } else if (mask || mask === 0) {
              this.bitmask = parseInt(mask, 10);
              this.maskLong = 0;
              if (this.bitmask > 0) {
                this.maskLong = 4294967295 << 32 - this.bitmask >>> 0;
              }
            } else {
              throw new Error("Invalid mask: empty");
            }
            try {
              this.netLong = (ip2long(net) & this.maskLong) >>> 0;
            } catch (error1) {
              error = error1;
              throw new Error("Invalid net address: " + net);
            }
            if (!(this.bitmask <= 32)) {
              throw new Error("Invalid mask for ip4: " + mask);
            }
            this.size = Math.pow(2, 32 - this.bitmask);
            this.base = long2ip(this.netLong);
            this.mask = long2ip(this.maskLong);
            this.hostmask = long2ip(~this.maskLong);
            this.first = this.bitmask <= 30 ? long2ip(this.netLong + 1) : this.base;
            this.last = this.bitmask <= 30 ? long2ip(this.netLong + this.size - 2) : long2ip(this.netLong + this.size - 1);
            this.broadcast = this.bitmask <= 30 ? long2ip(this.netLong + this.size - 1) : void 0;
          }
          Netmask3.prototype.contains = function(ip) {
            if (typeof ip === "string" && (ip.indexOf("/") > 0 || ip.split(".").length !== 4)) {
              ip = new Netmask3(ip);
            }
            if (ip instanceof Netmask3) {
              return this.contains(ip.base) && this.contains(ip.broadcast || ip.last);
            } else {
              return (ip2long(ip) & this.maskLong) >>> 0 === (this.netLong & this.maskLong) >>> 0;
            }
          };
          Netmask3.prototype.next = function(count) {
            if (count == null) {
              count = 1;
            }
            return new Netmask3(long2ip(this.netLong + this.size * count), this.mask);
          };
          Netmask3.prototype.forEach = function(fn) {
            var index, lastLong, long;
            long = ip2long(this.first);
            lastLong = ip2long(this.last);
            index = 0;
            while (long <= lastLong) {
              fn(long2ip(long), long, index);
              index++;
              long++;
            }
          };
          Netmask3.prototype.toString = function() {
            return this.base + "/" + this.bitmask;
          };
          return Netmask3;
        }();
        exports.ip2long = ip2long;
        exports.long2ip = long2ip;
        exports.Netmask = Netmask2;
      }).call(exports);
    }
  });

  // node_modules/retry/lib/retry_operation.js
  var require_retry_operation = __commonJS({
    "node_modules/retry/lib/retry_operation.js"(exports, module) {
      var import_browser_shims438 = __toESM(require_browser_shims());
      function RetryOperation(timeouts, options) {
        if (typeof options === "boolean") {
          options = { forever: options };
        }
        this._originalTimeouts = JSON.parse(JSON.stringify(timeouts));
        this._timeouts = timeouts;
        this._options = options || {};
        this._maxRetryTime = options && options.maxRetryTime || Infinity;
        this._fn = null;
        this._errors = [];
        this._attempts = 1;
        this._operationTimeout = null;
        this._operationTimeoutCb = null;
        this._timeout = null;
        this._operationStart = null;
        this._timer = null;
        if (this._options.forever) {
          this._cachedTimeouts = this._timeouts.slice(0);
        }
      }
      module.exports = RetryOperation;
      RetryOperation.prototype.reset = function() {
        this._attempts = 1;
        this._timeouts = this._originalTimeouts.slice(0);
      };
      RetryOperation.prototype.stop = function() {
        if (this._timeout) {
          clearTimeout(this._timeout);
        }
        if (this._timer) {
          clearTimeout(this._timer);
        }
        this._timeouts = [];
        this._cachedTimeouts = null;
      };
      RetryOperation.prototype.retry = function(err) {
        if (this._timeout) {
          clearTimeout(this._timeout);
        }
        if (!err) {
          return false;
        }
        var currentTime = (/* @__PURE__ */ new Date()).getTime();
        if (err && currentTime - this._operationStart >= this._maxRetryTime) {
          this._errors.push(err);
          this._errors.unshift(new Error("RetryOperation timeout occurred"));
          return false;
        }
        this._errors.push(err);
        var timeout = this._timeouts.shift();
        if (timeout === void 0) {
          if (this._cachedTimeouts) {
            this._errors.splice(0, this._errors.length - 1);
            timeout = this._cachedTimeouts.slice(-1);
          } else {
            return false;
          }
        }
        var self = this;
        this._timer = setTimeout(function() {
          self._attempts++;
          if (self._operationTimeoutCb) {
            self._timeout = setTimeout(function() {
              self._operationTimeoutCb(self._attempts);
            }, self._operationTimeout);
            if (self._options.unref) {
              self._timeout.unref();
            }
          }
          self._fn(self._attempts);
        }, timeout);
        if (this._options.unref) {
          this._timer.unref();
        }
        return true;
      };
      RetryOperation.prototype.attempt = function(fn, timeoutOps) {
        this._fn = fn;
        if (timeoutOps) {
          if (timeoutOps.timeout) {
            this._operationTimeout = timeoutOps.timeout;
          }
          if (timeoutOps.cb) {
            this._operationTimeoutCb = timeoutOps.cb;
          }
        }
        var self = this;
        if (this._operationTimeoutCb) {
          this._timeout = setTimeout(function() {
            self._operationTimeoutCb();
          }, self._operationTimeout);
        }
        this._operationStart = (/* @__PURE__ */ new Date()).getTime();
        this._fn(this._attempts);
      };
      RetryOperation.prototype.try = function(fn) {
        console.log("Using RetryOperation.try() is deprecated");
        this.attempt(fn);
      };
      RetryOperation.prototype.start = function(fn) {
        console.log("Using RetryOperation.start() is deprecated");
        this.attempt(fn);
      };
      RetryOperation.prototype.start = RetryOperation.prototype.try;
      RetryOperation.prototype.errors = function() {
        return this._errors;
      };
      RetryOperation.prototype.attempts = function() {
        return this._attempts;
      };
      RetryOperation.prototype.mainError = function() {
        if (this._errors.length === 0) {
          return null;
        }
        var counts = {};
        var mainError = null;
        var mainErrorCount = 0;
        for (var i = 0; i < this._errors.length; i++) {
          var error = this._errors[i];
          var message2 = error.message;
          var count = (counts[message2] || 0) + 1;
          counts[message2] = count;
          if (count >= mainErrorCount) {
            mainError = error;
            mainErrorCount = count;
          }
        }
        return mainError;
      };
    }
  });

  // node_modules/retry/lib/retry.js
  var require_retry = __commonJS({
    "node_modules/retry/lib/retry.js"(exports) {
      var import_browser_shims438 = __toESM(require_browser_shims());
      var RetryOperation = require_retry_operation();
      exports.operation = function(options) {
        var timeouts = exports.timeouts(options);
        return new RetryOperation(timeouts, {
          forever: options && (options.forever || options.retries === Infinity),
          unref: options && options.unref,
          maxRetryTime: options && options.maxRetryTime
        });
      };
      exports.timeouts = function(options) {
        if (options instanceof Array) {
          return [].concat(options);
        }
        var opts = {
          retries: 10,
          factor: 2,
          minTimeout: 1 * 1e3,
          maxTimeout: Infinity,
          randomize: false
        };
        for (var key in options) {
          opts[key] = options[key];
        }
        if (opts.minTimeout > opts.maxTimeout) {
          throw new Error("minTimeout is greater than maxTimeout");
        }
        var timeouts = [];
        for (var i = 0; i < opts.retries; i++) {
          timeouts.push(this.createTimeout(i, opts));
        }
        if (options && options.forever && !timeouts.length) {
          timeouts.push(this.createTimeout(i, opts));
        }
        timeouts.sort(function(a, b) {
          return a - b;
        });
        return timeouts;
      };
      exports.createTimeout = function(attempt, opts) {
        var random = opts.randomize ? Math.random() + 1 : 1;
        var timeout = Math.round(random * Math.max(opts.minTimeout, 1) * Math.pow(opts.factor, attempt));
        timeout = Math.min(timeout, opts.maxTimeout);
        return timeout;
      };
      exports.wrap = function(obj, options, methods) {
        if (options instanceof Array) {
          methods = options;
          options = null;
        }
        if (!methods) {
          methods = [];
          for (var key in obj) {
            if (typeof obj[key] === "function") {
              methods.push(key);
            }
          }
        }
        for (var i = 0; i < methods.length; i++) {
          var method = methods[i];
          var original = obj[method];
          obj[method] = function retryWrapper(original2) {
            var op = exports.operation(options);
            var args = Array.prototype.slice.call(arguments, 1);
            var callback = args.pop();
            args.push(function(err) {
              if (op.retry(err)) {
                return;
              }
              if (err) {
                arguments[0] = op.mainError();
              }
              callback.apply(this, arguments);
            });
            op.attempt(function() {
              original2.apply(obj, args);
            });
          }.bind(obj, original);
          obj[method].options = options;
        }
      };
    }
  });

  // node_modules/retry/index.js
  var require_retry2 = __commonJS({
    "node_modules/retry/index.js"(exports, module) {
      var import_browser_shims438 = __toESM(require_browser_shims());
      module.exports = require_retry();
    }
  });

  // node_modules/denque/index.js
  var require_denque = __commonJS({
    "node_modules/denque/index.js"(exports, module) {
      "use strict";
      var import_browser_shims438 = __toESM(require_browser_shims());
      function Denque2(array, options) {
        var options = options || {};
        this._capacity = options.capacity;
        this._head = 0;
        this._tail = 0;
        if (Array.isArray(array)) {
          this._fromArray(array);
        } else {
          this._capacityMask = 3;
          this._list = new Array(4);
        }
      }
      Denque2.prototype.peekAt = function peekAt(index) {
        var i = index;
        if (i !== (i | 0)) {
          return void 0;
        }
        var len = this.size();
        if (i >= len || i < -len) return void 0;
        if (i < 0) i += len;
        i = this._head + i & this._capacityMask;
        return this._list[i];
      };
      Denque2.prototype.get = function get(i) {
        return this.peekAt(i);
      };
      Denque2.prototype.peek = function peek() {
        if (this._head === this._tail) return void 0;
        return this._list[this._head];
      };
      Denque2.prototype.peekFront = function peekFront() {
        return this.peek();
      };
      Denque2.prototype.peekBack = function peekBack() {
        return this.peekAt(-1);
      };
      Object.defineProperty(Denque2.prototype, "length", {
        get: function length4() {
          return this.size();
        }
      });
      Denque2.prototype.size = function size() {
        if (this._head === this._tail) return 0;
        if (this._head < this._tail) return this._tail - this._head;
        else return this._capacityMask + 1 - (this._head - this._tail);
      };
      Denque2.prototype.unshift = function unshift(item) {
        if (arguments.length === 0) return this.size();
        var len = this._list.length;
        this._head = this._head - 1 + len & this._capacityMask;
        this._list[this._head] = item;
        if (this._tail === this._head) this._growArray();
        if (this._capacity && this.size() > this._capacity) this.pop();
        if (this._head < this._tail) return this._tail - this._head;
        else return this._capacityMask + 1 - (this._head - this._tail);
      };
      Denque2.prototype.shift = function shift() {
        var head = this._head;
        if (head === this._tail) return void 0;
        var item = this._list[head];
        this._list[head] = void 0;
        this._head = head + 1 & this._capacityMask;
        if (head < 2 && this._tail > 1e4 && this._tail <= this._list.length >>> 2) this._shrinkArray();
        return item;
      };
      Denque2.prototype.push = function push(item) {
        if (arguments.length === 0) return this.size();
        var tail = this._tail;
        this._list[tail] = item;
        this._tail = tail + 1 & this._capacityMask;
        if (this._tail === this._head) {
          this._growArray();
        }
        if (this._capacity && this.size() > this._capacity) {
          this.shift();
        }
        if (this._head < this._tail) return this._tail - this._head;
        else return this._capacityMask + 1 - (this._head - this._tail);
      };
      Denque2.prototype.pop = function pop() {
        var tail = this._tail;
        if (tail === this._head) return void 0;
        var len = this._list.length;
        this._tail = tail - 1 + len & this._capacityMask;
        var item = this._list[this._tail];
        this._list[this._tail] = void 0;
        if (this._head < 2 && tail > 1e4 && tail <= len >>> 2) this._shrinkArray();
        return item;
      };
      Denque2.prototype.removeOne = function removeOne(index) {
        var i = index;
        if (i !== (i | 0)) {
          return void 0;
        }
        if (this._head === this._tail) return void 0;
        var size = this.size();
        var len = this._list.length;
        if (i >= size || i < -size) return void 0;
        if (i < 0) i += size;
        i = this._head + i & this._capacityMask;
        var item = this._list[i];
        var k;
        if (index < size / 2) {
          for (k = index; k > 0; k--) {
            this._list[i] = this._list[i = i - 1 + len & this._capacityMask];
          }
          this._list[i] = void 0;
          this._head = this._head + 1 + len & this._capacityMask;
        } else {
          for (k = size - 1 - index; k > 0; k--) {
            this._list[i] = this._list[i = i + 1 + len & this._capacityMask];
          }
          this._list[i] = void 0;
          this._tail = this._tail - 1 + len & this._capacityMask;
        }
        return item;
      };
      Denque2.prototype.remove = function remove(index, count) {
        var i = index;
        var removed;
        var del_count = count;
        if (i !== (i | 0)) {
          return void 0;
        }
        if (this._head === this._tail) return void 0;
        var size = this.size();
        var len = this._list.length;
        if (i >= size || i < -size || count < 1) return void 0;
        if (i < 0) i += size;
        if (count === 1 || !count) {
          removed = new Array(1);
          removed[0] = this.removeOne(i);
          return removed;
        }
        if (i === 0 && i + count >= size) {
          removed = this.toArray();
          this.clear();
          return removed;
        }
        if (i + count > size) count = size - i;
        var k;
        removed = new Array(count);
        for (k = 0; k < count; k++) {
          removed[k] = this._list[this._head + i + k & this._capacityMask];
        }
        i = this._head + i & this._capacityMask;
        if (index + count === size) {
          this._tail = this._tail - count + len & this._capacityMask;
          for (k = count; k > 0; k--) {
            this._list[i = i + 1 + len & this._capacityMask] = void 0;
          }
          return removed;
        }
        if (index === 0) {
          this._head = this._head + count + len & this._capacityMask;
          for (k = count - 1; k > 0; k--) {
            this._list[i = i + 1 + len & this._capacityMask] = void 0;
          }
          return removed;
        }
        if (i < size / 2) {
          this._head = this._head + index + count + len & this._capacityMask;
          for (k = index; k > 0; k--) {
            this.unshift(this._list[i = i - 1 + len & this._capacityMask]);
          }
          i = this._head - 1 + len & this._capacityMask;
          while (del_count > 0) {
            this._list[i = i - 1 + len & this._capacityMask] = void 0;
            del_count--;
          }
          if (index < 0) this._tail = i;
        } else {
          this._tail = i;
          i = i + count + len & this._capacityMask;
          for (k = size - (count + index); k > 0; k--) {
            this.push(this._list[i++]);
          }
          i = this._tail;
          while (del_count > 0) {
            this._list[i = i + 1 + len & this._capacityMask] = void 0;
            del_count--;
          }
        }
        if (this._head < 2 && this._tail > 1e4 && this._tail <= len >>> 2) this._shrinkArray();
        return removed;
      };
      Denque2.prototype.splice = function splice(index, count) {
        var i = index;
        if (i !== (i | 0)) {
          return void 0;
        }
        var size = this.size();
        if (i < 0) i += size;
        if (i > size) return void 0;
        if (arguments.length > 2) {
          var k;
          var temp;
          var removed;
          var arg_len = arguments.length;
          var len = this._list.length;
          var arguments_index = 2;
          if (!size || i < size / 2) {
            temp = new Array(i);
            for (k = 0; k < i; k++) {
              temp[k] = this._list[this._head + k & this._capacityMask];
            }
            if (count === 0) {
              removed = [];
              if (i > 0) {
                this._head = this._head + i + len & this._capacityMask;
              }
            } else {
              removed = this.remove(i, count);
              this._head = this._head + i + len & this._capacityMask;
            }
            while (arg_len > arguments_index) {
              this.unshift(arguments[--arg_len]);
            }
            for (k = i; k > 0; k--) {
              this.unshift(temp[k - 1]);
            }
          } else {
            temp = new Array(size - (i + count));
            var leng = temp.length;
            for (k = 0; k < leng; k++) {
              temp[k] = this._list[this._head + i + count + k & this._capacityMask];
            }
            if (count === 0) {
              removed = [];
              if (i != size) {
                this._tail = this._head + i + len & this._capacityMask;
              }
            } else {
              removed = this.remove(i, count);
              this._tail = this._tail - leng + len & this._capacityMask;
            }
            while (arguments_index < arg_len) {
              this.push(arguments[arguments_index++]);
            }
            for (k = 0; k < leng; k++) {
              this.push(temp[k]);
            }
          }
          return removed;
        } else {
          return this.remove(i, count);
        }
      };
      Denque2.prototype.clear = function clear() {
        this._list = new Array(this._list.length);
        this._head = 0;
        this._tail = 0;
      };
      Denque2.prototype.isEmpty = function isEmpty() {
        return this._head === this._tail;
      };
      Denque2.prototype.toArray = function toArray() {
        return this._copyArray(false);
      };
      Denque2.prototype._fromArray = function _fromArray(array) {
        var length4 = array.length;
        var capacity = this._nextPowerOf2(length4);
        this._list = new Array(capacity);
        this._capacityMask = capacity - 1;
        this._tail = length4;
        for (var i = 0; i < length4; i++) this._list[i] = array[i];
      };
      Denque2.prototype._copyArray = function _copyArray(fullCopy, size) {
        var src2 = this._list;
        var capacity = src2.length;
        var length4 = this.length;
        size = size | length4;
        if (size == length4 && this._head < this._tail) {
          return this._list.slice(this._head, this._tail);
        }
        var dest = new Array(size);
        var k = 0;
        var i;
        if (fullCopy || this._head > this._tail) {
          for (i = this._head; i < capacity; i++) dest[k++] = src2[i];
          for (i = 0; i < this._tail; i++) dest[k++] = src2[i];
        } else {
          for (i = this._head; i < this._tail; i++) dest[k++] = src2[i];
        }
        return dest;
      };
      Denque2.prototype._growArray = function _growArray() {
        if (this._head != 0) {
          var newList = this._copyArray(true, this._list.length << 1);
          this._tail = this._list.length;
          this._head = 0;
          this._list = newList;
        } else {
          this._tail = this._list.length;
          this._list.length <<= 1;
        }
        this._capacityMask = this._capacityMask << 1 | 1;
      };
      Denque2.prototype._shrinkArray = function _shrinkArray() {
        this._list.length >>>= 1;
        this._capacityMask >>>= 1;
      };
      Denque2.prototype._nextPowerOf2 = function _nextPowerOf2(num) {
        var log2 = Math.log(num) / Math.log(2);
        var nextPow2 = 1 << log2 + 1;
        return Math.max(nextPow2, 4);
      };
      module.exports = Denque2;
    }
  });

  // node_modules/event-iterator/lib/event-iterator.js
  var require_event_iterator = __commonJS({
    "node_modules/event-iterator/lib/event-iterator.js"(exports) {
      "use strict";
      var import_browser_shims438 = __toESM(require_browser_shims());
      Object.defineProperty(exports, "__esModule", { value: true });
      var EventQueue = class {
        constructor() {
          this.pullQueue = [];
          this.pushQueue = [];
          this.eventHandlers = {};
          this.isPaused = false;
          this.isStopped = false;
        }
        push(value) {
          if (this.isStopped)
            return;
          const resolution = { value, done: false };
          if (this.pullQueue.length) {
            const placeholder = this.pullQueue.shift();
            if (placeholder)
              placeholder.resolve(resolution);
          } else {
            this.pushQueue.push(Promise.resolve(resolution));
            if (this.highWaterMark !== void 0 && this.pushQueue.length >= this.highWaterMark && !this.isPaused) {
              this.isPaused = true;
              if (this.eventHandlers.highWater) {
                this.eventHandlers.highWater();
              } else if (console) {
                console.warn(`EventIterator queue reached ${this.pushQueue.length} items`);
              }
            }
          }
        }
        stop() {
          if (this.isStopped)
            return;
          this.isStopped = true;
          this.remove();
          for (const placeholder of this.pullQueue) {
            placeholder.resolve({ value: void 0, done: true });
          }
          this.pullQueue.length = 0;
        }
        fail(error) {
          if (this.isStopped)
            return;
          this.isStopped = true;
          this.remove();
          if (this.pullQueue.length) {
            for (const placeholder of this.pullQueue) {
              placeholder.reject(error);
            }
            this.pullQueue.length = 0;
          } else {
            const rejection = Promise.reject(error);
            rejection.catch(() => {
            });
            this.pushQueue.push(rejection);
          }
        }
        remove() {
          Promise.resolve().then(() => {
            if (this.removeCallback)
              this.removeCallback();
          });
        }
        [Symbol.asyncIterator]() {
          return {
            next: (value) => {
              const result = this.pushQueue.shift();
              if (result) {
                if (this.lowWaterMark !== void 0 && this.pushQueue.length <= this.lowWaterMark && this.isPaused) {
                  this.isPaused = false;
                  if (this.eventHandlers.lowWater) {
                    this.eventHandlers.lowWater();
                  }
                }
                return result;
              } else if (this.isStopped) {
                return Promise.resolve({ value: void 0, done: true });
              } else {
                return new Promise((resolve, reject) => {
                  this.pullQueue.push({ resolve, reject });
                });
              }
            },
            return: () => {
              this.isStopped = true;
              this.pushQueue.length = 0;
              this.remove();
              return Promise.resolve({ value: void 0, done: true });
            }
          };
        }
      };
      var EventIterator2 = class {
        constructor(listen, { highWaterMark = 100, lowWaterMark = 1 } = {}) {
          const queue = new EventQueue();
          queue.highWaterMark = highWaterMark;
          queue.lowWaterMark = lowWaterMark;
          queue.removeCallback = listen({
            push: (value) => queue.push(value),
            stop: () => queue.stop(),
            fail: (error) => queue.fail(error),
            on: (event, fn) => {
              queue.eventHandlers[event] = fn;
            }
          }) || (() => {
          });
          this[Symbol.asyncIterator] = () => queue[Symbol.asyncIterator]();
          Object.freeze(this);
        }
      };
      exports.EventIterator = EventIterator2;
      exports.default = EventIterator2;
    }
  });

  // node_modules/event-iterator/lib/dom.js
  var require_dom = __commonJS({
    "node_modules/event-iterator/lib/dom.js"(exports) {
      "use strict";
      var import_browser_shims438 = __toESM(require_browser_shims());
      Object.defineProperty(exports, "__esModule", { value: true });
      var event_iterator_1 = require_event_iterator();
      exports.EventIterator = event_iterator_1.EventIterator;
      function subscribe(event, options, evOptions) {
        return new event_iterator_1.EventIterator(({ push }) => {
          this.addEventListener(event, push, options);
          return () => this.removeEventListener(event, push, options);
        }, evOptions);
      }
      exports.subscribe = subscribe;
      exports.default = event_iterator_1.EventIterator;
    }
  });

  // chrome-extension/libp2p-client.js
  var libp2p_client_exports = {};
  __export(libp2p_client_exports, {
    LibP2PClient: () => LibP2PClient
  });
  var import_browser_shims437 = __toESM(require_browser_shims());

  // node_modules/libp2p/dist/src/index.js
  var import_browser_shims272 = __toESM(require_browser_shims(), 1);

  // node_modules/@libp2p/crypto/dist/src/keys/index.js
  var import_browser_shims100 = __toESM(require_browser_shims(), 1);

  // node_modules/@libp2p/interface/dist/src/index.js
  var import_browser_shims13 = __toESM(require_browser_shims(), 1);

  // node_modules/@libp2p/interface/dist/src/connection.js
  var import_browser_shims = __toESM(require_browser_shims(), 1);
  var connectionSymbol = Symbol.for("@libp2p/connection");

  // node_modules/@libp2p/interface/dist/src/content-routing.js
  var import_browser_shims2 = __toESM(require_browser_shims(), 1);
  var contentRoutingSymbol = Symbol.for("@libp2p/content-routing");

  // node_modules/@libp2p/interface/dist/src/peer-discovery.js
  var import_browser_shims3 = __toESM(require_browser_shims(), 1);
  var peerDiscoverySymbol = Symbol.for("@libp2p/peer-discovery");

  // node_modules/@libp2p/interface/dist/src/peer-id.js
  var import_browser_shims4 = __toESM(require_browser_shims(), 1);
  var peerIdSymbol = Symbol.for("@libp2p/peer-id");
  function isPeerId(other) {
    return Boolean(other == null ? void 0 : other[peerIdSymbol]);
  }

  // node_modules/@libp2p/interface/dist/src/peer-routing.js
  var import_browser_shims5 = __toESM(require_browser_shims(), 1);
  var peerRoutingSymbol = Symbol.for("@libp2p/peer-routing");

  // node_modules/@libp2p/interface/dist/src/peer-store.js
  var import_browser_shims6 = __toESM(require_browser_shims(), 1);
  var KEEP_ALIVE = "keep-alive";

  // node_modules/@libp2p/interface/dist/src/pubsub.js
  var import_browser_shims7 = __toESM(require_browser_shims(), 1);
  var StrictSign = "StrictSign";
  var StrictNoSign = "StrictNoSign";
  var TopicValidatorResult;
  (function(TopicValidatorResult2) {
    TopicValidatorResult2["Accept"] = "accept";
    TopicValidatorResult2["Ignore"] = "ignore";
    TopicValidatorResult2["Reject"] = "reject";
  })(TopicValidatorResult || (TopicValidatorResult = {}));
  var pubSubSymbol = Symbol.for("@libp2p/pubsub");

  // node_modules/@libp2p/interface/dist/src/transport.js
  var import_browser_shims8 = __toESM(require_browser_shims(), 1);
  var transportSymbol = Symbol.for("@libp2p/transport");
  var FaultTolerance;
  (function(FaultTolerance2) {
    FaultTolerance2[FaultTolerance2["FATAL_ALL"] = 0] = "FATAL_ALL";
    FaultTolerance2[FaultTolerance2["NO_FATAL"] = 1] = "NO_FATAL";
  })(FaultTolerance || (FaultTolerance = {}));

  // node_modules/@libp2p/interface/dist/src/errors.js
  var import_browser_shims9 = __toESM(require_browser_shims(), 1);
  var AbortError = class extends Error {
    static name = "AbortError";
    constructor(message2 = "The operation was aborted") {
      super(message2);
      this.name = "AbortError";
    }
  };
  var UnexpectedPeerError = class extends Error {
    static name = "UnexpectedPeerError";
    constructor(message2 = "Unexpected Peer") {
      super(message2);
      this.name = "UnexpectedPeerError";
    }
  };
  var InvalidCryptoExchangeError = class extends Error {
    static name = "InvalidCryptoExchangeError";
    constructor(message2 = "Invalid crypto exchange") {
      super(message2);
      this.name = "InvalidCryptoExchangeError";
    }
  };
  var InvalidParametersError = class extends Error {
    static name = "InvalidParametersError";
    constructor(message2 = "Invalid parameters") {
      super(message2);
      this.name = "InvalidParametersError";
    }
  };
  var InvalidPublicKeyError = class extends Error {
    static name = "InvalidPublicKeyError";
    constructor(message2 = "Invalid public key") {
      super(message2);
      this.name = "InvalidPublicKeyError";
    }
  };
  var InvalidPrivateKeyError = class extends Error {
    static name = "InvalidPrivateKeyError";
    constructor(message2 = "Invalid private key") {
      super(message2);
      this.name = "InvalidPrivateKeyError";
    }
  };
  var ConnectionClosingError = class extends Error {
    static name = "ConnectionClosingError";
    constructor(message2 = "The connection is closing") {
      super(message2);
      this.name = "ConnectionClosingError";
    }
  };
  var ConnectionClosedError = class extends Error {
    static name = "ConnectionClosedError";
    constructor(message2 = "The connection is closed") {
      super(message2);
      this.name = "ConnectionClosedError";
    }
  };
  var ConnectionFailedError = class extends Error {
    static name = "ConnectionFailedError";
    constructor(message2 = "Connection failed") {
      super(message2);
      this.name = "ConnectionFailedError";
    }
  };
  var MuxerClosedError = class extends Error {
    static name = "MuxerClosedError";
    constructor(message2 = "The muxer is closed") {
      super(message2);
      this.name = "MuxerClosedError";
    }
  };
  var StreamResetError = class extends Error {
    static name = "StreamResetError";
    constructor(message2 = "The stream has been reset") {
      super(message2);
      this.name = "StreamResetError";
    }
  };
  var StreamStateError = class extends Error {
    static name = "StreamStateError";
    constructor(message2 = "The stream is in an invalid state") {
      super(message2);
      this.name = "StreamStateError";
    }
  };
  var NotFoundError = class extends Error {
    static name = "NotFoundError";
    constructor(message2 = "Not found") {
      super(message2);
      this.name = "NotFoundError";
    }
  };
  var InvalidPeerIdError = class extends Error {
    static name = "InvalidPeerIdError";
    constructor(message2 = "Invalid PeerID") {
      super(message2);
      this.name = "InvalidPeerIdError";
    }
  };
  var InvalidMultiaddrError = class extends Error {
    static name = "InvalidMultiaddrError";
    constructor(message2 = "Invalid multiaddr") {
      super(message2);
      this.name = "InvalidMultiaddrError";
    }
  };
  var InvalidCIDError = class extends Error {
    static name = "InvalidCIDError";
    constructor(message2 = "Invalid CID") {
      super(message2);
      this.name = "InvalidCIDError";
    }
  };
  var InvalidMultihashError = class extends Error {
    static name = "InvalidMultihashError";
    constructor(message2 = "Invalid Multihash") {
      super(message2);
      this.name = "InvalidMultihashError";
    }
  };
  var UnsupportedProtocolError = class extends Error {
    static name = "UnsupportedProtocolError";
    constructor(message2 = "Unsupported protocol error") {
      super(message2);
      this.name = "UnsupportedProtocolError";
    }
  };
  var InvalidMessageError = class extends Error {
    static name = "InvalidMessageError";
    constructor(message2 = "Invalid message") {
      super(message2);
      this.name = "InvalidMessageError";
    }
  };
  var TimeoutError = class extends Error {
    static name = "TimeoutError";
    constructor(message2 = "Timed out") {
      super(message2);
      this.name = "TimeoutError";
    }
  };
  var NotStartedError = class extends Error {
    static name = "NotStartedError";
    constructor(message2 = "Not started") {
      super(message2);
      this.name = "NotStartedError";
    }
  };
  var DialError = class extends Error {
    static name = "DialError";
    constructor(message2 = "Dial error") {
      super(message2);
      this.name = "DialError";
    }
  };
  var LimitedConnectionError = class extends Error {
    static name = "LimitedConnectionError";
    constructor(message2 = "Limited connection") {
      super(message2);
      this.name = "LimitedConnectionError";
    }
  };
  var TooManyInboundProtocolStreamsError = class extends Error {
    static name = "TooManyInboundProtocolStreamsError";
    constructor(message2 = "Too many inbound protocol streams") {
      super(message2);
      this.name = "TooManyInboundProtocolStreamsError";
    }
  };
  var TooManyOutboundProtocolStreamsError = class extends Error {
    static name = "TooManyOutboundProtocolStreamsError";
    constructor(message2 = "Too many outbound protocol streams") {
      super(message2);
      this.name = "TooManyOutboundProtocolStreamsError";
    }
  };
  var UnsupportedKeyTypeError = class extends Error {
    static name = "UnsupportedKeyTypeError";
    constructor(message2 = "Unsupported key type") {
      super(message2);
      this.name = "UnsupportedKeyTypeError";
    }
  };

  // node_modules/main-event/dist/src/index.js
  var import_browser_shims11 = __toESM(require_browser_shims(), 1);

  // node_modules/main-event/dist/src/events.browser.js
  var import_browser_shims10 = __toESM(require_browser_shims(), 1);
  function setMaxListeners() {
  }

  // node_modules/main-event/dist/src/index.js
  var TypedEventEmitter = class extends EventTarget {
    #listeners = /* @__PURE__ */ new Map();
    constructor() {
      super();
      setMaxListeners(Infinity, this);
    }
    listenerCount(type) {
      const listeners = this.#listeners.get(type);
      if (listeners == null) {
        return 0;
      }
      return listeners.length;
    }
    addEventListener(type, listener, options) {
      super.addEventListener(type, listener, options);
      let list = this.#listeners.get(type);
      if (list == null) {
        list = [];
        this.#listeners.set(type, list);
      }
      list.push({
        callback: listener,
        once: (options !== true && options !== false && (options == null ? void 0 : options.once)) ?? false
      });
    }
    removeEventListener(type, listener, options) {
      super.removeEventListener(type.toString(), listener ?? null, options);
      let list = this.#listeners.get(type);
      if (list == null) {
        return;
      }
      list = list.filter(({ callback }) => callback !== listener);
      this.#listeners.set(type, list);
    }
    dispatchEvent(event) {
      const result = super.dispatchEvent(event);
      let list = this.#listeners.get(event.type);
      if (list == null) {
        return result;
      }
      list = list.filter(({ once }) => !once);
      this.#listeners.set(event.type, list);
      return result;
    }
    safeDispatchEvent(type, detail = {}) {
      return this.dispatchEvent(new CustomEvent(type, detail));
    }
  };

  // node_modules/@libp2p/interface/dist/src/startable.js
  var import_browser_shims12 = __toESM(require_browser_shims(), 1);
  function isStartable(obj) {
    return obj != null && typeof obj.start === "function" && typeof obj.stop === "function";
  }
  async function start(...objs) {
    const startables = [];
    for (const obj of objs) {
      if (isStartable(obj)) {
        startables.push(obj);
      }
    }
    await Promise.all(startables.map(async (s2) => {
      if (s2.beforeStart != null) {
        await s2.beforeStart();
      }
    }));
    await Promise.all(startables.map(async (s2) => {
      await s2.start();
    }));
    await Promise.all(startables.map(async (s2) => {
      if (s2.afterStart != null) {
        await s2.afterStart();
      }
    }));
  }
  async function stop(...objs) {
    const startables = [];
    for (const obj of objs) {
      if (isStartable(obj)) {
        startables.push(obj);
      }
    }
    await Promise.all(startables.map(async (s2) => {
      if (s2.beforeStop != null) {
        await s2.beforeStop();
      }
    }));
    await Promise.all(startables.map(async (s2) => {
      await s2.stop();
    }));
    await Promise.all(startables.map(async (s2) => {
      if (s2.afterStop != null) {
        await s2.afterStop();
      }
    }));
  }

  // node_modules/@libp2p/interface/dist/src/index.js
  var serviceCapabilities = Symbol.for("@libp2p/service-capabilities");
  var serviceDependencies = Symbol.for("@libp2p/service-dependencies");

  // node_modules/@libp2p/crypto/dist/src/keys/ecdsa/ecdsa.js
  var import_browser_shims55 = __toESM(require_browser_shims(), 1);

  // node_modules/multiformats/dist/src/bases/base58.js
  var base58_exports = {};
  __export(base58_exports, {
    base58btc: () => base58btc,
    base58flickr: () => base58flickr
  });
  var import_browser_shims17 = __toESM(require_browser_shims(), 1);

  // node_modules/multiformats/dist/src/bases/base.js
  var import_browser_shims16 = __toESM(require_browser_shims(), 1);

  // node_modules/multiformats/dist/src/bytes.js
  var import_browser_shims14 = __toESM(require_browser_shims(), 1);
  var empty = new Uint8Array(0);
  function equals(aa, bb) {
    if (aa === bb) {
      return true;
    }
    if (aa.byteLength !== bb.byteLength) {
      return false;
    }
    for (let ii = 0; ii < aa.byteLength; ii++) {
      if (aa[ii] !== bb[ii]) {
        return false;
      }
    }
    return true;
  }
  function coerce(o) {
    if (o instanceof Uint8Array && o.constructor.name === "Uint8Array") {
      return o;
    }
    if (o instanceof ArrayBuffer) {
      return new Uint8Array(o);
    }
    if (ArrayBuffer.isView(o)) {
      return new Uint8Array(o.buffer, o.byteOffset, o.byteLength);
    }
    throw new Error("Unknown type, must be binary type");
  }
  function fromString(str) {
    return new TextEncoder().encode(str);
  }
  function toString(b) {
    return new TextDecoder().decode(b);
  }

  // node_modules/multiformats/dist/src/vendor/base-x.js
  var import_browser_shims15 = __toESM(require_browser_shims(), 1);
  function base(ALPHABET, name3) {
    if (ALPHABET.length >= 255) {
      throw new TypeError("Alphabet too long");
    }
    var BASE_MAP = new Uint8Array(256);
    for (var j = 0; j < BASE_MAP.length; j++) {
      BASE_MAP[j] = 255;
    }
    for (var i = 0; i < ALPHABET.length; i++) {
      var x = ALPHABET.charAt(i);
      var xc = x.charCodeAt(0);
      if (BASE_MAP[xc] !== 255) {
        throw new TypeError(x + " is ambiguous");
      }
      BASE_MAP[xc] = i;
    }
    var BASE = ALPHABET.length;
    var LEADER = ALPHABET.charAt(0);
    var FACTOR = Math.log(BASE) / Math.log(256);
    var iFACTOR = Math.log(256) / Math.log(BASE);
    function encode10(source) {
      if (source instanceof Uint8Array)
        ;
      else if (ArrayBuffer.isView(source)) {
        source = new Uint8Array(source.buffer, source.byteOffset, source.byteLength);
      } else if (Array.isArray(source)) {
        source = Uint8Array.from(source);
      }
      if (!(source instanceof Uint8Array)) {
        throw new TypeError("Expected Uint8Array");
      }
      if (source.length === 0) {
        return "";
      }
      var zeroes = 0;
      var length4 = 0;
      var pbegin = 0;
      var pend = source.length;
      while (pbegin !== pend && source[pbegin] === 0) {
        pbegin++;
        zeroes++;
      }
      var size = (pend - pbegin) * iFACTOR + 1 >>> 0;
      var b58 = new Uint8Array(size);
      while (pbegin !== pend) {
        var carry = source[pbegin];
        var i2 = 0;
        for (var it1 = size - 1; (carry !== 0 || i2 < length4) && it1 !== -1; it1--, i2++) {
          carry += 256 * b58[it1] >>> 0;
          b58[it1] = carry % BASE >>> 0;
          carry = carry / BASE >>> 0;
        }
        if (carry !== 0) {
          throw new Error("Non-zero carry");
        }
        length4 = i2;
        pbegin++;
      }
      var it2 = size - length4;
      while (it2 !== size && b58[it2] === 0) {
        it2++;
      }
      var str = LEADER.repeat(zeroes);
      for (; it2 < size; ++it2) {
        str += ALPHABET.charAt(b58[it2]);
      }
      return str;
    }
    function decodeUnsafe(source) {
      if (typeof source !== "string") {
        throw new TypeError("Expected String");
      }
      if (source.length === 0) {
        return new Uint8Array();
      }
      var psz = 0;
      if (source[psz] === " ") {
        return;
      }
      var zeroes = 0;
      var length4 = 0;
      while (source[psz] === LEADER) {
        zeroes++;
        psz++;
      }
      var size = (source.length - psz) * FACTOR + 1 >>> 0;
      var b256 = new Uint8Array(size);
      while (source[psz]) {
        var carry = BASE_MAP[source.charCodeAt(psz)];
        if (carry === 255) {
          return;
        }
        var i2 = 0;
        for (var it3 = size - 1; (carry !== 0 || i2 < length4) && it3 !== -1; it3--, i2++) {
          carry += BASE * b256[it3] >>> 0;
          b256[it3] = carry % 256 >>> 0;
          carry = carry / 256 >>> 0;
        }
        if (carry !== 0) {
          throw new Error("Non-zero carry");
        }
        length4 = i2;
        psz++;
      }
      if (source[psz] === " ") {
        return;
      }
      var it4 = size - length4;
      while (it4 !== size && b256[it4] === 0) {
        it4++;
      }
      var vch = new Uint8Array(zeroes + (size - it4));
      var j2 = zeroes;
      while (it4 !== size) {
        vch[j2++] = b256[it4++];
      }
      return vch;
    }
    function decode11(string3) {
      var buffer = decodeUnsafe(string3);
      if (buffer) {
        return buffer;
      }
      throw new Error(`Non-${name3} character`);
    }
    return {
      encode: encode10,
      decodeUnsafe,
      decode: decode11
    };
  }
  var src = base;
  var _brrp__multiformats_scope_baseX = src;
  var base_x_default = _brrp__multiformats_scope_baseX;

  // node_modules/multiformats/dist/src/bases/base.js
  var Encoder = class {
    name;
    prefix;
    baseEncode;
    constructor(name3, prefix, baseEncode) {
      this.name = name3;
      this.prefix = prefix;
      this.baseEncode = baseEncode;
    }
    encode(bytes) {
      if (bytes instanceof Uint8Array) {
        return `${this.prefix}${this.baseEncode(bytes)}`;
      } else {
        throw Error("Unknown type, must be binary type");
      }
    }
  };
  var Decoder = class {
    name;
    prefix;
    baseDecode;
    prefixCodePoint;
    constructor(name3, prefix, baseDecode) {
      this.name = name3;
      this.prefix = prefix;
      const prefixCodePoint = prefix.codePointAt(0);
      if (prefixCodePoint === void 0) {
        throw new Error("Invalid prefix character");
      }
      this.prefixCodePoint = prefixCodePoint;
      this.baseDecode = baseDecode;
    }
    decode(text) {
      if (typeof text === "string") {
        if (text.codePointAt(0) !== this.prefixCodePoint) {
          throw Error(`Unable to decode multibase string ${JSON.stringify(text)}, ${this.name} decoder only supports inputs prefixed with ${this.prefix}`);
        }
        return this.baseDecode(text.slice(this.prefix.length));
      } else {
        throw Error("Can only multibase decode strings");
      }
    }
    or(decoder) {
      return or(this, decoder);
    }
  };
  var ComposedDecoder = class {
    decoders;
    constructor(decoders3) {
      this.decoders = decoders3;
    }
    or(decoder) {
      return or(this, decoder);
    }
    decode(input) {
      const prefix = input[0];
      const decoder = this.decoders[prefix];
      if (decoder != null) {
        return decoder.decode(input);
      } else {
        throw RangeError(`Unable to decode multibase string ${JSON.stringify(input)}, only inputs prefixed with ${Object.keys(this.decoders)} are supported`);
      }
    }
  };
  function or(left, right) {
    return new ComposedDecoder({
      ...left.decoders ?? { [left.prefix]: left },
      ...right.decoders ?? { [right.prefix]: right }
    });
  }
  var Codec = class {
    name;
    prefix;
    baseEncode;
    baseDecode;
    encoder;
    decoder;
    constructor(name3, prefix, baseEncode, baseDecode) {
      this.name = name3;
      this.prefix = prefix;
      this.baseEncode = baseEncode;
      this.baseDecode = baseDecode;
      this.encoder = new Encoder(name3, prefix, baseEncode);
      this.decoder = new Decoder(name3, prefix, baseDecode);
    }
    encode(input) {
      return this.encoder.encode(input);
    }
    decode(input) {
      return this.decoder.decode(input);
    }
  };
  function from({ name: name3, prefix, encode: encode10, decode: decode11 }) {
    return new Codec(name3, prefix, encode10, decode11);
  }
  function baseX({ name: name3, prefix, alphabet: alphabet2 }) {
    const { encode: encode10, decode: decode11 } = base_x_default(alphabet2, name3);
    return from({
      prefix,
      name: name3,
      encode: encode10,
      decode: (text) => coerce(decode11(text))
    });
  }
  function decode(string3, alphabetIdx, bitsPerChar, name3) {
    let end = string3.length;
    while (string3[end - 1] === "=") {
      --end;
    }
    const out = new Uint8Array(end * bitsPerChar / 8 | 0);
    let bits = 0;
    let buffer = 0;
    let written = 0;
    for (let i = 0; i < end; ++i) {
      const value = alphabetIdx[string3[i]];
      if (value === void 0) {
        throw new SyntaxError(`Non-${name3} character`);
      }
      buffer = buffer << bitsPerChar | value;
      bits += bitsPerChar;
      if (bits >= 8) {
        bits -= 8;
        out[written++] = 255 & buffer >> bits;
      }
    }
    if (bits >= bitsPerChar || (255 & buffer << 8 - bits) !== 0) {
      throw new SyntaxError("Unexpected end of data");
    }
    return out;
  }
  function encode(data, alphabet2, bitsPerChar) {
    const pad = alphabet2[alphabet2.length - 1] === "=";
    const mask = (1 << bitsPerChar) - 1;
    let out = "";
    let bits = 0;
    let buffer = 0;
    for (let i = 0; i < data.length; ++i) {
      buffer = buffer << 8 | data[i];
      bits += 8;
      while (bits > bitsPerChar) {
        bits -= bitsPerChar;
        out += alphabet2[mask & buffer >> bits];
      }
    }
    if (bits !== 0) {
      out += alphabet2[mask & buffer << bitsPerChar - bits];
    }
    if (pad) {
      while ((out.length * bitsPerChar & 7) !== 0) {
        out += "=";
      }
    }
    return out;
  }
  function createAlphabetIdx(alphabet2) {
    const alphabetIdx = {};
    for (let i = 0; i < alphabet2.length; ++i) {
      alphabetIdx[alphabet2[i]] = i;
    }
    return alphabetIdx;
  }
  function rfc4648({ name: name3, prefix, bitsPerChar, alphabet: alphabet2 }) {
    const alphabetIdx = createAlphabetIdx(alphabet2);
    return from({
      prefix,
      name: name3,
      encode(input) {
        return encode(input, alphabet2, bitsPerChar);
      },
      decode(input) {
        return decode(input, alphabetIdx, bitsPerChar, name3);
      }
    });
  }

  // node_modules/multiformats/dist/src/bases/base58.js
  var base58btc = baseX({
    name: "base58btc",
    prefix: "z",
    alphabet: "123456789ABCDEFGHJKLMNPQRSTUVWXYZabcdefghijkmnopqrstuvwxyz"
  });
  var base58flickr = baseX({
    name: "base58flickr",
    prefix: "Z",
    alphabet: "123456789abcdefghijkmnopqrstuvwxyzABCDEFGHJKLMNPQRSTUVWXYZ"
  });

  // node_modules/multiformats/dist/src/cid.js
  var import_browser_shims24 = __toESM(require_browser_shims(), 1);

  // node_modules/multiformats/dist/src/bases/base32.js
  var base32_exports = {};
  __export(base32_exports, {
    base32: () => base32,
    base32hex: () => base32hex,
    base32hexpad: () => base32hexpad,
    base32hexpadupper: () => base32hexpadupper,
    base32hexupper: () => base32hexupper,
    base32pad: () => base32pad,
    base32padupper: () => base32padupper,
    base32upper: () => base32upper,
    base32z: () => base32z
  });
  var import_browser_shims18 = __toESM(require_browser_shims(), 1);
  var base32 = rfc4648({
    prefix: "b",
    name: "base32",
    alphabet: "abcdefghijklmnopqrstuvwxyz234567",
    bitsPerChar: 5
  });
  var base32upper = rfc4648({
    prefix: "B",
    name: "base32upper",
    alphabet: "ABCDEFGHIJKLMNOPQRSTUVWXYZ234567",
    bitsPerChar: 5
  });
  var base32pad = rfc4648({
    prefix: "c",
    name: "base32pad",
    alphabet: "abcdefghijklmnopqrstuvwxyz234567=",
    bitsPerChar: 5
  });
  var base32padupper = rfc4648({
    prefix: "C",
    name: "base32padupper",
    alphabet: "ABCDEFGHIJKLMNOPQRSTUVWXYZ234567=",
    bitsPerChar: 5
  });
  var base32hex = rfc4648({
    prefix: "v",
    name: "base32hex",
    alphabet: "0123456789abcdefghijklmnopqrstuv",
    bitsPerChar: 5
  });
  var base32hexupper = rfc4648({
    prefix: "V",
    name: "base32hexupper",
    alphabet: "0123456789ABCDEFGHIJKLMNOPQRSTUV",
    bitsPerChar: 5
  });
  var base32hexpad = rfc4648({
    prefix: "t",
    name: "base32hexpad",
    alphabet: "0123456789abcdefghijklmnopqrstuv=",
    bitsPerChar: 5
  });
  var base32hexpadupper = rfc4648({
    prefix: "T",
    name: "base32hexpadupper",
    alphabet: "0123456789ABCDEFGHIJKLMNOPQRSTUV=",
    bitsPerChar: 5
  });
  var base32z = rfc4648({
    prefix: "h",
    name: "base32z",
    alphabet: "ybndrfg8ejkmcpqxot1uwisza345h769",
    bitsPerChar: 5
  });

  // node_modules/multiformats/dist/src/bases/base36.js
  var base36_exports = {};
  __export(base36_exports, {
    base36: () => base36,
    base36upper: () => base36upper
  });
  var import_browser_shims19 = __toESM(require_browser_shims(), 1);
  var base36 = baseX({
    prefix: "k",
    name: "base36",
    alphabet: "0123456789abcdefghijklmnopqrstuvwxyz"
  });
  var base36upper = baseX({
    prefix: "K",
    name: "base36upper",
    alphabet: "0123456789ABCDEFGHIJKLMNOPQRSTUVWXYZ"
  });

  // node_modules/multiformats/dist/src/hashes/digest.js
  var import_browser_shims22 = __toESM(require_browser_shims(), 1);

  // node_modules/multiformats/dist/src/varint.js
  var import_browser_shims21 = __toESM(require_browser_shims(), 1);

  // node_modules/multiformats/dist/src/vendor/varint.js
  var import_browser_shims20 = __toESM(require_browser_shims(), 1);
  var encode_1 = encode2;
  var MSB = 128;
  var REST = 127;
  var MSBALL = ~REST;
  var INT = Math.pow(2, 31);
  function encode2(num, out, offset) {
    out = out || [];
    offset = offset || 0;
    var oldOffset = offset;
    while (num >= INT) {
      out[offset++] = num & 255 | MSB;
      num /= 128;
    }
    while (num & MSBALL) {
      out[offset++] = num & 255 | MSB;
      num >>>= 7;
    }
    out[offset] = num | 0;
    encode2.bytes = offset - oldOffset + 1;
    return out;
  }
  var decode2 = read;
  var MSB$1 = 128;
  var REST$1 = 127;
  function read(buf, offset) {
    var res = 0, offset = offset || 0, shift = 0, counter = offset, b, l = buf.length;
    do {
      if (counter >= l) {
        read.bytes = 0;
        throw new RangeError("Could not decode varint");
      }
      b = buf[counter++];
      res += shift < 28 ? (b & REST$1) << shift : (b & REST$1) * Math.pow(2, shift);
      shift += 7;
    } while (b >= MSB$1);
    read.bytes = counter - offset;
    return res;
  }
  var N1 = Math.pow(2, 7);
  var N2 = Math.pow(2, 14);
  var N3 = Math.pow(2, 21);
  var N4 = Math.pow(2, 28);
  var N5 = Math.pow(2, 35);
  var N6 = Math.pow(2, 42);
  var N7 = Math.pow(2, 49);
  var N8 = Math.pow(2, 56);
  var N9 = Math.pow(2, 63);
  var length = function(value) {
    return value < N1 ? 1 : value < N2 ? 2 : value < N3 ? 3 : value < N4 ? 4 : value < N5 ? 5 : value < N6 ? 6 : value < N7 ? 7 : value < N8 ? 8 : value < N9 ? 9 : 10;
  };
  var varint = {
    encode: encode_1,
    decode: decode2,
    encodingLength: length
  };
  var _brrp_varint = varint;
  var varint_default = _brrp_varint;

  // node_modules/multiformats/dist/src/varint.js
  function decode3(data, offset = 0) {
    const code2 = varint_default.decode(data, offset);
    return [code2, varint_default.decode.bytes];
  }
  function encodeTo(int, target, offset = 0) {
    varint_default.encode(int, target, offset);
    return target;
  }
  function encodingLength(int) {
    return varint_default.encodingLength(int);
  }

  // node_modules/multiformats/dist/src/hashes/digest.js
  function create(code2, digest2) {
    const size = digest2.byteLength;
    const sizeOffset = encodingLength(code2);
    const digestOffset = sizeOffset + encodingLength(size);
    const bytes = new Uint8Array(digestOffset + size);
    encodeTo(code2, bytes, 0);
    encodeTo(size, bytes, sizeOffset);
    bytes.set(digest2, digestOffset);
    return new Digest(code2, size, digest2, bytes);
  }
  function decode4(multihash) {
    const bytes = coerce(multihash);
    const [code2, sizeOffset] = decode3(bytes);
    const [size, digestOffset] = decode3(bytes.subarray(sizeOffset));
    const digest2 = bytes.subarray(sizeOffset + digestOffset);
    if (digest2.byteLength !== size) {
      throw new Error("Incorrect length");
    }
    return new Digest(code2, size, digest2, bytes);
  }
  function equals2(a, b) {
    if (a === b) {
      return true;
    } else {
      const data = b;
      return a.code === data.code && a.size === data.size && data.bytes instanceof Uint8Array && equals(a.bytes, data.bytes);
    }
  }
  var Digest = class {
    code;
    size;
    digest;
    bytes;
    /**
     * Creates a multihash digest.
     */
    constructor(code2, size, digest2, bytes) {
      this.code = code2;
      this.size = size;
      this.digest = digest2;
      this.bytes = bytes;
    }
  };

  // node_modules/multiformats/dist/src/link/interface.js
  var import_browser_shims23 = __toESM(require_browser_shims(), 1);

  // node_modules/multiformats/dist/src/cid.js
  function format(link, base3) {
    const { bytes, version: version2 } = link;
    switch (version2) {
      case 0:
        return toStringV0(bytes, baseCache(link), base3 ?? base58btc.encoder);
      default:
        return toStringV1(bytes, baseCache(link), base3 ?? base32.encoder);
    }
  }
  var cache = /* @__PURE__ */ new WeakMap();
  function baseCache(cid) {
    const baseCache2 = cache.get(cid);
    if (baseCache2 == null) {
      const baseCache3 = /* @__PURE__ */ new Map();
      cache.set(cid, baseCache3);
      return baseCache3;
    }
    return baseCache2;
  }
  var CID = class _CID {
    code;
    version;
    multihash;
    bytes;
    "/";
    /**
     * @param version - Version of the CID
     * @param code - Code of the codec content is encoded in, see https://github.com/multiformats/multicodec/blob/master/table.csv
     * @param multihash - (Multi)hash of the of the content.
     */
    constructor(version2, code2, multihash, bytes) {
      this.code = code2;
      this.version = version2;
      this.multihash = multihash;
      this.bytes = bytes;
      this["/"] = bytes;
    }
    /**
     * Signalling `cid.asCID === cid` has been replaced with `cid['/'] === cid.bytes`
     * please either use `CID.asCID(cid)` or switch to new signalling mechanism
     *
     * @deprecated
     */
    get asCID() {
      return this;
    }
    // ArrayBufferView
    get byteOffset() {
      return this.bytes.byteOffset;
    }
    // ArrayBufferView
    get byteLength() {
      return this.bytes.byteLength;
    }
    toV0() {
      switch (this.version) {
        case 0: {
          return this;
        }
        case 1: {
          const { code: code2, multihash } = this;
          if (code2 !== DAG_PB_CODE) {
            throw new Error("Cannot convert a non dag-pb CID to CIDv0");
          }
          if (multihash.code !== SHA_256_CODE) {
            throw new Error("Cannot convert non sha2-256 multihash CID to CIDv0");
          }
          return _CID.createV0(multihash);
        }
        default: {
          throw Error(`Can not convert CID version ${this.version} to version 0. This is a bug please report`);
        }
      }
    }
    toV1() {
      switch (this.version) {
        case 0: {
          const { code: code2, digest: digest2 } = this.multihash;
          const multihash = create(code2, digest2);
          return _CID.createV1(this.code, multihash);
        }
        case 1: {
          return this;
        }
        default: {
          throw Error(`Can not convert CID version ${this.version} to version 1. This is a bug please report`);
        }
      }
    }
    equals(other) {
      return _CID.equals(this, other);
    }
    static equals(self, other) {
      const unknown = other;
      return unknown != null && self.code === unknown.code && self.version === unknown.version && equals2(self.multihash, unknown.multihash);
    }
    toString(base3) {
      return format(this, base3);
    }
    toJSON() {
      return { "/": format(this) };
    }
    link() {
      return this;
    }
    [Symbol.toStringTag] = "CID";
    // Legacy
    [Symbol.for("nodejs.util.inspect.custom")]() {
      return `CID(${this.toString()})`;
    }
    /**
     * Takes any input `value` and returns a `CID` instance if it was
     * a `CID` otherwise returns `null`. If `value` is instanceof `CID`
     * it will return value back. If `value` is not instance of this CID
     * class, but is compatible CID it will return new instance of this
     * `CID` class. Otherwise returns null.
     *
     * This allows two different incompatible versions of CID library to
     * co-exist and interop as long as binary interface is compatible.
     */
    static asCID(input) {
      if (input == null) {
        return null;
      }
      const value = input;
      if (value instanceof _CID) {
        return value;
      } else if (value["/"] != null && value["/"] === value.bytes || value.asCID === value) {
        const { version: version2, code: code2, multihash, bytes } = value;
        return new _CID(version2, code2, multihash, bytes ?? encodeCID(version2, code2, multihash.bytes));
      } else if (value[cidSymbol] === true) {
        const { version: version2, multihash, code: code2 } = value;
        const digest2 = decode4(multihash);
        return _CID.create(version2, code2, digest2);
      } else {
        return null;
      }
    }
    /**
     * @param version - Version of the CID
     * @param code - Code of the codec content is encoded in, see https://github.com/multiformats/multicodec/blob/master/table.csv
     * @param digest - (Multi)hash of the of the content.
     */
    static create(version2, code2, digest2) {
      if (typeof code2 !== "number") {
        throw new Error("String codecs are no longer supported");
      }
      if (!(digest2.bytes instanceof Uint8Array)) {
        throw new Error("Invalid digest");
      }
      switch (version2) {
        case 0: {
          if (code2 !== DAG_PB_CODE) {
            throw new Error(`Version 0 CID must use dag-pb (code: ${DAG_PB_CODE}) block encoding`);
          } else {
            return new _CID(version2, code2, digest2, digest2.bytes);
          }
        }
        case 1: {
          const bytes = encodeCID(version2, code2, digest2.bytes);
          return new _CID(version2, code2, digest2, bytes);
        }
        default: {
          throw new Error("Invalid version");
        }
      }
    }
    /**
     * Simplified version of `create` for CIDv0.
     */
    static createV0(digest2) {
      return _CID.create(0, DAG_PB_CODE, digest2);
    }
    /**
     * Simplified version of `create` for CIDv1.
     *
     * @param code - Content encoding format code.
     * @param digest - Multihash of the content.
     */
    static createV1(code2, digest2) {
      return _CID.create(1, code2, digest2);
    }
    /**
     * Decoded a CID from its binary representation. The byte array must contain
     * only the CID with no additional bytes.
     *
     * An error will be thrown if the bytes provided do not contain a valid
     * binary representation of a CID.
     */
    static decode(bytes) {
      const [cid, remainder] = _CID.decodeFirst(bytes);
      if (remainder.length !== 0) {
        throw new Error("Incorrect length");
      }
      return cid;
    }
    /**
     * Decoded a CID from its binary representation at the beginning of a byte
     * array.
     *
     * Returns an array with the first element containing the CID and the second
     * element containing the remainder of the original byte array. The remainder
     * will be a zero-length byte array if the provided bytes only contained a
     * binary CID representation.
     */
    static decodeFirst(bytes) {
      const specs = _CID.inspectBytes(bytes);
      const prefixSize = specs.size - specs.multihashSize;
      const multihashBytes = coerce(bytes.subarray(prefixSize, prefixSize + specs.multihashSize));
      if (multihashBytes.byteLength !== specs.multihashSize) {
        throw new Error("Incorrect length");
      }
      const digestBytes = multihashBytes.subarray(specs.multihashSize - specs.digestSize);
      const digest2 = new Digest(specs.multihashCode, specs.digestSize, digestBytes, multihashBytes);
      const cid = specs.version === 0 ? _CID.createV0(digest2) : _CID.createV1(specs.codec, digest2);
      return [cid, bytes.subarray(specs.size)];
    }
    /**
     * Inspect the initial bytes of a CID to determine its properties.
     *
     * Involves decoding up to 4 varints. Typically this will require only 4 to 6
     * bytes but for larger multicodec code values and larger multihash digest
     * lengths these varints can be quite large. It is recommended that at least
     * 10 bytes be made available in the `initialBytes` argument for a complete
     * inspection.
     */
    static inspectBytes(initialBytes) {
      let offset = 0;
      const next = () => {
        const [i, length4] = decode3(initialBytes.subarray(offset));
        offset += length4;
        return i;
      };
      let version2 = next();
      let codec = DAG_PB_CODE;
      if (version2 === 18) {
        version2 = 0;
        offset = 0;
      } else {
        codec = next();
      }
      if (version2 !== 0 && version2 !== 1) {
        throw new RangeError(`Invalid CID version ${version2}`);
      }
      const prefixSize = offset;
      const multihashCode = next();
      const digestSize = next();
      const size = offset + digestSize;
      const multihashSize = size - prefixSize;
      return { version: version2, codec, multihashCode, digestSize, multihashSize, size };
    }
    /**
     * Takes cid in a string representation and creates an instance. If `base`
     * decoder is not provided will use a default from the configuration. It will
     * throw an error if encoding of the CID is not compatible with supplied (or
     * a default decoder).
     */
    static parse(source, base3) {
      const [prefix, bytes] = parseCIDtoBytes(source, base3);
      const cid = _CID.decode(bytes);
      if (cid.version === 0 && source[0] !== "Q") {
        throw Error("Version 0 CID string must not include multibase prefix");
      }
      baseCache(cid).set(prefix, source);
      return cid;
    }
  };
  function parseCIDtoBytes(source, base3) {
    switch (source[0]) {
      // CIDv0 is parsed differently
      case "Q": {
        const decoder = base3 ?? base58btc;
        return [
          base58btc.prefix,
          decoder.decode(`${base58btc.prefix}${source}`)
        ];
      }
      case base58btc.prefix: {
        const decoder = base3 ?? base58btc;
        return [base58btc.prefix, decoder.decode(source)];
      }
      case base32.prefix: {
        const decoder = base3 ?? base32;
        return [base32.prefix, decoder.decode(source)];
      }
      case base36.prefix: {
        const decoder = base3 ?? base36;
        return [base36.prefix, decoder.decode(source)];
      }
      default: {
        if (base3 == null) {
          throw Error("To parse non base32, base36 or base58btc encoded CID multibase decoder must be provided");
        }
        return [source[0], base3.decode(source)];
      }
    }
  }
  function toStringV0(bytes, cache4, base3) {
    const { prefix } = base3;
    if (prefix !== base58btc.prefix) {
      throw Error(`Cannot string encode V0 in ${base3.name} encoding`);
    }
    const cid = cache4.get(prefix);
    if (cid == null) {
      const cid2 = base3.encode(bytes).slice(1);
      cache4.set(prefix, cid2);
      return cid2;
    } else {
      return cid;
    }
  }
  function toStringV1(bytes, cache4, base3) {
    const { prefix } = base3;
    const cid = cache4.get(prefix);
    if (cid == null) {
      const cid2 = base3.encode(bytes);
      cache4.set(prefix, cid2);
      return cid2;
    } else {
      return cid;
    }
  }
  var DAG_PB_CODE = 112;
  var SHA_256_CODE = 18;
  function encodeCID(version2, code2, multihash) {
    const codeOffset = encodingLength(version2);
    const hashOffset = codeOffset + encodingLength(code2);
    const bytes = new Uint8Array(hashOffset + multihash.byteLength);
    encodeTo(version2, bytes, 0);
    encodeTo(code2, bytes, codeOffset);
    bytes.set(multihash, hashOffset);
    return bytes;
  }
  var cidSymbol = Symbol.for("@ipld/js-cid/CID");

  // node_modules/multiformats/dist/src/hashes/identity.js
  var identity_exports = {};
  __export(identity_exports, {
    identity: () => identity
  });
  var import_browser_shims25 = __toESM(require_browser_shims(), 1);
  var code = 0;
  var name = "identity";
  var encode3 = coerce;
  function digest(input) {
    return create(code, encode3(input));
  }
  var identity = { code, name, encode: encode3, digest };

  // node_modules/uint8arrays/dist/src/equals.js
  var import_browser_shims26 = __toESM(require_browser_shims(), 1);
  function equals3(a, b) {
    if (a === b) {
      return true;
    }
    if (a.byteLength !== b.byteLength) {
      return false;
    }
    for (let i = 0; i < a.byteLength; i++) {
      if (a[i] !== b[i]) {
        return false;
      }
    }
    return true;
  }

  // node_modules/@libp2p/crypto/dist/src/keys/ecdsa/utils.js
  var import_browser_shims54 = __toESM(require_browser_shims(), 1);

  // node_modules/uint8arraylist/dist/src/index.js
  var import_browser_shims30 = __toESM(require_browser_shims(), 1);

  // node_modules/uint8arrays/dist/src/alloc.js
  var import_browser_shims27 = __toESM(require_browser_shims(), 1);
  function alloc(size = 0) {
    return new Uint8Array(size);
  }
  function allocUnsafe(size = 0) {
    return new Uint8Array(size);
  }

  // node_modules/uint8arrays/dist/src/concat.js
  var import_browser_shims29 = __toESM(require_browser_shims(), 1);

  // node_modules/uint8arrays/dist/src/util/as-uint8array.js
  var import_browser_shims28 = __toESM(require_browser_shims(), 1);
  function asUint8Array(buf) {
    return buf;
  }

  // node_modules/uint8arrays/dist/src/concat.js
  function concat(arrays, length4) {
    if (length4 == null) {
      length4 = arrays.reduce((acc, curr) => acc + curr.length, 0);
    }
    const output = allocUnsafe(length4);
    let offset = 0;
    for (const arr of arrays) {
      output.set(arr, offset);
      offset += arr.length;
    }
    return asUint8Array(output);
  }

  // node_modules/uint8arraylist/dist/src/index.js
  var symbol = Symbol.for("@achingbrain/uint8arraylist");
  function findBufAndOffset(bufs, index) {
    if (index == null || index < 0) {
      throw new RangeError("index is out of bounds");
    }
    let offset = 0;
    for (const buf of bufs) {
      const bufEnd = offset + buf.byteLength;
      if (index < bufEnd) {
        return {
          buf,
          index: index - offset
        };
      }
      offset = bufEnd;
    }
    throw new RangeError("index is out of bounds");
  }
  function isUint8ArrayList(value) {
    return Boolean(value == null ? void 0 : value[symbol]);
  }
  var Uint8ArrayList = class _Uint8ArrayList {
    bufs;
    length;
    [symbol] = true;
    constructor(...data) {
      this.bufs = [];
      this.length = 0;
      if (data.length > 0) {
        this.appendAll(data);
      }
    }
    *[Symbol.iterator]() {
      yield* this.bufs;
    }
    get byteLength() {
      return this.length;
    }
    /**
     * Add one or more `bufs` to the end of this Uint8ArrayList
     */
    append(...bufs) {
      this.appendAll(bufs);
    }
    /**
     * Add all `bufs` to the end of this Uint8ArrayList
     */
    appendAll(bufs) {
      let length4 = 0;
      for (const buf of bufs) {
        if (buf instanceof Uint8Array) {
          length4 += buf.byteLength;
          this.bufs.push(buf);
        } else if (isUint8ArrayList(buf)) {
          length4 += buf.byteLength;
          this.bufs.push(...buf.bufs);
        } else {
          throw new Error("Could not append value, must be an Uint8Array or a Uint8ArrayList");
        }
      }
      this.length += length4;
    }
    /**
     * Add one or more `bufs` to the start of this Uint8ArrayList
     */
    prepend(...bufs) {
      this.prependAll(bufs);
    }
    /**
     * Add all `bufs` to the start of this Uint8ArrayList
     */
    prependAll(bufs) {
      let length4 = 0;
      for (const buf of bufs.reverse()) {
        if (buf instanceof Uint8Array) {
          length4 += buf.byteLength;
          this.bufs.unshift(buf);
        } else if (isUint8ArrayList(buf)) {
          length4 += buf.byteLength;
          this.bufs.unshift(...buf.bufs);
        } else {
          throw new Error("Could not prepend value, must be an Uint8Array or a Uint8ArrayList");
        }
      }
      this.length += length4;
    }
    /**
     * Read the value at `index`
     */
    get(index) {
      const res = findBufAndOffset(this.bufs, index);
      return res.buf[res.index];
    }
    /**
     * Set the value at `index` to `value`
     */
    set(index, value) {
      const res = findBufAndOffset(this.bufs, index);
      res.buf[res.index] = value;
    }
    /**
     * Copy bytes from `buf` to the index specified by `offset`
     */
    write(buf, offset = 0) {
      if (buf instanceof Uint8Array) {
        for (let i = 0; i < buf.length; i++) {
          this.set(offset + i, buf[i]);
        }
      } else if (isUint8ArrayList(buf)) {
        for (let i = 0; i < buf.length; i++) {
          this.set(offset + i, buf.get(i));
        }
      } else {
        throw new Error("Could not write value, must be an Uint8Array or a Uint8ArrayList");
      }
    }
    /**
     * Remove bytes from the front of the pool
     */
    consume(bytes) {
      bytes = Math.trunc(bytes);
      if (Number.isNaN(bytes) || bytes <= 0) {
        return;
      }
      if (bytes === this.byteLength) {
        this.bufs = [];
        this.length = 0;
        return;
      }
      while (this.bufs.length > 0) {
        if (bytes >= this.bufs[0].byteLength) {
          bytes -= this.bufs[0].byteLength;
          this.length -= this.bufs[0].byteLength;
          this.bufs.shift();
        } else {
          this.bufs[0] = this.bufs[0].subarray(bytes);
          this.length -= bytes;
          break;
        }
      }
    }
    /**
     * Extracts a section of an array and returns a new array.
     *
     * This is a copy operation as it is with Uint8Arrays and Arrays
     * - note this is different to the behaviour of Node Buffers.
     */
    slice(beginInclusive, endExclusive) {
      const { bufs, length: length4 } = this._subList(beginInclusive, endExclusive);
      return concat(bufs, length4);
    }
    /**
     * Returns a alloc from the given start and end element index.
     *
     * In the best case where the data extracted comes from a single Uint8Array
     * internally this is a no-copy operation otherwise it is a copy operation.
     */
    subarray(beginInclusive, endExclusive) {
      const { bufs, length: length4 } = this._subList(beginInclusive, endExclusive);
      if (bufs.length === 1) {
        return bufs[0];
      }
      return concat(bufs, length4);
    }
    /**
     * Returns a allocList from the given start and end element index.
     *
     * This is a no-copy operation.
     */
    sublist(beginInclusive, endExclusive) {
      const { bufs, length: length4 } = this._subList(beginInclusive, endExclusive);
      const list = new _Uint8ArrayList();
      list.length = length4;
      list.bufs = [...bufs];
      return list;
    }
    _subList(beginInclusive, endExclusive) {
      beginInclusive = beginInclusive ?? 0;
      endExclusive = endExclusive ?? this.length;
      if (beginInclusive < 0) {
        beginInclusive = this.length + beginInclusive;
      }
      if (endExclusive < 0) {
        endExclusive = this.length + endExclusive;
      }
      if (beginInclusive < 0 || endExclusive > this.length) {
        throw new RangeError("index is out of bounds");
      }
      if (beginInclusive === endExclusive) {
        return { bufs: [], length: 0 };
      }
      if (beginInclusive === 0 && endExclusive === this.length) {
        return { bufs: this.bufs, length: this.length };
      }
      const bufs = [];
      let offset = 0;
      for (let i = 0; i < this.bufs.length; i++) {
        const buf = this.bufs[i];
        const bufStart = offset;
        const bufEnd = bufStart + buf.byteLength;
        offset = bufEnd;
        if (beginInclusive >= bufEnd) {
          continue;
        }
        const sliceStartInBuf = beginInclusive >= bufStart && beginInclusive < bufEnd;
        const sliceEndsInBuf = endExclusive > bufStart && endExclusive <= bufEnd;
        if (sliceStartInBuf && sliceEndsInBuf) {
          if (beginInclusive === bufStart && endExclusive === bufEnd) {
            bufs.push(buf);
            break;
          }
          const start2 = beginInclusive - bufStart;
          bufs.push(buf.subarray(start2, start2 + (endExclusive - beginInclusive)));
          break;
        }
        if (sliceStartInBuf) {
          if (beginInclusive === 0) {
            bufs.push(buf);
            continue;
          }
          bufs.push(buf.subarray(beginInclusive - bufStart));
          continue;
        }
        if (sliceEndsInBuf) {
          if (endExclusive === bufEnd) {
            bufs.push(buf);
            break;
          }
          bufs.push(buf.subarray(0, endExclusive - bufStart));
          break;
        }
        bufs.push(buf);
      }
      return { bufs, length: endExclusive - beginInclusive };
    }
    indexOf(search, offset = 0) {
      if (!isUint8ArrayList(search) && !(search instanceof Uint8Array)) {
        throw new TypeError('The "value" argument must be a Uint8ArrayList or Uint8Array');
      }
      const needle = search instanceof Uint8Array ? search : search.subarray();
      offset = Number(offset ?? 0);
      if (isNaN(offset)) {
        offset = 0;
      }
      if (offset < 0) {
        offset = this.length + offset;
      }
      if (offset < 0) {
        offset = 0;
      }
      if (search.length === 0) {
        return offset > this.length ? this.length : offset;
      }
      const M = needle.byteLength;
      if (M === 0) {
        throw new TypeError("search must be at least 1 byte long");
      }
      const radix = 256;
      const rightmostPositions = new Int32Array(radix);
      for (let c = 0; c < radix; c++) {
        rightmostPositions[c] = -1;
      }
      for (let j = 0; j < M; j++) {
        rightmostPositions[needle[j]] = j;
      }
      const right = rightmostPositions;
      const lastIndex = this.byteLength - needle.byteLength;
      const lastPatIndex = needle.byteLength - 1;
      let skip;
      for (let i = offset; i <= lastIndex; i += skip) {
        skip = 0;
        for (let j = lastPatIndex; j >= 0; j--) {
          const char = this.get(i + j);
          if (needle[j] !== char) {
            skip = Math.max(1, j - right[char]);
            break;
          }
        }
        if (skip === 0) {
          return i;
        }
      }
      return -1;
    }
    getInt8(byteOffset) {
      const buf = this.subarray(byteOffset, byteOffset + 1);
      const view = new DataView(buf.buffer, buf.byteOffset, buf.byteLength);
      return view.getInt8(0);
    }
    setInt8(byteOffset, value) {
      const buf = allocUnsafe(1);
      const view = new DataView(buf.buffer, buf.byteOffset, buf.byteLength);
      view.setInt8(0, value);
      this.write(buf, byteOffset);
    }
    getInt16(byteOffset, littleEndian) {
      const buf = this.subarray(byteOffset, byteOffset + 2);
      const view = new DataView(buf.buffer, buf.byteOffset, buf.byteLength);
      return view.getInt16(0, littleEndian);
    }
    setInt16(byteOffset, value, littleEndian) {
      const buf = alloc(2);
      const view = new DataView(buf.buffer, buf.byteOffset, buf.byteLength);
      view.setInt16(0, value, littleEndian);
      this.write(buf, byteOffset);
    }
    getInt32(byteOffset, littleEndian) {
      const buf = this.subarray(byteOffset, byteOffset + 4);
      const view = new DataView(buf.buffer, buf.byteOffset, buf.byteLength);
      return view.getInt32(0, littleEndian);
    }
    setInt32(byteOffset, value, littleEndian) {
      const buf = alloc(4);
      const view = new DataView(buf.buffer, buf.byteOffset, buf.byteLength);
      view.setInt32(0, value, littleEndian);
      this.write(buf, byteOffset);
    }
    getBigInt64(byteOffset, littleEndian) {
      const buf = this.subarray(byteOffset, byteOffset + 8);
      const view = new DataView(buf.buffer, buf.byteOffset, buf.byteLength);
      return view.getBigInt64(0, littleEndian);
    }
    setBigInt64(byteOffset, value, littleEndian) {
      const buf = alloc(8);
      const view = new DataView(buf.buffer, buf.byteOffset, buf.byteLength);
      view.setBigInt64(0, value, littleEndian);
      this.write(buf, byteOffset);
    }
    getUint8(byteOffset) {
      const buf = this.subarray(byteOffset, byteOffset + 1);
      const view = new DataView(buf.buffer, buf.byteOffset, buf.byteLength);
      return view.getUint8(0);
    }
    setUint8(byteOffset, value) {
      const buf = allocUnsafe(1);
      const view = new DataView(buf.buffer, buf.byteOffset, buf.byteLength);
      view.setUint8(0, value);
      this.write(buf, byteOffset);
    }
    getUint16(byteOffset, littleEndian) {
      const buf = this.subarray(byteOffset, byteOffset + 2);
      const view = new DataView(buf.buffer, buf.byteOffset, buf.byteLength);
      return view.getUint16(0, littleEndian);
    }
    setUint16(byteOffset, value, littleEndian) {
      const buf = alloc(2);
      const view = new DataView(buf.buffer, buf.byteOffset, buf.byteLength);
      view.setUint16(0, value, littleEndian);
      this.write(buf, byteOffset);
    }
    getUint32(byteOffset, littleEndian) {
      const buf = this.subarray(byteOffset, byteOffset + 4);
      const view = new DataView(buf.buffer, buf.byteOffset, buf.byteLength);
      return view.getUint32(0, littleEndian);
    }
    setUint32(byteOffset, value, littleEndian) {
      const buf = alloc(4);
      const view = new DataView(buf.buffer, buf.byteOffset, buf.byteLength);
      view.setUint32(0, value, littleEndian);
      this.write(buf, byteOffset);
    }
    getBigUint64(byteOffset, littleEndian) {
      const buf = this.subarray(byteOffset, byteOffset + 8);
      const view = new DataView(buf.buffer, buf.byteOffset, buf.byteLength);
      return view.getBigUint64(0, littleEndian);
    }
    setBigUint64(byteOffset, value, littleEndian) {
      const buf = alloc(8);
      const view = new DataView(buf.buffer, buf.byteOffset, buf.byteLength);
      view.setBigUint64(0, value, littleEndian);
      this.write(buf, byteOffset);
    }
    getFloat32(byteOffset, littleEndian) {
      const buf = this.subarray(byteOffset, byteOffset + 4);
      const view = new DataView(buf.buffer, buf.byteOffset, buf.byteLength);
      return view.getFloat32(0, littleEndian);
    }
    setFloat32(byteOffset, value, littleEndian) {
      const buf = alloc(4);
      const view = new DataView(buf.buffer, buf.byteOffset, buf.byteLength);
      view.setFloat32(0, value, littleEndian);
      this.write(buf, byteOffset);
    }
    getFloat64(byteOffset, littleEndian) {
      const buf = this.subarray(byteOffset, byteOffset + 8);
      const view = new DataView(buf.buffer, buf.byteOffset, buf.byteLength);
      return view.getFloat64(0, littleEndian);
    }
    setFloat64(byteOffset, value, littleEndian) {
      const buf = alloc(8);
      const view = new DataView(buf.buffer, buf.byteOffset, buf.byteLength);
      view.setFloat64(0, value, littleEndian);
      this.write(buf, byteOffset);
    }
    equals(other) {
      if (other == null) {
        return false;
      }
      if (!(other instanceof _Uint8ArrayList)) {
        return false;
      }
      if (other.bufs.length !== this.bufs.length) {
        return false;
      }
      for (let i = 0; i < this.bufs.length; i++) {
        if (!equals3(this.bufs[i], other.bufs[i])) {
          return false;
        }
      }
      return true;
    }
    /**
     * Create a Uint8ArrayList from a pre-existing list of Uint8Arrays.  Use this
     * method if you know the total size of all the Uint8Arrays ahead of time.
     */
    static fromUint8Arrays(bufs, length4) {
      const list = new _Uint8ArrayList();
      list.bufs = bufs;
      if (length4 == null) {
        length4 = bufs.reduce((acc, curr) => acc + curr.byteLength, 0);
      }
      list.length = length4;
      return list;
    }
  };

  // node_modules/uint8arrays/dist/src/from-string.js
  var import_browser_shims50 = __toESM(require_browser_shims(), 1);

  // node_modules/uint8arrays/dist/src/util/bases.js
  var import_browser_shims49 = __toESM(require_browser_shims(), 1);

  // node_modules/multiformats/dist/src/basics.js
  var import_browser_shims48 = __toESM(require_browser_shims(), 1);

  // node_modules/multiformats/dist/src/bases/base10.js
  var base10_exports = {};
  __export(base10_exports, {
    base10: () => base10
  });
  var import_browser_shims31 = __toESM(require_browser_shims(), 1);
  var base10 = baseX({
    prefix: "9",
    name: "base10",
    alphabet: "0123456789"
  });

  // node_modules/multiformats/dist/src/bases/base16.js
  var base16_exports = {};
  __export(base16_exports, {
    base16: () => base16,
    base16upper: () => base16upper
  });
  var import_browser_shims32 = __toESM(require_browser_shims(), 1);
  var base16 = rfc4648({
    prefix: "f",
    name: "base16",
    alphabet: "0123456789abcdef",
    bitsPerChar: 4
  });
  var base16upper = rfc4648({
    prefix: "F",
    name: "base16upper",
    alphabet: "0123456789ABCDEF",
    bitsPerChar: 4
  });

  // node_modules/multiformats/dist/src/bases/base2.js
  var base2_exports = {};
  __export(base2_exports, {
    base2: () => base2
  });
  var import_browser_shims33 = __toESM(require_browser_shims(), 1);
  var base2 = rfc4648({
    prefix: "0",
    name: "base2",
    alphabet: "01",
    bitsPerChar: 1
  });

  // node_modules/multiformats/dist/src/bases/base256emoji.js
  var base256emoji_exports = {};
  __export(base256emoji_exports, {
    base256emoji: () => base256emoji
  });
  var import_browser_shims34 = __toESM(require_browser_shims(), 1);
  var alphabet = Array.from("\u{1F680}\u{1FA90}\u2604\u{1F6F0}\u{1F30C}\u{1F311}\u{1F312}\u{1F313}\u{1F314}\u{1F315}\u{1F316}\u{1F317}\u{1F318}\u{1F30D}\u{1F30F}\u{1F30E}\u{1F409}\u2600\u{1F4BB}\u{1F5A5}\u{1F4BE}\u{1F4BF}\u{1F602}\u2764\u{1F60D}\u{1F923}\u{1F60A}\u{1F64F}\u{1F495}\u{1F62D}\u{1F618}\u{1F44D}\u{1F605}\u{1F44F}\u{1F601}\u{1F525}\u{1F970}\u{1F494}\u{1F496}\u{1F499}\u{1F622}\u{1F914}\u{1F606}\u{1F644}\u{1F4AA}\u{1F609}\u263A\u{1F44C}\u{1F917}\u{1F49C}\u{1F614}\u{1F60E}\u{1F607}\u{1F339}\u{1F926}\u{1F389}\u{1F49E}\u270C\u2728\u{1F937}\u{1F631}\u{1F60C}\u{1F338}\u{1F64C}\u{1F60B}\u{1F497}\u{1F49A}\u{1F60F}\u{1F49B}\u{1F642}\u{1F493}\u{1F929}\u{1F604}\u{1F600}\u{1F5A4}\u{1F603}\u{1F4AF}\u{1F648}\u{1F447}\u{1F3B6}\u{1F612}\u{1F92D}\u2763\u{1F61C}\u{1F48B}\u{1F440}\u{1F62A}\u{1F611}\u{1F4A5}\u{1F64B}\u{1F61E}\u{1F629}\u{1F621}\u{1F92A}\u{1F44A}\u{1F973}\u{1F625}\u{1F924}\u{1F449}\u{1F483}\u{1F633}\u270B\u{1F61A}\u{1F61D}\u{1F634}\u{1F31F}\u{1F62C}\u{1F643}\u{1F340}\u{1F337}\u{1F63B}\u{1F613}\u2B50\u2705\u{1F97A}\u{1F308}\u{1F608}\u{1F918}\u{1F4A6}\u2714\u{1F623}\u{1F3C3}\u{1F490}\u2639\u{1F38A}\u{1F498}\u{1F620}\u261D\u{1F615}\u{1F33A}\u{1F382}\u{1F33B}\u{1F610}\u{1F595}\u{1F49D}\u{1F64A}\u{1F639}\u{1F5E3}\u{1F4AB}\u{1F480}\u{1F451}\u{1F3B5}\u{1F91E}\u{1F61B}\u{1F534}\u{1F624}\u{1F33C}\u{1F62B}\u26BD\u{1F919}\u2615\u{1F3C6}\u{1F92B}\u{1F448}\u{1F62E}\u{1F646}\u{1F37B}\u{1F343}\u{1F436}\u{1F481}\u{1F632}\u{1F33F}\u{1F9E1}\u{1F381}\u26A1\u{1F31E}\u{1F388}\u274C\u270A\u{1F44B}\u{1F630}\u{1F928}\u{1F636}\u{1F91D}\u{1F6B6}\u{1F4B0}\u{1F353}\u{1F4A2}\u{1F91F}\u{1F641}\u{1F6A8}\u{1F4A8}\u{1F92C}\u2708\u{1F380}\u{1F37A}\u{1F913}\u{1F619}\u{1F49F}\u{1F331}\u{1F616}\u{1F476}\u{1F974}\u25B6\u27A1\u2753\u{1F48E}\u{1F4B8}\u2B07\u{1F628}\u{1F31A}\u{1F98B}\u{1F637}\u{1F57A}\u26A0\u{1F645}\u{1F61F}\u{1F635}\u{1F44E}\u{1F932}\u{1F920}\u{1F927}\u{1F4CC}\u{1F535}\u{1F485}\u{1F9D0}\u{1F43E}\u{1F352}\u{1F617}\u{1F911}\u{1F30A}\u{1F92F}\u{1F437}\u260E\u{1F4A7}\u{1F62F}\u{1F486}\u{1F446}\u{1F3A4}\u{1F647}\u{1F351}\u2744\u{1F334}\u{1F4A3}\u{1F438}\u{1F48C}\u{1F4CD}\u{1F940}\u{1F922}\u{1F445}\u{1F4A1}\u{1F4A9}\u{1F450}\u{1F4F8}\u{1F47B}\u{1F910}\u{1F92E}\u{1F3BC}\u{1F975}\u{1F6A9}\u{1F34E}\u{1F34A}\u{1F47C}\u{1F48D}\u{1F4E3}\u{1F942}");
  var alphabetBytesToChars = alphabet.reduce((p, c, i) => {
    p[i] = c;
    return p;
  }, []);
  var alphabetCharsToBytes = alphabet.reduce((p, c, i) => {
    const codePoint = c.codePointAt(0);
    if (codePoint == null) {
      throw new Error(`Invalid character: ${c}`);
    }
    p[codePoint] = i;
    return p;
  }, []);
  function encode4(data) {
    return data.reduce((p, c) => {
      p += alphabetBytesToChars[c];
      return p;
    }, "");
  }
  function decode5(str) {
    const byts = [];
    for (const char of str) {
      const codePoint = char.codePointAt(0);
      if (codePoint == null) {
        throw new Error(`Invalid character: ${char}`);
      }
      const byt = alphabetCharsToBytes[codePoint];
      if (byt == null) {
        throw new Error(`Non-base256emoji character: ${char}`);
      }
      byts.push(byt);
    }
    return new Uint8Array(byts);
  }
  var base256emoji = from({
    prefix: "\u{1F680}",
    name: "base256emoji",
    encode: encode4,
    decode: decode5
  });

  // node_modules/multiformats/dist/src/bases/base64.js
  var base64_exports = {};
  __export(base64_exports, {
    base64: () => base64,
    base64pad: () => base64pad,
    base64url: () => base64url,
    base64urlpad: () => base64urlpad
  });
  var import_browser_shims35 = __toESM(require_browser_shims(), 1);
  var base64 = rfc4648({
    prefix: "m",
    name: "base64",
    alphabet: "ABCDEFGHIJKLMNOPQRSTUVWXYZabcdefghijklmnopqrstuvwxyz0123456789+/",
    bitsPerChar: 6
  });
  var base64pad = rfc4648({
    prefix: "M",
    name: "base64pad",
    alphabet: "ABCDEFGHIJKLMNOPQRSTUVWXYZabcdefghijklmnopqrstuvwxyz0123456789+/=",
    bitsPerChar: 6
  });
  var base64url = rfc4648({
    prefix: "u",
    name: "base64url",
    alphabet: "ABCDEFGHIJKLMNOPQRSTUVWXYZabcdefghijklmnopqrstuvwxyz0123456789-_",
    bitsPerChar: 6
  });
  var base64urlpad = rfc4648({
    prefix: "U",
    name: "base64urlpad",
    alphabet: "ABCDEFGHIJKLMNOPQRSTUVWXYZabcdefghijklmnopqrstuvwxyz0123456789-_=",
    bitsPerChar: 6
  });

  // node_modules/multiformats/dist/src/bases/base8.js
  var base8_exports = {};
  __export(base8_exports, {
    base8: () => base8
  });
  var import_browser_shims36 = __toESM(require_browser_shims(), 1);
  var base8 = rfc4648({
    prefix: "7",
    name: "base8",
    alphabet: "01234567",
    bitsPerChar: 3
  });

  // node_modules/multiformats/dist/src/bases/identity.js
  var identity_exports2 = {};
  __export(identity_exports2, {
    identity: () => identity2
  });
  var import_browser_shims37 = __toESM(require_browser_shims(), 1);
  var identity2 = from({
    prefix: "\0",
    name: "identity",
    encode: (buf) => toString(buf),
    decode: (str) => fromString(str)
  });

  // node_modules/multiformats/dist/src/codecs/json.js
  var import_browser_shims38 = __toESM(require_browser_shims(), 1);
  var textEncoder = new TextEncoder();
  var textDecoder = new TextDecoder();

  // node_modules/multiformats/dist/src/codecs/raw.js
  var import_browser_shims39 = __toESM(require_browser_shims(), 1);

  // node_modules/multiformats/dist/src/hashes/sha2-browser.js
  var sha2_browser_exports = {};
  __export(sha2_browser_exports, {
    sha256: () => sha256,
    sha512: () => sha512
  });
  var import_browser_shims41 = __toESM(require_browser_shims(), 1);

  // node_modules/multiformats/dist/src/hashes/hasher.js
  var import_browser_shims40 = __toESM(require_browser_shims(), 1);
  function from2({ name: name3, code: code2, encode: encode10 }) {
    return new Hasher(name3, code2, encode10);
  }
  var Hasher = class {
    name;
    code;
    encode;
    constructor(name3, code2, encode10) {
      this.name = name3;
      this.code = code2;
      this.encode = encode10;
    }
    digest(input) {
      if (input instanceof Uint8Array) {
        const result = this.encode(input);
        return result instanceof Uint8Array ? create(this.code, result) : result.then((digest2) => create(this.code, digest2));
      } else {
        throw Error("Unknown type, must be binary type");
      }
    }
  };

  // node_modules/multiformats/dist/src/hashes/sha2-browser.js
  function sha(name3) {
    return async (data) => new Uint8Array(await crypto.subtle.digest(name3, data));
  }
  var sha256 = from2({
    name: "sha2-256",
    code: 18,
    encode: sha("SHA-256")
  });
  var sha512 = from2({
    name: "sha2-512",
    code: 19,
    encode: sha("SHA-512")
  });

  // node_modules/multiformats/dist/src/index.js
  var import_browser_shims47 = __toESM(require_browser_shims(), 1);

  // node_modules/multiformats/dist/src/interface.js
  var import_browser_shims46 = __toESM(require_browser_shims(), 1);

  // node_modules/multiformats/dist/src/bases/interface.js
  var import_browser_shims42 = __toESM(require_browser_shims(), 1);

  // node_modules/multiformats/dist/src/hashes/interface.js
  var import_browser_shims43 = __toESM(require_browser_shims(), 1);

  // node_modules/multiformats/dist/src/codecs/interface.js
  var import_browser_shims44 = __toESM(require_browser_shims(), 1);

  // node_modules/multiformats/dist/src/block/interface.js
  var import_browser_shims45 = __toESM(require_browser_shims(), 1);

  // node_modules/multiformats/dist/src/basics.js
  var bases = { ...identity_exports2, ...base2_exports, ...base8_exports, ...base10_exports, ...base16_exports, ...base32_exports, ...base36_exports, ...base58_exports, ...base64_exports, ...base256emoji_exports };
  var hashes = { ...sha2_browser_exports, ...identity_exports };

  // node_modules/uint8arrays/dist/src/util/bases.js
  function createCodec(name3, prefix, encode10, decode11) {
    return {
      name: name3,
      prefix,
      encoder: {
        name: name3,
        prefix,
        encode: encode10
      },
      decoder: {
        decode: decode11
      }
    };
  }
  var string = createCodec("utf8", "u", (buf) => {
    const decoder = new TextDecoder("utf8");
    return "u" + decoder.decode(buf);
  }, (str) => {
    const encoder = new TextEncoder();
    return encoder.encode(str.substring(1));
  });
  var ascii = createCodec("ascii", "a", (buf) => {
    let string3 = "a";
    for (let i = 0; i < buf.length; i++) {
      string3 += String.fromCharCode(buf[i]);
    }
    return string3;
  }, (str) => {
    str = str.substring(1);
    const buf = allocUnsafe(str.length);
    for (let i = 0; i < str.length; i++) {
      buf[i] = str.charCodeAt(i);
    }
    return buf;
  });
  var BASES = {
    utf8: string,
    "utf-8": string,
    hex: bases.base16,
    latin1: ascii,
    ascii,
    binary: ascii,
    ...bases
  };
  var bases_default = BASES;

  // node_modules/uint8arrays/dist/src/from-string.js
  function fromString2(string3, encoding = "utf8") {
    const base3 = bases_default[encoding];
    if (base3 == null) {
      throw new Error(`Unsupported encoding "${encoding}"`);
    }
    return base3.decoder.decode(`${base3.prefix}${string3}`);
  }

  // node_modules/uint8arrays/dist/src/to-string.js
  var import_browser_shims51 = __toESM(require_browser_shims(), 1);
  function toString2(array, encoding = "utf8") {
    const base3 = bases_default[encoding];
    if (base3 == null) {
      throw new Error(`Unsupported encoding "${encoding}"`);
    }
    return base3.encoder.encode(array).substring(1);
  }

  // node_modules/@libp2p/crypto/dist/src/keys/rsa/der.js
  var import_browser_shims52 = __toESM(require_browser_shims(), 1);
  var TAG_MASK = parseInt("11111", 2);
  var LONG_LENGTH_MASK = parseInt("10000000", 2);
  var LONG_LENGTH_BYTES_MASK = parseInt("01111111", 2);
  var decoders = {
    0: readSequence,
    1: readSequence,
    2: readInteger,
    3: readBitString,
    4: readOctetString,
    5: readNull,
    6: readObjectIdentifier,
    16: readSequence,
    22: readSequence,
    48: readSequence
  };
  function decodeDer(buf, context = { offset: 0 }) {
    const tag = buf[context.offset] & TAG_MASK;
    context.offset++;
    if (decoders[tag] != null) {
      return decoders[tag](buf, context);
    }
    throw new Error("No decoder for tag " + tag);
  }
  function readLength(buf, context) {
    let length4 = 0;
    if ((buf[context.offset] & LONG_LENGTH_MASK) === LONG_LENGTH_MASK) {
      const count = buf[context.offset] & LONG_LENGTH_BYTES_MASK;
      let str = "0x";
      context.offset++;
      for (let i = 0; i < count; i++, context.offset++) {
        str += buf[context.offset].toString(16).padStart(2, "0");
      }
      length4 = parseInt(str, 16);
    } else {
      length4 = buf[context.offset];
      context.offset++;
    }
    return length4;
  }
  function readSequence(buf, context) {
    readLength(buf, context);
    const entries = [];
    while (true) {
      if (context.offset >= buf.byteLength) {
        break;
      }
      const result = decodeDer(buf, context);
      if (result === null) {
        break;
      }
      entries.push(result);
    }
    return entries;
  }
  function readInteger(buf, context) {
    const length4 = readLength(buf, context);
    const start2 = context.offset;
    const end = context.offset + length4;
    const vals = [];
    for (let i = start2; i < end; i++) {
      if (i === start2 && buf[i] === 0) {
        continue;
      }
      vals.push(buf[i]);
    }
    context.offset += length4;
    return Uint8Array.from(vals);
  }
  function readObjectIdentifier(buf, context) {
    const count = readLength(buf, context);
    const finalOffset = context.offset + count;
    const byte = buf[context.offset];
    context.offset++;
    let val1 = 0;
    let val2 = 0;
    if (byte < 40) {
      val1 = 0;
      val2 = byte;
    } else if (byte < 80) {
      val1 = 1;
      val2 = byte - 40;
    } else {
      val1 = 2;
      val2 = byte - 80;
    }
    let oid = `${val1}.${val2}`;
    let num = [];
    while (context.offset < finalOffset) {
      const byte2 = buf[context.offset];
      context.offset++;
      num.push(byte2 & 127);
      if (byte2 < 128) {
        num.reverse();
        let val = 0;
        for (let i = 0; i < num.length; i++) {
          val += num[i] << i * 7;
        }
        oid += `.${val}`;
        num = [];
      }
    }
    return oid;
  }
  function readNull(buf, context) {
    context.offset++;
    return null;
  }
  function readBitString(buf, context) {
    const length4 = readLength(buf, context);
    const unusedBits = buf[context.offset];
    context.offset++;
    const bytes = buf.subarray(context.offset, context.offset + length4 - 1);
    context.offset += length4;
    if (unusedBits !== 0) {
      throw new Error("Unused bits in bit string is unimplemented");
    }
    return bytes;
  }
  function readOctetString(buf, context) {
    const length4 = readLength(buf, context);
    const bytes = buf.subarray(context.offset, context.offset + length4);
    context.offset += length4;
    return bytes;
  }
  function encodeNumber(value) {
    let number2 = value.toString(16);
    if (number2.length % 2 === 1) {
      number2 = "0" + number2;
    }
    const array = new Uint8ArrayList();
    for (let i = 0; i < number2.length; i += 2) {
      array.append(Uint8Array.from([parseInt(`${number2[i]}${number2[i + 1]}`, 16)]));
    }
    return array;
  }
  function encodeLength(bytes) {
    if (bytes.byteLength < 128) {
      return Uint8Array.from([bytes.byteLength]);
    }
    const length4 = encodeNumber(bytes.byteLength);
    return new Uint8ArrayList(Uint8Array.from([
      length4.byteLength | LONG_LENGTH_MASK
    ]), length4);
  }
  function encodeInteger(value) {
    const contents = new Uint8ArrayList();
    const mask = 128;
    const positive = (value.subarray()[0] & mask) === mask;
    if (positive) {
      contents.append(Uint8Array.from([0]));
    }
    contents.append(value);
    return new Uint8ArrayList(Uint8Array.from([2]), encodeLength(contents), contents);
  }
  function encodeBitString(value) {
    const unusedBits = Uint8Array.from([0]);
    const contents = new Uint8ArrayList(unusedBits, value);
    return new Uint8ArrayList(Uint8Array.from([3]), encodeLength(contents), contents);
  }
  function encodeOctetString(value) {
    return new Uint8ArrayList(Uint8Array.from([4]), encodeLength(value), value);
  }
  function encodeSequence(values, tag = 48) {
    const output = new Uint8ArrayList();
    for (const buf of values) {
      output.append(buf);
    }
    return new Uint8ArrayList(Uint8Array.from([tag]), encodeLength(output), output);
  }

  // node_modules/@libp2p/crypto/dist/src/keys/ecdsa/index.js
  var import_browser_shims53 = __toESM(require_browser_shims(), 1);
  async function generateECDSAKey(curve = "P-256") {
    const keyPair = await crypto.subtle.generateKey({
      name: "ECDSA",
      namedCurve: curve
    }, true, ["sign", "verify"]);
    return {
      publicKey: await crypto.subtle.exportKey("jwk", keyPair.publicKey),
      privateKey: await crypto.subtle.exportKey("jwk", keyPair.privateKey)
    };
  }
  async function hashAndSign(key, msg, options) {
    var _a2, _b2;
    const privateKey = await crypto.subtle.importKey("jwk", key, {
      name: "ECDSA",
      namedCurve: key.crv ?? "P-256"
    }, false, ["sign"]);
    (_a2 = options == null ? void 0 : options.signal) == null ? void 0 : _a2.throwIfAborted();
    const signature = await crypto.subtle.sign({
      name: "ECDSA",
      hash: {
        name: "SHA-256"
      }
    }, privateKey, msg.subarray());
    (_b2 = options == null ? void 0 : options.signal) == null ? void 0 : _b2.throwIfAborted();
    return new Uint8Array(signature, 0, signature.byteLength);
  }
  async function hashAndVerify(key, sig, msg, options) {
    var _a2, _b2;
    const publicKey = await crypto.subtle.importKey("jwk", key, {
      name: "ECDSA",
      namedCurve: key.crv ?? "P-256"
    }, false, ["verify"]);
    (_a2 = options == null ? void 0 : options.signal) == null ? void 0 : _a2.throwIfAborted();
    const result = await crypto.subtle.verify({
      name: "ECDSA",
      hash: {
        name: "SHA-256"
      }
    }, publicKey, sig, msg.subarray());
    (_b2 = options == null ? void 0 : options.signal) == null ? void 0 : _b2.throwIfAborted();
    return result;
  }

  // node_modules/@libp2p/crypto/dist/src/keys/ecdsa/utils.js
  var OID_256 = Uint8Array.from([6, 8, 42, 134, 72, 206, 61, 3, 1, 7]);
  var OID_384 = Uint8Array.from([6, 5, 43, 129, 4, 0, 34]);
  var OID_521 = Uint8Array.from([6, 5, 43, 129, 4, 0, 35]);
  var P_256_KEY_JWK = {
    ext: true,
    kty: "EC",
    crv: "P-256"
  };
  var P_384_KEY_JWK = {
    ext: true,
    kty: "EC",
    crv: "P-384"
  };
  var P_521_KEY_JWK = {
    ext: true,
    kty: "EC",
    crv: "P-521"
  };
  var P_256_KEY_LENGTH = 32;
  var P_384_KEY_LENGTH = 48;
  var P_521_KEY_LENGTH = 66;
  function unmarshalECDSAPublicKey(bytes) {
    const message2 = decodeDer(bytes);
    return pkiMessageToECDSAPublicKey(message2);
  }
  function pkiMessageToECDSAPublicKey(message2) {
    const coordinates = message2[1][1][0];
    const offset = 1;
    let x;
    let y2;
    if (coordinates.byteLength === P_256_KEY_LENGTH * 2 + 1) {
      x = toString2(coordinates.subarray(offset, offset + P_256_KEY_LENGTH), "base64url");
      y2 = toString2(coordinates.subarray(offset + P_256_KEY_LENGTH), "base64url");
      return new ECDSAPublicKey({
        ...P_256_KEY_JWK,
        key_ops: ["verify"],
        x,
        y: y2
      });
    }
    if (coordinates.byteLength === P_384_KEY_LENGTH * 2 + 1) {
      x = toString2(coordinates.subarray(offset, offset + P_384_KEY_LENGTH), "base64url");
      y2 = toString2(coordinates.subarray(offset + P_384_KEY_LENGTH), "base64url");
      return new ECDSAPublicKey({
        ...P_384_KEY_JWK,
        key_ops: ["verify"],
        x,
        y: y2
      });
    }
    if (coordinates.byteLength === P_521_KEY_LENGTH * 2 + 1) {
      x = toString2(coordinates.subarray(offset, offset + P_521_KEY_LENGTH), "base64url");
      y2 = toString2(coordinates.subarray(offset + P_521_KEY_LENGTH), "base64url");
      return new ECDSAPublicKey({
        ...P_521_KEY_JWK,
        key_ops: ["verify"],
        x,
        y: y2
      });
    }
    throw new InvalidParametersError(`coordinates were wrong length, got ${coordinates.byteLength}, expected 65, 97 or 133`);
  }
  function privateKeyToPKIMessage(privateKey) {
    return encodeSequence([
      encodeInteger(Uint8Array.from([1])),
      // header
      encodeOctetString(fromString2(privateKey.d ?? "", "base64url")),
      // body
      encodeSequence([
        getOID(privateKey.crv)
      ], 160),
      encodeSequence([
        encodeBitString(new Uint8ArrayList(Uint8Array.from([4]), fromString2(privateKey.x ?? "", "base64url"), fromString2(privateKey.y ?? "", "base64url")))
      ], 161)
    ]).subarray();
  }
  function publicKeyToPKIMessage(publicKey) {
    return encodeSequence([
      encodeInteger(Uint8Array.from([1])),
      // header
      encodeSequence([
        getOID(publicKey.crv)
      ], 160),
      encodeSequence([
        encodeBitString(new Uint8ArrayList(Uint8Array.from([4]), fromString2(publicKey.x ?? "", "base64url"), fromString2(publicKey.y ?? "", "base64url")))
      ], 161)
    ]).subarray();
  }
  function getOID(curve) {
    if (curve === "P-256") {
      return OID_256;
    }
    if (curve === "P-384") {
      return OID_384;
    }
    if (curve === "P-521") {
      return OID_521;
    }
    throw new InvalidParametersError(`Invalid curve ${curve}`);
  }
  async function generateECDSAKeyPair(curve = "P-256") {
    const key = await generateECDSAKey(curve);
    return new ECDSAPrivateKey(key.privateKey);
  }

  // node_modules/@libp2p/crypto/dist/src/keys/ecdsa/ecdsa.js
  var ECDSAPublicKey = class {
    type = "ECDSA";
    jwk;
    _raw;
    constructor(jwk) {
      this.jwk = jwk;
    }
    get raw() {
      if (this._raw == null) {
        this._raw = publicKeyToPKIMessage(this.jwk);
      }
      return this._raw;
    }
    toMultihash() {
      return identity.digest(publicKeyToProtobuf(this));
    }
    toCID() {
      return CID.createV1(114, this.toMultihash());
    }
    toString() {
      return base58btc.encode(this.toMultihash().bytes).substring(1);
    }
    equals(key) {
      if (key == null || !(key.raw instanceof Uint8Array)) {
        return false;
      }
      return equals3(this.raw, key.raw);
    }
    async verify(data, sig, options) {
      return hashAndVerify(this.jwk, sig, data, options);
    }
  };
  var ECDSAPrivateKey = class {
    type = "ECDSA";
    jwk;
    publicKey;
    _raw;
    constructor(jwk) {
      this.jwk = jwk;
      this.publicKey = new ECDSAPublicKey({
        crv: jwk.crv,
        ext: jwk.ext,
        key_ops: ["verify"],
        kty: "EC",
        x: jwk.x,
        y: jwk.y
      });
    }
    get raw() {
      if (this._raw == null) {
        this._raw = privateKeyToPKIMessage(this.jwk);
      }
      return this._raw;
    }
    equals(key) {
      if (key == null || !(key.raw instanceof Uint8Array)) {
        return false;
      }
      return equals3(this.raw, key.raw);
    }
    async sign(message2, options) {
      return hashAndSign(this.jwk, message2, options);
    }
  };

  // node_modules/@libp2p/crypto/dist/src/keys/ed25519/index.browser.js
  var import_browser_shims70 = __toESM(require_browser_shims(), 1);

  // node_modules/@noble/curves/esm/ed25519.js
  var import_browser_shims66 = __toESM(require_browser_shims(), 1);

  // node_modules/@noble/hashes/esm/sha2.js
  var import_browser_shims60 = __toESM(require_browser_shims(), 1);

  // node_modules/@noble/hashes/esm/_md.js
  var import_browser_shims58 = __toESM(require_browser_shims(), 1);

  // node_modules/@noble/hashes/esm/utils.js
  var import_browser_shims57 = __toESM(require_browser_shims(), 1);

  // node_modules/@noble/hashes/esm/crypto.js
  var import_browser_shims56 = __toESM(require_browser_shims(), 1);
  var crypto2 = typeof globalThis === "object" && "crypto" in globalThis ? globalThis.crypto : void 0;

  // node_modules/@noble/hashes/esm/utils.js
  function isBytes(a) {
    return a instanceof Uint8Array || ArrayBuffer.isView(a) && a.constructor.name === "Uint8Array";
  }
  function anumber(n) {
    if (!Number.isSafeInteger(n) || n < 0)
      throw new Error("positive integer expected, got " + n);
  }
  function abytes(b, ...lengths) {
    if (!isBytes(b))
      throw new Error("Uint8Array expected");
    if (lengths.length > 0 && !lengths.includes(b.length))
      throw new Error("Uint8Array expected of length " + lengths + ", got length=" + b.length);
  }
  function ahash(h2) {
    if (typeof h2 !== "function" || typeof h2.create !== "function")
      throw new Error("Hash should be wrapped by utils.createHasher");
    anumber(h2.outputLen);
    anumber(h2.blockLen);
  }
  function aexists(instance, checkFinished = true) {
    if (instance.destroyed)
      throw new Error("Hash instance has been destroyed");
    if (checkFinished && instance.finished)
      throw new Error("Hash#digest() has already been called");
  }
  function aoutput(out, instance) {
    abytes(out);
    const min = instance.outputLen;
    if (out.length < min) {
      throw new Error("digestInto() expects output buffer of length at least " + min);
    }
  }
  function clean(...arrays) {
    for (let i = 0; i < arrays.length; i++) {
      arrays[i].fill(0);
    }
  }
  function createView(arr) {
    return new DataView(arr.buffer, arr.byteOffset, arr.byteLength);
  }
  function rotr(word, shift) {
    return word << 32 - shift | word >>> shift;
  }
  function utf8ToBytes(str) {
    if (typeof str !== "string")
      throw new Error("string expected");
    return new Uint8Array(new TextEncoder().encode(str));
  }
  function toBytes(data) {
    if (typeof data === "string")
      data = utf8ToBytes(data);
    abytes(data);
    return data;
  }
  function concatBytes(...arrays) {
    let sum = 0;
    for (let i = 0; i < arrays.length; i++) {
      const a = arrays[i];
      abytes(a);
      sum += a.length;
    }
    const res = new Uint8Array(sum);
    for (let i = 0, pad = 0; i < arrays.length; i++) {
      const a = arrays[i];
      res.set(a, pad);
      pad += a.length;
    }
    return res;
  }
  var Hash = class {
  };
  function createHasher(hashCons) {
    const hashC = (msg) => hashCons().update(toBytes(msg)).digest();
    const tmp = hashCons();
    hashC.outputLen = tmp.outputLen;
    hashC.blockLen = tmp.blockLen;
    hashC.create = () => hashCons();
    return hashC;
  }
  function randomBytes(bytesLength = 32) {
    if (crypto2 && typeof crypto2.getRandomValues === "function") {
      return crypto2.getRandomValues(new Uint8Array(bytesLength));
    }
    if (crypto2 && typeof crypto2.randomBytes === "function") {
      return Uint8Array.from(crypto2.randomBytes(bytesLength));
    }
    throw new Error("crypto.getRandomValues must be defined");
  }

  // node_modules/@noble/hashes/esm/_md.js
  function setBigUint64(view, byteOffset, value, isLE2) {
    if (typeof view.setBigUint64 === "function")
      return view.setBigUint64(byteOffset, value, isLE2);
    const _32n2 = BigInt(32);
    const _u32_max = BigInt(4294967295);
    const wh = Number(value >> _32n2 & _u32_max);
    const wl = Number(value & _u32_max);
    const h2 = isLE2 ? 4 : 0;
    const l = isLE2 ? 0 : 4;
    view.setUint32(byteOffset + h2, wh, isLE2);
    view.setUint32(byteOffset + l, wl, isLE2);
  }
  function Chi(a, b, c) {
    return a & b ^ ~a & c;
  }
  function Maj(a, b, c) {
    return a & b ^ a & c ^ b & c;
  }
  var HashMD = class extends Hash {
    constructor(blockLen, outputLen, padOffset, isLE2) {
      super();
      this.finished = false;
      this.length = 0;
      this.pos = 0;
      this.destroyed = false;
      this.blockLen = blockLen;
      this.outputLen = outputLen;
      this.padOffset = padOffset;
      this.isLE = isLE2;
      this.buffer = new Uint8Array(blockLen);
      this.view = createView(this.buffer);
    }
    update(data) {
      aexists(this);
      data = toBytes(data);
      abytes(data);
      const { view, buffer, blockLen } = this;
      const len = data.length;
      for (let pos = 0; pos < len; ) {
        const take2 = Math.min(blockLen - this.pos, len - pos);
        if (take2 === blockLen) {
          const dataView = createView(data);
          for (; blockLen <= len - pos; pos += blockLen)
            this.process(dataView, pos);
          continue;
        }
        buffer.set(data.subarray(pos, pos + take2), this.pos);
        this.pos += take2;
        pos += take2;
        if (this.pos === blockLen) {
          this.process(view, 0);
          this.pos = 0;
        }
      }
      this.length += data.length;
      this.roundClean();
      return this;
    }
    digestInto(out) {
      aexists(this);
      aoutput(out, this);
      this.finished = true;
      const { buffer, view, blockLen, isLE: isLE2 } = this;
      let { pos } = this;
      buffer[pos++] = 128;
      clean(this.buffer.subarray(pos));
      if (this.padOffset > blockLen - pos) {
        this.process(view, 0);
        pos = 0;
      }
      for (let i = pos; i < blockLen; i++)
        buffer[i] = 0;
      setBigUint64(view, blockLen - 8, BigInt(this.length * 8), isLE2);
      this.process(view, 0);
      const oview = createView(out);
      const len = this.outputLen;
      if (len % 4)
        throw new Error("_sha2: outputLen should be aligned to 32bit");
      const outLen = len / 4;
      const state = this.get();
      if (outLen > state.length)
        throw new Error("_sha2: outputLen bigger than state");
      for (let i = 0; i < outLen; i++)
        oview.setUint32(4 * i, state[i], isLE2);
    }
    digest() {
      const { buffer, outputLen } = this;
      this.digestInto(buffer);
      const res = buffer.slice(0, outputLen);
      this.destroy();
      return res;
    }
    _cloneInto(to) {
      to || (to = new this.constructor());
      to.set(...this.get());
      const { blockLen, buffer, length: length4, finished, destroyed, pos } = this;
      to.destroyed = destroyed;
      to.finished = finished;
      to.length = length4;
      to.pos = pos;
      if (length4 % blockLen)
        to.buffer.set(buffer);
      return to;
    }
    clone() {
      return this._cloneInto();
    }
  };
  var SHA256_IV = /* @__PURE__ */ Uint32Array.from([
    1779033703,
    3144134277,
    1013904242,
    2773480762,
    1359893119,
    2600822924,
    528734635,
    1541459225
  ]);
  var SHA512_IV = /* @__PURE__ */ Uint32Array.from([
    1779033703,
    4089235720,
    3144134277,
    2227873595,
    1013904242,
    4271175723,
    2773480762,
    1595750129,
    1359893119,
    2917565137,
    2600822924,
    725511199,
    528734635,
    4215389547,
    1541459225,
    327033209
  ]);

  // node_modules/@noble/hashes/esm/_u64.js
  var import_browser_shims59 = __toESM(require_browser_shims(), 1);
  var U32_MASK64 = /* @__PURE__ */ BigInt(2 ** 32 - 1);
  var _32n = /* @__PURE__ */ BigInt(32);
  function fromBig(n, le = false) {
    if (le)
      return { h: Number(n & U32_MASK64), l: Number(n >> _32n & U32_MASK64) };
    return { h: Number(n >> _32n & U32_MASK64) | 0, l: Number(n & U32_MASK64) | 0 };
  }
  function split(lst, le = false) {
    const len = lst.length;
    let Ah = new Uint32Array(len);
    let Al = new Uint32Array(len);
    for (let i = 0; i < len; i++) {
      const { h: h2, l } = fromBig(lst[i], le);
      [Ah[i], Al[i]] = [h2, l];
    }
    return [Ah, Al];
  }
  var shrSH = (h2, _l, s2) => h2 >>> s2;
  var shrSL = (h2, l, s2) => h2 << 32 - s2 | l >>> s2;
  var rotrSH = (h2, l, s2) => h2 >>> s2 | l << 32 - s2;
  var rotrSL = (h2, l, s2) => h2 << 32 - s2 | l >>> s2;
  var rotrBH = (h2, l, s2) => h2 << 64 - s2 | l >>> s2 - 32;
  var rotrBL = (h2, l, s2) => h2 >>> s2 - 32 | l << 64 - s2;
  function add(Ah, Al, Bh, Bl) {
    const l = (Al >>> 0) + (Bl >>> 0);
    return { h: Ah + Bh + (l / 2 ** 32 | 0) | 0, l: l | 0 };
  }
  var add3L = (Al, Bl, Cl) => (Al >>> 0) + (Bl >>> 0) + (Cl >>> 0);
  var add3H = (low, Ah, Bh, Ch) => Ah + Bh + Ch + (low / 2 ** 32 | 0) | 0;
  var add4L = (Al, Bl, Cl, Dl) => (Al >>> 0) + (Bl >>> 0) + (Cl >>> 0) + (Dl >>> 0);
  var add4H = (low, Ah, Bh, Ch, Dh) => Ah + Bh + Ch + Dh + (low / 2 ** 32 | 0) | 0;
  var add5L = (Al, Bl, Cl, Dl, El) => (Al >>> 0) + (Bl >>> 0) + (Cl >>> 0) + (Dl >>> 0) + (El >>> 0);
  var add5H = (low, Ah, Bh, Ch, Dh, Eh) => Ah + Bh + Ch + Dh + Eh + (low / 2 ** 32 | 0) | 0;

  // node_modules/@noble/hashes/esm/sha2.js
  var SHA256_K = /* @__PURE__ */ Uint32Array.from([
    1116352408,
    1899447441,
    3049323471,
    3921009573,
    961987163,
    1508970993,
    2453635748,
    2870763221,
    3624381080,
    310598401,
    607225278,
    1426881987,
    1925078388,
    2162078206,
    2614888103,
    3248222580,
    3835390401,
    4022224774,
    264347078,
    604807628,
    770255983,
    1249150122,
    1555081692,
    1996064986,
    2554220882,
    2821834349,
    2952996808,
    3210313671,
    3336571891,
    3584528711,
    113926993,
    338241895,
    666307205,
    773529912,
    1294757372,
    1396182291,
    1695183700,
    1986661051,
    2177026350,
    2456956037,
    2730485921,
    2820302411,
    3259730800,
    3345764771,
    3516065817,
    3600352804,
    4094571909,
    275423344,
    430227734,
    506948616,
    659060556,
    883997877,
    958139571,
    1322822218,
    1537002063,
    1747873779,
    1955562222,
    2024104815,
    2227730452,
    2361852424,
    2428436474,
    2756734187,
    3204031479,
    3329325298
  ]);
  var SHA256_W = /* @__PURE__ */ new Uint32Array(64);
  var SHA256 = class extends HashMD {
    constructor(outputLen = 32) {
      super(64, outputLen, 8, false);
      this.A = SHA256_IV[0] | 0;
      this.B = SHA256_IV[1] | 0;
      this.C = SHA256_IV[2] | 0;
      this.D = SHA256_IV[3] | 0;
      this.E = SHA256_IV[4] | 0;
      this.F = SHA256_IV[5] | 0;
      this.G = SHA256_IV[6] | 0;
      this.H = SHA256_IV[7] | 0;
    }
    get() {
      const { A, B, C, D, E, F, G, H } = this;
      return [A, B, C, D, E, F, G, H];
    }
    // prettier-ignore
    set(A, B, C, D, E, F, G, H) {
      this.A = A | 0;
      this.B = B | 0;
      this.C = C | 0;
      this.D = D | 0;
      this.E = E | 0;
      this.F = F | 0;
      this.G = G | 0;
      this.H = H | 0;
    }
    process(view, offset) {
      for (let i = 0; i < 16; i++, offset += 4)
        SHA256_W[i] = view.getUint32(offset, false);
      for (let i = 16; i < 64; i++) {
        const W15 = SHA256_W[i - 15];
        const W2 = SHA256_W[i - 2];
        const s0 = rotr(W15, 7) ^ rotr(W15, 18) ^ W15 >>> 3;
        const s1 = rotr(W2, 17) ^ rotr(W2, 19) ^ W2 >>> 10;
        SHA256_W[i] = s1 + SHA256_W[i - 7] + s0 + SHA256_W[i - 16] | 0;
      }
      let { A, B, C, D, E, F, G, H } = this;
      for (let i = 0; i < 64; i++) {
        const sigma1 = rotr(E, 6) ^ rotr(E, 11) ^ rotr(E, 25);
        const T1 = H + sigma1 + Chi(E, F, G) + SHA256_K[i] + SHA256_W[i] | 0;
        const sigma0 = rotr(A, 2) ^ rotr(A, 13) ^ rotr(A, 22);
        const T2 = sigma0 + Maj(A, B, C) | 0;
        H = G;
        G = F;
        F = E;
        E = D + T1 | 0;
        D = C;
        C = B;
        B = A;
        A = T1 + T2 | 0;
      }
      A = A + this.A | 0;
      B = B + this.B | 0;
      C = C + this.C | 0;
      D = D + this.D | 0;
      E = E + this.E | 0;
      F = F + this.F | 0;
      G = G + this.G | 0;
      H = H + this.H | 0;
      this.set(A, B, C, D, E, F, G, H);
    }
    roundClean() {
      clean(SHA256_W);
    }
    destroy() {
      this.set(0, 0, 0, 0, 0, 0, 0, 0);
      clean(this.buffer);
    }
  };
  var K512 = /* @__PURE__ */ (() => split([
    "0x428a2f98d728ae22",
    "0x7137449123ef65cd",
    "0xb5c0fbcfec4d3b2f",
    "0xe9b5dba58189dbbc",
    "0x3956c25bf348b538",
    "0x59f111f1b605d019",
    "0x923f82a4af194f9b",
    "0xab1c5ed5da6d8118",
    "0xd807aa98a3030242",
    "0x12835b0145706fbe",
    "0x243185be4ee4b28c",
    "0x550c7dc3d5ffb4e2",
    "0x72be5d74f27b896f",
    "0x80deb1fe3b1696b1",
    "0x9bdc06a725c71235",
    "0xc19bf174cf692694",
    "0xe49b69c19ef14ad2",
    "0xefbe4786384f25e3",
    "0x0fc19dc68b8cd5b5",
    "0x240ca1cc77ac9c65",
    "0x2de92c6f592b0275",
    "0x4a7484aa6ea6e483",
    "0x5cb0a9dcbd41fbd4",
    "0x76f988da831153b5",
    "0x983e5152ee66dfab",
    "0xa831c66d2db43210",
    "0xb00327c898fb213f",
    "0xbf597fc7beef0ee4",
    "0xc6e00bf33da88fc2",
    "0xd5a79147930aa725",
    "0x06ca6351e003826f",
    "0x142929670a0e6e70",
    "0x27b70a8546d22ffc",
    "0x2e1b21385c26c926",
    "0x4d2c6dfc5ac42aed",
    "0x53380d139d95b3df",
    "0x650a73548baf63de",
    "0x766a0abb3c77b2a8",
    "0x81c2c92e47edaee6",
    "0x92722c851482353b",
    "0xa2bfe8a14cf10364",
    "0xa81a664bbc423001",
    "0xc24b8b70d0f89791",
    "0xc76c51a30654be30",
    "0xd192e819d6ef5218",
    "0xd69906245565a910",
    "0xf40e35855771202a",
    "0x106aa07032bbd1b8",
    "0x19a4c116b8d2d0c8",
    "0x1e376c085141ab53",
    "0x2748774cdf8eeb99",
    "0x34b0bcb5e19b48a8",
    "0x391c0cb3c5c95a63",
    "0x4ed8aa4ae3418acb",
    "0x5b9cca4f7763e373",
    "0x682e6ff3d6b2b8a3",
    "0x748f82ee5defb2fc",
    "0x78a5636f43172f60",
    "0x84c87814a1f0ab72",
    "0x8cc702081a6439ec",
    "0x90befffa23631e28",
    "0xa4506cebde82bde9",
    "0xbef9a3f7b2c67915",
    "0xc67178f2e372532b",
    "0xca273eceea26619c",
    "0xd186b8c721c0c207",
    "0xeada7dd6cde0eb1e",
    "0xf57d4f7fee6ed178",
    "0x06f067aa72176fba",
    "0x0a637dc5a2c898a6",
    "0x113f9804bef90dae",
    "0x1b710b35131c471b",
    "0x28db77f523047d84",
    "0x32caab7b40c72493",
    "0x3c9ebe0a15c9bebc",
    "0x431d67c49c100d4c",
    "0x4cc5d4becb3e42b6",
    "0x597f299cfc657e2a",
    "0x5fcb6fab3ad6faec",
    "0x6c44198c4a475817"
  ].map((n) => BigInt(n))))();
  var SHA512_Kh = /* @__PURE__ */ (() => K512[0])();
  var SHA512_Kl = /* @__PURE__ */ (() => K512[1])();
  var SHA512_W_H = /* @__PURE__ */ new Uint32Array(80);
  var SHA512_W_L = /* @__PURE__ */ new Uint32Array(80);
  var SHA512 = class extends HashMD {
    constructor(outputLen = 64) {
      super(128, outputLen, 16, false);
      this.Ah = SHA512_IV[0] | 0;
      this.Al = SHA512_IV[1] | 0;
      this.Bh = SHA512_IV[2] | 0;
      this.Bl = SHA512_IV[3] | 0;
      this.Ch = SHA512_IV[4] | 0;
      this.Cl = SHA512_IV[5] | 0;
      this.Dh = SHA512_IV[6] | 0;
      this.Dl = SHA512_IV[7] | 0;
      this.Eh = SHA512_IV[8] | 0;
      this.El = SHA512_IV[9] | 0;
      this.Fh = SHA512_IV[10] | 0;
      this.Fl = SHA512_IV[11] | 0;
      this.Gh = SHA512_IV[12] | 0;
      this.Gl = SHA512_IV[13] | 0;
      this.Hh = SHA512_IV[14] | 0;
      this.Hl = SHA512_IV[15] | 0;
    }
    // prettier-ignore
    get() {
      const { Ah, Al, Bh, Bl, Ch, Cl, Dh, Dl, Eh, El, Fh, Fl, Gh, Gl, Hh, Hl } = this;
      return [Ah, Al, Bh, Bl, Ch, Cl, Dh, Dl, Eh, El, Fh, Fl, Gh, Gl, Hh, Hl];
    }
    // prettier-ignore
    set(Ah, Al, Bh, Bl, Ch, Cl, Dh, Dl, Eh, El, Fh, Fl, Gh, Gl, Hh, Hl) {
      this.Ah = Ah | 0;
      this.Al = Al | 0;
      this.Bh = Bh | 0;
      this.Bl = Bl | 0;
      this.Ch = Ch | 0;
      this.Cl = Cl | 0;
      this.Dh = Dh | 0;
      this.Dl = Dl | 0;
      this.Eh = Eh | 0;
      this.El = El | 0;
      this.Fh = Fh | 0;
      this.Fl = Fl | 0;
      this.Gh = Gh | 0;
      this.Gl = Gl | 0;
      this.Hh = Hh | 0;
      this.Hl = Hl | 0;
    }
    process(view, offset) {
      for (let i = 0; i < 16; i++, offset += 4) {
        SHA512_W_H[i] = view.getUint32(offset);
        SHA512_W_L[i] = view.getUint32(offset += 4);
      }
      for (let i = 16; i < 80; i++) {
        const W15h = SHA512_W_H[i - 15] | 0;
        const W15l = SHA512_W_L[i - 15] | 0;
        const s0h = rotrSH(W15h, W15l, 1) ^ rotrSH(W15h, W15l, 8) ^ shrSH(W15h, W15l, 7);
        const s0l = rotrSL(W15h, W15l, 1) ^ rotrSL(W15h, W15l, 8) ^ shrSL(W15h, W15l, 7);
        const W2h = SHA512_W_H[i - 2] | 0;
        const W2l = SHA512_W_L[i - 2] | 0;
        const s1h = rotrSH(W2h, W2l, 19) ^ rotrBH(W2h, W2l, 61) ^ shrSH(W2h, W2l, 6);
        const s1l = rotrSL(W2h, W2l, 19) ^ rotrBL(W2h, W2l, 61) ^ shrSL(W2h, W2l, 6);
        const SUMl = add4L(s0l, s1l, SHA512_W_L[i - 7], SHA512_W_L[i - 16]);
        const SUMh = add4H(SUMl, s0h, s1h, SHA512_W_H[i - 7], SHA512_W_H[i - 16]);
        SHA512_W_H[i] = SUMh | 0;
        SHA512_W_L[i] = SUMl | 0;
      }
      let { Ah, Al, Bh, Bl, Ch, Cl, Dh, Dl, Eh, El, Fh, Fl, Gh, Gl, Hh, Hl } = this;
      for (let i = 0; i < 80; i++) {
        const sigma1h = rotrSH(Eh, El, 14) ^ rotrSH(Eh, El, 18) ^ rotrBH(Eh, El, 41);
        const sigma1l = rotrSL(Eh, El, 14) ^ rotrSL(Eh, El, 18) ^ rotrBL(Eh, El, 41);
        const CHIh = Eh & Fh ^ ~Eh & Gh;
        const CHIl = El & Fl ^ ~El & Gl;
        const T1ll = add5L(Hl, sigma1l, CHIl, SHA512_Kl[i], SHA512_W_L[i]);
        const T1h = add5H(T1ll, Hh, sigma1h, CHIh, SHA512_Kh[i], SHA512_W_H[i]);
        const T1l = T1ll | 0;
        const sigma0h = rotrSH(Ah, Al, 28) ^ rotrBH(Ah, Al, 34) ^ rotrBH(Ah, Al, 39);
        const sigma0l = rotrSL(Ah, Al, 28) ^ rotrBL(Ah, Al, 34) ^ rotrBL(Ah, Al, 39);
        const MAJh = Ah & Bh ^ Ah & Ch ^ Bh & Ch;
        const MAJl = Al & Bl ^ Al & Cl ^ Bl & Cl;
        Hh = Gh | 0;
        Hl = Gl | 0;
        Gh = Fh | 0;
        Gl = Fl | 0;
        Fh = Eh | 0;
        Fl = El | 0;
        ({ h: Eh, l: El } = add(Dh | 0, Dl | 0, T1h | 0, T1l | 0));
        Dh = Ch | 0;
        Dl = Cl | 0;
        Ch = Bh | 0;
        Cl = Bl | 0;
        Bh = Ah | 0;
        Bl = Al | 0;
        const All = add3L(T1l, sigma0l, MAJl);
        Ah = add3H(All, T1h, sigma0h, MAJh);
        Al = All | 0;
      }
      ({ h: Ah, l: Al } = add(this.Ah | 0, this.Al | 0, Ah | 0, Al | 0));
      ({ h: Bh, l: Bl } = add(this.Bh | 0, this.Bl | 0, Bh | 0, Bl | 0));
      ({ h: Ch, l: Cl } = add(this.Ch | 0, this.Cl | 0, Ch | 0, Cl | 0));
      ({ h: Dh, l: Dl } = add(this.Dh | 0, this.Dl | 0, Dh | 0, Dl | 0));
      ({ h: Eh, l: El } = add(this.Eh | 0, this.El | 0, Eh | 0, El | 0));
      ({ h: Fh, l: Fl } = add(this.Fh | 0, this.Fl | 0, Fh | 0, Fl | 0));
      ({ h: Gh, l: Gl } = add(this.Gh | 0, this.Gl | 0, Gh | 0, Gl | 0));
      ({ h: Hh, l: Hl } = add(this.Hh | 0, this.Hl | 0, Hh | 0, Hl | 0));
      this.set(Ah, Al, Bh, Bl, Ch, Cl, Dh, Dl, Eh, El, Fh, Fl, Gh, Gl, Hh, Hl);
    }
    roundClean() {
      clean(SHA512_W_H, SHA512_W_L);
    }
    destroy() {
      clean(this.buffer);
      this.set(0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0);
    }
  };
  var sha2562 = /* @__PURE__ */ createHasher(() => new SHA256());
  var sha5122 = /* @__PURE__ */ createHasher(() => new SHA512());

  // node_modules/@noble/curves/esm/abstract/curve.js
  var import_browser_shims63 = __toESM(require_browser_shims(), 1);

  // node_modules/@noble/curves/esm/abstract/modular.js
  var import_browser_shims62 = __toESM(require_browser_shims(), 1);

  // node_modules/@noble/curves/esm/abstract/utils.js
  var import_browser_shims61 = __toESM(require_browser_shims(), 1);
  var _0n = /* @__PURE__ */ BigInt(0);
  var _1n = /* @__PURE__ */ BigInt(1);
  function isBytes2(a) {
    return a instanceof Uint8Array || ArrayBuffer.isView(a) && a.constructor.name === "Uint8Array";
  }
  function abytes2(item) {
    if (!isBytes2(item))
      throw new Error("Uint8Array expected");
  }
  function abool(title, value) {
    if (typeof value !== "boolean")
      throw new Error(title + " boolean expected, got " + value);
  }
  function numberToHexUnpadded(num) {
    const hex = num.toString(16);
    return hex.length & 1 ? "0" + hex : hex;
  }
  function hexToNumber(hex) {
    if (typeof hex !== "string")
      throw new Error("hex string expected, got " + typeof hex);
    return hex === "" ? _0n : BigInt("0x" + hex);
  }
  var hasHexBuiltin = (
    // @ts-ignore
    typeof Uint8Array.from([]).toHex === "function" && typeof Uint8Array.fromHex === "function"
  );
  var hexes = /* @__PURE__ */ Array.from({ length: 256 }, (_, i) => i.toString(16).padStart(2, "0"));
  function bytesToHex(bytes) {
    abytes2(bytes);
    if (hasHexBuiltin)
      return bytes.toHex();
    let hex = "";
    for (let i = 0; i < bytes.length; i++) {
      hex += hexes[bytes[i]];
    }
    return hex;
  }
  var asciis = { _0: 48, _9: 57, A: 65, F: 70, a: 97, f: 102 };
  function asciiToBase16(ch) {
    if (ch >= asciis._0 && ch <= asciis._9)
      return ch - asciis._0;
    if (ch >= asciis.A && ch <= asciis.F)
      return ch - (asciis.A - 10);
    if (ch >= asciis.a && ch <= asciis.f)
      return ch - (asciis.a - 10);
    return;
  }
  function hexToBytes(hex) {
    if (typeof hex !== "string")
      throw new Error("hex string expected, got " + typeof hex);
    if (hasHexBuiltin)
      return Uint8Array.fromHex(hex);
    const hl = hex.length;
    const al = hl / 2;
    if (hl % 2)
      throw new Error("hex string expected, got unpadded hex of length " + hl);
    const array = new Uint8Array(al);
    for (let ai = 0, hi = 0; ai < al; ai++, hi += 2) {
      const n1 = asciiToBase16(hex.charCodeAt(hi));
      const n2 = asciiToBase16(hex.charCodeAt(hi + 1));
      if (n1 === void 0 || n2 === void 0) {
        const char = hex[hi] + hex[hi + 1];
        throw new Error('hex string expected, got non-hex character "' + char + '" at index ' + hi);
      }
      array[ai] = n1 * 16 + n2;
    }
    return array;
  }
  function bytesToNumberBE(bytes) {
    return hexToNumber(bytesToHex(bytes));
  }
  function bytesToNumberLE(bytes) {
    abytes2(bytes);
    return hexToNumber(bytesToHex(Uint8Array.from(bytes).reverse()));
  }
  function numberToBytesBE(n, len) {
    return hexToBytes(n.toString(16).padStart(len * 2, "0"));
  }
  function numberToBytesLE(n, len) {
    return numberToBytesBE(n, len).reverse();
  }
  function ensureBytes(title, hex, expectedLength) {
    let res;
    if (typeof hex === "string") {
      try {
        res = hexToBytes(hex);
      } catch (e) {
        throw new Error(title + " must be hex string or Uint8Array, cause: " + e);
      }
    } else if (isBytes2(hex)) {
      res = Uint8Array.from(hex);
    } else {
      throw new Error(title + " must be hex string or Uint8Array");
    }
    const len = res.length;
    if (typeof expectedLength === "number" && len !== expectedLength)
      throw new Error(title + " of length " + expectedLength + " expected, got " + len);
    return res;
  }
  function concatBytes2(...arrays) {
    let sum = 0;
    for (let i = 0; i < arrays.length; i++) {
      const a = arrays[i];
      abytes2(a);
      sum += a.length;
    }
    const res = new Uint8Array(sum);
    for (let i = 0, pad = 0; i < arrays.length; i++) {
      const a = arrays[i];
      res.set(a, pad);
      pad += a.length;
    }
    return res;
  }
  var isPosBig = (n) => typeof n === "bigint" && _0n <= n;
  function inRange(n, min, max) {
    return isPosBig(n) && isPosBig(min) && isPosBig(max) && min <= n && n < max;
  }
  function aInRange(title, n, min, max) {
    if (!inRange(n, min, max))
      throw new Error("expected valid " + title + ": " + min + " <= n < " + max + ", got " + n);
  }
  function bitLen(n) {
    let len;
    for (len = 0; n > _0n; n >>= _1n, len += 1)
      ;
    return len;
  }
  var bitMask = (n) => (_1n << BigInt(n)) - _1n;
  var u8n = (len) => new Uint8Array(len);
  var u8fr = (arr) => Uint8Array.from(arr);
  function createHmacDrbg(hashLen, qByteLen, hmacFn) {
    if (typeof hashLen !== "number" || hashLen < 2)
      throw new Error("hashLen must be a number");
    if (typeof qByteLen !== "number" || qByteLen < 2)
      throw new Error("qByteLen must be a number");
    if (typeof hmacFn !== "function")
      throw new Error("hmacFn must be a function");
    let v = u8n(hashLen);
    let k = u8n(hashLen);
    let i = 0;
    const reset = () => {
      v.fill(1);
      k.fill(0);
      i = 0;
    };
    const h2 = (...b) => hmacFn(k, v, ...b);
    const reseed = (seed = u8n(0)) => {
      k = h2(u8fr([0]), seed);
      v = h2();
      if (seed.length === 0)
        return;
      k = h2(u8fr([1]), seed);
      v = h2();
    };
    const gen = () => {
      if (i++ >= 1e3)
        throw new Error("drbg: tried 1000 values");
      let len = 0;
      const out = [];
      while (len < qByteLen) {
        v = h2();
        const sl = v.slice();
        out.push(sl);
        len += v.length;
      }
      return concatBytes2(...out);
    };
    const genUntil = (seed, pred) => {
      reset();
      reseed(seed);
      let res = void 0;
      while (!(res = pred(gen())))
        reseed();
      reset();
      return res;
    };
    return genUntil;
  }
  var validatorFns = {
    bigint: (val) => typeof val === "bigint",
    function: (val) => typeof val === "function",
    boolean: (val) => typeof val === "boolean",
    string: (val) => typeof val === "string",
    stringOrUint8Array: (val) => typeof val === "string" || isBytes2(val),
    isSafeInteger: (val) => Number.isSafeInteger(val),
    array: (val) => Array.isArray(val),
    field: (val, object) => object.Fp.isValid(val),
    hash: (val) => typeof val === "function" && Number.isSafeInteger(val.outputLen)
  };
  function validateObject(object, validators2, optValidators = {}) {
    const checkField = (fieldName, type, isOptional) => {
      const checkVal = validatorFns[type];
      if (typeof checkVal !== "function")
        throw new Error("invalid validator function");
      const val = object[fieldName];
      if (isOptional && val === void 0)
        return;
      if (!checkVal(val, object)) {
        throw new Error("param " + String(fieldName) + " is invalid. Expected " + type + ", got " + val);
      }
    };
    for (const [fieldName, type] of Object.entries(validators2))
      checkField(fieldName, type, false);
    for (const [fieldName, type] of Object.entries(optValidators))
      checkField(fieldName, type, true);
    return object;
  }
  function memoized(fn) {
    const map3 = /* @__PURE__ */ new WeakMap();
    return (arg, ...args) => {
      const val = map3.get(arg);
      if (val !== void 0)
        return val;
      const computed = fn(arg, ...args);
      map3.set(arg, computed);
      return computed;
    };
  }

  // node_modules/@noble/curves/esm/abstract/modular.js
  var _0n2 = BigInt(0);
  var _1n2 = BigInt(1);
  var _2n = /* @__PURE__ */ BigInt(2);
  var _3n = /* @__PURE__ */ BigInt(3);
  var _4n = /* @__PURE__ */ BigInt(4);
  var _5n = /* @__PURE__ */ BigInt(5);
  var _8n = /* @__PURE__ */ BigInt(8);
  function mod(a, b) {
    const result = a % b;
    return result >= _0n2 ? result : b + result;
  }
  function pow2(x, power, modulo) {
    let res = x;
    while (power-- > _0n2) {
      res *= res;
      res %= modulo;
    }
    return res;
  }
  function invert(number2, modulo) {
    if (number2 === _0n2)
      throw new Error("invert: expected non-zero number");
    if (modulo <= _0n2)
      throw new Error("invert: expected positive modulus, got " + modulo);
    let a = mod(number2, modulo);
    let b = modulo;
    let x = _0n2, y2 = _1n2, u = _1n2, v = _0n2;
    while (a !== _0n2) {
      const q = b / a;
      const r = b % a;
      const m2 = x - u * q;
      const n = y2 - v * q;
      b = a, a = r, x = u, y2 = v, u = m2, v = n;
    }
    const gcd = b;
    if (gcd !== _1n2)
      throw new Error("invert: does not exist");
    return mod(x, modulo);
  }
  function sqrt3mod4(Fp2, n) {
    const p1div4 = (Fp2.ORDER + _1n2) / _4n;
    const root = Fp2.pow(n, p1div4);
    if (!Fp2.eql(Fp2.sqr(root), n))
      throw new Error("Cannot find square root");
    return root;
  }
  function sqrt5mod8(Fp2, n) {
    const p5div8 = (Fp2.ORDER - _5n) / _8n;
    const n2 = Fp2.mul(n, _2n);
    const v = Fp2.pow(n2, p5div8);
    const nv = Fp2.mul(n, v);
    const i = Fp2.mul(Fp2.mul(nv, _2n), v);
    const root = Fp2.mul(nv, Fp2.sub(i, Fp2.ONE));
    if (!Fp2.eql(Fp2.sqr(root), n))
      throw new Error("Cannot find square root");
    return root;
  }
  function tonelliShanks(P) {
    if (P < BigInt(3))
      throw new Error("sqrt is not defined for small field");
    let Q = P - _1n2;
    let S = 0;
    while (Q % _2n === _0n2) {
      Q /= _2n;
      S++;
    }
    let Z = _2n;
    const _Fp = Field(P);
    while (FpLegendre(_Fp, Z) === 1) {
      if (Z++ > 1e3)
        throw new Error("Cannot find square root: probably non-prime P");
    }
    if (S === 1)
      return sqrt3mod4;
    let cc = _Fp.pow(Z, Q);
    const Q1div2 = (Q + _1n2) / _2n;
    return function tonelliSlow(Fp2, n) {
      if (Fp2.is0(n))
        return n;
      if (FpLegendre(Fp2, n) !== 1)
        throw new Error("Cannot find square root");
      let M = S;
      let c = Fp2.mul(Fp2.ONE, cc);
      let t = Fp2.pow(n, Q);
      let R = Fp2.pow(n, Q1div2);
      while (!Fp2.eql(t, Fp2.ONE)) {
        if (Fp2.is0(t))
          return Fp2.ZERO;
        let i = 1;
        let t_tmp = Fp2.sqr(t);
        while (!Fp2.eql(t_tmp, Fp2.ONE)) {
          i++;
          t_tmp = Fp2.sqr(t_tmp);
          if (i === M)
            throw new Error("Cannot find square root");
        }
        const exponent = _1n2 << BigInt(M - i - 1);
        const b = Fp2.pow(c, exponent);
        M = i;
        c = Fp2.sqr(b);
        t = Fp2.mul(t, c);
        R = Fp2.mul(R, b);
      }
      return R;
    };
  }
  function FpSqrt(P) {
    if (P % _4n === _3n)
      return sqrt3mod4;
    if (P % _8n === _5n)
      return sqrt5mod8;
    return tonelliShanks(P);
  }
  var isNegativeLE = (num, modulo) => (mod(num, modulo) & _1n2) === _1n2;
  var FIELD_FIELDS = [
    "create",
    "isValid",
    "is0",
    "neg",
    "inv",
    "sqrt",
    "sqr",
    "eql",
    "add",
    "sub",
    "mul",
    "pow",
    "div",
    "addN",
    "subN",
    "mulN",
    "sqrN"
  ];
  function validateField(field) {
    const initial = {
      ORDER: "bigint",
      MASK: "bigint",
      BYTES: "isSafeInteger",
      BITS: "isSafeInteger"
    };
    const opts = FIELD_FIELDS.reduce((map3, val) => {
      map3[val] = "function";
      return map3;
    }, initial);
    return validateObject(field, opts);
  }
  function FpPow(Fp2, num, power) {
    if (power < _0n2)
      throw new Error("invalid exponent, negatives unsupported");
    if (power === _0n2)
      return Fp2.ONE;
    if (power === _1n2)
      return num;
    let p = Fp2.ONE;
    let d2 = num;
    while (power > _0n2) {
      if (power & _1n2)
        p = Fp2.mul(p, d2);
      d2 = Fp2.sqr(d2);
      power >>= _1n2;
    }
    return p;
  }
  function FpInvertBatch(Fp2, nums, passZero = false) {
    const inverted = new Array(nums.length).fill(passZero ? Fp2.ZERO : void 0);
    const multipliedAcc = nums.reduce((acc, num, i) => {
      if (Fp2.is0(num))
        return acc;
      inverted[i] = acc;
      return Fp2.mul(acc, num);
    }, Fp2.ONE);
    const invertedAcc = Fp2.inv(multipliedAcc);
    nums.reduceRight((acc, num, i) => {
      if (Fp2.is0(num))
        return acc;
      inverted[i] = Fp2.mul(acc, inverted[i]);
      return Fp2.mul(acc, num);
    }, invertedAcc);
    return inverted;
  }
  function FpLegendre(Fp2, n) {
    const p1mod2 = (Fp2.ORDER - _1n2) / _2n;
    const powered = Fp2.pow(n, p1mod2);
    const yes = Fp2.eql(powered, Fp2.ONE);
    const zero2 = Fp2.eql(powered, Fp2.ZERO);
    const no = Fp2.eql(powered, Fp2.neg(Fp2.ONE));
    if (!yes && !zero2 && !no)
      throw new Error("invalid Legendre symbol result");
    return yes ? 1 : zero2 ? 0 : -1;
  }
  function nLength(n, nBitLength) {
    if (nBitLength !== void 0)
      anumber(nBitLength);
    const _nBitLength = nBitLength !== void 0 ? nBitLength : n.toString(2).length;
    const nByteLength = Math.ceil(_nBitLength / 8);
    return { nBitLength: _nBitLength, nByteLength };
  }
  function Field(ORDER, bitLen2, isLE2 = false, redef = {}) {
    if (ORDER <= _0n2)
      throw new Error("invalid field: expected ORDER > 0, got " + ORDER);
    const { nBitLength: BITS, nByteLength: BYTES } = nLength(ORDER, bitLen2);
    if (BYTES > 2048)
      throw new Error("invalid field: expected ORDER of <= 2048 bytes");
    let sqrtP;
    const f = Object.freeze({
      ORDER,
      isLE: isLE2,
      BITS,
      BYTES,
      MASK: bitMask(BITS),
      ZERO: _0n2,
      ONE: _1n2,
      create: (num) => mod(num, ORDER),
      isValid: (num) => {
        if (typeof num !== "bigint")
          throw new Error("invalid field element: expected bigint, got " + typeof num);
        return _0n2 <= num && num < ORDER;
      },
      is0: (num) => num === _0n2,
      isOdd: (num) => (num & _1n2) === _1n2,
      neg: (num) => mod(-num, ORDER),
      eql: (lhs, rhs) => lhs === rhs,
      sqr: (num) => mod(num * num, ORDER),
      add: (lhs, rhs) => mod(lhs + rhs, ORDER),
      sub: (lhs, rhs) => mod(lhs - rhs, ORDER),
      mul: (lhs, rhs) => mod(lhs * rhs, ORDER),
      pow: (num, power) => FpPow(f, num, power),
      div: (lhs, rhs) => mod(lhs * invert(rhs, ORDER), ORDER),
      // Same as above, but doesn't normalize
      sqrN: (num) => num * num,
      addN: (lhs, rhs) => lhs + rhs,
      subN: (lhs, rhs) => lhs - rhs,
      mulN: (lhs, rhs) => lhs * rhs,
      inv: (num) => invert(num, ORDER),
      sqrt: redef.sqrt || ((n) => {
        if (!sqrtP)
          sqrtP = FpSqrt(ORDER);
        return sqrtP(f, n);
      }),
      toBytes: (num) => isLE2 ? numberToBytesLE(num, BYTES) : numberToBytesBE(num, BYTES),
      fromBytes: (bytes) => {
        if (bytes.length !== BYTES)
          throw new Error("Field.fromBytes: expected " + BYTES + " bytes, got " + bytes.length);
        return isLE2 ? bytesToNumberLE(bytes) : bytesToNumberBE(bytes);
      },
      // TODO: we don't need it here, move out to separate fn
      invertBatch: (lst) => FpInvertBatch(f, lst),
      // We can't move this out because Fp6, Fp12 implement it
      // and it's unclear what to return in there.
      cmov: (a, b, c) => c ? b : a
    });
    return Object.freeze(f);
  }
  function getFieldBytesLength(fieldOrder) {
    if (typeof fieldOrder !== "bigint")
      throw new Error("field order must be bigint");
    const bitLength = fieldOrder.toString(2).length;
    return Math.ceil(bitLength / 8);
  }
  function getMinHashLength(fieldOrder) {
    const length4 = getFieldBytesLength(fieldOrder);
    return length4 + Math.ceil(length4 / 2);
  }
  function mapHashToField(key, fieldOrder, isLE2 = false) {
    const len = key.length;
    const fieldLen = getFieldBytesLength(fieldOrder);
    const minLen = getMinHashLength(fieldOrder);
    if (len < 16 || len < minLen || len > 1024)
      throw new Error("expected " + minLen + "-1024 bytes of input, got " + len);
    const num = isLE2 ? bytesToNumberLE(key) : bytesToNumberBE(key);
    const reduced = mod(num, fieldOrder - _1n2) + _1n2;
    return isLE2 ? numberToBytesLE(reduced, fieldLen) : numberToBytesBE(reduced, fieldLen);
  }

  // node_modules/@noble/curves/esm/abstract/curve.js
  var _0n3 = BigInt(0);
  var _1n3 = BigInt(1);
  function constTimeNegate(condition, item) {
    const neg = item.negate();
    return condition ? neg : item;
  }
  function validateW(W, bits) {
    if (!Number.isSafeInteger(W) || W <= 0 || W > bits)
      throw new Error("invalid window size, expected [1.." + bits + "], got W=" + W);
  }
  function calcWOpts(W, scalarBits) {
    validateW(W, scalarBits);
    const windows = Math.ceil(scalarBits / W) + 1;
    const windowSize = 2 ** (W - 1);
    const maxNumber = 2 ** W;
    const mask = bitMask(W);
    const shiftBy = BigInt(W);
    return { windows, windowSize, mask, maxNumber, shiftBy };
  }
  function calcOffsets(n, window2, wOpts) {
    const { windowSize, mask, maxNumber, shiftBy } = wOpts;
    let wbits = Number(n & mask);
    let nextN = n >> shiftBy;
    if (wbits > windowSize) {
      wbits -= maxNumber;
      nextN += _1n3;
    }
    const offsetStart = window2 * windowSize;
    const offset = offsetStart + Math.abs(wbits) - 1;
    const isZero = wbits === 0;
    const isNeg = wbits < 0;
    const isNegF = window2 % 2 !== 0;
    const offsetF = offsetStart;
    return { nextN, offset, isZero, isNeg, isNegF, offsetF };
  }
  function validateMSMPoints(points, c) {
    if (!Array.isArray(points))
      throw new Error("array expected");
    points.forEach((p, i) => {
      if (!(p instanceof c))
        throw new Error("invalid point at index " + i);
    });
  }
  function validateMSMScalars(scalars, field) {
    if (!Array.isArray(scalars))
      throw new Error("array of scalars expected");
    scalars.forEach((s2, i) => {
      if (!field.isValid(s2))
        throw new Error("invalid scalar at index " + i);
    });
  }
  var pointPrecomputes = /* @__PURE__ */ new WeakMap();
  var pointWindowSizes = /* @__PURE__ */ new WeakMap();
  function getW(P) {
    return pointWindowSizes.get(P) || 1;
  }
  function wNAF(c, bits) {
    return {
      constTimeNegate,
      hasPrecomputes(elm) {
        return getW(elm) !== 1;
      },
      // non-const time multiplication ladder
      unsafeLadder(elm, n, p = c.ZERO) {
        let d2 = elm;
        while (n > _0n3) {
          if (n & _1n3)
            p = p.add(d2);
          d2 = d2.double();
          n >>= _1n3;
        }
        return p;
      },
      /**
       * Creates a wNAF precomputation window. Used for caching.
       * Default window size is set by `utils.precompute()` and is equal to 8.
       * Number of precomputed points depends on the curve size:
       * 2^(1) * (Math.ceil( / ) + 1), where:
       * -  is the window size
       * -  is the bitlength of the curve order.
       * For a 256-bit curve and window size 8, the number of precomputed points is 128 * 33 = 4224.
       * @param elm Point instance
       * @param W window size
       * @returns precomputed point tables flattened to a single array
       */
      precomputeWindow(elm, W) {
        const { windows, windowSize } = calcWOpts(W, bits);
        const points = [];
        let p = elm;
        let base3 = p;
        for (let window2 = 0; window2 < windows; window2++) {
          base3 = p;
          points.push(base3);
          for (let i = 1; i < windowSize; i++) {
            base3 = base3.add(p);
            points.push(base3);
          }
          p = base3.double();
        }
        return points;
      },
      /**
       * Implements ec multiplication using precomputed tables and w-ary non-adjacent form.
       * @param W window size
       * @param precomputes precomputed tables
       * @param n scalar (we don't check here, but should be less than curve order)
       * @returns real and fake (for const-time) points
       */
      wNAF(W, precomputes, n) {
        let p = c.ZERO;
        let f = c.BASE;
        const wo = calcWOpts(W, bits);
        for (let window2 = 0; window2 < wo.windows; window2++) {
          const { nextN, offset, isZero, isNeg, isNegF, offsetF } = calcOffsets(n, window2, wo);
          n = nextN;
          if (isZero) {
            f = f.add(constTimeNegate(isNegF, precomputes[offsetF]));
          } else {
            p = p.add(constTimeNegate(isNeg, precomputes[offset]));
          }
        }
        return { p, f };
      },
      /**
       * Implements ec unsafe (non const-time) multiplication using precomputed tables and w-ary non-adjacent form.
       * @param W window size
       * @param precomputes precomputed tables
       * @param n scalar (we don't check here, but should be less than curve order)
       * @param acc accumulator point to add result of multiplication
       * @returns point
       */
      wNAFUnsafe(W, precomputes, n, acc = c.ZERO) {
        const wo = calcWOpts(W, bits);
        for (let window2 = 0; window2 < wo.windows; window2++) {
          if (n === _0n3)
            break;
          const { nextN, offset, isZero, isNeg } = calcOffsets(n, window2, wo);
          n = nextN;
          if (isZero) {
            continue;
          } else {
            const item = precomputes[offset];
            acc = acc.add(isNeg ? item.negate() : item);
          }
        }
        return acc;
      },
      getPrecomputes(W, P, transform) {
        let comp = pointPrecomputes.get(P);
        if (!comp) {
          comp = this.precomputeWindow(P, W);
          if (W !== 1)
            pointPrecomputes.set(P, transform(comp));
        }
        return comp;
      },
      wNAFCached(P, n, transform) {
        const W = getW(P);
        return this.wNAF(W, this.getPrecomputes(W, P, transform), n);
      },
      wNAFCachedUnsafe(P, n, transform, prev) {
        const W = getW(P);
        if (W === 1)
          return this.unsafeLadder(P, n, prev);
        return this.wNAFUnsafe(W, this.getPrecomputes(W, P, transform), n, prev);
      },
      // We calculate precomputes for elliptic curve point multiplication
      // using windowed method. This specifies window size and
      // stores precomputed values. Usually only base point would be precomputed.
      setWindowSize(P, W) {
        validateW(W, bits);
        pointWindowSizes.set(P, W);
        pointPrecomputes.delete(P);
      }
    };
  }
  function pippenger(c, fieldN, points, scalars) {
    validateMSMPoints(points, c);
    validateMSMScalars(scalars, fieldN);
    const plength = points.length;
    const slength = scalars.length;
    if (plength !== slength)
      throw new Error("arrays of points and scalars must have equal length");
    const zero2 = c.ZERO;
    const wbits = bitLen(BigInt(plength));
    let windowSize = 1;
    if (wbits > 12)
      windowSize = wbits - 3;
    else if (wbits > 4)
      windowSize = wbits - 2;
    else if (wbits > 0)
      windowSize = 2;
    const MASK = bitMask(windowSize);
    const buckets = new Array(Number(MASK) + 1).fill(zero2);
    const lastBits = Math.floor((fieldN.BITS - 1) / windowSize) * windowSize;
    let sum = zero2;
    for (let i = lastBits; i >= 0; i -= windowSize) {
      buckets.fill(zero2);
      for (let j = 0; j < slength; j++) {
        const scalar = scalars[j];
        const wbits2 = Number(scalar >> BigInt(i) & MASK);
        buckets[wbits2] = buckets[wbits2].add(points[j]);
      }
      let resI = zero2;
      for (let j = buckets.length - 1, sumI = zero2; j > 0; j--) {
        sumI = sumI.add(buckets[j]);
        resI = resI.add(sumI);
      }
      sum = sum.add(resI);
      if (i !== 0)
        for (let j = 0; j < windowSize; j++)
          sum = sum.double();
    }
    return sum;
  }
  function validateBasic(curve) {
    validateField(curve.Fp);
    validateObject(curve, {
      n: "bigint",
      h: "bigint",
      Gx: "field",
      Gy: "field"
    }, {
      nBitLength: "isSafeInteger",
      nByteLength: "isSafeInteger"
    });
    return Object.freeze({
      ...nLength(curve.n, curve.nBitLength),
      ...curve,
      ...{ p: curve.Fp.ORDER }
    });
  }

  // node_modules/@noble/curves/esm/abstract/edwards.js
  var import_browser_shims64 = __toESM(require_browser_shims(), 1);
  var _0n4 = BigInt(0);
  var _1n4 = BigInt(1);
  var _2n2 = BigInt(2);
  var _8n2 = BigInt(8);
  var VERIFY_DEFAULT = { zip215: true };
  function validateOpts(curve) {
    const opts = validateBasic(curve);
    validateObject(curve, {
      hash: "function",
      a: "bigint",
      d: "bigint",
      randomBytes: "function"
    }, {
      adjustScalarBytes: "function",
      domain: "function",
      uvRatio: "function",
      mapToCurve: "function"
    });
    return Object.freeze({ ...opts });
  }
  function twistedEdwards(curveDef) {
    const CURVE = validateOpts(curveDef);
    const { Fp: Fp2, n: CURVE_ORDER, prehash, hash: cHash, randomBytes: randomBytes3, nByteLength, h: cofactor } = CURVE;
    const MASK = _2n2 << BigInt(nByteLength * 8) - _1n4;
    const modP = Fp2.create;
    const Fn = Field(CURVE.n, CURVE.nBitLength);
    function isEdValidXY(x, y2) {
      const x2 = Fp2.sqr(x);
      const y22 = Fp2.sqr(y2);
      const left = Fp2.add(Fp2.mul(CURVE.a, x2), y22);
      const right = Fp2.add(Fp2.ONE, Fp2.mul(CURVE.d, Fp2.mul(x2, y22)));
      return Fp2.eql(left, right);
    }
    if (!isEdValidXY(CURVE.Gx, CURVE.Gy))
      throw new Error("bad curve params: generator point");
    const uvRatio2 = CURVE.uvRatio || ((u, v) => {
      try {
        return { isValid: true, value: Fp2.sqrt(u * Fp2.inv(v)) };
      } catch (e) {
        return { isValid: false, value: _0n4 };
      }
    });
    const adjustScalarBytes2 = CURVE.adjustScalarBytes || ((bytes) => bytes);
    const domain = CURVE.domain || ((data, ctx, phflag) => {
      abool("phflag", phflag);
      if (ctx.length || phflag)
        throw new Error("Contexts/pre-hash are not supported");
      return data;
    });
    function aCoordinate(title, n, banZero = false) {
      const min = banZero ? _1n4 : _0n4;
      aInRange("coordinate " + title, n, min, MASK);
    }
    function aextpoint(other) {
      if (!(other instanceof Point))
        throw new Error("ExtendedPoint expected");
    }
    const toAffineMemo = memoized((p, iz) => {
      const { ex: x, ey: y2, ez: z } = p;
      const is0 = p.is0();
      if (iz == null)
        iz = is0 ? _8n2 : Fp2.inv(z);
      const ax = modP(x * iz);
      const ay = modP(y2 * iz);
      const zz = modP(z * iz);
      if (is0)
        return { x: _0n4, y: _1n4 };
      if (zz !== _1n4)
        throw new Error("invZ was invalid");
      return { x: ax, y: ay };
    });
    const assertValidMemo = memoized((p) => {
      const { a, d: d2 } = CURVE;
      if (p.is0())
        throw new Error("bad point: ZERO");
      const { ex: X, ey: Y, ez: Z, et: T } = p;
      const X2 = modP(X * X);
      const Y2 = modP(Y * Y);
      const Z2 = modP(Z * Z);
      const Z4 = modP(Z2 * Z2);
      const aX2 = modP(X2 * a);
      const left = modP(Z2 * modP(aX2 + Y2));
      const right = modP(Z4 + modP(d2 * modP(X2 * Y2)));
      if (left !== right)
        throw new Error("bad point: equation left != right (1)");
      const XY = modP(X * Y);
      const ZT = modP(Z * T);
      if (XY !== ZT)
        throw new Error("bad point: equation left != right (2)");
      return true;
    });
    class Point {
      constructor(ex, ey, ez, et) {
        aCoordinate("x", ex);
        aCoordinate("y", ey);
        aCoordinate("z", ez, true);
        aCoordinate("t", et);
        this.ex = ex;
        this.ey = ey;
        this.ez = ez;
        this.et = et;
        Object.freeze(this);
      }
      get x() {
        return this.toAffine().x;
      }
      get y() {
        return this.toAffine().y;
      }
      static fromAffine(p) {
        if (p instanceof Point)
          throw new Error("extended point not allowed");
        const { x, y: y2 } = p || {};
        aCoordinate("x", x);
        aCoordinate("y", y2);
        return new Point(x, y2, _1n4, modP(x * y2));
      }
      static normalizeZ(points) {
        const toInv = FpInvertBatch(Fp2, points.map((p) => p.ez));
        return points.map((p, i) => p.toAffine(toInv[i])).map(Point.fromAffine);
      }
      // Multiscalar Multiplication
      static msm(points, scalars) {
        return pippenger(Point, Fn, points, scalars);
      }
      // "Private method", don't use it directly
      _setWindowSize(windowSize) {
        wnaf.setWindowSize(this, windowSize);
      }
      // Not required for fromHex(), which always creates valid points.
      // Could be useful for fromAffine().
      assertValidity() {
        assertValidMemo(this);
      }
      // Compare one point to another.
      equals(other) {
        aextpoint(other);
        const { ex: X1, ey: Y1, ez: Z1 } = this;
        const { ex: X2, ey: Y2, ez: Z2 } = other;
        const X1Z2 = modP(X1 * Z2);
        const X2Z1 = modP(X2 * Z1);
        const Y1Z2 = modP(Y1 * Z2);
        const Y2Z1 = modP(Y2 * Z1);
        return X1Z2 === X2Z1 && Y1Z2 === Y2Z1;
      }
      is0() {
        return this.equals(Point.ZERO);
      }
      negate() {
        return new Point(modP(-this.ex), this.ey, this.ez, modP(-this.et));
      }
      // Fast algo for doubling Extended Point.
      // https://hyperelliptic.org/EFD/g1p/auto-twisted-extended.html#doubling-dbl-2008-hwcd
      // Cost: 4M + 4S + 1*a + 6add + 1*2.
      double() {
        const { a } = CURVE;
        const { ex: X1, ey: Y1, ez: Z1 } = this;
        const A = modP(X1 * X1);
        const B = modP(Y1 * Y1);
        const C = modP(_2n2 * modP(Z1 * Z1));
        const D = modP(a * A);
        const x1y1 = X1 + Y1;
        const E = modP(modP(x1y1 * x1y1) - A - B);
        const G2 = D + B;
        const F = G2 - C;
        const H = D - B;
        const X3 = modP(E * F);
        const Y3 = modP(G2 * H);
        const T3 = modP(E * H);
        const Z3 = modP(F * G2);
        return new Point(X3, Y3, Z3, T3);
      }
      // Fast algo for adding 2 Extended Points.
      // https://hyperelliptic.org/EFD/g1p/auto-twisted-extended.html#addition-add-2008-hwcd
      // Cost: 9M + 1*a + 1*d + 7add.
      add(other) {
        aextpoint(other);
        const { a, d: d2 } = CURVE;
        const { ex: X1, ey: Y1, ez: Z1, et: T1 } = this;
        const { ex: X2, ey: Y2, ez: Z2, et: T2 } = other;
        const A = modP(X1 * X2);
        const B = modP(Y1 * Y2);
        const C = modP(T1 * d2 * T2);
        const D = modP(Z1 * Z2);
        const E = modP((X1 + Y1) * (X2 + Y2) - A - B);
        const F = D - C;
        const G2 = D + C;
        const H = modP(B - a * A);
        const X3 = modP(E * F);
        const Y3 = modP(G2 * H);
        const T3 = modP(E * H);
        const Z3 = modP(F * G2);
        return new Point(X3, Y3, Z3, T3);
      }
      subtract(other) {
        return this.add(other.negate());
      }
      wNAF(n) {
        return wnaf.wNAFCached(this, n, Point.normalizeZ);
      }
      // Constant-time multiplication.
      multiply(scalar) {
        const n = scalar;
        aInRange("scalar", n, _1n4, CURVE_ORDER);
        const { p, f } = this.wNAF(n);
        return Point.normalizeZ([p, f])[0];
      }
      // Non-constant-time multiplication. Uses double-and-add algorithm.
      // It's faster, but should only be used when you don't care about
      // an exposed private key e.g. sig verification.
      // Does NOT allow scalars higher than CURVE.n.
      // Accepts optional accumulator to merge with multiply (important for sparse scalars)
      multiplyUnsafe(scalar, acc = Point.ZERO) {
        const n = scalar;
        aInRange("scalar", n, _0n4, CURVE_ORDER);
        if (n === _0n4)
          return I;
        if (this.is0() || n === _1n4)
          return this;
        return wnaf.wNAFCachedUnsafe(this, n, Point.normalizeZ, acc);
      }
      // Checks if point is of small order.
      // If you add something to small order point, you will have "dirty"
      // point with torsion component.
      // Multiplies point by cofactor and checks if the result is 0.
      isSmallOrder() {
        return this.multiplyUnsafe(cofactor).is0();
      }
      // Multiplies point by curve order and checks if the result is 0.
      // Returns `false` is the point is dirty.
      isTorsionFree() {
        return wnaf.unsafeLadder(this, CURVE_ORDER).is0();
      }
      // Converts Extended point to default (x, y) coordinates.
      // Can accept precomputed Z^-1 - for example, from invertBatch.
      toAffine(iz) {
        return toAffineMemo(this, iz);
      }
      clearCofactor() {
        const { h: cofactor2 } = CURVE;
        if (cofactor2 === _1n4)
          return this;
        return this.multiplyUnsafe(cofactor2);
      }
      // Converts hash string or Uint8Array to Point.
      // Uses algo from RFC8032 5.1.3.
      static fromHex(hex, zip215 = false) {
        const { d: d2, a } = CURVE;
        const len = Fp2.BYTES;
        hex = ensureBytes("pointHex", hex, len);
        abool("zip215", zip215);
        const normed = hex.slice();
        const lastByte = hex[len - 1];
        normed[len - 1] = lastByte & ~128;
        const y2 = bytesToNumberLE(normed);
        const max = zip215 ? MASK : Fp2.ORDER;
        aInRange("pointHex.y", y2, _0n4, max);
        const y22 = modP(y2 * y2);
        const u = modP(y22 - _1n4);
        const v = modP(d2 * y22 - a);
        let { isValid, value: x } = uvRatio2(u, v);
        if (!isValid)
          throw new Error("Point.fromHex: invalid y coordinate");
        const isXOdd = (x & _1n4) === _1n4;
        const isLastByteOdd = (lastByte & 128) !== 0;
        if (!zip215 && x === _0n4 && isLastByteOdd)
          throw new Error("Point.fromHex: x=0 and x_0=1");
        if (isLastByteOdd !== isXOdd)
          x = modP(-x);
        return Point.fromAffine({ x, y: y2 });
      }
      static fromPrivateKey(privKey) {
        const { scalar } = getPrivateScalar(privKey);
        return G.multiply(scalar);
      }
      toRawBytes() {
        const { x, y: y2 } = this.toAffine();
        const bytes = numberToBytesLE(y2, Fp2.BYTES);
        bytes[bytes.length - 1] |= x & _1n4 ? 128 : 0;
        return bytes;
      }
      toHex() {
        return bytesToHex(this.toRawBytes());
      }
    }
    Point.BASE = new Point(CURVE.Gx, CURVE.Gy, _1n4, modP(CURVE.Gx * CURVE.Gy));
    Point.ZERO = new Point(_0n4, _1n4, _1n4, _0n4);
    const { BASE: G, ZERO: I } = Point;
    const wnaf = wNAF(Point, nByteLength * 8);
    function modN(a) {
      return mod(a, CURVE_ORDER);
    }
    function modN_LE(hash) {
      return modN(bytesToNumberLE(hash));
    }
    function getPrivateScalar(key) {
      const len = Fp2.BYTES;
      key = ensureBytes("private key", key, len);
      const hashed = ensureBytes("hashed private key", cHash(key), 2 * len);
      const head = adjustScalarBytes2(hashed.slice(0, len));
      const prefix = hashed.slice(len, 2 * len);
      const scalar = modN_LE(head);
      return { head, prefix, scalar };
    }
    function getExtendedPublicKey(key) {
      const { head, prefix, scalar } = getPrivateScalar(key);
      const point = G.multiply(scalar);
      const pointBytes = point.toRawBytes();
      return { head, prefix, scalar, point, pointBytes };
    }
    function getPublicKey(privKey) {
      return getExtendedPublicKey(privKey).pointBytes;
    }
    function hashDomainToScalar(context = Uint8Array.of(), ...msgs) {
      const msg = concatBytes2(...msgs);
      return modN_LE(cHash(domain(msg, ensureBytes("context", context), !!prehash)));
    }
    function sign(msg, privKey, options = {}) {
      msg = ensureBytes("message", msg);
      if (prehash)
        msg = prehash(msg);
      const { prefix, scalar, pointBytes } = getExtendedPublicKey(privKey);
      const r = hashDomainToScalar(options.context, prefix, msg);
      const R = G.multiply(r).toRawBytes();
      const k = hashDomainToScalar(options.context, R, pointBytes, msg);
      const s2 = modN(r + k * scalar);
      aInRange("signature.s", s2, _0n4, CURVE_ORDER);
      const res = concatBytes2(R, numberToBytesLE(s2, Fp2.BYTES));
      return ensureBytes("result", res, Fp2.BYTES * 2);
    }
    const verifyOpts = VERIFY_DEFAULT;
    function verify(sig, msg, publicKey, options = verifyOpts) {
      const { context, zip215 } = options;
      const len = Fp2.BYTES;
      sig = ensureBytes("signature", sig, 2 * len);
      msg = ensureBytes("message", msg);
      publicKey = ensureBytes("publicKey", publicKey, len);
      if (zip215 !== void 0)
        abool("zip215", zip215);
      if (prehash)
        msg = prehash(msg);
      const s2 = bytesToNumberLE(sig.slice(len, 2 * len));
      let A, R, SB;
      try {
        A = Point.fromHex(publicKey, zip215);
        R = Point.fromHex(sig.slice(0, len), zip215);
        SB = G.multiplyUnsafe(s2);
      } catch (error) {
        return false;
      }
      if (!zip215 && A.isSmallOrder())
        return false;
      const k = hashDomainToScalar(context, R.toRawBytes(), A.toRawBytes(), msg);
      const RkA = R.add(A.multiplyUnsafe(k));
      return RkA.subtract(SB).clearCofactor().equals(Point.ZERO);
    }
    G._setWindowSize(8);
    const utils = {
      getExtendedPublicKey,
      /** ed25519 priv keys are uniform 32b. No need to check for modulo bias, like in secp256k1. */
      randomPrivateKey: () => randomBytes3(Fp2.BYTES),
      /**
       * We're doing scalar multiplication (used in getPublicKey etc) with precomputed BASE_POINT
       * values. This slows down first getPublicKey() by milliseconds (see Speed section),
       * but allows to speed-up subsequent getPublicKey() calls up to 20x.
       * @param windowSize 2, 4, 8, 16
       */
      precompute(windowSize = 8, point = Point.BASE) {
        point._setWindowSize(windowSize);
        point.multiply(BigInt(3));
        return point;
      }
    };
    return {
      CURVE,
      getPublicKey,
      sign,
      verify,
      ExtendedPoint: Point,
      utils
    };
  }

  // node_modules/@noble/curves/esm/abstract/montgomery.js
  var import_browser_shims65 = __toESM(require_browser_shims(), 1);
  var _0n5 = BigInt(0);
  var _1n5 = BigInt(1);
  var _2n3 = BigInt(2);
  function validateOpts2(curve) {
    validateObject(curve, {
      adjustScalarBytes: "function",
      powPminus2: "function"
    });
    return Object.freeze({ ...curve });
  }
  function montgomery(curveDef) {
    const CURVE = validateOpts2(curveDef);
    const { P, type, adjustScalarBytes: adjustScalarBytes2, powPminus2 } = CURVE;
    const is25519 = type === "x25519";
    if (!is25519 && type !== "x448")
      throw new Error("invalid type");
    const montgomeryBits = is25519 ? 255 : 448;
    const fieldLen = is25519 ? 32 : 56;
    const Gu = is25519 ? BigInt(9) : BigInt(5);
    const a24 = is25519 ? BigInt(121665) : BigInt(39081);
    const minScalar = is25519 ? _2n3 ** BigInt(254) : _2n3 ** BigInt(447);
    const maxAdded = is25519 ? BigInt(8) * _2n3 ** BigInt(251) - _1n5 : BigInt(4) * _2n3 ** BigInt(445) - _1n5;
    const maxScalar = minScalar + maxAdded + _1n5;
    const modP = (n) => mod(n, P);
    const GuBytes = encodeU(Gu);
    function encodeU(u) {
      return numberToBytesLE(modP(u), fieldLen);
    }
    function decodeU(u) {
      const _u = ensureBytes("u coordinate", u, fieldLen);
      if (is25519)
        _u[31] &= 127;
      return modP(bytesToNumberLE(_u));
    }
    function decodeScalar(scalar) {
      return bytesToNumberLE(adjustScalarBytes2(ensureBytes("scalar", scalar, fieldLen)));
    }
    function scalarMult(scalar, u) {
      const pu = montgomeryLadder(decodeU(u), decodeScalar(scalar));
      if (pu === _0n5)
        throw new Error("invalid private or public key received");
      return encodeU(pu);
    }
    function scalarMultBase(scalar) {
      return scalarMult(scalar, GuBytes);
    }
    function cswap(swap, x_2, x_3) {
      const dummy = modP(swap * (x_2 - x_3));
      x_2 = modP(x_2 - dummy);
      x_3 = modP(x_3 + dummy);
      return { x_2, x_3 };
    }
    function montgomeryLadder(u, scalar) {
      aInRange("u", u, _0n5, P);
      aInRange("scalar", scalar, minScalar, maxScalar);
      const k = scalar;
      const x_1 = u;
      let x_2 = _1n5;
      let z_2 = _0n5;
      let x_3 = u;
      let z_3 = _1n5;
      let swap = _0n5;
      for (let t = BigInt(montgomeryBits - 1); t >= _0n5; t--) {
        const k_t = k >> t & _1n5;
        swap ^= k_t;
        ({ x_2, x_3 } = cswap(swap, x_2, x_3));
        ({ x_2: z_2, x_3: z_3 } = cswap(swap, z_2, z_3));
        swap = k_t;
        const A = x_2 + z_2;
        const AA = modP(A * A);
        const B = x_2 - z_2;
        const BB = modP(B * B);
        const E = AA - BB;
        const C = x_3 + z_3;
        const D = x_3 - z_3;
        const DA = modP(D * A);
        const CB = modP(C * B);
        const dacb = DA + CB;
        const da_cb = DA - CB;
        x_3 = modP(dacb * dacb);
        z_3 = modP(x_1 * modP(da_cb * da_cb));
        x_2 = modP(AA * BB);
        z_2 = modP(E * (AA + modP(a24 * E)));
      }
      ({ x_2, x_3 } = cswap(swap, x_2, x_3));
      ({ x_2: z_2, x_3: z_3 } = cswap(swap, z_2, z_3));
      const z2 = powPminus2(z_2);
      return modP(x_2 * z2);
    }
    return {
      scalarMult,
      scalarMultBase,
      getSharedSecret: (privateKey, publicKey) => scalarMult(privateKey, publicKey),
      getPublicKey: (privateKey) => scalarMultBase(privateKey),
      utils: { randomPrivateKey: () => CURVE.randomBytes(fieldLen) },
      GuBytes: GuBytes.slice()
    };
  }

  // node_modules/@noble/curves/esm/ed25519.js
  var ED25519_P = BigInt("57896044618658097711785492504343953926634992332820282019728792003956564819949");
  var ED25519_SQRT_M1 = /* @__PURE__ */ BigInt("19681161376707505956807079304988542015446066515923890162744021073123829784752");
  var _0n6 = BigInt(0);
  var _1n6 = BigInt(1);
  var _2n4 = BigInt(2);
  var _3n2 = BigInt(3);
  var _5n2 = BigInt(5);
  var _8n3 = BigInt(8);
  function ed25519_pow_2_252_3(x) {
    const _10n = BigInt(10), _20n = BigInt(20), _40n = BigInt(40), _80n = BigInt(80);
    const P = ED25519_P;
    const x2 = x * x % P;
    const b2 = x2 * x % P;
    const b4 = pow2(b2, _2n4, P) * b2 % P;
    const b5 = pow2(b4, _1n6, P) * x % P;
    const b10 = pow2(b5, _5n2, P) * b5 % P;
    const b20 = pow2(b10, _10n, P) * b10 % P;
    const b40 = pow2(b20, _20n, P) * b20 % P;
    const b80 = pow2(b40, _40n, P) * b40 % P;
    const b160 = pow2(b80, _80n, P) * b80 % P;
    const b240 = pow2(b160, _80n, P) * b80 % P;
    const b250 = pow2(b240, _10n, P) * b10 % P;
    const pow_p_5_8 = pow2(b250, _2n4, P) * x % P;
    return { pow_p_5_8, b2 };
  }
  function adjustScalarBytes(bytes) {
    bytes[0] &= 248;
    bytes[31] &= 127;
    bytes[31] |= 64;
    return bytes;
  }
  function uvRatio(u, v) {
    const P = ED25519_P;
    const v3 = mod(v * v * v, P);
    const v7 = mod(v3 * v3 * v, P);
    const pow = ed25519_pow_2_252_3(u * v7).pow_p_5_8;
    let x = mod(u * v3 * pow, P);
    const vx2 = mod(v * x * x, P);
    const root1 = x;
    const root2 = mod(x * ED25519_SQRT_M1, P);
    const useRoot1 = vx2 === u;
    const useRoot2 = vx2 === mod(-u, P);
    const noRoot = vx2 === mod(-u * ED25519_SQRT_M1, P);
    if (useRoot1)
      x = root1;
    if (useRoot2 || noRoot)
      x = root2;
    if (isNegativeLE(x, P))
      x = mod(-x, P);
    return { isValid: useRoot1 || useRoot2, value: x };
  }
  var Fp = /* @__PURE__ */ (() => Field(ED25519_P, void 0, true))();
  var ed25519Defaults = /* @__PURE__ */ (() => ({
    // Removing Fp.create() will still work, and is 10% faster on sign
    a: Fp.create(BigInt(-1)),
    // d is -121665/121666 a.k.a. Fp.neg(121665 * Fp.inv(121666))
    d: BigInt("37095705934669439343138083508754565189542113879843219016388785533085940283555"),
    // Finite field 2n**255n - 19n
    Fp,
    // Subgroup order 2n**252n + 27742317777372353535851937790883648493n;
    n: BigInt("7237005577332262213973186563042994240857116359379907606001950938285454250989"),
    h: _8n3,
    Gx: BigInt("15112221349535400772501151409588531511454012693041857206046113283949847762202"),
    Gy: BigInt("46316835694926478169428394003475163141307993866256225615783033603165251855960"),
    hash: sha5122,
    randomBytes,
    adjustScalarBytes,
    // dom2
    // Ratio of u to v. Allows us to combine inversion and square root. Uses algo from RFC8032 5.1.3.
    // Constant-time, u/v
    uvRatio
  }))();
  var ed25519 = /* @__PURE__ */ (() => twistedEdwards(ed25519Defaults))();
  var x25519 = /* @__PURE__ */ (() => montgomery({
    P: ED25519_P,
    type: "x25519",
    powPminus2: (x) => {
      const P = ED25519_P;
      const { pow_p_5_8, b2 } = ed25519_pow_2_252_3(x);
      return mod(pow2(pow_p_5_8, _3n2, P) * b2, P);
    },
    adjustScalarBytes,
    randomBytes
  }))();

  // node_modules/@libp2p/crypto/dist/src/webcrypto/index.js
  var import_browser_shims69 = __toESM(require_browser_shims(), 1);

  // node_modules/@libp2p/crypto/dist/src/webcrypto/webcrypto.browser.js
  var import_browser_shims68 = __toESM(require_browser_shims(), 1);

  // node_modules/@libp2p/crypto/dist/src/errors.js
  var import_browser_shims67 = __toESM(require_browser_shims(), 1);
  var SigningError = class extends Error {
    constructor(message2 = "An error occurred while signing a message") {
      super(message2);
      this.name = "SigningError";
    }
  };
  var VerificationError = class extends Error {
    constructor(message2 = "An error occurred while verifying a message") {
      super(message2);
      this.name = "VerificationError";
    }
  };
  var WebCryptoMissingError = class extends Error {
    constructor(message2 = "Missing Web Crypto API") {
      super(message2);
      this.name = "WebCryptoMissingError";
    }
  };

  // node_modules/@libp2p/crypto/dist/src/webcrypto/webcrypto.browser.js
  var webcrypto_browser_default = {
    get(win = globalThis) {
      const nativeCrypto = win.crypto;
      if ((nativeCrypto == null ? void 0 : nativeCrypto.subtle) == null) {
        throw new WebCryptoMissingError("Missing Web Crypto API. The most likely cause of this error is that this page is being accessed from an insecure context (i.e. not HTTPS). For more information and possible resolutions see https://github.com/libp2p/js-libp2p/blob/main/packages/crypto/README.md#web-crypto-api");
      }
      return nativeCrypto;
    }
  };

  // node_modules/@libp2p/crypto/dist/src/webcrypto/index.js
  var webcrypto_default = webcrypto_browser_default;

  // node_modules/@libp2p/crypto/dist/src/keys/ed25519/index.browser.js
  var PUBLIC_KEY_BYTE_LENGTH = 32;
  var PRIVATE_KEY_BYTE_LENGTH = 64;
  var KEYS_BYTE_LENGTH = 32;
  var ed25519Supported;
  var webCryptoEd25519SupportedPromise = (async () => {
    try {
      await webcrypto_default.get().subtle.generateKey({ name: "Ed25519" }, true, ["sign", "verify"]);
      return true;
    } catch {
      return false;
    }
  })();
  function generateKey() {
    const privateKeyRaw = ed25519.utils.randomPrivateKey();
    const publicKey = ed25519.getPublicKey(privateKeyRaw);
    const privateKey = concatKeys(privateKeyRaw, publicKey);
    return {
      privateKey,
      publicKey
    };
  }
  async function hashAndSignWebCrypto(privateKey, msg) {
    let privateKeyRaw;
    if (privateKey.length === PRIVATE_KEY_BYTE_LENGTH) {
      privateKeyRaw = privateKey.subarray(0, 32);
    } else {
      privateKeyRaw = privateKey;
    }
    const jwk = {
      crv: "Ed25519",
      kty: "OKP",
      x: toString2(privateKey.subarray(32), "base64url"),
      d: toString2(privateKeyRaw, "base64url"),
      ext: true,
      key_ops: ["sign"]
    };
    const key = await webcrypto_default.get().subtle.importKey("jwk", jwk, { name: "Ed25519" }, true, ["sign"]);
    const sig = await webcrypto_default.get().subtle.sign({ name: "Ed25519" }, key, msg instanceof Uint8Array ? msg : msg.subarray());
    return new Uint8Array(sig, 0, sig.byteLength);
  }
  function hashAndSignNoble(privateKey, msg) {
    const privateKeyRaw = privateKey.subarray(0, KEYS_BYTE_LENGTH);
    return ed25519.sign(msg instanceof Uint8Array ? msg : msg.subarray(), privateKeyRaw);
  }
  async function hashAndSign2(privateKey, msg) {
    if (ed25519Supported == null) {
      ed25519Supported = await webCryptoEd25519SupportedPromise;
    }
    if (ed25519Supported) {
      return hashAndSignWebCrypto(privateKey, msg);
    }
    return hashAndSignNoble(privateKey, msg);
  }
  async function hashAndVerifyWebCrypto(publicKey, sig, msg) {
    if (publicKey.buffer instanceof ArrayBuffer) {
      const key = await webcrypto_default.get().subtle.importKey("raw", publicKey.buffer, { name: "Ed25519" }, false, ["verify"]);
      const isValid = await webcrypto_default.get().subtle.verify({ name: "Ed25519" }, key, sig, msg instanceof Uint8Array ? msg : msg.subarray());
      return isValid;
    }
    throw new TypeError("WebCrypto does not support SharedArrayBuffer for Ed25519 keys");
  }
  function hashAndVerifyNoble(publicKey, sig, msg) {
    return ed25519.verify(sig, msg instanceof Uint8Array ? msg : msg.subarray(), publicKey);
  }
  async function hashAndVerify2(publicKey, sig, msg) {
    if (ed25519Supported == null) {
      ed25519Supported = await webCryptoEd25519SupportedPromise;
    }
    if (ed25519Supported) {
      return hashAndVerifyWebCrypto(publicKey, sig, msg);
    }
    return hashAndVerifyNoble(publicKey, sig, msg);
  }
  function concatKeys(privateKeyRaw, publicKey) {
    const privateKey = new Uint8Array(PRIVATE_KEY_BYTE_LENGTH);
    for (let i = 0; i < KEYS_BYTE_LENGTH; i++) {
      privateKey[i] = privateKeyRaw[i];
      privateKey[KEYS_BYTE_LENGTH + i] = publicKey[i];
    }
    return privateKey;
  }

  // node_modules/@libp2p/crypto/dist/src/keys/ed25519/utils.js
  var import_browser_shims73 = __toESM(require_browser_shims(), 1);

  // node_modules/@libp2p/crypto/dist/src/keys/ed25519/ed25519.js
  var import_browser_shims72 = __toESM(require_browser_shims(), 1);

  // node_modules/@libp2p/crypto/dist/src/util.js
  var import_browser_shims71 = __toESM(require_browser_shims(), 1);
  function isPromise(thing) {
    if (thing == null) {
      return false;
    }
    return typeof thing.then === "function" && typeof thing.catch === "function" && typeof thing.finally === "function";
  }

  // node_modules/@libp2p/crypto/dist/src/keys/ed25519/ed25519.js
  var Ed25519PublicKey = class {
    type = "Ed25519";
    raw;
    constructor(key) {
      this.raw = ensureEd25519Key(key, PUBLIC_KEY_BYTE_LENGTH);
    }
    toMultihash() {
      return identity.digest(publicKeyToProtobuf(this));
    }
    toCID() {
      return CID.createV1(114, this.toMultihash());
    }
    toString() {
      return base58btc.encode(this.toMultihash().bytes).substring(1);
    }
    equals(key) {
      if (key == null || !(key.raw instanceof Uint8Array)) {
        return false;
      }
      return equals3(this.raw, key.raw);
    }
    verify(data, sig, options) {
      var _a2;
      (_a2 = options == null ? void 0 : options.signal) == null ? void 0 : _a2.throwIfAborted();
      const result = hashAndVerify2(this.raw, sig, data);
      if (isPromise(result)) {
        return result.then((res) => {
          var _a3;
          (_a3 = options == null ? void 0 : options.signal) == null ? void 0 : _a3.throwIfAborted();
          return res;
        });
      }
      return result;
    }
  };
  var Ed25519PrivateKey = class {
    type = "Ed25519";
    raw;
    publicKey;
    // key       - 64 byte Uint8Array containing private key
    // publicKey - 32 byte Uint8Array containing public key
    constructor(key, publicKey) {
      this.raw = ensureEd25519Key(key, PRIVATE_KEY_BYTE_LENGTH);
      this.publicKey = new Ed25519PublicKey(publicKey);
    }
    equals(key) {
      if (key == null || !(key.raw instanceof Uint8Array)) {
        return false;
      }
      return equals3(this.raw, key.raw);
    }
    sign(message2, options) {
      var _a2, _b2;
      (_a2 = options == null ? void 0 : options.signal) == null ? void 0 : _a2.throwIfAborted();
      const sig = hashAndSign2(this.raw, message2);
      if (isPromise(sig)) {
        return sig.then((res) => {
          var _a3;
          (_a3 = options == null ? void 0 : options.signal) == null ? void 0 : _a3.throwIfAborted();
          return res;
        });
      }
      (_b2 = options == null ? void 0 : options.signal) == null ? void 0 : _b2.throwIfAborted();
      return sig;
    }
  };

  // node_modules/@libp2p/crypto/dist/src/keys/ed25519/utils.js
  function unmarshalEd25519PublicKey(bytes) {
    bytes = ensureEd25519Key(bytes, PUBLIC_KEY_BYTE_LENGTH);
    return new Ed25519PublicKey(bytes);
  }
  async function generateEd25519KeyPair() {
    const { privateKey, publicKey } = generateKey();
    return new Ed25519PrivateKey(privateKey, publicKey);
  }
  function ensureEd25519Key(key, length4) {
    key = Uint8Array.from(key ?? []);
    if (key.length !== length4) {
      throw new InvalidParametersError(`Key must be a Uint8Array of length ${length4}, got ${key.length}`);
    }
    return key;
  }

  // node_modules/@libp2p/crypto/dist/src/keys/keys.js
  var import_browser_shims87 = __toESM(require_browser_shims(), 1);

  // node_modules/protons-runtime/dist/src/index.js
  var import_browser_shims86 = __toESM(require_browser_shims(), 1);

  // node_modules/protons-runtime/dist/src/decode.js
  var import_browser_shims79 = __toESM(require_browser_shims(), 1);

  // node_modules/protons-runtime/dist/src/utils/reader.js
  var import_browser_shims78 = __toESM(require_browser_shims(), 1);

  // node_modules/uint8-varint/dist/src/index.js
  var import_browser_shims74 = __toESM(require_browser_shims(), 1);
  var N12 = Math.pow(2, 7);
  var N22 = Math.pow(2, 14);
  var N32 = Math.pow(2, 21);
  var N42 = Math.pow(2, 28);
  var N52 = Math.pow(2, 35);
  var N62 = Math.pow(2, 42);
  var N72 = Math.pow(2, 49);
  var MSB2 = 128;
  var REST2 = 127;
  function encodingLength2(value) {
    if (value < N12) {
      return 1;
    }
    if (value < N22) {
      return 2;
    }
    if (value < N32) {
      return 3;
    }
    if (value < N42) {
      return 4;
    }
    if (value < N52) {
      return 5;
    }
    if (value < N62) {
      return 6;
    }
    if (value < N72) {
      return 7;
    }
    if (Number.MAX_SAFE_INTEGER != null && value > Number.MAX_SAFE_INTEGER) {
      throw new RangeError("Could not encode varint");
    }
    return 8;
  }
  function encodeUint8Array(value, buf, offset = 0) {
    switch (encodingLength2(value)) {
      case 8: {
        buf[offset++] = value & 255 | MSB2;
        value /= 128;
      }
      case 7: {
        buf[offset++] = value & 255 | MSB2;
        value /= 128;
      }
      case 6: {
        buf[offset++] = value & 255 | MSB2;
        value /= 128;
      }
      case 5: {
        buf[offset++] = value & 255 | MSB2;
        value /= 128;
      }
      case 4: {
        buf[offset++] = value & 255 | MSB2;
        value >>>= 7;
      }
      case 3: {
        buf[offset++] = value & 255 | MSB2;
        value >>>= 7;
      }
      case 2: {
        buf[offset++] = value & 255 | MSB2;
        value >>>= 7;
      }
      case 1: {
        buf[offset++] = value & 255;
        value >>>= 7;
        break;
      }
      default:
        throw new Error("unreachable");
    }
    return buf;
  }
  function encodeUint8ArrayList(value, buf, offset = 0) {
    switch (encodingLength2(value)) {
      case 8: {
        buf.set(offset++, value & 255 | MSB2);
        value /= 128;
      }
      case 7: {
        buf.set(offset++, value & 255 | MSB2);
        value /= 128;
      }
      case 6: {
        buf.set(offset++, value & 255 | MSB2);
        value /= 128;
      }
      case 5: {
        buf.set(offset++, value & 255 | MSB2);
        value /= 128;
      }
      case 4: {
        buf.set(offset++, value & 255 | MSB2);
        value >>>= 7;
      }
      case 3: {
        buf.set(offset++, value & 255 | MSB2);
        value >>>= 7;
      }
      case 2: {
        buf.set(offset++, value & 255 | MSB2);
        value >>>= 7;
      }
      case 1: {
        buf.set(offset++, value & 255);
        value >>>= 7;
        break;
      }
      default:
        throw new Error("unreachable");
    }
    return buf;
  }
  function decodeUint8Array(buf, offset) {
    let b = buf[offset];
    let res = 0;
    res += b & REST2;
    if (b < MSB2) {
      return res;
    }
    b = buf[offset + 1];
    res += (b & REST2) << 7;
    if (b < MSB2) {
      return res;
    }
    b = buf[offset + 2];
    res += (b & REST2) << 14;
    if (b < MSB2) {
      return res;
    }
    b = buf[offset + 3];
    res += (b & REST2) << 21;
    if (b < MSB2) {
      return res;
    }
    b = buf[offset + 4];
    res += (b & REST2) * N42;
    if (b < MSB2) {
      return res;
    }
    b = buf[offset + 5];
    res += (b & REST2) * N52;
    if (b < MSB2) {
      return res;
    }
    b = buf[offset + 6];
    res += (b & REST2) * N62;
    if (b < MSB2) {
      return res;
    }
    b = buf[offset + 7];
    res += (b & REST2) * N72;
    if (b < MSB2) {
      return res;
    }
    throw new RangeError("Could not decode varint");
  }
  function decodeUint8ArrayList(buf, offset) {
    let b = buf.get(offset);
    let res = 0;
    res += b & REST2;
    if (b < MSB2) {
      return res;
    }
    b = buf.get(offset + 1);
    res += (b & REST2) << 7;
    if (b < MSB2) {
      return res;
    }
    b = buf.get(offset + 2);
    res += (b & REST2) << 14;
    if (b < MSB2) {
      return res;
    }
    b = buf.get(offset + 3);
    res += (b & REST2) << 21;
    if (b < MSB2) {
      return res;
    }
    b = buf.get(offset + 4);
    res += (b & REST2) * N42;
    if (b < MSB2) {
      return res;
    }
    b = buf.get(offset + 5);
    res += (b & REST2) * N52;
    if (b < MSB2) {
      return res;
    }
    b = buf.get(offset + 6);
    res += (b & REST2) * N62;
    if (b < MSB2) {
      return res;
    }
    b = buf.get(offset + 7);
    res += (b & REST2) * N72;
    if (b < MSB2) {
      return res;
    }
    throw new RangeError("Could not decode varint");
  }
  function encode5(value, buf, offset = 0) {
    if (buf == null) {
      buf = allocUnsafe(encodingLength2(value));
    }
    if (buf instanceof Uint8Array) {
      return encodeUint8Array(value, buf, offset);
    } else {
      return encodeUint8ArrayList(value, buf, offset);
    }
  }
  function decode6(buf, offset = 0) {
    if (buf instanceof Uint8Array) {
      return decodeUint8Array(buf, offset);
    } else {
      return decodeUint8ArrayList(buf, offset);
    }
  }

  // node_modules/protons-runtime/dist/src/utils/float.js
  var import_browser_shims75 = __toESM(require_browser_shims(), 1);
  var f32 = new Float32Array([-0]);
  var f8b = new Uint8Array(f32.buffer);
  function writeFloatLE(val, buf, pos) {
    f32[0] = val;
    buf[pos] = f8b[0];
    buf[pos + 1] = f8b[1];
    buf[pos + 2] = f8b[2];
    buf[pos + 3] = f8b[3];
  }
  function readFloatLE(buf, pos) {
    f8b[0] = buf[pos];
    f8b[1] = buf[pos + 1];
    f8b[2] = buf[pos + 2];
    f8b[3] = buf[pos + 3];
    return f32[0];
  }
  var f64 = new Float64Array([-0]);
  var d8b = new Uint8Array(f64.buffer);
  function writeDoubleLE(val, buf, pos) {
    f64[0] = val;
    buf[pos] = d8b[0];
    buf[pos + 1] = d8b[1];
    buf[pos + 2] = d8b[2];
    buf[pos + 3] = d8b[3];
    buf[pos + 4] = d8b[4];
    buf[pos + 5] = d8b[5];
    buf[pos + 6] = d8b[6];
    buf[pos + 7] = d8b[7];
  }
  function readDoubleLE(buf, pos) {
    d8b[0] = buf[pos];
    d8b[1] = buf[pos + 1];
    d8b[2] = buf[pos + 2];
    d8b[3] = buf[pos + 3];
    d8b[4] = buf[pos + 4];
    d8b[5] = buf[pos + 5];
    d8b[6] = buf[pos + 6];
    d8b[7] = buf[pos + 7];
    return f64[0];
  }

  // node_modules/protons-runtime/dist/src/utils/longbits.js
  var import_browser_shims76 = __toESM(require_browser_shims(), 1);
  var MAX_SAFE_NUMBER_INTEGER = BigInt(Number.MAX_SAFE_INTEGER);
  var MIN_SAFE_NUMBER_INTEGER = BigInt(Number.MIN_SAFE_INTEGER);
  var LongBits = class _LongBits {
    lo;
    hi;
    constructor(lo, hi) {
      this.lo = lo | 0;
      this.hi = hi | 0;
    }
    /**
     * Converts this long bits to a possibly unsafe JavaScript number
     */
    toNumber(unsigned = false) {
      if (!unsigned && this.hi >>> 31 > 0) {
        const lo = ~this.lo + 1 >>> 0;
        let hi = ~this.hi >>> 0;
        if (lo === 0) {
          hi = hi + 1 >>> 0;
        }
        return -(lo + hi * 4294967296);
      }
      return this.lo + this.hi * 4294967296;
    }
    /**
     * Converts this long bits to a bigint
     */
    toBigInt(unsigned = false) {
      if (unsigned) {
        return BigInt(this.lo >>> 0) + (BigInt(this.hi >>> 0) << 32n);
      }
      if (this.hi >>> 31 !== 0) {
        const lo = ~this.lo + 1 >>> 0;
        let hi = ~this.hi >>> 0;
        if (lo === 0) {
          hi = hi + 1 >>> 0;
        }
        return -(BigInt(lo) + (BigInt(hi) << 32n));
      }
      return BigInt(this.lo >>> 0) + (BigInt(this.hi >>> 0) << 32n);
    }
    /**
     * Converts this long bits to a string
     */
    toString(unsigned = false) {
      return this.toBigInt(unsigned).toString();
    }
    /**
     * Zig-zag encodes this long bits
     */
    zzEncode() {
      const mask = this.hi >> 31;
      this.hi = ((this.hi << 1 | this.lo >>> 31) ^ mask) >>> 0;
      this.lo = (this.lo << 1 ^ mask) >>> 0;
      return this;
    }
    /**
     * Zig-zag decodes this long bits
     */
    zzDecode() {
      const mask = -(this.lo & 1);
      this.lo = ((this.lo >>> 1 | this.hi << 31) ^ mask) >>> 0;
      this.hi = (this.hi >>> 1 ^ mask) >>> 0;
      return this;
    }
    /**
     * Calculates the length of this longbits when encoded as a varint.
     */
    length() {
      const part0 = this.lo;
      const part1 = (this.lo >>> 28 | this.hi << 4) >>> 0;
      const part2 = this.hi >>> 24;
      return part2 === 0 ? part1 === 0 ? part0 < 16384 ? part0 < 128 ? 1 : 2 : part0 < 2097152 ? 3 : 4 : part1 < 16384 ? part1 < 128 ? 5 : 6 : part1 < 2097152 ? 7 : 8 : part2 < 128 ? 9 : 10;
    }
    /**
     * Constructs new long bits from the specified number
     */
    static fromBigInt(value) {
      if (value === 0n) {
        return zero;
      }
      if (value < MAX_SAFE_NUMBER_INTEGER && value > MIN_SAFE_NUMBER_INTEGER) {
        return this.fromNumber(Number(value));
      }
      const negative = value < 0n;
      if (negative) {
        value = -value;
      }
      let hi = value >> 32n;
      let lo = value - (hi << 32n);
      if (negative) {
        hi = ~hi | 0n;
        lo = ~lo | 0n;
        if (++lo > TWO_32) {
          lo = 0n;
          if (++hi > TWO_32) {
            hi = 0n;
          }
        }
      }
      return new _LongBits(Number(lo), Number(hi));
    }
    /**
     * Constructs new long bits from the specified number
     */
    static fromNumber(value) {
      if (value === 0) {
        return zero;
      }
      const sign = value < 0;
      if (sign) {
        value = -value;
      }
      let lo = value >>> 0;
      let hi = (value - lo) / 4294967296 >>> 0;
      if (sign) {
        hi = ~hi >>> 0;
        lo = ~lo >>> 0;
        if (++lo > 4294967295) {
          lo = 0;
          if (++hi > 4294967295) {
            hi = 0;
          }
        }
      }
      return new _LongBits(lo, hi);
    }
    /**
     * Constructs new long bits from a number, long or string
     */
    static from(value) {
      if (typeof value === "number") {
        return _LongBits.fromNumber(value);
      }
      if (typeof value === "bigint") {
        return _LongBits.fromBigInt(value);
      }
      if (typeof value === "string") {
        return _LongBits.fromBigInt(BigInt(value));
      }
      return value.low != null || value.high != null ? new _LongBits(value.low >>> 0, value.high >>> 0) : zero;
    }
  };
  var zero = new LongBits(0, 0);
  zero.toBigInt = function() {
    return 0n;
  };
  zero.zzEncode = zero.zzDecode = function() {
    return this;
  };
  zero.length = function() {
    return 1;
  };
  var TWO_32 = 4294967296n;

  // node_modules/protons-runtime/dist/src/utils/utf8.js
  var import_browser_shims77 = __toESM(require_browser_shims(), 1);
  function length2(string3) {
    let len = 0;
    let c = 0;
    for (let i = 0; i < string3.length; ++i) {
      c = string3.charCodeAt(i);
      if (c < 128) {
        len += 1;
      } else if (c < 2048) {
        len += 2;
      } else if ((c & 64512) === 55296 && (string3.charCodeAt(i + 1) & 64512) === 56320) {
        ++i;
        len += 4;
      } else {
        len += 3;
      }
    }
    return len;
  }
  function read2(buffer, start2, end) {
    const len = end - start2;
    if (len < 1) {
      return "";
    }
    let parts;
    const chunk = [];
    let i = 0;
    let t;
    while (start2 < end) {
      t = buffer[start2++];
      if (t < 128) {
        chunk[i++] = t;
      } else if (t > 191 && t < 224) {
        chunk[i++] = (t & 31) << 6 | buffer[start2++] & 63;
      } else if (t > 239 && t < 365) {
        t = ((t & 7) << 18 | (buffer[start2++] & 63) << 12 | (buffer[start2++] & 63) << 6 | buffer[start2++] & 63) - 65536;
        chunk[i++] = 55296 + (t >> 10);
        chunk[i++] = 56320 + (t & 1023);
      } else {
        chunk[i++] = (t & 15) << 12 | (buffer[start2++] & 63) << 6 | buffer[start2++] & 63;
      }
      if (i > 8191) {
        (parts ?? (parts = [])).push(String.fromCharCode.apply(String, chunk));
        i = 0;
      }
    }
    if (parts != null) {
      if (i > 0) {
        parts.push(String.fromCharCode.apply(String, chunk.slice(0, i)));
      }
      return parts.join("");
    }
    return String.fromCharCode.apply(String, chunk.slice(0, i));
  }
  function write(string3, buffer, offset) {
    const start2 = offset;
    let c1;
    let c2;
    for (let i = 0; i < string3.length; ++i) {
      c1 = string3.charCodeAt(i);
      if (c1 < 128) {
        buffer[offset++] = c1;
      } else if (c1 < 2048) {
        buffer[offset++] = c1 >> 6 | 192;
        buffer[offset++] = c1 & 63 | 128;
      } else if ((c1 & 64512) === 55296 && ((c2 = string3.charCodeAt(i + 1)) & 64512) === 56320) {
        c1 = 65536 + ((c1 & 1023) << 10) + (c2 & 1023);
        ++i;
        buffer[offset++] = c1 >> 18 | 240;
        buffer[offset++] = c1 >> 12 & 63 | 128;
        buffer[offset++] = c1 >> 6 & 63 | 128;
        buffer[offset++] = c1 & 63 | 128;
      } else {
        buffer[offset++] = c1 >> 12 | 224;
        buffer[offset++] = c1 >> 6 & 63 | 128;
        buffer[offset++] = c1 & 63 | 128;
      }
    }
    return offset - start2;
  }

  // node_modules/protons-runtime/dist/src/utils/reader.js
  function indexOutOfRange(reader, writeLength) {
    return RangeError(`index out of range: ${reader.pos} + ${writeLength ?? 1} > ${reader.len}`);
  }
  function readFixed32End(buf, end) {
    return (buf[end - 4] | buf[end - 3] << 8 | buf[end - 2] << 16 | buf[end - 1] << 24) >>> 0;
  }
  var Uint8ArrayReader = class {
    buf;
    pos;
    len;
    _slice = Uint8Array.prototype.subarray;
    constructor(buffer) {
      this.buf = buffer;
      this.pos = 0;
      this.len = buffer.length;
    }
    /**
     * Reads a varint as an unsigned 32 bit value
     */
    uint32() {
      let value = 4294967295;
      value = (this.buf[this.pos] & 127) >>> 0;
      if (this.buf[this.pos++] < 128)
        return value;
      value = (value | (this.buf[this.pos] & 127) << 7) >>> 0;
      if (this.buf[this.pos++] < 128)
        return value;
      value = (value | (this.buf[this.pos] & 127) << 14) >>> 0;
      if (this.buf[this.pos++] < 128)
        return value;
      value = (value | (this.buf[this.pos] & 127) << 21) >>> 0;
      if (this.buf[this.pos++] < 128)
        return value;
      value = (value | (this.buf[this.pos] & 15) << 28) >>> 0;
      if (this.buf[this.pos++] < 128)
        return value;
      if ((this.pos += 5) > this.len) {
        this.pos = this.len;
        throw indexOutOfRange(this, 10);
      }
      return value;
    }
    /**
     * Reads a varint as a signed 32 bit value
     */
    int32() {
      return this.uint32() | 0;
    }
    /**
     * Reads a zig-zag encoded varint as a signed 32 bit value
     */
    sint32() {
      const value = this.uint32();
      return value >>> 1 ^ -(value & 1) | 0;
    }
    /**
     * Reads a varint as a boolean
     */
    bool() {
      return this.uint32() !== 0;
    }
    /**
     * Reads fixed 32 bits as an unsigned 32 bit integer
     */
    fixed32() {
      if (this.pos + 4 > this.len) {
        throw indexOutOfRange(this, 4);
      }
      const res = readFixed32End(this.buf, this.pos += 4);
      return res;
    }
    /**
     * Reads fixed 32 bits as a signed 32 bit integer
     */
    sfixed32() {
      if (this.pos + 4 > this.len) {
        throw indexOutOfRange(this, 4);
      }
      const res = readFixed32End(this.buf, this.pos += 4) | 0;
      return res;
    }
    /**
     * Reads a float (32 bit) as a number
     */
    float() {
      if (this.pos + 4 > this.len) {
        throw indexOutOfRange(this, 4);
      }
      const value = readFloatLE(this.buf, this.pos);
      this.pos += 4;
      return value;
    }
    /**
     * Reads a double (64 bit float) as a number
     */
    double() {
      if (this.pos + 8 > this.len) {
        throw indexOutOfRange(this, 4);
      }
      const value = readDoubleLE(this.buf, this.pos);
      this.pos += 8;
      return value;
    }
    /**
     * Reads a sequence of bytes preceded by its length as a varint
     */
    bytes() {
      const length4 = this.uint32();
      const start2 = this.pos;
      const end = this.pos + length4;
      if (end > this.len) {
        throw indexOutOfRange(this, length4);
      }
      this.pos += length4;
      return start2 === end ? new Uint8Array(0) : this.buf.subarray(start2, end);
    }
    /**
     * Reads a string preceded by its byte length as a varint
     */
    string() {
      const bytes = this.bytes();
      return read2(bytes, 0, bytes.length);
    }
    /**
     * Skips the specified number of bytes if specified, otherwise skips a varint
     */
    skip(length4) {
      if (typeof length4 === "number") {
        if (this.pos + length4 > this.len) {
          throw indexOutOfRange(this, length4);
        }
        this.pos += length4;
      } else {
        do {
          if (this.pos >= this.len) {
            throw indexOutOfRange(this);
          }
        } while ((this.buf[this.pos++] & 128) !== 0);
      }
      return this;
    }
    /**
     * Skips the next element of the specified wire type
     */
    skipType(wireType) {
      switch (wireType) {
        case 0:
          this.skip();
          break;
        case 1:
          this.skip(8);
          break;
        case 2:
          this.skip(this.uint32());
          break;
        case 3:
          while ((wireType = this.uint32() & 7) !== 4) {
            this.skipType(wireType);
          }
          break;
        case 5:
          this.skip(4);
          break;
        /* istanbul ignore next */
        default:
          throw Error(`invalid wire type ${wireType} at offset ${this.pos}`);
      }
      return this;
    }
    readLongVarint() {
      const bits = new LongBits(0, 0);
      let i = 0;
      if (this.len - this.pos > 4) {
        for (; i < 4; ++i) {
          bits.lo = (bits.lo | (this.buf[this.pos] & 127) << i * 7) >>> 0;
          if (this.buf[this.pos++] < 128) {
            return bits;
          }
        }
        bits.lo = (bits.lo | (this.buf[this.pos] & 127) << 28) >>> 0;
        bits.hi = (bits.hi | (this.buf[this.pos] & 127) >> 4) >>> 0;
        if (this.buf[this.pos++] < 128) {
          return bits;
        }
        i = 0;
      } else {
        for (; i < 3; ++i) {
          if (this.pos >= this.len) {
            throw indexOutOfRange(this);
          }
          bits.lo = (bits.lo | (this.buf[this.pos] & 127) << i * 7) >>> 0;
          if (this.buf[this.pos++] < 128) {
            return bits;
          }
        }
        bits.lo = (bits.lo | (this.buf[this.pos++] & 127) << i * 7) >>> 0;
        return bits;
      }
      if (this.len - this.pos > 4) {
        for (; i < 5; ++i) {
          bits.hi = (bits.hi | (this.buf[this.pos] & 127) << i * 7 + 3) >>> 0;
          if (this.buf[this.pos++] < 128) {
            return bits;
          }
        }
      } else {
        for (; i < 5; ++i) {
          if (this.pos >= this.len) {
            throw indexOutOfRange(this);
          }
          bits.hi = (bits.hi | (this.buf[this.pos] & 127) << i * 7 + 3) >>> 0;
          if (this.buf[this.pos++] < 128) {
            return bits;
          }
        }
      }
      throw Error("invalid varint encoding");
    }
    readFixed64() {
      if (this.pos + 8 > this.len) {
        throw indexOutOfRange(this, 8);
      }
      const lo = readFixed32End(this.buf, this.pos += 4);
      const hi = readFixed32End(this.buf, this.pos += 4);
      return new LongBits(lo, hi);
    }
    /**
     * Reads a varint as a signed 64 bit value
     */
    int64() {
      return this.readLongVarint().toBigInt();
    }
    /**
     * Reads a varint as a signed 64 bit value returned as a possibly unsafe
     * JavaScript number
     */
    int64Number() {
      return this.readLongVarint().toNumber();
    }
    /**
     * Reads a varint as a signed 64 bit value returned as a string
     */
    int64String() {
      return this.readLongVarint().toString();
    }
    /**
     * Reads a varint as an unsigned 64 bit value
     */
    uint64() {
      return this.readLongVarint().toBigInt(true);
    }
    /**
     * Reads a varint as an unsigned 64 bit value returned as a possibly unsafe
     * JavaScript number
     */
    uint64Number() {
      const value = decodeUint8Array(this.buf, this.pos);
      this.pos += encodingLength2(value);
      return value;
    }
    /**
     * Reads a varint as an unsigned 64 bit value returned as a string
     */
    uint64String() {
      return this.readLongVarint().toString(true);
    }
    /**
     * Reads a zig-zag encoded varint as a signed 64 bit value
     */
    sint64() {
      return this.readLongVarint().zzDecode().toBigInt();
    }
    /**
     * Reads a zig-zag encoded varint as a signed 64 bit value returned as a
     * possibly unsafe JavaScript number
     */
    sint64Number() {
      return this.readLongVarint().zzDecode().toNumber();
    }
    /**
     * Reads a zig-zag encoded varint as a signed 64 bit value returned as a
     * string
     */
    sint64String() {
      return this.readLongVarint().zzDecode().toString();
    }
    /**
     * Reads fixed 64 bits
     */
    fixed64() {
      return this.readFixed64().toBigInt();
    }
    /**
     * Reads fixed 64 bits returned as a possibly unsafe JavaScript number
     */
    fixed64Number() {
      return this.readFixed64().toNumber();
    }
    /**
     * Reads fixed 64 bits returned as a string
     */
    fixed64String() {
      return this.readFixed64().toString();
    }
    /**
     * Reads zig-zag encoded fixed 64 bits
     */
    sfixed64() {
      return this.readFixed64().toBigInt();
    }
    /**
     * Reads zig-zag encoded fixed 64 bits returned as a possibly unsafe
     * JavaScript number
     */
    sfixed64Number() {
      return this.readFixed64().toNumber();
    }
    /**
     * Reads zig-zag encoded fixed 64 bits returned as a string
     */
    sfixed64String() {
      return this.readFixed64().toString();
    }
  };
  function createReader(buf) {
    return new Uint8ArrayReader(buf instanceof Uint8Array ? buf : buf.subarray());
  }

  // node_modules/protons-runtime/dist/src/decode.js
  function decodeMessage(buf, codec, opts) {
    const reader = createReader(buf);
    return codec.decode(reader, void 0, opts);
  }

  // node_modules/protons-runtime/dist/src/encode.js
  var import_browser_shims82 = __toESM(require_browser_shims(), 1);

  // node_modules/protons-runtime/dist/src/utils/writer.js
  var import_browser_shims81 = __toESM(require_browser_shims(), 1);

  // node_modules/protons-runtime/dist/src/utils/pool.js
  var import_browser_shims80 = __toESM(require_browser_shims(), 1);
  function pool(size) {
    const SIZE = size ?? 8192;
    const MAX = SIZE >>> 1;
    let slab;
    let offset = SIZE;
    return function poolAlloc(size2) {
      if (size2 < 1 || size2 > MAX) {
        return allocUnsafe(size2);
      }
      if (offset + size2 > SIZE) {
        slab = allocUnsafe(SIZE);
        offset = 0;
      }
      const buf = slab.subarray(offset, offset += size2);
      if ((offset & 7) !== 0) {
        offset = (offset | 7) + 1;
      }
      return buf;
    };
  }

  // node_modules/protons-runtime/dist/src/utils/writer.js
  var Op = class {
    /**
     * Function to call
     */
    fn;
    /**
     * Value byte length
     */
    len;
    /**
     * Next operation
     */
    next;
    /**
     * Value to write
     */
    val;
    constructor(fn, len, val) {
      this.fn = fn;
      this.len = len;
      this.next = void 0;
      this.val = val;
    }
  };
  function noop() {
  }
  var State = class {
    /**
     * Current head
     */
    head;
    /**
     * Current tail
     */
    tail;
    /**
     * Current buffer length
     */
    len;
    /**
     * Next state
     */
    next;
    constructor(writer) {
      this.head = writer.head;
      this.tail = writer.tail;
      this.len = writer.len;
      this.next = writer.states;
    }
  };
  var bufferPool = pool();
  function alloc2(size) {
    if (globalThis.Buffer != null) {
      return allocUnsafe(size);
    }
    return bufferPool(size);
  }
  var Uint8ArrayWriter = class {
    /**
     * Current length
     */
    len;
    /**
     * Operations head
     */
    head;
    /**
     * Operations tail
     */
    tail;
    /**
     * Linked forked states
     */
    states;
    constructor() {
      this.len = 0;
      this.head = new Op(noop, 0, 0);
      this.tail = this.head;
      this.states = null;
    }
    /**
     * Pushes a new operation to the queue
     */
    _push(fn, len, val) {
      this.tail = this.tail.next = new Op(fn, len, val);
      this.len += len;
      return this;
    }
    /**
     * Writes an unsigned 32 bit value as a varint
     */
    uint32(value) {
      this.len += (this.tail = this.tail.next = new VarintOp((value = value >>> 0) < 128 ? 1 : value < 16384 ? 2 : value < 2097152 ? 3 : value < 268435456 ? 4 : 5, value)).len;
      return this;
    }
    /**
     * Writes a signed 32 bit value as a varint`
     */
    int32(value) {
      return value < 0 ? this._push(writeVarint64, 10, LongBits.fromNumber(value)) : this.uint32(value);
    }
    /**
     * Writes a 32 bit value as a varint, zig-zag encoded
     */
    sint32(value) {
      return this.uint32((value << 1 ^ value >> 31) >>> 0);
    }
    /**
     * Writes an unsigned 64 bit value as a varint
     */
    uint64(value) {
      const bits = LongBits.fromBigInt(value);
      return this._push(writeVarint64, bits.length(), bits);
    }
    /**
     * Writes an unsigned 64 bit value as a varint
     */
    uint64Number(value) {
      return this._push(encodeUint8Array, encodingLength2(value), value);
    }
    /**
     * Writes an unsigned 64 bit value as a varint
     */
    uint64String(value) {
      return this.uint64(BigInt(value));
    }
    /**
     * Writes a signed 64 bit value as a varint
     */
    int64(value) {
      return this.uint64(value);
    }
    /**
     * Writes a signed 64 bit value as a varint
     */
    int64Number(value) {
      return this.uint64Number(value);
    }
    /**
     * Writes a signed 64 bit value as a varint
     */
    int64String(value) {
      return this.uint64String(value);
    }
    /**
     * Writes a signed 64 bit value as a varint, zig-zag encoded
     */
    sint64(value) {
      const bits = LongBits.fromBigInt(value).zzEncode();
      return this._push(writeVarint64, bits.length(), bits);
    }
    /**
     * Writes a signed 64 bit value as a varint, zig-zag encoded
     */
    sint64Number(value) {
      const bits = LongBits.fromNumber(value).zzEncode();
      return this._push(writeVarint64, bits.length(), bits);
    }
    /**
     * Writes a signed 64 bit value as a varint, zig-zag encoded
     */
    sint64String(value) {
      return this.sint64(BigInt(value));
    }
    /**
     * Writes a boolish value as a varint
     */
    bool(value) {
      return this._push(writeByte, 1, value ? 1 : 0);
    }
    /**
     * Writes an unsigned 32 bit value as fixed 32 bits
     */
    fixed32(value) {
      return this._push(writeFixed32, 4, value >>> 0);
    }
    /**
     * Writes a signed 32 bit value as fixed 32 bits
     */
    sfixed32(value) {
      return this.fixed32(value);
    }
    /**
     * Writes an unsigned 64 bit value as fixed 64 bits
     */
    fixed64(value) {
      const bits = LongBits.fromBigInt(value);
      return this._push(writeFixed32, 4, bits.lo)._push(writeFixed32, 4, bits.hi);
    }
    /**
     * Writes an unsigned 64 bit value as fixed 64 bits
     */
    fixed64Number(value) {
      const bits = LongBits.fromNumber(value);
      return this._push(writeFixed32, 4, bits.lo)._push(writeFixed32, 4, bits.hi);
    }
    /**
     * Writes an unsigned 64 bit value as fixed 64 bits
     */
    fixed64String(value) {
      return this.fixed64(BigInt(value));
    }
    /**
     * Writes a signed 64 bit value as fixed 64 bits
     */
    sfixed64(value) {
      return this.fixed64(value);
    }
    /**
     * Writes a signed 64 bit value as fixed 64 bits
     */
    sfixed64Number(value) {
      return this.fixed64Number(value);
    }
    /**
     * Writes a signed 64 bit value as fixed 64 bits
     */
    sfixed64String(value) {
      return this.fixed64String(value);
    }
    /**
     * Writes a float (32 bit)
     */
    float(value) {
      return this._push(writeFloatLE, 4, value);
    }
    /**
     * Writes a double (64 bit float).
     *
     * @function
     * @param {number} value - Value to write
     * @returns {Writer} `this`
     */
    double(value) {
      return this._push(writeDoubleLE, 8, value);
    }
    /**
     * Writes a sequence of bytes
     */
    bytes(value) {
      const len = value.length >>> 0;
      if (len === 0) {
        return this._push(writeByte, 1, 0);
      }
      return this.uint32(len)._push(writeBytes, len, value);
    }
    /**
     * Writes a string
     */
    string(value) {
      const len = length2(value);
      return len !== 0 ? this.uint32(len)._push(write, len, value) : this._push(writeByte, 1, 0);
    }
    /**
     * Forks this writer's state by pushing it to a stack.
     * Calling {@link Writer#reset|reset} or {@link Writer#ldelim|ldelim} resets the writer to the previous state.
     */
    fork() {
      this.states = new State(this);
      this.head = this.tail = new Op(noop, 0, 0);
      this.len = 0;
      return this;
    }
    /**
     * Resets this instance to the last state
     */
    reset() {
      if (this.states != null) {
        this.head = this.states.head;
        this.tail = this.states.tail;
        this.len = this.states.len;
        this.states = this.states.next;
      } else {
        this.head = this.tail = new Op(noop, 0, 0);
        this.len = 0;
      }
      return this;
    }
    /**
     * Resets to the last state and appends the fork state's current write length as a varint followed by its operations.
     */
    ldelim() {
      const head = this.head;
      const tail = this.tail;
      const len = this.len;
      this.reset().uint32(len);
      if (len !== 0) {
        this.tail.next = head.next;
        this.tail = tail;
        this.len += len;
      }
      return this;
    }
    /**
     * Finishes the write operation
     */
    finish() {
      let head = this.head.next;
      const buf = alloc2(this.len);
      let pos = 0;
      while (head != null) {
        head.fn(head.val, buf, pos);
        pos += head.len;
        head = head.next;
      }
      return buf;
    }
  };
  function writeByte(val, buf, pos) {
    buf[pos] = val & 255;
  }
  function writeVarint32(val, buf, pos) {
    while (val > 127) {
      buf[pos++] = val & 127 | 128;
      val >>>= 7;
    }
    buf[pos] = val;
  }
  var VarintOp = class extends Op {
    next;
    constructor(len, val) {
      super(writeVarint32, len, val);
      this.next = void 0;
    }
  };
  function writeVarint64(val, buf, pos) {
    while (val.hi !== 0) {
      buf[pos++] = val.lo & 127 | 128;
      val.lo = (val.lo >>> 7 | val.hi << 25) >>> 0;
      val.hi >>>= 7;
    }
    while (val.lo > 127) {
      buf[pos++] = val.lo & 127 | 128;
      val.lo = val.lo >>> 7;
    }
    buf[pos++] = val.lo;
  }
  function writeFixed32(val, buf, pos) {
    buf[pos] = val & 255;
    buf[pos + 1] = val >>> 8 & 255;
    buf[pos + 2] = val >>> 16 & 255;
    buf[pos + 3] = val >>> 24;
  }
  function writeBytes(val, buf, pos) {
    buf.set(val, pos);
  }
  if (globalThis.Buffer != null) {
    Uint8ArrayWriter.prototype.bytes = function(value) {
      const len = value.length >>> 0;
      this.uint32(len);
      if (len > 0) {
        this._push(writeBytesBuffer, len, value);
      }
      return this;
    };
    Uint8ArrayWriter.prototype.string = function(value) {
      const len = globalThis.Buffer.byteLength(value);
      this.uint32(len);
      if (len > 0) {
        this._push(writeStringBuffer, len, value);
      }
      return this;
    };
  }
  function writeBytesBuffer(val, buf, pos) {
    buf.set(val, pos);
  }
  function writeStringBuffer(val, buf, pos) {
    if (val.length < 40) {
      write(val, buf, pos);
    } else if (buf.utf8Write != null) {
      buf.utf8Write(val, pos);
    } else {
      buf.set(fromString2(val), pos);
    }
  }
  function createWriter() {
    return new Uint8ArrayWriter();
  }

  // node_modules/protons-runtime/dist/src/encode.js
  function encodeMessage(message2, codec) {
    const w2 = createWriter();
    codec.encode(message2, w2, {
      lengthDelimited: false
    });
    return w2.finish();
  }

  // node_modules/protons-runtime/dist/src/codecs/enum.js
  var import_browser_shims84 = __toESM(require_browser_shims(), 1);

  // node_modules/protons-runtime/dist/src/codec.js
  var import_browser_shims83 = __toESM(require_browser_shims(), 1);
  var CODEC_TYPES;
  (function(CODEC_TYPES2) {
    CODEC_TYPES2[CODEC_TYPES2["VARINT"] = 0] = "VARINT";
    CODEC_TYPES2[CODEC_TYPES2["BIT64"] = 1] = "BIT64";
    CODEC_TYPES2[CODEC_TYPES2["LENGTH_DELIMITED"] = 2] = "LENGTH_DELIMITED";
    CODEC_TYPES2[CODEC_TYPES2["START_GROUP"] = 3] = "START_GROUP";
    CODEC_TYPES2[CODEC_TYPES2["END_GROUP"] = 4] = "END_GROUP";
    CODEC_TYPES2[CODEC_TYPES2["BIT32"] = 5] = "BIT32";
  })(CODEC_TYPES || (CODEC_TYPES = {}));
  function createCodec2(name3, type, encode10, decode11) {
    return {
      name: name3,
      type,
      encode: encode10,
      decode: decode11
    };
  }

  // node_modules/protons-runtime/dist/src/codecs/enum.js
  function enumeration(v) {
    function findValue(val) {
      if (v[val.toString()] == null) {
        throw new Error("Invalid enum value");
      }
      return v[val];
    }
    const encode10 = function enumEncode(val, writer) {
      const enumValue = findValue(val);
      writer.int32(enumValue);
    };
    const decode11 = function enumDecode(reader) {
      const val = reader.int32();
      return findValue(val);
    };
    return createCodec2("enum", CODEC_TYPES.VARINT, encode10, decode11);
  }

  // node_modules/protons-runtime/dist/src/codecs/message.js
  var import_browser_shims85 = __toESM(require_browser_shims(), 1);
  function message(encode10, decode11) {
    return createCodec2("message", CODEC_TYPES.LENGTH_DELIMITED, encode10, decode11);
  }

  // node_modules/protons-runtime/dist/src/index.js
  var MaxLengthError = class extends Error {
    /**
     * This will be removed in a future release
     *
     * @deprecated use the `.name` property instead
     */
    code = "ERR_MAX_LENGTH";
    name = "MaxLengthError";
  };
  var MaxSizeError = class extends Error {
    /**
     * This will be removed in a future release
     *
     * @deprecated use the `.name` property instead
     */
    code = "ERR_MAX_SIZE";
    name = "MaxSizeError";
  };

  // node_modules/@libp2p/crypto/dist/src/keys/keys.js
  var KeyType;
  (function(KeyType2) {
    KeyType2["RSA"] = "RSA";
    KeyType2["Ed25519"] = "Ed25519";
    KeyType2["secp256k1"] = "secp256k1";
    KeyType2["ECDSA"] = "ECDSA";
  })(KeyType || (KeyType = {}));
  var __KeyTypeValues;
  (function(__KeyTypeValues2) {
    __KeyTypeValues2[__KeyTypeValues2["RSA"] = 0] = "RSA";
    __KeyTypeValues2[__KeyTypeValues2["Ed25519"] = 1] = "Ed25519";
    __KeyTypeValues2[__KeyTypeValues2["secp256k1"] = 2] = "secp256k1";
    __KeyTypeValues2[__KeyTypeValues2["ECDSA"] = 3] = "ECDSA";
  })(__KeyTypeValues || (__KeyTypeValues = {}));
  (function(KeyType2) {
    KeyType2.codec = () => {
      return enumeration(__KeyTypeValues);
    };
  })(KeyType || (KeyType = {}));
  var PublicKey;
  (function(PublicKey2) {
    let _codec;
    PublicKey2.codec = () => {
      if (_codec == null) {
        _codec = message((obj, w2, opts = {}) => {
          if (opts.lengthDelimited !== false) {
            w2.fork();
          }
          if (obj.Type != null) {
            w2.uint32(8);
            KeyType.codec().encode(obj.Type, w2);
          }
          if (obj.Data != null) {
            w2.uint32(18);
            w2.bytes(obj.Data);
          }
          if (opts.lengthDelimited !== false) {
            w2.ldelim();
          }
        }, (reader, length4, opts = {}) => {
          const obj = {};
          const end = length4 == null ? reader.len : reader.pos + length4;
          while (reader.pos < end) {
            const tag = reader.uint32();
            switch (tag >>> 3) {
              case 1: {
                obj.Type = KeyType.codec().decode(reader);
                break;
              }
              case 2: {
                obj.Data = reader.bytes();
                break;
              }
              default: {
                reader.skipType(tag & 7);
                break;
              }
            }
          }
          return obj;
        });
      }
      return _codec;
    };
    PublicKey2.encode = (obj) => {
      return encodeMessage(obj, PublicKey2.codec());
    };
    PublicKey2.decode = (buf, opts) => {
      return decodeMessage(buf, PublicKey2.codec(), opts);
    };
  })(PublicKey || (PublicKey = {}));
  var PrivateKey;
  (function(PrivateKey2) {
    let _codec;
    PrivateKey2.codec = () => {
      if (_codec == null) {
        _codec = message((obj, w2, opts = {}) => {
          if (opts.lengthDelimited !== false) {
            w2.fork();
          }
          if (obj.Type != null) {
            w2.uint32(8);
            KeyType.codec().encode(obj.Type, w2);
          }
          if (obj.Data != null) {
            w2.uint32(18);
            w2.bytes(obj.Data);
          }
          if (opts.lengthDelimited !== false) {
            w2.ldelim();
          }
        }, (reader, length4, opts = {}) => {
          const obj = {};
          const end = length4 == null ? reader.len : reader.pos + length4;
          while (reader.pos < end) {
            const tag = reader.uint32();
            switch (tag >>> 3) {
              case 1: {
                obj.Type = KeyType.codec().decode(reader);
                break;
              }
              case 2: {
                obj.Data = reader.bytes();
                break;
              }
              default: {
                reader.skipType(tag & 7);
                break;
              }
            }
          }
          return obj;
        });
      }
      return _codec;
    };
    PrivateKey2.encode = (obj) => {
      return encodeMessage(obj, PrivateKey2.codec());
    };
    PrivateKey2.decode = (buf, opts) => {
      return decodeMessage(buf, PrivateKey2.codec(), opts);
    };
  })(PrivateKey || (PrivateKey = {}));

  // node_modules/@libp2p/crypto/dist/src/keys/rsa/index.browser.js
  var import_browser_shims92 = __toESM(require_browser_shims(), 1);

  // node_modules/@libp2p/crypto/dist/src/random-bytes.js
  var import_browser_shims88 = __toESM(require_browser_shims(), 1);
  function randomBytes2(length4) {
    if (isNaN(length4) || length4 <= 0) {
      throw new InvalidParametersError("random bytes length must be a Number bigger than 0");
    }
    return randomBytes(length4);
  }

  // node_modules/@libp2p/crypto/dist/src/keys/rsa/utils.js
  var utils_exports = {};
  __export(utils_exports, {
    MAX_RSA_KEY_SIZE: () => MAX_RSA_KEY_SIZE,
    generateRSAKeyPair: () => generateRSAKeyPair,
    jwkToJWKKeyPair: () => jwkToJWKKeyPair,
    jwkToPkcs1: () => jwkToPkcs1,
    jwkToPkix: () => jwkToPkix,
    jwkToRSAPrivateKey: () => jwkToRSAPrivateKey,
    pkcs1MessageToJwk: () => pkcs1MessageToJwk,
    pkcs1MessageToRSAPrivateKey: () => pkcs1MessageToRSAPrivateKey,
    pkcs1ToJwk: () => pkcs1ToJwk,
    pkcs1ToRSAPrivateKey: () => pkcs1ToRSAPrivateKey,
    pkixMessageToJwk: () => pkixMessageToJwk,
    pkixMessageToRSAPublicKey: () => pkixMessageToRSAPublicKey,
    pkixToJwk: () => pkixToJwk,
    pkixToRSAPublicKey: () => pkixToRSAPublicKey
  });
  var import_browser_shims91 = __toESM(require_browser_shims(), 1);

  // node_modules/@noble/hashes/esm/sha256.js
  var import_browser_shims89 = __toESM(require_browser_shims(), 1);
  var sha2563 = sha2562;

  // node_modules/@libp2p/crypto/dist/src/keys/rsa/rsa.js
  var import_browser_shims90 = __toESM(require_browser_shims(), 1);
  var RSAPublicKey = class {
    type = "RSA";
    jwk;
    _raw;
    _multihash;
    constructor(jwk, digest2) {
      this.jwk = jwk;
      this._multihash = digest2;
    }
    get raw() {
      if (this._raw == null) {
        this._raw = utils_exports.jwkToPkix(this.jwk);
      }
      return this._raw;
    }
    toMultihash() {
      return this._multihash;
    }
    toCID() {
      return CID.createV1(114, this._multihash);
    }
    toString() {
      return base58btc.encode(this.toMultihash().bytes).substring(1);
    }
    equals(key) {
      if (key == null || !(key.raw instanceof Uint8Array)) {
        return false;
      }
      return equals3(this.raw, key.raw);
    }
    verify(data, sig, options) {
      return hashAndVerify3(this.jwk, sig, data, options);
    }
  };
  var RSAPrivateKey = class {
    type = "RSA";
    jwk;
    _raw;
    publicKey;
    constructor(jwk, publicKey) {
      this.jwk = jwk;
      this.publicKey = publicKey;
    }
    get raw() {
      if (this._raw == null) {
        this._raw = utils_exports.jwkToPkcs1(this.jwk);
      }
      return this._raw;
    }
    equals(key) {
      if (key == null || !(key.raw instanceof Uint8Array)) {
        return false;
      }
      return equals3(this.raw, key.raw);
    }
    sign(message2, options) {
      return hashAndSign3(this.jwk, message2, options);
    }
  };

  // node_modules/@libp2p/crypto/dist/src/keys/rsa/utils.js
  var MAX_RSA_KEY_SIZE = 8192;
  var SHA2_256_CODE = 18;
  var MAX_RSA_JWK_SIZE = 1062;
  var RSA_ALGORITHM_IDENTIFIER = Uint8Array.from([
    48,
    13,
    6,
    9,
    42,
    134,
    72,
    134,
    247,
    13,
    1,
    1,
    1,
    5,
    0
  ]);
  function pkcs1ToJwk(bytes) {
    const message2 = decodeDer(bytes);
    return pkcs1MessageToJwk(message2);
  }
  function pkcs1MessageToJwk(message2) {
    return {
      n: toString2(message2[1], "base64url"),
      e: toString2(message2[2], "base64url"),
      d: toString2(message2[3], "base64url"),
      p: toString2(message2[4], "base64url"),
      q: toString2(message2[5], "base64url"),
      dp: toString2(message2[6], "base64url"),
      dq: toString2(message2[7], "base64url"),
      qi: toString2(message2[8], "base64url"),
      kty: "RSA"
    };
  }
  function jwkToPkcs1(jwk) {
    if (jwk.n == null || jwk.e == null || jwk.d == null || jwk.p == null || jwk.q == null || jwk.dp == null || jwk.dq == null || jwk.qi == null) {
      throw new InvalidParametersError("JWK was missing components");
    }
    return encodeSequence([
      encodeInteger(Uint8Array.from([0])),
      encodeInteger(fromString2(jwk.n, "base64url")),
      encodeInteger(fromString2(jwk.e, "base64url")),
      encodeInteger(fromString2(jwk.d, "base64url")),
      encodeInteger(fromString2(jwk.p, "base64url")),
      encodeInteger(fromString2(jwk.q, "base64url")),
      encodeInteger(fromString2(jwk.dp, "base64url")),
      encodeInteger(fromString2(jwk.dq, "base64url")),
      encodeInteger(fromString2(jwk.qi, "base64url"))
    ]).subarray();
  }
  function pkixToJwk(bytes) {
    const message2 = decodeDer(bytes, {
      offset: 0
    });
    return pkixMessageToJwk(message2);
  }
  function pkixMessageToJwk(message2) {
    const keys = decodeDer(message2[1], {
      offset: 0
    });
    return {
      kty: "RSA",
      n: toString2(keys[0], "base64url"),
      e: toString2(keys[1], "base64url")
    };
  }
  function jwkToPkix(jwk) {
    if (jwk.n == null || jwk.e == null) {
      throw new InvalidParametersError("JWK was missing components");
    }
    const subjectPublicKeyInfo = encodeSequence([
      RSA_ALGORITHM_IDENTIFIER,
      encodeBitString(encodeSequence([
        encodeInteger(fromString2(jwk.n, "base64url")),
        encodeInteger(fromString2(jwk.e, "base64url"))
      ]))
    ]);
    return subjectPublicKeyInfo.subarray();
  }
  function pkcs1ToRSAPrivateKey(bytes) {
    const message2 = decodeDer(bytes);
    return pkcs1MessageToRSAPrivateKey(message2);
  }
  function pkcs1MessageToRSAPrivateKey(message2) {
    const jwk = pkcs1MessageToJwk(message2);
    return jwkToRSAPrivateKey(jwk);
  }
  function pkixToRSAPublicKey(bytes, digest2) {
    if (bytes.byteLength >= MAX_RSA_JWK_SIZE) {
      throw new InvalidPublicKeyError("Key size is too large");
    }
    const message2 = decodeDer(bytes, {
      offset: 0
    });
    return pkixMessageToRSAPublicKey(message2, bytes, digest2);
  }
  function pkixMessageToRSAPublicKey(message2, bytes, digest2) {
    const jwk = pkixMessageToJwk(message2);
    if (digest2 == null) {
      const hash = sha2563(PublicKey.encode({
        Type: KeyType.RSA,
        Data: bytes
      }));
      digest2 = create(SHA2_256_CODE, hash);
    }
    return new RSAPublicKey(jwk, digest2);
  }
  function jwkToRSAPrivateKey(jwk) {
    if (rsaKeySize(jwk) > MAX_RSA_KEY_SIZE) {
      throw new InvalidParametersError("Key size is too large");
    }
    const keys = jwkToJWKKeyPair(jwk);
    const hash = sha2563(PublicKey.encode({
      Type: KeyType.RSA,
      Data: jwkToPkix(keys.publicKey)
    }));
    const digest2 = create(SHA2_256_CODE, hash);
    return new RSAPrivateKey(keys.privateKey, new RSAPublicKey(keys.publicKey, digest2));
  }
  async function generateRSAKeyPair(bits) {
    if (bits > MAX_RSA_KEY_SIZE) {
      throw new InvalidParametersError("Key size is too large");
    }
    const keys = await generateRSAKey(bits);
    const hash = sha2563(PublicKey.encode({
      Type: KeyType.RSA,
      Data: jwkToPkix(keys.publicKey)
    }));
    const digest2 = create(SHA2_256_CODE, hash);
    return new RSAPrivateKey(keys.privateKey, new RSAPublicKey(keys.publicKey, digest2));
  }
  function jwkToJWKKeyPair(key) {
    if (key == null) {
      throw new InvalidParametersError("Missing key parameter");
    }
    return {
      privateKey: key,
      publicKey: {
        kty: key.kty,
        n: key.n,
        e: key.e
      }
    };
  }

  // node_modules/@libp2p/crypto/dist/src/keys/rsa/index.browser.js
  async function generateRSAKey(bits, options) {
    var _a2;
    const pair2 = await webcrypto_default.get().subtle.generateKey({
      name: "RSASSA-PKCS1-v1_5",
      modulusLength: bits,
      publicExponent: new Uint8Array([1, 0, 1]),
      hash: { name: "SHA-256" }
    }, true, ["sign", "verify"]);
    (_a2 = options == null ? void 0 : options.signal) == null ? void 0 : _a2.throwIfAborted();
    const keys = await exportKey(pair2, options);
    return {
      privateKey: keys[0],
      publicKey: keys[1]
    };
  }
  async function hashAndSign3(key, msg, options) {
    var _a2, _b2;
    const privateKey = await webcrypto_default.get().subtle.importKey("jwk", key, {
      name: "RSASSA-PKCS1-v1_5",
      hash: { name: "SHA-256" }
    }, false, ["sign"]);
    (_a2 = options == null ? void 0 : options.signal) == null ? void 0 : _a2.throwIfAborted();
    const sig = await webcrypto_default.get().subtle.sign({ name: "RSASSA-PKCS1-v1_5" }, privateKey, msg instanceof Uint8Array ? msg : msg.subarray());
    (_b2 = options == null ? void 0 : options.signal) == null ? void 0 : _b2.throwIfAborted();
    return new Uint8Array(sig, 0, sig.byteLength);
  }
  async function hashAndVerify3(key, sig, msg, options) {
    var _a2, _b2;
    const publicKey = await webcrypto_default.get().subtle.importKey("jwk", key, {
      name: "RSASSA-PKCS1-v1_5",
      hash: { name: "SHA-256" }
    }, false, ["verify"]);
    (_a2 = options == null ? void 0 : options.signal) == null ? void 0 : _a2.throwIfAborted();
    const result = await webcrypto_default.get().subtle.verify({ name: "RSASSA-PKCS1-v1_5" }, publicKey, sig, msg instanceof Uint8Array ? msg : msg.subarray());
    (_b2 = options == null ? void 0 : options.signal) == null ? void 0 : _b2.throwIfAborted();
    return result;
  }
  async function exportKey(pair2, options) {
    var _a2;
    if (pair2.privateKey == null || pair2.publicKey == null) {
      throw new InvalidParametersError("Private and public key are required");
    }
    const result = await Promise.all([
      webcrypto_default.get().subtle.exportKey("jwk", pair2.privateKey),
      webcrypto_default.get().subtle.exportKey("jwk", pair2.publicKey)
    ]);
    (_a2 = options == null ? void 0 : options.signal) == null ? void 0 : _a2.throwIfAborted();
    return result;
  }
  function rsaKeySize(jwk) {
    if (jwk.kty !== "RSA") {
      throw new InvalidParametersError("invalid key type");
    } else if (jwk.n == null) {
      throw new InvalidParametersError("invalid key modulus");
    }
    const bytes = fromString2(jwk.n, "base64url");
    return bytes.length * 8;
  }

  // node_modules/@libp2p/crypto/dist/src/keys/secp256k1/index.browser.js
  var import_browser_shims97 = __toESM(require_browser_shims(), 1);

  // node_modules/@noble/curves/esm/secp256k1.js
  var import_browser_shims96 = __toESM(require_browser_shims(), 1);

  // node_modules/@noble/curves/esm/_shortw_utils.js
  var import_browser_shims95 = __toESM(require_browser_shims(), 1);

  // node_modules/@noble/hashes/esm/hmac.js
  var import_browser_shims93 = __toESM(require_browser_shims(), 1);
  var HMAC = class extends Hash {
    constructor(hash, _key) {
      super();
      this.finished = false;
      this.destroyed = false;
      ahash(hash);
      const key = toBytes(_key);
      this.iHash = hash.create();
      if (typeof this.iHash.update !== "function")
        throw new Error("Expected instance of class which extends utils.Hash");
      this.blockLen = this.iHash.blockLen;
      this.outputLen = this.iHash.outputLen;
      const blockLen = this.blockLen;
      const pad = new Uint8Array(blockLen);
      pad.set(key.length > blockLen ? hash.create().update(key).digest() : key);
      for (let i = 0; i < pad.length; i++)
        pad[i] ^= 54;
      this.iHash.update(pad);
      this.oHash = hash.create();
      for (let i = 0; i < pad.length; i++)
        pad[i] ^= 54 ^ 92;
      this.oHash.update(pad);
      clean(pad);
    }
    update(buf) {
      aexists(this);
      this.iHash.update(buf);
      return this;
    }
    digestInto(out) {
      aexists(this);
      abytes(out, this.outputLen);
      this.finished = true;
      this.iHash.digestInto(out);
      this.oHash.update(out);
      this.oHash.digestInto(out);
      this.destroy();
    }
    digest() {
      const out = new Uint8Array(this.oHash.outputLen);
      this.digestInto(out);
      return out;
    }
    _cloneInto(to) {
      to || (to = Object.create(Object.getPrototypeOf(this), {}));
      const { oHash, iHash, finished, destroyed, blockLen, outputLen } = this;
      to = to;
      to.finished = finished;
      to.destroyed = destroyed;
      to.blockLen = blockLen;
      to.outputLen = outputLen;
      to.oHash = oHash._cloneInto(to.oHash);
      to.iHash = iHash._cloneInto(to.iHash);
      return to;
    }
    clone() {
      return this._cloneInto();
    }
    destroy() {
      this.destroyed = true;
      this.oHash.destroy();
      this.iHash.destroy();
    }
  };
  var hmac = (hash, key, message2) => new HMAC(hash, key).update(message2).digest();
  hmac.create = (hash, key) => new HMAC(hash, key);

  // node_modules/@noble/curves/esm/abstract/weierstrass.js
  var import_browser_shims94 = __toESM(require_browser_shims(), 1);
  function validateSigVerOpts(opts) {
    if (opts.lowS !== void 0)
      abool("lowS", opts.lowS);
    if (opts.prehash !== void 0)
      abool("prehash", opts.prehash);
  }
  function validatePointOpts(curve) {
    const opts = validateBasic(curve);
    validateObject(opts, {
      a: "field",
      b: "field"
    }, {
      allowInfinityPoint: "boolean",
      allowedPrivateKeyLengths: "array",
      clearCofactor: "function",
      fromBytes: "function",
      isTorsionFree: "function",
      toBytes: "function",
      wrapPrivateKey: "boolean"
    });
    const { endo, Fp: Fp2, a } = opts;
    if (endo) {
      if (!Fp2.eql(a, Fp2.ZERO)) {
        throw new Error("invalid endo: CURVE.a must be 0");
      }
      if (typeof endo !== "object" || typeof endo.beta !== "bigint" || typeof endo.splitScalar !== "function") {
        throw new Error('invalid endo: expected "beta": bigint and "splitScalar": function');
      }
    }
    return Object.freeze({ ...opts });
  }
  var DERErr = class extends Error {
    constructor(m2 = "") {
      super(m2);
    }
  };
  var DER = {
    // asn.1 DER encoding utils
    Err: DERErr,
    // Basic building block is TLV (Tag-Length-Value)
    _tlv: {
      encode: (tag, data) => {
        const { Err: E } = DER;
        if (tag < 0 || tag > 256)
          throw new E("tlv.encode: wrong tag");
        if (data.length & 1)
          throw new E("tlv.encode: unpadded data");
        const dataLen = data.length / 2;
        const len = numberToHexUnpadded(dataLen);
        if (len.length / 2 & 128)
          throw new E("tlv.encode: long form length too big");
        const lenLen = dataLen > 127 ? numberToHexUnpadded(len.length / 2 | 128) : "";
        const t = numberToHexUnpadded(tag);
        return t + lenLen + len + data;
      },
      // v - value, l - left bytes (unparsed)
      decode(tag, data) {
        const { Err: E } = DER;
        let pos = 0;
        if (tag < 0 || tag > 256)
          throw new E("tlv.encode: wrong tag");
        if (data.length < 2 || data[pos++] !== tag)
          throw new E("tlv.decode: wrong tlv");
        const first = data[pos++];
        const isLong = !!(first & 128);
        let length4 = 0;
        if (!isLong)
          length4 = first;
        else {
          const lenLen = first & 127;
          if (!lenLen)
            throw new E("tlv.decode(long): indefinite length not supported");
          if (lenLen > 4)
            throw new E("tlv.decode(long): byte length is too big");
          const lengthBytes = data.subarray(pos, pos + lenLen);
          if (lengthBytes.length !== lenLen)
            throw new E("tlv.decode: length bytes not complete");
          if (lengthBytes[0] === 0)
            throw new E("tlv.decode(long): zero leftmost byte");
          for (const b of lengthBytes)
            length4 = length4 << 8 | b;
          pos += lenLen;
          if (length4 < 128)
            throw new E("tlv.decode(long): not minimal encoding");
        }
        const v = data.subarray(pos, pos + length4);
        if (v.length !== length4)
          throw new E("tlv.decode: wrong value length");
        return { v, l: data.subarray(pos + length4) };
      }
    },
    // https://crypto.stackexchange.com/a/57734 Leftmost bit of first byte is 'negative' flag,
    // since we always use positive integers here. It must always be empty:
    // - add zero byte if exists
    // - if next byte doesn't have a flag, leading zero is not allowed (minimal encoding)
    _int: {
      encode(num) {
        const { Err: E } = DER;
        if (num < _0n7)
          throw new E("integer: negative integers are not allowed");
        let hex = numberToHexUnpadded(num);
        if (Number.parseInt(hex[0], 16) & 8)
          hex = "00" + hex;
        if (hex.length & 1)
          throw new E("unexpected DER parsing assertion: unpadded hex");
        return hex;
      },
      decode(data) {
        const { Err: E } = DER;
        if (data[0] & 128)
          throw new E("invalid signature integer: negative");
        if (data[0] === 0 && !(data[1] & 128))
          throw new E("invalid signature integer: unnecessary leading zero");
        return bytesToNumberBE(data);
      }
    },
    toSig(hex) {
      const { Err: E, _int: int, _tlv: tlv } = DER;
      const data = ensureBytes("signature", hex);
      const { v: seqBytes, l: seqLeftBytes } = tlv.decode(48, data);
      if (seqLeftBytes.length)
        throw new E("invalid signature: left bytes after parsing");
      const { v: rBytes, l: rLeftBytes } = tlv.decode(2, seqBytes);
      const { v: sBytes, l: sLeftBytes } = tlv.decode(2, rLeftBytes);
      if (sLeftBytes.length)
        throw new E("invalid signature: left bytes after parsing");
      return { r: int.decode(rBytes), s: int.decode(sBytes) };
    },
    hexFromSig(sig) {
      const { _tlv: tlv, _int: int } = DER;
      const rs = tlv.encode(2, int.encode(sig.r));
      const ss = tlv.encode(2, int.encode(sig.s));
      const seq = rs + ss;
      return tlv.encode(48, seq);
    }
  };
  function numToSizedHex(num, size) {
    return bytesToHex(numberToBytesBE(num, size));
  }
  var _0n7 = BigInt(0);
  var _1n7 = BigInt(1);
  var _2n5 = BigInt(2);
  var _3n3 = BigInt(3);
  var _4n2 = BigInt(4);
  function weierstrassPoints(opts) {
    const CURVE = validatePointOpts(opts);
    const { Fp: Fp2 } = CURVE;
    const Fn = Field(CURVE.n, CURVE.nBitLength);
    const toBytes4 = CURVE.toBytes || ((_c, point, _isCompressed) => {
      const a = point.toAffine();
      return concatBytes2(Uint8Array.from([4]), Fp2.toBytes(a.x), Fp2.toBytes(a.y));
    });
    const fromBytes = CURVE.fromBytes || ((bytes) => {
      const tail = bytes.subarray(1);
      const x = Fp2.fromBytes(tail.subarray(0, Fp2.BYTES));
      const y2 = Fp2.fromBytes(tail.subarray(Fp2.BYTES, 2 * Fp2.BYTES));
      return { x, y: y2 };
    });
    function weierstrassEquation(x) {
      const { a, b } = CURVE;
      const x2 = Fp2.sqr(x);
      const x3 = Fp2.mul(x2, x);
      return Fp2.add(Fp2.add(x3, Fp2.mul(x, a)), b);
    }
    function isValidXY(x, y2) {
      const left = Fp2.sqr(y2);
      const right = weierstrassEquation(x);
      return Fp2.eql(left, right);
    }
    if (!isValidXY(CURVE.Gx, CURVE.Gy))
      throw new Error("bad curve params: generator point");
    const _4a3 = Fp2.mul(Fp2.pow(CURVE.a, _3n3), _4n2);
    const _27b2 = Fp2.mul(Fp2.sqr(CURVE.b), BigInt(27));
    if (Fp2.is0(Fp2.add(_4a3, _27b2)))
      throw new Error("bad curve params: a or b");
    function isWithinCurveOrder(num) {
      return inRange(num, _1n7, CURVE.n);
    }
    function normPrivateKeyToScalar(key) {
      const { allowedPrivateKeyLengths: lengths, nByteLength, wrapPrivateKey, n: N } = CURVE;
      if (lengths && typeof key !== "bigint") {
        if (isBytes2(key))
          key = bytesToHex(key);
        if (typeof key !== "string" || !lengths.includes(key.length))
          throw new Error("invalid private key");
        key = key.padStart(nByteLength * 2, "0");
      }
      let num;
      try {
        num = typeof key === "bigint" ? key : bytesToNumberBE(ensureBytes("private key", key, nByteLength));
      } catch (error) {
        throw new Error("invalid private key, expected hex or " + nByteLength + " bytes, got " + typeof key);
      }
      if (wrapPrivateKey)
        num = mod(num, N);
      aInRange("private key", num, _1n7, N);
      return num;
    }
    function aprjpoint(other) {
      if (!(other instanceof Point))
        throw new Error("ProjectivePoint expected");
    }
    const toAffineMemo = memoized((p, iz) => {
      const { px: x, py: y2, pz: z } = p;
      if (Fp2.eql(z, Fp2.ONE))
        return { x, y: y2 };
      const is0 = p.is0();
      if (iz == null)
        iz = is0 ? Fp2.ONE : Fp2.inv(z);
      const ax = Fp2.mul(x, iz);
      const ay = Fp2.mul(y2, iz);
      const zz = Fp2.mul(z, iz);
      if (is0)
        return { x: Fp2.ZERO, y: Fp2.ZERO };
      if (!Fp2.eql(zz, Fp2.ONE))
        throw new Error("invZ was invalid");
      return { x: ax, y: ay };
    });
    const assertValidMemo = memoized((p) => {
      if (p.is0()) {
        if (CURVE.allowInfinityPoint && !Fp2.is0(p.py))
          return;
        throw new Error("bad point: ZERO");
      }
      const { x, y: y2 } = p.toAffine();
      if (!Fp2.isValid(x) || !Fp2.isValid(y2))
        throw new Error("bad point: x or y not FE");
      if (!isValidXY(x, y2))
        throw new Error("bad point: equation left != right");
      if (!p.isTorsionFree())
        throw new Error("bad point: not in prime-order subgroup");
      return true;
    });
    class Point {
      constructor(px, py, pz) {
        if (px == null || !Fp2.isValid(px))
          throw new Error("x required");
        if (py == null || !Fp2.isValid(py) || Fp2.is0(py))
          throw new Error("y required");
        if (pz == null || !Fp2.isValid(pz))
          throw new Error("z required");
        this.px = px;
        this.py = py;
        this.pz = pz;
        Object.freeze(this);
      }
      // Does not validate if the point is on-curve.
      // Use fromHex instead, or call assertValidity() later.
      static fromAffine(p) {
        const { x, y: y2 } = p || {};
        if (!p || !Fp2.isValid(x) || !Fp2.isValid(y2))
          throw new Error("invalid affine point");
        if (p instanceof Point)
          throw new Error("projective point not allowed");
        const is0 = (i) => Fp2.eql(i, Fp2.ZERO);
        if (is0(x) && is0(y2))
          return Point.ZERO;
        return new Point(x, y2, Fp2.ONE);
      }
      get x() {
        return this.toAffine().x;
      }
      get y() {
        return this.toAffine().y;
      }
      /**
       * Takes a bunch of Projective Points but executes only one
       * inversion on all of them. Inversion is very slow operation,
       * so this improves performance massively.
       * Optimization: converts a list of projective points to a list of identical points with Z=1.
       */
      static normalizeZ(points) {
        const toInv = FpInvertBatch(Fp2, points.map((p) => p.pz));
        return points.map((p, i) => p.toAffine(toInv[i])).map(Point.fromAffine);
      }
      /**
       * Converts hash string or Uint8Array to Point.
       * @param hex short/long ECDSA hex
       */
      static fromHex(hex) {
        const P = Point.fromAffine(fromBytes(ensureBytes("pointHex", hex)));
        P.assertValidity();
        return P;
      }
      // Multiplies generator point by privateKey.
      static fromPrivateKey(privateKey) {
        return Point.BASE.multiply(normPrivateKeyToScalar(privateKey));
      }
      // Multiscalar Multiplication
      static msm(points, scalars) {
        return pippenger(Point, Fn, points, scalars);
      }
      // "Private method", don't use it directly
      _setWindowSize(windowSize) {
        wnaf.setWindowSize(this, windowSize);
      }
      // A point on curve is valid if it conforms to equation.
      assertValidity() {
        assertValidMemo(this);
      }
      hasEvenY() {
        const { y: y2 } = this.toAffine();
        if (Fp2.isOdd)
          return !Fp2.isOdd(y2);
        throw new Error("Field doesn't support isOdd");
      }
      /**
       * Compare one point to another.
       */
      equals(other) {
        aprjpoint(other);
        const { px: X1, py: Y1, pz: Z1 } = this;
        const { px: X2, py: Y2, pz: Z2 } = other;
        const U1 = Fp2.eql(Fp2.mul(X1, Z2), Fp2.mul(X2, Z1));
        const U2 = Fp2.eql(Fp2.mul(Y1, Z2), Fp2.mul(Y2, Z1));
        return U1 && U2;
      }
      /**
       * Flips point to one corresponding to (x, -y) in Affine coordinates.
       */
      negate() {
        return new Point(this.px, Fp2.neg(this.py), this.pz);
      }
      // Renes-Costello-Batina exception-free doubling formula.
      // There is 30% faster Jacobian formula, but it is not complete.
      // https://eprint.iacr.org/2015/1060, algorithm 3
      // Cost: 8M + 3S + 3*a + 2*b3 + 15add.
      double() {
        const { a, b } = CURVE;
        const b3 = Fp2.mul(b, _3n3);
        const { px: X1, py: Y1, pz: Z1 } = this;
        let X3 = Fp2.ZERO, Y3 = Fp2.ZERO, Z3 = Fp2.ZERO;
        let t0 = Fp2.mul(X1, X1);
        let t1 = Fp2.mul(Y1, Y1);
        let t2 = Fp2.mul(Z1, Z1);
        let t3 = Fp2.mul(X1, Y1);
        t3 = Fp2.add(t3, t3);
        Z3 = Fp2.mul(X1, Z1);
        Z3 = Fp2.add(Z3, Z3);
        X3 = Fp2.mul(a, Z3);
        Y3 = Fp2.mul(b3, t2);
        Y3 = Fp2.add(X3, Y3);
        X3 = Fp2.sub(t1, Y3);
        Y3 = Fp2.add(t1, Y3);
        Y3 = Fp2.mul(X3, Y3);
        X3 = Fp2.mul(t3, X3);
        Z3 = Fp2.mul(b3, Z3);
        t2 = Fp2.mul(a, t2);
        t3 = Fp2.sub(t0, t2);
        t3 = Fp2.mul(a, t3);
        t3 = Fp2.add(t3, Z3);
        Z3 = Fp2.add(t0, t0);
        t0 = Fp2.add(Z3, t0);
        t0 = Fp2.add(t0, t2);
        t0 = Fp2.mul(t0, t3);
        Y3 = Fp2.add(Y3, t0);
        t2 = Fp2.mul(Y1, Z1);
        t2 = Fp2.add(t2, t2);
        t0 = Fp2.mul(t2, t3);
        X3 = Fp2.sub(X3, t0);
        Z3 = Fp2.mul(t2, t1);
        Z3 = Fp2.add(Z3, Z3);
        Z3 = Fp2.add(Z3, Z3);
        return new Point(X3, Y3, Z3);
      }
      // Renes-Costello-Batina exception-free addition formula.
      // There is 30% faster Jacobian formula, but it is not complete.
      // https://eprint.iacr.org/2015/1060, algorithm 1
      // Cost: 12M + 0S + 3*a + 3*b3 + 23add.
      add(other) {
        aprjpoint(other);
        const { px: X1, py: Y1, pz: Z1 } = this;
        const { px: X2, py: Y2, pz: Z2 } = other;
        let X3 = Fp2.ZERO, Y3 = Fp2.ZERO, Z3 = Fp2.ZERO;
        const a = CURVE.a;
        const b3 = Fp2.mul(CURVE.b, _3n3);
        let t0 = Fp2.mul(X1, X2);
        let t1 = Fp2.mul(Y1, Y2);
        let t2 = Fp2.mul(Z1, Z2);
        let t3 = Fp2.add(X1, Y1);
        let t4 = Fp2.add(X2, Y2);
        t3 = Fp2.mul(t3, t4);
        t4 = Fp2.add(t0, t1);
        t3 = Fp2.sub(t3, t4);
        t4 = Fp2.add(X1, Z1);
        let t5 = Fp2.add(X2, Z2);
        t4 = Fp2.mul(t4, t5);
        t5 = Fp2.add(t0, t2);
        t4 = Fp2.sub(t4, t5);
        t5 = Fp2.add(Y1, Z1);
        X3 = Fp2.add(Y2, Z2);
        t5 = Fp2.mul(t5, X3);
        X3 = Fp2.add(t1, t2);
        t5 = Fp2.sub(t5, X3);
        Z3 = Fp2.mul(a, t4);
        X3 = Fp2.mul(b3, t2);
        Z3 = Fp2.add(X3, Z3);
        X3 = Fp2.sub(t1, Z3);
        Z3 = Fp2.add(t1, Z3);
        Y3 = Fp2.mul(X3, Z3);
        t1 = Fp2.add(t0, t0);
        t1 = Fp2.add(t1, t0);
        t2 = Fp2.mul(a, t2);
        t4 = Fp2.mul(b3, t4);
        t1 = Fp2.add(t1, t2);
        t2 = Fp2.sub(t0, t2);
        t2 = Fp2.mul(a, t2);
        t4 = Fp2.add(t4, t2);
        t0 = Fp2.mul(t1, t4);
        Y3 = Fp2.add(Y3, t0);
        t0 = Fp2.mul(t5, t4);
        X3 = Fp2.mul(t3, X3);
        X3 = Fp2.sub(X3, t0);
        t0 = Fp2.mul(t3, t1);
        Z3 = Fp2.mul(t5, Z3);
        Z3 = Fp2.add(Z3, t0);
        return new Point(X3, Y3, Z3);
      }
      subtract(other) {
        return this.add(other.negate());
      }
      is0() {
        return this.equals(Point.ZERO);
      }
      wNAF(n) {
        return wnaf.wNAFCached(this, n, Point.normalizeZ);
      }
      /**
       * Non-constant-time multiplication. Uses double-and-add algorithm.
       * It's faster, but should only be used when you don't care about
       * an exposed private key e.g. sig verification, which works over *public* keys.
       */
      multiplyUnsafe(sc) {
        const { endo: endo2, n: N } = CURVE;
        aInRange("scalar", sc, _0n7, N);
        const I = Point.ZERO;
        if (sc === _0n7)
          return I;
        if (this.is0() || sc === _1n7)
          return this;
        if (!endo2 || wnaf.hasPrecomputes(this))
          return wnaf.wNAFCachedUnsafe(this, sc, Point.normalizeZ);
        let { k1neg, k1, k2neg, k2 } = endo2.splitScalar(sc);
        let k1p = I;
        let k2p = I;
        let d2 = this;
        while (k1 > _0n7 || k2 > _0n7) {
          if (k1 & _1n7)
            k1p = k1p.add(d2);
          if (k2 & _1n7)
            k2p = k2p.add(d2);
          d2 = d2.double();
          k1 >>= _1n7;
          k2 >>= _1n7;
        }
        if (k1neg)
          k1p = k1p.negate();
        if (k2neg)
          k2p = k2p.negate();
        k2p = new Point(Fp2.mul(k2p.px, endo2.beta), k2p.py, k2p.pz);
        return k1p.add(k2p);
      }
      /**
       * Constant time multiplication.
       * Uses wNAF method. Windowed method may be 10% faster,
       * but takes 2x longer to generate and consumes 2x memory.
       * Uses precomputes when available.
       * Uses endomorphism for Koblitz curves.
       * @param scalar by which the point would be multiplied
       * @returns New point
       */
      multiply(scalar) {
        const { endo: endo2, n: N } = CURVE;
        aInRange("scalar", scalar, _1n7, N);
        let point, fake;
        if (endo2) {
          const { k1neg, k1, k2neg, k2 } = endo2.splitScalar(scalar);
          let { p: k1p, f: f1p } = this.wNAF(k1);
          let { p: k2p, f: f2p } = this.wNAF(k2);
          k1p = wnaf.constTimeNegate(k1neg, k1p);
          k2p = wnaf.constTimeNegate(k2neg, k2p);
          k2p = new Point(Fp2.mul(k2p.px, endo2.beta), k2p.py, k2p.pz);
          point = k1p.add(k2p);
          fake = f1p.add(f2p);
        } else {
          const { p, f } = this.wNAF(scalar);
          point = p;
          fake = f;
        }
        return Point.normalizeZ([point, fake])[0];
      }
      /**
       * Efficiently calculate `aP + bQ`. Unsafe, can expose private key, if used incorrectly.
       * Not using Strauss-Shamir trick: precomputation tables are faster.
       * The trick could be useful if both P and Q are not G (not in our case).
       * @returns non-zero affine point
       */
      multiplyAndAddUnsafe(Q, a, b) {
        const G = Point.BASE;
        const mul = (P, a2) => a2 === _0n7 || a2 === _1n7 || !P.equals(G) ? P.multiplyUnsafe(a2) : P.multiply(a2);
        const sum = mul(this, a).add(mul(Q, b));
        return sum.is0() ? void 0 : sum;
      }
      // Converts Projective point to affine (x, y) coordinates.
      // Can accept precomputed Z^-1 - for example, from invertBatch.
      // (x, y, z)  (x=x/z, y=y/z)
      toAffine(iz) {
        return toAffineMemo(this, iz);
      }
      isTorsionFree() {
        const { h: cofactor, isTorsionFree } = CURVE;
        if (cofactor === _1n7)
          return true;
        if (isTorsionFree)
          return isTorsionFree(Point, this);
        throw new Error("isTorsionFree() has not been declared for the elliptic curve");
      }
      clearCofactor() {
        const { h: cofactor, clearCofactor } = CURVE;
        if (cofactor === _1n7)
          return this;
        if (clearCofactor)
          return clearCofactor(Point, this);
        return this.multiplyUnsafe(CURVE.h);
      }
      toRawBytes(isCompressed = true) {
        abool("isCompressed", isCompressed);
        this.assertValidity();
        return toBytes4(Point, this, isCompressed);
      }
      toHex(isCompressed = true) {
        abool("isCompressed", isCompressed);
        return bytesToHex(this.toRawBytes(isCompressed));
      }
    }
    Point.BASE = new Point(CURVE.Gx, CURVE.Gy, Fp2.ONE);
    Point.ZERO = new Point(Fp2.ZERO, Fp2.ONE, Fp2.ZERO);
    const { endo, nBitLength } = CURVE;
    const wnaf = wNAF(Point, endo ? Math.ceil(nBitLength / 2) : nBitLength);
    return {
      CURVE,
      ProjectivePoint: Point,
      normPrivateKeyToScalar,
      weierstrassEquation,
      isWithinCurveOrder
    };
  }
  function validateOpts3(curve) {
    const opts = validateBasic(curve);
    validateObject(opts, {
      hash: "hash",
      hmac: "function",
      randomBytes: "function"
    }, {
      bits2int: "function",
      bits2int_modN: "function",
      lowS: "boolean"
    });
    return Object.freeze({ lowS: true, ...opts });
  }
  function weierstrass(curveDef) {
    const CURVE = validateOpts3(curveDef);
    const { Fp: Fp2, n: CURVE_ORDER, nByteLength, nBitLength } = CURVE;
    const compressedLen = Fp2.BYTES + 1;
    const uncompressedLen = 2 * Fp2.BYTES + 1;
    function modN(a) {
      return mod(a, CURVE_ORDER);
    }
    function invN(a) {
      return invert(a, CURVE_ORDER);
    }
    const { ProjectivePoint: Point, normPrivateKeyToScalar, weierstrassEquation, isWithinCurveOrder } = weierstrassPoints({
      ...CURVE,
      toBytes(_c, point, isCompressed) {
        const a = point.toAffine();
        const x = Fp2.toBytes(a.x);
        const cat = concatBytes2;
        abool("isCompressed", isCompressed);
        if (isCompressed) {
          return cat(Uint8Array.from([point.hasEvenY() ? 2 : 3]), x);
        } else {
          return cat(Uint8Array.from([4]), x, Fp2.toBytes(a.y));
        }
      },
      fromBytes(bytes) {
        const len = bytes.length;
        const head = bytes[0];
        const tail = bytes.subarray(1);
        if (len === compressedLen && (head === 2 || head === 3)) {
          const x = bytesToNumberBE(tail);
          if (!inRange(x, _1n7, Fp2.ORDER))
            throw new Error("Point is not on curve");
          const y2 = weierstrassEquation(x);
          let y3;
          try {
            y3 = Fp2.sqrt(y2);
          } catch (sqrtError) {
            const suffix = sqrtError instanceof Error ? ": " + sqrtError.message : "";
            throw new Error("Point is not on curve" + suffix);
          }
          const isYOdd = (y3 & _1n7) === _1n7;
          const isHeadOdd = (head & 1) === 1;
          if (isHeadOdd !== isYOdd)
            y3 = Fp2.neg(y3);
          return { x, y: y3 };
        } else if (len === uncompressedLen && head === 4) {
          const x = Fp2.fromBytes(tail.subarray(0, Fp2.BYTES));
          const y2 = Fp2.fromBytes(tail.subarray(Fp2.BYTES, 2 * Fp2.BYTES));
          return { x, y: y2 };
        } else {
          const cl = compressedLen;
          const ul = uncompressedLen;
          throw new Error("invalid Point, expected length of " + cl + ", or uncompressed " + ul + ", got " + len);
        }
      }
    });
    function isBiggerThanHalfOrder(number2) {
      const HALF = CURVE_ORDER >> _1n7;
      return number2 > HALF;
    }
    function normalizeS(s2) {
      return isBiggerThanHalfOrder(s2) ? modN(-s2) : s2;
    }
    const slcNum = (b, from3, to) => bytesToNumberBE(b.slice(from3, to));
    class Signature {
      constructor(r, s2, recovery) {
        aInRange("r", r, _1n7, CURVE_ORDER);
        aInRange("s", s2, _1n7, CURVE_ORDER);
        this.r = r;
        this.s = s2;
        if (recovery != null)
          this.recovery = recovery;
        Object.freeze(this);
      }
      // pair (bytes of r, bytes of s)
      static fromCompact(hex) {
        const l = nByteLength;
        hex = ensureBytes("compactSignature", hex, l * 2);
        return new Signature(slcNum(hex, 0, l), slcNum(hex, l, 2 * l));
      }
      // DER encoded ECDSA signature
      // https://bitcoin.stackexchange.com/questions/57644/what-are-the-parts-of-a-bitcoin-transaction-input-script
      static fromDER(hex) {
        const { r, s: s2 } = DER.toSig(ensureBytes("DER", hex));
        return new Signature(r, s2);
      }
      /**
       * @todo remove
       * @deprecated
       */
      assertValidity() {
      }
      addRecoveryBit(recovery) {
        return new Signature(this.r, this.s, recovery);
      }
      recoverPublicKey(msgHash) {
        const { r, s: s2, recovery: rec } = this;
        const h2 = bits2int_modN(ensureBytes("msgHash", msgHash));
        if (rec == null || ![0, 1, 2, 3].includes(rec))
          throw new Error("recovery id invalid");
        const radj = rec === 2 || rec === 3 ? r + CURVE.n : r;
        if (radj >= Fp2.ORDER)
          throw new Error("recovery id 2 or 3 invalid");
        const prefix = (rec & 1) === 0 ? "02" : "03";
        const R = Point.fromHex(prefix + numToSizedHex(radj, Fp2.BYTES));
        const ir = invN(radj);
        const u1 = modN(-h2 * ir);
        const u2 = modN(s2 * ir);
        const Q = Point.BASE.multiplyAndAddUnsafe(R, u1, u2);
        if (!Q)
          throw new Error("point at infinify");
        Q.assertValidity();
        return Q;
      }
      // Signatures should be low-s, to prevent malleability.
      hasHighS() {
        return isBiggerThanHalfOrder(this.s);
      }
      normalizeS() {
        return this.hasHighS() ? new Signature(this.r, modN(-this.s), this.recovery) : this;
      }
      // DER-encoded
      toDERRawBytes() {
        return hexToBytes(this.toDERHex());
      }
      toDERHex() {
        return DER.hexFromSig(this);
      }
      // padded bytes of r, then padded bytes of s
      toCompactRawBytes() {
        return hexToBytes(this.toCompactHex());
      }
      toCompactHex() {
        const l = nByteLength;
        return numToSizedHex(this.r, l) + numToSizedHex(this.s, l);
      }
    }
    const utils = {
      isValidPrivateKey(privateKey) {
        try {
          normPrivateKeyToScalar(privateKey);
          return true;
        } catch (error) {
          return false;
        }
      },
      normPrivateKeyToScalar,
      /**
       * Produces cryptographically secure private key from random of size
       * (groupLen + ceil(groupLen / 2)) with modulo bias being negligible.
       */
      randomPrivateKey: () => {
        const length4 = getMinHashLength(CURVE.n);
        return mapHashToField(CURVE.randomBytes(length4), CURVE.n);
      },
      /**
       * Creates precompute table for an arbitrary EC point. Makes point "cached".
       * Allows to massively speed-up `point.multiply(scalar)`.
       * @returns cached point
       * @example
       * const fast = utils.precompute(8, ProjectivePoint.fromHex(someonesPubKey));
       * fast.multiply(privKey); // much faster ECDH now
       */
      precompute(windowSize = 8, point = Point.BASE) {
        point._setWindowSize(windowSize);
        point.multiply(BigInt(3));
        return point;
      }
    };
    function getPublicKey(privateKey, isCompressed = true) {
      return Point.fromPrivateKey(privateKey).toRawBytes(isCompressed);
    }
    function isProbPub(item) {
      if (typeof item === "bigint")
        return false;
      if (item instanceof Point)
        return true;
      const arr = ensureBytes("key", item);
      const len = arr.length;
      const fpl = Fp2.BYTES;
      const compLen = fpl + 1;
      const uncompLen = 2 * fpl + 1;
      if (CURVE.allowedPrivateKeyLengths || nByteLength === compLen) {
        return void 0;
      } else {
        return len === compLen || len === uncompLen;
      }
    }
    function getSharedSecret(privateA, publicB, isCompressed = true) {
      if (isProbPub(privateA) === true)
        throw new Error("first arg must be private key");
      if (isProbPub(publicB) === false)
        throw new Error("second arg must be public key");
      const b = Point.fromHex(publicB);
      return b.multiply(normPrivateKeyToScalar(privateA)).toRawBytes(isCompressed);
    }
    const bits2int = CURVE.bits2int || function(bytes) {
      if (bytes.length > 8192)
        throw new Error("input is too large");
      const num = bytesToNumberBE(bytes);
      const delta = bytes.length * 8 - nBitLength;
      return delta > 0 ? num >> BigInt(delta) : num;
    };
    const bits2int_modN = CURVE.bits2int_modN || function(bytes) {
      return modN(bits2int(bytes));
    };
    const ORDER_MASK = bitMask(nBitLength);
    function int2octets(num) {
      aInRange("num < 2^" + nBitLength, num, _0n7, ORDER_MASK);
      return numberToBytesBE(num, nByteLength);
    }
    function prepSig(msgHash, privateKey, opts = defaultSigOpts) {
      if (["recovered", "canonical"].some((k) => k in opts))
        throw new Error("sign() legacy options not supported");
      const { hash, randomBytes: randomBytes3 } = CURVE;
      let { lowS, prehash, extraEntropy: ent } = opts;
      if (lowS == null)
        lowS = true;
      msgHash = ensureBytes("msgHash", msgHash);
      validateSigVerOpts(opts);
      if (prehash)
        msgHash = ensureBytes("prehashed msgHash", hash(msgHash));
      const h1int = bits2int_modN(msgHash);
      const d2 = normPrivateKeyToScalar(privateKey);
      const seedArgs = [int2octets(d2), int2octets(h1int)];
      if (ent != null && ent !== false) {
        const e = ent === true ? randomBytes3(Fp2.BYTES) : ent;
        seedArgs.push(ensureBytes("extraEntropy", e));
      }
      const seed = concatBytes2(...seedArgs);
      const m2 = h1int;
      function k2sig(kBytes) {
        const k = bits2int(kBytes);
        if (!isWithinCurveOrder(k))
          return;
        const ik = invN(k);
        const q = Point.BASE.multiply(k).toAffine();
        const r = modN(q.x);
        if (r === _0n7)
          return;
        const s2 = modN(ik * modN(m2 + r * d2));
        if (s2 === _0n7)
          return;
        let recovery = (q.x === r ? 0 : 2) | Number(q.y & _1n7);
        let normS = s2;
        if (lowS && isBiggerThanHalfOrder(s2)) {
          normS = normalizeS(s2);
          recovery ^= 1;
        }
        return new Signature(r, normS, recovery);
      }
      return { seed, k2sig };
    }
    const defaultSigOpts = { lowS: CURVE.lowS, prehash: false };
    const defaultVerOpts = { lowS: CURVE.lowS, prehash: false };
    function sign(msgHash, privKey, opts = defaultSigOpts) {
      const { seed, k2sig } = prepSig(msgHash, privKey, opts);
      const C = CURVE;
      const drbg = createHmacDrbg(C.hash.outputLen, C.nByteLength, C.hmac);
      return drbg(seed, k2sig);
    }
    Point.BASE._setWindowSize(8);
    function verify(signature, msgHash, publicKey, opts = defaultVerOpts) {
      var _a2;
      const sg = signature;
      msgHash = ensureBytes("msgHash", msgHash);
      publicKey = ensureBytes("publicKey", publicKey);
      const { lowS, prehash, format: format2 } = opts;
      validateSigVerOpts(opts);
      if ("strict" in opts)
        throw new Error("options.strict was renamed to lowS");
      if (format2 !== void 0 && format2 !== "compact" && format2 !== "der")
        throw new Error("format must be compact or der");
      const isHex = typeof sg === "string" || isBytes2(sg);
      const isObj = !isHex && !format2 && typeof sg === "object" && sg !== null && typeof sg.r === "bigint" && typeof sg.s === "bigint";
      if (!isHex && !isObj)
        throw new Error("invalid signature, expected Uint8Array, hex string or Signature instance");
      let _sig = void 0;
      let P;
      try {
        if (isObj)
          _sig = new Signature(sg.r, sg.s);
        if (isHex) {
          try {
            if (format2 !== "compact")
              _sig = Signature.fromDER(sg);
          } catch (derError) {
            if (!(derError instanceof DER.Err))
              throw derError;
          }
          if (!_sig && format2 !== "der")
            _sig = Signature.fromCompact(sg);
        }
        P = Point.fromHex(publicKey);
      } catch (error) {
        return false;
      }
      if (!_sig)
        return false;
      if (lowS && _sig.hasHighS())
        return false;
      if (prehash)
        msgHash = CURVE.hash(msgHash);
      const { r, s: s2 } = _sig;
      const h2 = bits2int_modN(msgHash);
      const is = invN(s2);
      const u1 = modN(h2 * is);
      const u2 = modN(r * is);
      const R = (_a2 = Point.BASE.multiplyAndAddUnsafe(P, u1, u2)) == null ? void 0 : _a2.toAffine();
      if (!R)
        return false;
      const v = modN(R.x);
      return v === r;
    }
    return {
      CURVE,
      getPublicKey,
      getSharedSecret,
      sign,
      verify,
      ProjectivePoint: Point,
      Signature,
      utils
    };
  }

  // node_modules/@noble/curves/esm/_shortw_utils.js
  function getHash(hash) {
    return {
      hash,
      hmac: (key, ...msgs) => hmac(hash, key, concatBytes(...msgs)),
      randomBytes
    };
  }
  function createCurve(curveDef, defHash) {
    const create2 = (hash) => weierstrass({ ...curveDef, ...getHash(hash) });
    return { ...create2(defHash), create: create2 };
  }

  // node_modules/@noble/curves/esm/secp256k1.js
  var secp256k1P = BigInt("0xfffffffffffffffffffffffffffffffffffffffffffffffffffffffefffffc2f");
  var secp256k1N = BigInt("0xfffffffffffffffffffffffffffffffebaaedce6af48a03bbfd25e8cd0364141");
  var _0n8 = BigInt(0);
  var _1n8 = BigInt(1);
  var _2n6 = BigInt(2);
  var divNearest = (a, b) => (a + b / _2n6) / b;
  function sqrtMod(y2) {
    const P = secp256k1P;
    const _3n4 = BigInt(3), _6n = BigInt(6), _11n = BigInt(11), _22n = BigInt(22);
    const _23n = BigInt(23), _44n = BigInt(44), _88n = BigInt(88);
    const b2 = y2 * y2 * y2 % P;
    const b3 = b2 * b2 * y2 % P;
    const b6 = pow2(b3, _3n4, P) * b3 % P;
    const b9 = pow2(b6, _3n4, P) * b3 % P;
    const b11 = pow2(b9, _2n6, P) * b2 % P;
    const b22 = pow2(b11, _11n, P) * b11 % P;
    const b44 = pow2(b22, _22n, P) * b22 % P;
    const b88 = pow2(b44, _44n, P) * b44 % P;
    const b176 = pow2(b88, _88n, P) * b88 % P;
    const b220 = pow2(b176, _44n, P) * b44 % P;
    const b223 = pow2(b220, _3n4, P) * b3 % P;
    const t1 = pow2(b223, _23n, P) * b22 % P;
    const t2 = pow2(t1, _6n, P) * b2 % P;
    const root = pow2(t2, _2n6, P);
    if (!Fpk1.eql(Fpk1.sqr(root), y2))
      throw new Error("Cannot find square root");
    return root;
  }
  var Fpk1 = Field(secp256k1P, void 0, void 0, { sqrt: sqrtMod });
  var secp256k1 = createCurve({
    a: _0n8,
    b: BigInt(7),
    Fp: Fpk1,
    n: secp256k1N,
    Gx: BigInt("55066263022277343669578718895168534326250603453777594175500187360389116729240"),
    Gy: BigInt("32670510020758816978083085130507043184471273380659243275938904335757337482424"),
    h: BigInt(1),
    lowS: true,
    // Allow only low-S signatures by default in sign() and verify()
    endo: {
      // Endomorphism, see above
      beta: BigInt("0x7ae96a2b657c07106e64479eac3434e99cf0497512f58995c1396c28719501ee"),
      splitScalar: (k) => {
        const n = secp256k1N;
        const a1 = BigInt("0x3086d221a7d46bcde86c90e49284eb15");
        const b1 = -_1n8 * BigInt("0xe4437ed6010e88286f547fa90abfe4c3");
        const a2 = BigInt("0x114ca50f7a8e2f3f657c1108d9d44cfd8");
        const b2 = a1;
        const POW_2_128 = BigInt("0x100000000000000000000000000000000");
        const c1 = divNearest(b2 * k, n);
        const c2 = divNearest(-b1 * k, n);
        let k1 = mod(k - c1 * a1 - c2 * a2, n);
        let k2 = mod(-c1 * b1 - c2 * b2, n);
        const k1neg = k1 > POW_2_128;
        const k2neg = k2 > POW_2_128;
        if (k1neg)
          k1 = n - k1;
        if (k2neg)
          k2 = n - k2;
        if (k1 > POW_2_128 || k2 > POW_2_128) {
          throw new Error("splitScalar: Endomorphism failed, k=" + k);
        }
        return { k1neg, k1, k2neg, k2 };
      }
    }
  }, sha2562);

  // node_modules/@libp2p/crypto/dist/src/keys/secp256k1/index.browser.js
  function hashAndSign4(key, msg, options) {
    const p = sha256.digest(msg instanceof Uint8Array ? msg : msg.subarray());
    if (isPromise(p)) {
      return p.then(({ digest: digest2 }) => {
        var _a2;
        (_a2 = options == null ? void 0 : options.signal) == null ? void 0 : _a2.throwIfAborted();
        return secp256k1.sign(digest2, key).toDERRawBytes();
      }).catch((err) => {
        if (err.name === "AbortError") {
          throw err;
        }
        throw new SigningError(String(err));
      });
    }
    try {
      return secp256k1.sign(p.digest, key).toDERRawBytes();
    } catch (err) {
      throw new SigningError(String(err));
    }
  }
  function hashAndVerify4(key, sig, msg, options) {
    var _a2;
    const p = sha256.digest(msg instanceof Uint8Array ? msg : msg.subarray());
    if (isPromise(p)) {
      return p.then(({ digest: digest2 }) => {
        var _a3;
        (_a3 = options == null ? void 0 : options.signal) == null ? void 0 : _a3.throwIfAborted();
        return secp256k1.verify(sig, digest2, key);
      }).catch((err) => {
        if (err.name === "AbortError") {
          throw err;
        }
        throw new VerificationError(String(err));
      });
    }
    try {
      (_a2 = options == null ? void 0 : options.signal) == null ? void 0 : _a2.throwIfAborted();
      return secp256k1.verify(sig, p.digest, key);
    } catch (err) {
      throw new VerificationError(String(err));
    }
  }

  // node_modules/@libp2p/crypto/dist/src/keys/secp256k1/utils.js
  var import_browser_shims99 = __toESM(require_browser_shims(), 1);

  // node_modules/@libp2p/crypto/dist/src/keys/secp256k1/secp256k1.js
  var import_browser_shims98 = __toESM(require_browser_shims(), 1);
  var Secp256k1PublicKey = class {
    type = "secp256k1";
    raw;
    _key;
    constructor(key) {
      this._key = validateSecp256k1PublicKey(key);
      this.raw = compressSecp256k1PublicKey(this._key);
    }
    toMultihash() {
      return identity.digest(publicKeyToProtobuf(this));
    }
    toCID() {
      return CID.createV1(114, this.toMultihash());
    }
    toString() {
      return base58btc.encode(this.toMultihash().bytes).substring(1);
    }
    equals(key) {
      if (key == null || !(key.raw instanceof Uint8Array)) {
        return false;
      }
      return equals3(this.raw, key.raw);
    }
    verify(data, sig, options) {
      return hashAndVerify4(this._key, sig, data, options);
    }
  };
  var Secp256k1PrivateKey = class {
    type = "secp256k1";
    raw;
    publicKey;
    constructor(key, publicKey) {
      this.raw = validateSecp256k1PrivateKey(key);
      this.publicKey = new Secp256k1PublicKey(publicKey ?? computeSecp256k1PublicKey(key));
    }
    equals(key) {
      if (key == null || !(key.raw instanceof Uint8Array)) {
        return false;
      }
      return equals3(this.raw, key.raw);
    }
    sign(message2, options) {
      return hashAndSign4(this.raw, message2, options);
    }
  };

  // node_modules/@libp2p/crypto/dist/src/keys/secp256k1/utils.js
  function unmarshalSecp256k1PublicKey(bytes) {
    return new Secp256k1PublicKey(bytes);
  }
  async function generateSecp256k1KeyPair() {
    const privateKeyBytes = generateSecp256k1PrivateKey();
    return new Secp256k1PrivateKey(privateKeyBytes);
  }
  function compressSecp256k1PublicKey(key) {
    const point = secp256k1.ProjectivePoint.fromHex(key).toRawBytes(true);
    return point;
  }
  function validateSecp256k1PrivateKey(key) {
    try {
      secp256k1.getPublicKey(key, true);
      return key;
    } catch (err) {
      throw new InvalidPrivateKeyError(String(err));
    }
  }
  function validateSecp256k1PublicKey(key) {
    try {
      secp256k1.ProjectivePoint.fromHex(key);
      return key;
    } catch (err) {
      throw new InvalidPublicKeyError(String(err));
    }
  }
  function computeSecp256k1PublicKey(privateKey) {
    try {
      return secp256k1.getPublicKey(privateKey, true);
    } catch (err) {
      throw new InvalidPrivateKeyError(String(err));
    }
  }
  function generateSecp256k1PrivateKey() {
    return secp256k1.utils.randomPrivateKey();
  }

  // node_modules/@libp2p/crypto/dist/src/keys/index.js
  async function generateKeyPair(type, bits) {
    if (type === "Ed25519") {
      return generateEd25519KeyPair();
    }
    if (type === "secp256k1") {
      return generateSecp256k1KeyPair();
    }
    if (type === "RSA") {
      return generateRSAKeyPair(toBits(bits));
    }
    if (type === "ECDSA") {
      return generateECDSAKeyPair(toCurve(bits));
    }
    throw new UnsupportedKeyTypeError();
  }
  function publicKeyFromProtobuf(buf, digest2) {
    const { Type, Data } = PublicKey.decode(buf);
    const data = Data ?? new Uint8Array();
    switch (Type) {
      case KeyType.RSA:
        return pkixToRSAPublicKey(data, digest2);
      case KeyType.Ed25519:
        return unmarshalEd25519PublicKey(data);
      case KeyType.secp256k1:
        return unmarshalSecp256k1PublicKey(data);
      case KeyType.ECDSA:
        return unmarshalECDSAPublicKey(data);
      default:
        throw new UnsupportedKeyTypeError();
    }
  }
  function publicKeyFromMultihash(digest2) {
    const { Type, Data } = PublicKey.decode(digest2.digest);
    const data = Data ?? new Uint8Array();
    switch (Type) {
      case KeyType.Ed25519:
        return unmarshalEd25519PublicKey(data);
      case KeyType.secp256k1:
        return unmarshalSecp256k1PublicKey(data);
      case KeyType.ECDSA:
        return unmarshalECDSAPublicKey(data);
      default:
        throw new UnsupportedKeyTypeError();
    }
  }
  function publicKeyToProtobuf(key) {
    return PublicKey.encode({
      Type: KeyType[key.type],
      Data: key.raw
    });
  }
  function toBits(bits) {
    if (bits == null) {
      return 2048;
    }
    return parseInt(bits, 10);
  }
  function toCurve(curve) {
    if (curve === "P-256" || curve == null) {
      return "P-256";
    }
    if (curve === "P-384") {
      return "P-384";
    }
    if (curve === "P-521") {
      return "P-521";
    }
    throw new InvalidParametersError("Unsupported curve, should be P-256, P-384 or P-521");
  }

  // node_modules/@libp2p/peer-id/dist/src/index.js
  var import_browser_shims102 = __toESM(require_browser_shims(), 1);

  // node_modules/@libp2p/peer-id/dist/src/peer-id.js
  var import_browser_shims101 = __toESM(require_browser_shims(), 1);
  var inspect = Symbol.for("nodejs.util.inspect.custom");
  var LIBP2P_KEY_CODE = 114;
  var PeerIdImpl = class {
    type;
    multihash;
    publicKey;
    string;
    constructor(init) {
      this.type = init.type;
      this.multihash = init.multihash;
      Object.defineProperty(this, "string", {
        enumerable: false,
        writable: true
      });
    }
    get [Symbol.toStringTag]() {
      return `PeerId(${this.toString()})`;
    }
    [peerIdSymbol] = true;
    toString() {
      if (this.string == null) {
        this.string = base58btc.encode(this.multihash.bytes).slice(1);
      }
      return this.string;
    }
    toMultihash() {
      return this.multihash;
    }
    // return self-describing String representation
    // in default format from RFC 0001: https://github.com/libp2p/specs/pull/209
    toCID() {
      return CID.createV1(LIBP2P_KEY_CODE, this.multihash);
    }
    toJSON() {
      return this.toString();
    }
    /**
     * Checks the equality of `this` peer against a given PeerId
     */
    equals(id) {
      var _a2;
      if (id == null) {
        return false;
      }
      if (id instanceof Uint8Array) {
        return equals3(this.multihash.bytes, id);
      } else if (typeof id === "string") {
        return this.toString() === id;
      } else if (((_a2 = id == null ? void 0 : id.toMultihash()) == null ? void 0 : _a2.bytes) != null) {
        return equals3(this.multihash.bytes, id.toMultihash().bytes);
      } else {
        throw new Error("not valid Id");
      }
    }
    /**
     * Returns PeerId as a human-readable string
     * https://nodejs.org/api/util.html#utilinspectcustom
     *
     * @example
     * ```TypeScript
     * import { peerIdFromString } from '@libp2p/peer-id'
     *
     * console.info(peerIdFromString('QmFoo'))
     * // 'PeerId(QmFoo)'
     * ```
     */
    [inspect]() {
      return `PeerId(${this.toString()})`;
    }
  };
  var RSAPeerId = class extends PeerIdImpl {
    type = "RSA";
    publicKey;
    constructor(init) {
      super({ ...init, type: "RSA" });
      this.publicKey = init.publicKey;
    }
  };
  var Ed25519PeerId = class extends PeerIdImpl {
    type = "Ed25519";
    publicKey;
    constructor(init) {
      super({ ...init, type: "Ed25519" });
      this.publicKey = init.publicKey;
    }
  };
  var Secp256k1PeerId = class extends PeerIdImpl {
    type = "secp256k1";
    publicKey;
    constructor(init) {
      super({ ...init, type: "secp256k1" });
      this.publicKey = init.publicKey;
    }
  };
  var TRANSPORT_IPFS_GATEWAY_HTTP_CODE = 2336;
  var URLPeerId = class {
    type = "url";
    multihash;
    publicKey;
    url;
    constructor(url) {
      this.url = url.toString();
      this.multihash = identity.digest(fromString2(this.url));
    }
    [inspect]() {
      return `PeerId(${this.url})`;
    }
    [peerIdSymbol] = true;
    toString() {
      return this.toCID().toString();
    }
    toMultihash() {
      return this.multihash;
    }
    toCID() {
      return CID.createV1(TRANSPORT_IPFS_GATEWAY_HTTP_CODE, this.toMultihash());
    }
    toJSON() {
      return this.toString();
    }
    equals(other) {
      if (other == null) {
        return false;
      }
      if (other instanceof Uint8Array) {
        other = toString2(other);
      }
      return other.toString() === this.toString();
    }
  };

  // node_modules/@libp2p/peer-id/dist/src/index.js
  var LIBP2P_KEY_CODE2 = 114;
  var TRANSPORT_IPFS_GATEWAY_HTTP_CODE2 = 2336;
  function peerIdFromString(str, decoder) {
    let multihash;
    if (str.charAt(0) === "1" || str.charAt(0) === "Q") {
      multihash = decode4(base58btc.decode(`z${str}`));
    } else if (str.startsWith("k51qzi5uqu5") || str.startsWith("kzwfwjn5ji4") || str.startsWith("k2k4r8") || str.startsWith("bafz")) {
      return peerIdFromCID(CID.parse(str));
    } else {
      if (decoder == null) {
        throw new InvalidParametersError('Please pass a multibase decoder for strings that do not start with "1" or "Q"');
      }
      multihash = decode4(decoder.decode(str));
    }
    return peerIdFromMultihash(multihash);
  }
  function peerIdFromPublicKey(publicKey) {
    if (publicKey.type === "Ed25519") {
      return new Ed25519PeerId({
        multihash: publicKey.toCID().multihash,
        publicKey
      });
    } else if (publicKey.type === "secp256k1") {
      return new Secp256k1PeerId({
        multihash: publicKey.toCID().multihash,
        publicKey
      });
    } else if (publicKey.type === "RSA") {
      return new RSAPeerId({
        multihash: publicKey.toCID().multihash,
        publicKey
      });
    }
    throw new UnsupportedKeyTypeError();
  }
  function peerIdFromPrivateKey(privateKey) {
    return peerIdFromPublicKey(privateKey.publicKey);
  }
  function peerIdFromMultihash(multihash) {
    if (isSha256Multihash(multihash)) {
      return new RSAPeerId({ multihash });
    } else if (isIdentityMultihash(multihash)) {
      try {
        const publicKey = publicKeyFromMultihash(multihash);
        if (publicKey.type === "Ed25519") {
          return new Ed25519PeerId({ multihash, publicKey });
        } else if (publicKey.type === "secp256k1") {
          return new Secp256k1PeerId({ multihash, publicKey });
        }
      } catch (err) {
        const url = toString2(multihash.digest);
        return new URLPeerId(new URL(url));
      }
    }
    throw new InvalidMultihashError("Supplied PeerID Multihash is invalid");
  }
  function peerIdFromCID(cid) {
    if ((cid == null ? void 0 : cid.multihash) == null || cid.version == null || cid.version === 1 && cid.code !== LIBP2P_KEY_CODE2 && cid.code !== TRANSPORT_IPFS_GATEWAY_HTTP_CODE2) {
      throw new InvalidCIDError("Supplied PeerID CID is invalid");
    }
    if (cid.code === TRANSPORT_IPFS_GATEWAY_HTTP_CODE2) {
      const url = toString2(cid.multihash.digest);
      return new URLPeerId(new URL(url));
    }
    return peerIdFromMultihash(cid.multihash);
  }
  function isIdentityMultihash(multihash) {
    return multihash.code === identity.code;
  }
  function isSha256Multihash(multihash) {
    return multihash.code === sha256.code;
  }

  // node_modules/libp2p/dist/src/config.js
  var import_browser_shims135 = __toESM(require_browser_shims(), 1);

  // node_modules/@libp2p/utils/dist/src/merge-options.js
  var import_browser_shims104 = __toESM(require_browser_shims(), 1);

  // node_modules/is-plain-obj/index.js
  var import_browser_shims103 = __toESM(require_browser_shims(), 1);
  function isPlainObject(value) {
    if (typeof value !== "object" || value === null) {
      return false;
    }
    const prototype = Object.getPrototypeOf(value);
    return (prototype === null || prototype === Object.prototype || Object.getPrototypeOf(prototype) === null) && !(Symbol.toStringTag in value) && !(Symbol.iterator in value);
  }

  // node_modules/@libp2p/utils/dist/src/merge-options.js
  var { hasOwnProperty } = Object.prototype;
  var { propertyIsEnumerable } = Object;
  var defineProperty = (object, name3, value) => {
    Object.defineProperty(object, name3, {
      value,
      writable: true,
      enumerable: true,
      configurable: true
    });
  };
  var globalThis2 = void 0;
  var defaultMergeOptions = {
    concatArrays: false,
    ignoreUndefined: false
  };
  var getEnumerableOwnPropertyKeys = (value) => {
    const keys = [];
    for (const key in value) {
      if (hasOwnProperty.call(value, key)) {
        keys.push(key);
      }
    }
    if (Object.getOwnPropertySymbols) {
      const symbols = Object.getOwnPropertySymbols(value);
      for (const symbol3 of symbols) {
        if (propertyIsEnumerable.call(value, symbol3)) {
          keys.push(symbol3);
        }
      }
    }
    return keys;
  };
  function clone(value) {
    if (Array.isArray(value)) {
      return cloneArray(value);
    }
    if (isPlainObject(value)) {
      return cloneOptionObject(value);
    }
    return value;
  }
  function cloneArray(array) {
    const result = array.slice(0, 0);
    getEnumerableOwnPropertyKeys(array).forEach((key) => {
      defineProperty(result, key, clone(array[key]));
    });
    return result;
  }
  function cloneOptionObject(object) {
    const result = Object.getPrototypeOf(object) === null ? /* @__PURE__ */ Object.create(null) : {};
    getEnumerableOwnPropertyKeys(object).forEach((key) => {
      defineProperty(result, key, clone(object[key]));
    });
    return result;
  }
  var mergeKeys = (merged, source, keys, config) => {
    keys.forEach((key) => {
      if (typeof source[key] === "undefined" && config.ignoreUndefined) {
        return;
      }
      if (key in merged && merged[key] !== Object.getPrototypeOf(merged)) {
        defineProperty(merged, key, merge(merged[key], source[key], config));
      } else {
        defineProperty(merged, key, clone(source[key]));
      }
    });
    return merged;
  };
  var concatArrays = (merged, source, config) => {
    let result = merged.slice(0, 0);
    let resultIndex = 0;
    [merged, source].forEach((array) => {
      const indices = [];
      for (let k = 0; k < array.length; k++) {
        if (!hasOwnProperty.call(array, k)) {
          continue;
        }
        indices.push(String(k));
        if (array === merged) {
          defineProperty(result, resultIndex++, array[k]);
        } else {
          defineProperty(result, resultIndex++, clone(array[k]));
        }
      }
      result = mergeKeys(result, array, getEnumerableOwnPropertyKeys(array).filter((key) => !indices.includes(key)), config);
    });
    return result;
  };
  function merge(merged, source, config) {
    if (config.concatArrays && Array.isArray(merged) && Array.isArray(source)) {
      return concatArrays(merged, source, config);
    }
    if (!isPlainObject(source) || !isPlainObject(merged)) {
      return clone(source);
    }
    return mergeKeys(merged, source, getEnumerableOwnPropertyKeys(source), config);
  }
  function mergeOptions(...options) {
    const config = merge(clone(defaultMergeOptions), this !== globalThis2 && this || {}, defaultMergeOptions);
    let merged = { _: {} };
    for (const option of options) {
      if (option === void 0) {
        continue;
      }
      if (!isPlainObject(option)) {
        throw new TypeError("`" + option + "` is not an Option Object");
      }
      merged = merge(merged, { _: option }, config);
    }
    return merged._;
  }

  // node_modules/@multiformats/multiaddr/dist/src/resolvers/index.js
  var import_browser_shims134 = __toESM(require_browser_shims(), 1);

  // node_modules/@multiformats/multiaddr/dist/src/resolvers/dnsaddr.js
  var import_browser_shims133 = __toESM(require_browser_shims(), 1);

  // node_modules/@multiformats/dns/dist/src/index.js
  var import_browser_shims117 = __toESM(require_browser_shims(), 1);

  // node_modules/@multiformats/dns/dist/src/dns.js
  var import_browser_shims116 = __toESM(require_browser_shims(), 1);

  // node_modules/progress-events/dist/src/index.js
  var import_browser_shims105 = __toESM(require_browser_shims(), 1);
  var CustomProgressEvent = class extends Event {
    type;
    detail;
    constructor(type, detail) {
      super(type);
      this.type = type;
      this.detail = detail;
    }
  };

  // node_modules/@multiformats/dns/dist/src/resolvers/default.browser.js
  var import_browser_shims114 = __toESM(require_browser_shims(), 1);

  // node_modules/@multiformats/dns/dist/src/resolvers/dns-json-over-https.js
  var import_browser_shims113 = __toESM(require_browser_shims(), 1);

  // node_modules/p-queue/dist/index.js
  var import_browser_shims110 = __toESM(require_browser_shims(), 1);

  // node_modules/eventemitter3/index.mjs
  var import_browser_shims106 = __toESM(require_browser_shims(), 1);
  var import_index7 = __toESM(require_eventemitter3(), 1);

  // node_modules/p-timeout/index.js
  var import_browser_shims107 = __toESM(require_browser_shims(), 1);
  var TimeoutError2 = class extends Error {
    constructor(message2) {
      super(message2);
      this.name = "TimeoutError";
    }
  };
  var AbortError2 = class extends Error {
    constructor(message2) {
      super();
      this.name = "AbortError";
      this.message = message2;
    }
  };
  var getDOMException = (errorMessage) => globalThis.DOMException === void 0 ? new AbortError2(errorMessage) : new DOMException(errorMessage);
  var getAbortedReason = (signal) => {
    const reason = signal.reason === void 0 ? getDOMException("This operation was aborted.") : signal.reason;
    return reason instanceof Error ? reason : getDOMException(reason);
  };
  function pTimeout(promise, options) {
    const {
      milliseconds,
      fallback,
      message: message2,
      customTimers = { setTimeout, clearTimeout }
    } = options;
    let timer;
    let abortHandler;
    const wrappedPromise = new Promise((resolve, reject) => {
      if (typeof milliseconds !== "number" || Math.sign(milliseconds) !== 1) {
        throw new TypeError(`Expected \`milliseconds\` to be a positive number, got \`${milliseconds}\``);
      }
      if (options.signal) {
        const { signal } = options;
        if (signal.aborted) {
          reject(getAbortedReason(signal));
        }
        abortHandler = () => {
          reject(getAbortedReason(signal));
        };
        signal.addEventListener("abort", abortHandler, { once: true });
      }
      if (milliseconds === Number.POSITIVE_INFINITY) {
        promise.then(resolve, reject);
        return;
      }
      const timeoutError = new TimeoutError2();
      timer = customTimers.setTimeout.call(void 0, () => {
        if (fallback) {
          try {
            resolve(fallback());
          } catch (error) {
            reject(error);
          }
          return;
        }
        if (typeof promise.cancel === "function") {
          promise.cancel();
        }
        if (message2 === false) {
          resolve();
        } else if (message2 instanceof Error) {
          reject(message2);
        } else {
          timeoutError.message = message2 ?? `Promise timed out after ${milliseconds} milliseconds`;
          reject(timeoutError);
        }
      }, milliseconds);
      (async () => {
        try {
          resolve(await promise);
        } catch (error) {
          reject(error);
        }
      })();
    });
    const cancelablePromise = wrappedPromise.finally(() => {
      cancelablePromise.clear();
      if (abortHandler && options.signal) {
        options.signal.removeEventListener("abort", abortHandler);
      }
    });
    cancelablePromise.clear = () => {
      customTimers.clearTimeout.call(void 0, timer);
      timer = void 0;
    };
    return cancelablePromise;
  }

  // node_modules/p-queue/dist/priority-queue.js
  var import_browser_shims109 = __toESM(require_browser_shims(), 1);

  // node_modules/p-queue/dist/lower-bound.js
  var import_browser_shims108 = __toESM(require_browser_shims(), 1);
  function lowerBound(array, value, comparator) {
    let first = 0;
    let count = array.length;
    while (count > 0) {
      const step = Math.trunc(count / 2);
      let it = first + step;
      if (comparator(array[it], value) <= 0) {
        first = ++it;
        count -= step + 1;
      } else {
        count = step;
      }
    }
    return first;
  }

  // node_modules/p-queue/dist/priority-queue.js
  var PriorityQueue = class {
    #queue = [];
    enqueue(run, options) {
      options = {
        priority: 0,
        ...options
      };
      const element = {
        priority: options.priority,
        id: options.id,
        run
      };
      if (this.size === 0 || this.#queue[this.size - 1].priority >= options.priority) {
        this.#queue.push(element);
        return;
      }
      const index = lowerBound(this.#queue, element, (a, b) => b.priority - a.priority);
      this.#queue.splice(index, 0, element);
    }
    setPriority(id, priority) {
      const index = this.#queue.findIndex((element) => element.id === id);
      if (index === -1) {
        throw new ReferenceError(`No promise function with the id "${id}" exists in the queue.`);
      }
      const [item] = this.#queue.splice(index, 1);
      this.enqueue(item.run, { priority, id });
    }
    dequeue() {
      const item = this.#queue.shift();
      return item == null ? void 0 : item.run;
    }
    filter(options) {
      return this.#queue.filter((element) => element.priority === options.priority).map((element) => element.run);
    }
    get size() {
      return this.#queue.length;
    }
  };

  // node_modules/p-queue/dist/index.js
  var PQueue = class extends import_index7.default {
    #carryoverConcurrencyCount;
    #isIntervalIgnored;
    #intervalCount = 0;
    #intervalCap;
    #interval;
    #intervalEnd = 0;
    #intervalId;
    #timeoutId;
    #queue;
    #queueClass;
    #pending = 0;
    // The `!` is needed because of https://github.com/microsoft/TypeScript/issues/32194
    #concurrency;
    #isPaused;
    #throwOnTimeout;
    // Use to assign a unique identifier to a promise function, if not explicitly specified
    #idAssigner = 1n;
    /**
        Per-operation timeout in milliseconds. Operations fulfill once `timeout` elapses if they haven't already.
    
        Applies to each future operation.
        */
    timeout;
    // TODO: The `throwOnTimeout` option should affect the return types of `add()` and `addAll()`
    constructor(options) {
      var _a2, _b2;
      super();
      options = {
        carryoverConcurrencyCount: false,
        intervalCap: Number.POSITIVE_INFINITY,
        interval: 0,
        concurrency: Number.POSITIVE_INFINITY,
        autoStart: true,
        queueClass: PriorityQueue,
        ...options
      };
      if (!(typeof options.intervalCap === "number" && options.intervalCap >= 1)) {
        throw new TypeError(`Expected \`intervalCap\` to be a number from 1 and up, got \`${((_a2 = options.intervalCap) == null ? void 0 : _a2.toString()) ?? ""}\` (${typeof options.intervalCap})`);
      }
      if (options.interval === void 0 || !(Number.isFinite(options.interval) && options.interval >= 0)) {
        throw new TypeError(`Expected \`interval\` to be a finite number >= 0, got \`${((_b2 = options.interval) == null ? void 0 : _b2.toString()) ?? ""}\` (${typeof options.interval})`);
      }
      this.#carryoverConcurrencyCount = options.carryoverConcurrencyCount;
      this.#isIntervalIgnored = options.intervalCap === Number.POSITIVE_INFINITY || options.interval === 0;
      this.#intervalCap = options.intervalCap;
      this.#interval = options.interval;
      this.#queue = new options.queueClass();
      this.#queueClass = options.queueClass;
      this.concurrency = options.concurrency;
      this.timeout = options.timeout;
      this.#throwOnTimeout = options.throwOnTimeout === true;
      this.#isPaused = options.autoStart === false;
    }
    get #doesIntervalAllowAnother() {
      return this.#isIntervalIgnored || this.#intervalCount < this.#intervalCap;
    }
    get #doesConcurrentAllowAnother() {
      return this.#pending < this.#concurrency;
    }
    #next() {
      this.#pending--;
      this.#tryToStartAnother();
      this.emit("next");
    }
    #onResumeInterval() {
      this.#onInterval();
      this.#initializeIntervalIfNeeded();
      this.#timeoutId = void 0;
    }
    get #isIntervalPaused() {
      const now = Date.now();
      if (this.#intervalId === void 0) {
        const delay2 = this.#intervalEnd - now;
        if (delay2 < 0) {
          this.#intervalCount = this.#carryoverConcurrencyCount ? this.#pending : 0;
        } else {
          if (this.#timeoutId === void 0) {
            this.#timeoutId = setTimeout(() => {
              this.#onResumeInterval();
            }, delay2);
          }
          return true;
        }
      }
      return false;
    }
    #tryToStartAnother() {
      if (this.#queue.size === 0) {
        if (this.#intervalId) {
          clearInterval(this.#intervalId);
        }
        this.#intervalId = void 0;
        this.emit("empty");
        if (this.#pending === 0) {
          this.emit("idle");
        }
        return false;
      }
      if (!this.#isPaused) {
        const canInitializeInterval = !this.#isIntervalPaused;
        if (this.#doesIntervalAllowAnother && this.#doesConcurrentAllowAnother) {
          const job = this.#queue.dequeue();
          if (!job) {
            return false;
          }
          this.emit("active");
          job();
          if (canInitializeInterval) {
            this.#initializeIntervalIfNeeded();
          }
          return true;
        }
      }
      return false;
    }
    #initializeIntervalIfNeeded() {
      if (this.#isIntervalIgnored || this.#intervalId !== void 0) {
        return;
      }
      this.#intervalId = setInterval(() => {
        this.#onInterval();
      }, this.#interval);
      this.#intervalEnd = Date.now() + this.#interval;
    }
    #onInterval() {
      if (this.#intervalCount === 0 && this.#pending === 0 && this.#intervalId) {
        clearInterval(this.#intervalId);
        this.#intervalId = void 0;
      }
      this.#intervalCount = this.#carryoverConcurrencyCount ? this.#pending : 0;
      this.#processQueue();
    }
    /**
    Executes all queued functions until it reaches the limit.
    */
    #processQueue() {
      while (this.#tryToStartAnother()) {
      }
    }
    get concurrency() {
      return this.#concurrency;
    }
    set concurrency(newConcurrency) {
      if (!(typeof newConcurrency === "number" && newConcurrency >= 1)) {
        throw new TypeError(`Expected \`concurrency\` to be a number from 1 and up, got \`${newConcurrency}\` (${typeof newConcurrency})`);
      }
      this.#concurrency = newConcurrency;
      this.#processQueue();
    }
    async #throwOnAbort(signal) {
      return new Promise((_resolve, reject) => {
        signal.addEventListener("abort", () => {
          reject(signal.reason);
        }, { once: true });
      });
    }
    /**
        Updates the priority of a promise function by its id, affecting its execution order. Requires a defined concurrency limit to take effect.
    
        For example, this can be used to prioritize a promise function to run earlier.
    
        ```js
        import PQueue from 'p-queue';
    
        const queue = new PQueue({concurrency: 1});
    
        queue.add(async () => '', {priority: 1});
        queue.add(async () => '', {priority: 0, id: ''});
        queue.add(async () => '', {priority: 1});
        queue.add(async () => '', {priority: 1});
    
        queue.setPriority('', 2);
        ```
    
        In this case, the promise function with `id: ''` runs second.
    
        You can also deprioritize a promise function to delay its execution:
    
        ```js
        import PQueue from 'p-queue';
    
        const queue = new PQueue({concurrency: 1});
    
        queue.add(async () => '', {priority: 1});
        queue.add(async () => '', {priority: 1, id: ''});
        queue.add(async () => '');
        queue.add(async () => '', {priority: 0});
    
        queue.setPriority('', -1);
        ```
        Here, the promise function with `id: ''` executes last.
        */
    setPriority(id, priority) {
      this.#queue.setPriority(id, priority);
    }
    async add(function_, options = {}) {
      options.id ??= (this.#idAssigner++).toString();
      options = {
        timeout: this.timeout,
        throwOnTimeout: this.#throwOnTimeout,
        ...options
      };
      return new Promise((resolve, reject) => {
        this.#queue.enqueue(async () => {
          var _a2;
          this.#pending++;
          this.#intervalCount++;
          try {
            (_a2 = options.signal) == null ? void 0 : _a2.throwIfAborted();
            let operation = function_({ signal: options.signal });
            if (options.timeout) {
              operation = pTimeout(Promise.resolve(operation), { milliseconds: options.timeout });
            }
            if (options.signal) {
              operation = Promise.race([operation, this.#throwOnAbort(options.signal)]);
            }
            const result = await operation;
            resolve(result);
            this.emit("completed", result);
          } catch (error) {
            if (error instanceof TimeoutError2 && !options.throwOnTimeout) {
              resolve();
              return;
            }
            reject(error);
            this.emit("error", error);
          } finally {
            this.#next();
          }
        }, options);
        this.emit("add");
        this.#tryToStartAnother();
      });
    }
    async addAll(functions, options) {
      return Promise.all(functions.map(async (function_) => this.add(function_, options)));
    }
    /**
    Start (or resume) executing enqueued tasks within concurrency limit. No need to call this if queue is not paused (via `options.autoStart = false` or by `.pause()` method.)
    */
    start() {
      if (!this.#isPaused) {
        return this;
      }
      this.#isPaused = false;
      this.#processQueue();
      return this;
    }
    /**
    Put queue execution on hold.
    */
    pause() {
      this.#isPaused = true;
    }
    /**
    Clear the queue.
    */
    clear() {
      this.#queue = new this.#queueClass();
    }
    /**
        Can be called multiple times. Useful if you for example add additional items at a later time.
    
        @returns A promise that settles when the queue becomes empty.
        */
    async onEmpty() {
      if (this.#queue.size === 0) {
        return;
      }
      await this.#onEvent("empty");
    }
    /**
        @returns A promise that settles when the queue size is less than the given limit: `queue.size < limit`.
    
        If you want to avoid having the queue grow beyond a certain size you can `await queue.onSizeLessThan()` before adding a new item.
    
        Note that this only limits the number of items waiting to start. There could still be up to `concurrency` jobs already running that this call does not include in its calculation.
        */
    async onSizeLessThan(limit) {
      if (this.#queue.size < limit) {
        return;
      }
      await this.#onEvent("next", () => this.#queue.size < limit);
    }
    /**
        The difference with `.onEmpty` is that `.onIdle` guarantees that all work from the queue has finished. `.onEmpty` merely signals that the queue is empty, but it could mean that some promises haven't completed yet.
    
        @returns A promise that settles when the queue becomes empty, and all promises have completed; `queue.size === 0 && queue.pending === 0`.
        */
    async onIdle() {
      if (this.#pending === 0 && this.#queue.size === 0) {
        return;
      }
      await this.#onEvent("idle");
    }
    async #onEvent(event, filter2) {
      return new Promise((resolve) => {
        const listener = () => {
          if (filter2 && !filter2()) {
            return;
          }
          this.off(event, listener);
          resolve();
        };
        this.on(event, listener);
      });
    }
    /**
    Size of the queue, the number of queued items waiting to run.
    */
    get size() {
      return this.#queue.size;
    }
    /**
        Size of the queue, filtered by the given options.
    
        For example, this can be used to find the number of items remaining in the queue with a specific priority level.
        */
    sizeBy(options) {
      return this.#queue.filter(options).length;
    }
    /**
    Number of running items (no longer in the queue).
    */
    get pending() {
      return this.#pending;
    }
    /**
    Whether the queue is currently paused.
    */
    get isPaused() {
      return this.#isPaused;
    }
  };

  // node_modules/@multiformats/dns/dist/src/utils/get-types.js
  var import_browser_shims111 = __toESM(require_browser_shims(), 1);
  function getTypes(types) {
    const DEFAULT_TYPES = [
      RecordType.A
    ];
    if (types == null) {
      return DEFAULT_TYPES;
    }
    if (Array.isArray(types)) {
      if (types.length === 0) {
        return DEFAULT_TYPES;
      }
      return types;
    }
    return [
      types
    ];
  }

  // node_modules/@multiformats/dns/dist/src/utils/to-dns-response.js
  var import_browser_shims112 = __toESM(require_browser_shims(), 1);
  var DEFAULT_TTL = 60;
  function toDNSResponse(obj) {
    return {
      Status: obj.Status ?? 0,
      TC: obj.TC ?? obj.flag_tc ?? false,
      RD: obj.RD ?? obj.flag_rd ?? false,
      RA: obj.RA ?? obj.flag_ra ?? false,
      AD: obj.AD ?? obj.flag_ad ?? false,
      CD: obj.CD ?? obj.flag_cd ?? false,
      Question: (obj.Question ?? obj.questions ?? []).map((question) => {
        return {
          name: question.name,
          type: RecordType[question.type]
        };
      }),
      Answer: (obj.Answer ?? obj.answers ?? []).map((answer) => {
        return {
          name: answer.name,
          type: RecordType[answer.type],
          TTL: answer.TTL ?? answer.ttl ?? DEFAULT_TTL,
          data: answer.data instanceof Uint8Array ? toString2(answer.data) : answer.data
        };
      })
    };
  }

  // node_modules/@multiformats/dns/dist/src/resolvers/dns-json-over-https.js
  var DEFAULT_QUERY_CONCURRENCY = 4;
  function dnsJsonOverHttps(url, init = {}) {
    const httpQueue = new PQueue({
      concurrency: init.queryConcurrency ?? DEFAULT_QUERY_CONCURRENCY
    });
    return async (fqdn, options = {}) => {
      var _a2;
      const searchParams = new URLSearchParams();
      searchParams.set("name", fqdn);
      getTypes(options.types).forEach((type) => {
        searchParams.append("type", RecordType[type]);
      });
      (_a2 = options.onProgress) == null ? void 0 : _a2.call(options, new CustomProgressEvent("dns:query", { detail: fqdn }));
      const response = await httpQueue.add(async () => {
        var _a3;
        const res = await fetch(`${url}?${searchParams}`, {
          headers: {
            accept: "application/dns-json"
          },
          signal: options == null ? void 0 : options.signal
        });
        if (res.status !== 200) {
          throw new Error(`Unexpected HTTP status: ${res.status} - ${res.statusText}`);
        }
        const response2 = toDNSResponse(await res.json());
        (_a3 = options.onProgress) == null ? void 0 : _a3.call(options, new CustomProgressEvent("dns:response", { detail: response2 }));
        return response2;
      }, {
        signal: options.signal
      });
      if (response == null) {
        throw new Error("No DNS response received");
      }
      return response;
    };
  }

  // node_modules/@multiformats/dns/dist/src/resolvers/default.browser.js
  function defaultResolver() {
    return [
      dnsJsonOverHttps("https://cloudflare-dns.com/dns-query"),
      dnsJsonOverHttps("https://dns.google/resolve")
    ];
  }

  // node_modules/@multiformats/dns/dist/src/utils/cache.js
  var import_browser_shims115 = __toESM(require_browser_shims(), 1);
  var import_hashlru = __toESM(require_hashlru(), 1);
  var CachedAnswers = class {
    lru;
    constructor(maxSize) {
      this.lru = (0, import_hashlru.default)(maxSize);
    }
    get(fqdn, types) {
      let foundAllAnswers = true;
      const answers = [];
      for (const type of types) {
        const cached = this.getAnswers(fqdn, type);
        if (cached.length === 0) {
          foundAllAnswers = false;
          break;
        }
        answers.push(...cached);
      }
      if (foundAllAnswers) {
        return toDNSResponse({ answers });
      }
    }
    getAnswers(domain, type) {
      const key = `${domain.toLowerCase()}-${type}`;
      const answers = this.lru.get(key);
      if (answers != null) {
        const cachedAnswers = answers.filter((entry) => {
          return entry.expires > Date.now();
        }).map(({ expires, value }) => ({
          ...value,
          TTL: Math.round((expires - Date.now()) / 1e3),
          type: RecordType[value.type]
        }));
        if (cachedAnswers.length === 0) {
          this.lru.remove(key);
        }
        return cachedAnswers;
      }
      return [];
    }
    add(domain, answer) {
      const key = `${domain.toLowerCase()}-${answer.type}`;
      const answers = this.lru.get(key) ?? [];
      answers.push({
        expires: Date.now() + (answer.TTL ?? DEFAULT_TTL) * 1e3,
        value: answer
      });
      this.lru.set(key, answers);
    }
    remove(domain, type) {
      const key = `${domain.toLowerCase()}-${type}`;
      this.lru.remove(key);
    }
    clear() {
      this.lru.clear();
    }
  };
  function cache2(size) {
    return new CachedAnswers(size);
  }

  // node_modules/@multiformats/dns/dist/src/dns.js
  var DEFAULT_ANSWER_CACHE_SIZE = 1e3;
  var DNS = class {
    resolvers;
    cache;
    constructor(init) {
      this.resolvers = {};
      this.cache = cache2(init.cacheSize ?? DEFAULT_ANSWER_CACHE_SIZE);
      Object.entries(init.resolvers ?? {}).forEach(([tld, resolver]) => {
        if (!Array.isArray(resolver)) {
          resolver = [resolver];
        }
        if (!tld.endsWith(".")) {
          tld = `${tld}.`;
        }
        this.resolvers[tld] = resolver;
      });
      if (this.resolvers["."] == null) {
        this.resolvers["."] = defaultResolver();
      }
    }
    /**
     * Queries DNS resolvers for the passed record types for the passed domain.
     *
     * If cached records exist for all desired types they will be returned
     * instead.
     *
     * Any new responses will be added to the cache for subsequent requests.
     */
    async query(domain, options = {}) {
      var _a2, _b2, _c;
      const types = getTypes(options.types);
      const cached = options.cached !== false ? this.cache.get(domain, types) : void 0;
      if (cached != null) {
        (_a2 = options.onProgress) == null ? void 0 : _a2.call(options, new CustomProgressEvent("dns:cache", { detail: cached }));
        return cached;
      }
      const tld = `${domain.split(".").pop()}.`;
      const resolvers2 = (this.resolvers[tld] ?? this.resolvers["."]).sort(() => {
        return Math.random() > 0.5 ? -1 : 1;
      });
      const errors = [];
      for (const resolver of resolvers2) {
        if (((_b2 = options.signal) == null ? void 0 : _b2.aborted) === true) {
          break;
        }
        try {
          const result = await resolver(domain, {
            ...options,
            types
          });
          for (const answer of result.Answer) {
            this.cache.add(domain, answer);
          }
          return result;
        } catch (err) {
          errors.push(err);
          (_c = options.onProgress) == null ? void 0 : _c.call(options, new CustomProgressEvent("dns:error", { detail: err }));
        }
      }
      if (errors.length === 1) {
        throw errors[0];
      }
      throw new AggregateError(errors, `DNS lookup of ${domain} ${types} failed`);
    }
  };

  // node_modules/@multiformats/dns/dist/src/index.js
  var RecordType;
  (function(RecordType2) {
    RecordType2[RecordType2["A"] = 1] = "A";
    RecordType2[RecordType2["CNAME"] = 5] = "CNAME";
    RecordType2[RecordType2["TXT"] = 16] = "TXT";
    RecordType2[RecordType2["AAAA"] = 28] = "AAAA";
  })(RecordType || (RecordType = {}));
  function dns(init = {}) {
    return new DNS(init);
  }

  // node_modules/@multiformats/multiaddr/dist/src/index.js
  var import_browser_shims132 = __toESM(require_browser_shims(), 1);

  // node_modules/@multiformats/multiaddr/dist/src/codec.js
  var import_browser_shims129 = __toESM(require_browser_shims(), 1);

  // node_modules/@multiformats/multiaddr/dist/src/convert.js
  var import_browser_shims128 = __toESM(require_browser_shims(), 1);

  // node_modules/@chainsafe/netmask/dist/src/index.js
  var import_browser_shims124 = __toESM(require_browser_shims(), 1);

  // node_modules/@chainsafe/netmask/dist/src/ipnet.js
  var import_browser_shims123 = __toESM(require_browser_shims(), 1);

  // node_modules/@chainsafe/is-ip/lib/parse.js
  var import_browser_shims119 = __toESM(require_browser_shims(), 1);

  // node_modules/@chainsafe/is-ip/lib/parser.js
  var import_browser_shims118 = __toESM(require_browser_shims(), 1);
  var Parser = class {
    index = 0;
    input = "";
    new(input) {
      this.index = 0;
      this.input = input;
      return this;
    }
    /** Run a parser, and restore the pre-parse state if it fails. */
    readAtomically(fn) {
      const index = this.index;
      const result = fn();
      if (result === void 0) {
        this.index = index;
      }
      return result;
    }
    /** Run a parser, but fail if the entire input wasn't consumed. Doesn't run atomically. */
    parseWith(fn) {
      const result = fn();
      if (this.index !== this.input.length) {
        return void 0;
      }
      return result;
    }
    /** Peek the next character from the input */
    peekChar() {
      if (this.index >= this.input.length) {
        return void 0;
      }
      return this.input[this.index];
    }
    /** Read the next character from the input */
    readChar() {
      if (this.index >= this.input.length) {
        return void 0;
      }
      return this.input[this.index++];
    }
    /** Read the next character from the input if it matches the target. */
    readGivenChar(target) {
      return this.readAtomically(() => {
        const char = this.readChar();
        if (char !== target) {
          return void 0;
        }
        return char;
      });
    }
    /**
     * Helper for reading separators in an indexed loop. Reads the separator
     * character iff index > 0, then runs the parser. When used in a loop,
     * the separator character will only be read on index > 0 (see
     * readIPv4Addr for an example)
     */
    readSeparator(sep, index, inner) {
      return this.readAtomically(() => {
        if (index > 0) {
          if (this.readGivenChar(sep) === void 0) {
            return void 0;
          }
        }
        return inner();
      });
    }
    /**
     * Read a number off the front of the input in the given radix, stopping
     * at the first non-digit character or eof. Fails if the number has more
     * digits than max_digits or if there is no number.
     */
    readNumber(radix, maxDigits, allowZeroPrefix, maxBytes) {
      return this.readAtomically(() => {
        let result = 0;
        let digitCount = 0;
        const leadingChar = this.peekChar();
        if (leadingChar === void 0) {
          return void 0;
        }
        const hasLeadingZero = leadingChar === "0";
        const maxValue = 2 ** (8 * maxBytes) - 1;
        while (true) {
          const digit = this.readAtomically(() => {
            const char = this.readChar();
            if (char === void 0) {
              return void 0;
            }
            const num = Number.parseInt(char, radix);
            if (Number.isNaN(num)) {
              return void 0;
            }
            return num;
          });
          if (digit === void 0) {
            break;
          }
          result *= radix;
          result += digit;
          if (result > maxValue) {
            return void 0;
          }
          digitCount += 1;
          if (maxDigits !== void 0) {
            if (digitCount > maxDigits) {
              return void 0;
            }
          }
        }
        if (digitCount === 0) {
          return void 0;
        } else if (!allowZeroPrefix && hasLeadingZero && digitCount > 1) {
          return void 0;
        } else {
          return result;
        }
      });
    }
    /** Read an IPv4 address. */
    readIPv4Addr() {
      return this.readAtomically(() => {
        const out = new Uint8Array(4);
        for (let i = 0; i < out.length; i++) {
          const ix = this.readSeparator(".", i, () => this.readNumber(10, 3, false, 1));
          if (ix === void 0) {
            return void 0;
          }
          out[i] = ix;
        }
        return out;
      });
    }
    /** Read an IPv6 Address. */
    readIPv6Addr() {
      const readGroups = (groups) => {
        for (let i = 0; i < groups.length / 2; i++) {
          const ix = i * 2;
          if (i < groups.length - 3) {
            const ipv4 = this.readSeparator(":", i, () => this.readIPv4Addr());
            if (ipv4 !== void 0) {
              groups[ix] = ipv4[0];
              groups[ix + 1] = ipv4[1];
              groups[ix + 2] = ipv4[2];
              groups[ix + 3] = ipv4[3];
              return [ix + 4, true];
            }
          }
          const group = this.readSeparator(":", i, () => this.readNumber(16, 4, true, 2));
          if (group === void 0) {
            return [ix, false];
          }
          groups[ix] = group >> 8;
          groups[ix + 1] = group & 255;
        }
        return [groups.length, false];
      };
      return this.readAtomically(() => {
        const head = new Uint8Array(16);
        const [headSize, headIp4] = readGroups(head);
        if (headSize === 16) {
          return head;
        }
        if (headIp4) {
          return void 0;
        }
        if (this.readGivenChar(":") === void 0) {
          return void 0;
        }
        if (this.readGivenChar(":") === void 0) {
          return void 0;
        }
        const tail = new Uint8Array(14);
        const limit = 16 - (headSize + 2);
        const [tailSize] = readGroups(tail.subarray(0, limit));
        head.set(tail.subarray(0, tailSize), 16 - tailSize);
        return head;
      });
    }
    /** Read an IP Address, either IPv4 or IPv6. */
    readIPAddr() {
      return this.readIPv4Addr() ?? this.readIPv6Addr();
    }
  };

  // node_modules/@chainsafe/is-ip/lib/parse.js
  var MAX_IPV6_LENGTH = 45;
  var MAX_IPV4_LENGTH = 15;
  var parser = new Parser();
  function parseIPv4(input) {
    if (input.length > MAX_IPV4_LENGTH) {
      return void 0;
    }
    return parser.new(input).parseWith(() => parser.readIPv4Addr());
  }
  function parseIPv6(input) {
    if (input.includes("%")) {
      input = input.split("%")[0];
    }
    if (input.length > MAX_IPV6_LENGTH) {
      return void 0;
    }
    return parser.new(input).parseWith(() => parser.readIPv6Addr());
  }
  function parseIP(input, mapIPv4ToIPv6 = false) {
    if (input.includes("%")) {
      input = input.split("%")[0];
    }
    if (input.length > MAX_IPV6_LENGTH) {
      return void 0;
    }
    const addr = parser.new(input).parseWith(() => parser.readIPAddr());
    if (!addr) {
      return void 0;
    }
    if (mapIPv4ToIPv6 && addr.length === 4) {
      return Uint8Array.from([0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 255, 255, addr[0], addr[1], addr[2], addr[3]]);
    }
    return addr;
  }

  // node_modules/@chainsafe/netmask/dist/src/cidr.js
  var import_browser_shims122 = __toESM(require_browser_shims(), 1);

  // node_modules/@chainsafe/netmask/dist/src/ip.js
  var import_browser_shims121 = __toESM(require_browser_shims(), 1);

  // node_modules/@chainsafe/netmask/dist/src/util.js
  var import_browser_shims120 = __toESM(require_browser_shims(), 1);
  function allFF(a, from3, to) {
    let i = 0;
    for (const e of a) {
      if (i < from3)
        continue;
      if (i > to)
        break;
      if (e !== 255)
        return false;
      i++;
    }
    return true;
  }
  function deepEqual(a, b, from3, to) {
    let i = 0;
    for (const e of a) {
      if (i < from3)
        continue;
      if (i > to)
        break;
      if (e !== b[i])
        return false;
      i++;
    }
    return true;
  }
  function ipToString(ip) {
    switch (ip.length) {
      case IPv4Len: {
        return ip.join(".");
      }
      case IPv6Len: {
        const result = [];
        for (let i = 0; i < ip.length; i++) {
          if (i % 2 === 0) {
            result.push(ip[i].toString(16).padStart(2, "0") + ip[i + 1].toString(16).padStart(2, "0"));
          }
        }
        return result.join(":");
      }
      default: {
        throw new Error("Invalid ip length");
      }
    }
  }
  function simpleMaskLength(mask) {
    let ones = 0;
    for (let [index, byte] of mask.entries()) {
      if (byte === 255) {
        ones += 8;
        continue;
      }
      while ((byte & 128) != 0) {
        ones++;
        byte = byte << 1;
      }
      if ((byte & 128) != 0) {
        return -1;
      }
      for (let i = index + 1; i < mask.length; i++) {
        if (mask[i] != 0) {
          return -1;
        }
      }
      break;
    }
    return ones;
  }
  function maskToHex(mask) {
    let hex = "0x";
    for (const byte of mask) {
      hex += (byte >> 4).toString(16) + (byte & 15).toString(16);
    }
    return hex;
  }

  // node_modules/@chainsafe/netmask/dist/src/ip.js
  var IPv4Len = 4;
  var IPv6Len = 16;
  var maxIPv6Octet = parseInt("0xFFFF", 16);
  var ipv4Prefix = new Uint8Array([
    0,
    0,
    0,
    0,
    0,
    0,
    0,
    0,
    0,
    0,
    255,
    255
  ]);
  function maskIp(ip, mask) {
    if (mask.length === IPv6Len && ip.length === IPv4Len && allFF(mask, 0, 11)) {
      mask = mask.slice(12);
    }
    if (mask.length === IPv4Len && ip.length === IPv6Len && deepEqual(ip, ipv4Prefix, 0, 11)) {
      ip = ip.slice(12);
    }
    const n = ip.length;
    if (n != mask.length) {
      throw new Error("Failed to mask ip");
    }
    const out = new Uint8Array(n);
    for (let i = 0; i < n; i++) {
      out[i] = ip[i] & mask[i];
    }
    return out;
  }
  function containsIp(net, ip) {
    if (typeof ip === "string") {
      ip = parseIP(ip);
    }
    if (ip == null)
      throw new Error("Invalid ip");
    if (ip.length !== net.network.length) {
      return false;
    }
    for (let i = 0; i < ip.length; i++) {
      if ((net.network[i] & net.mask[i]) !== (ip[i] & net.mask[i])) {
        return false;
      }
    }
    return true;
  }

  // node_modules/@chainsafe/netmask/dist/src/cidr.js
  function parseCidr(s2) {
    const [address, maskString] = s2.split("/");
    if (!address || !maskString)
      throw new Error("Failed to parse given CIDR: " + s2);
    let ipLength = IPv4Len;
    let ip = parseIPv4(address);
    if (ip == null) {
      ipLength = IPv6Len;
      ip = parseIPv6(address);
      if (ip == null)
        throw new Error("Failed to parse given CIDR: " + s2);
    }
    const m2 = parseInt(maskString, 10);
    if (Number.isNaN(m2) || String(m2).length !== maskString.length || m2 < 0 || m2 > ipLength * 8) {
      throw new Error("Failed to parse given CIDR: " + s2);
    }
    const mask = cidrMask(m2, 8 * ipLength);
    return {
      network: maskIp(ip, mask),
      mask
    };
  }
  function cidrMask(ones, bits) {
    if (bits !== 8 * IPv4Len && bits !== 8 * IPv6Len)
      throw new Error("Invalid CIDR mask");
    if (ones < 0 || ones > bits)
      throw new Error("Invalid CIDR mask");
    const l = bits / 8;
    const m2 = new Uint8Array(l);
    for (let i = 0; i < l; i++) {
      if (ones >= 8) {
        m2[i] = 255;
        ones -= 8;
        continue;
      }
      m2[i] = 255 - (255 >> ones);
      ones = 0;
    }
    return m2;
  }

  // node_modules/@chainsafe/netmask/dist/src/ipnet.js
  var IpNet = class {
    /**
     *
     * @param ipOrCidr either network ip or full cidr address
     * @param mask in case ipOrCidr is network this can be either mask in decimal format or as ip address
     */
    constructor(ipOrCidr, mask) {
      if (mask == null) {
        ({ network: this.network, mask: this.mask } = parseCidr(ipOrCidr));
      } else {
        const ipResult = parseIP(ipOrCidr);
        if (ipResult == null) {
          throw new Error("Failed to parse network");
        }
        mask = String(mask);
        const m2 = parseInt(mask, 10);
        if (Number.isNaN(m2) || String(m2).length !== mask.length || m2 < 0 || m2 > ipResult.length * 8) {
          const maskResult = parseIP(mask);
          if (maskResult == null) {
            throw new Error("Failed to parse mask");
          }
          this.mask = maskResult;
        } else {
          this.mask = cidrMask(m2, 8 * ipResult.length);
        }
        this.network = maskIp(ipResult, this.mask);
      }
    }
    /**
     * Checks if netmask contains ip address
     * @param ip
     * @returns
     */
    contains(ip) {
      return containsIp({ network: this.network, mask: this.mask }, ip);
    }
    /**Serializes back to string format */
    toString() {
      const l = simpleMaskLength(this.mask);
      const mask = l !== -1 ? String(l) : maskToHex(this.mask);
      return ipToString(this.network) + "/" + mask;
    }
  };

  // node_modules/@chainsafe/netmask/dist/src/index.js
  function cidrContains(cidr, ip) {
    const ipnet = new IpNet(cidr);
    return ipnet.contains(ip);
  }

  // node_modules/@multiformats/multiaddr/dist/src/ip.js
  var import_browser_shims126 = __toESM(require_browser_shims(), 1);

  // node_modules/@chainsafe/is-ip/lib/is-ip.js
  var import_browser_shims125 = __toESM(require_browser_shims(), 1);
  function isIPv4(input) {
    return Boolean(parseIPv4(input));
  }
  function isIPv6(input) {
    return Boolean(parseIPv6(input));
  }
  function isIP(input) {
    return Boolean(parseIP(input));
  }

  // node_modules/@multiformats/multiaddr/dist/src/ip.js
  var isV4 = isIPv4;
  var isV6 = isIPv6;
  var toBytes2 = function(ip) {
    let offset = 0;
    ip = ip.toString().trim();
    if (isV4(ip)) {
      const bytes = new Uint8Array(offset + 4);
      ip.split(/\./g).forEach((byte) => {
        bytes[offset++] = parseInt(byte, 10) & 255;
      });
      return bytes;
    }
    if (isV6(ip)) {
      const sections = ip.split(":", 8);
      let i;
      for (i = 0; i < sections.length; i++) {
        const isv4 = isV4(sections[i]);
        let v4Buffer;
        if (isv4) {
          v4Buffer = toBytes2(sections[i]);
          sections[i] = toString2(v4Buffer.slice(0, 2), "base16");
        }
        if (v4Buffer != null && ++i < 8) {
          sections.splice(i, 0, toString2(v4Buffer.slice(2, 4), "base16"));
        }
      }
      if (sections[0] === "") {
        while (sections.length < 8) {
          sections.unshift("0");
        }
      } else if (sections[sections.length - 1] === "") {
        while (sections.length < 8) {
          sections.push("0");
        }
      } else if (sections.length < 8) {
        for (i = 0; i < sections.length && sections[i] !== ""; i++) {
        }
        const argv = [i, 1];
        for (i = 9 - sections.length; i > 0; i--) {
          argv.push("0");
        }
        sections.splice.apply(sections, argv);
      }
      const bytes = new Uint8Array(offset + 16);
      for (i = 0; i < sections.length; i++) {
        const word = parseInt(sections[i], 16);
        bytes[offset++] = word >> 8 & 255;
        bytes[offset++] = word & 255;
      }
      return bytes;
    }
    throw new Error("invalid ip address");
  };
  var toString3 = function(buf, offset = 0, length4) {
    offset = ~~offset;
    length4 = length4 ?? buf.length - offset;
    const view = new DataView(buf.buffer);
    if (length4 === 4) {
      const result = [];
      for (let i = 0; i < length4; i++) {
        result.push(buf[offset + i]);
      }
      return result.join(".");
    }
    if (length4 === 16) {
      const result = [];
      for (let i = 0; i < length4; i += 2) {
        result.push(view.getUint16(offset + i).toString(16));
      }
      return result.join(":").replace(/(^|:)0(:0)*:0(:|$)/, "$1::$3").replace(/:{3,4}/, "::");
    }
    return "";
  };

  // node_modules/@multiformats/multiaddr/dist/src/protocols-table.js
  var import_browser_shims127 = __toESM(require_browser_shims(), 1);
  var V = -1;
  var names = {};
  var codes = {};
  var table = [
    [4, 32, "ip4"],
    [6, 16, "tcp"],
    [33, 16, "dccp"],
    [41, 128, "ip6"],
    [42, V, "ip6zone"],
    [43, 8, "ipcidr"],
    [53, V, "dns", true],
    [54, V, "dns4", true],
    [55, V, "dns6", true],
    [56, V, "dnsaddr", true],
    [132, 16, "sctp"],
    [273, 16, "udp"],
    [275, 0, "p2p-webrtc-star"],
    [276, 0, "p2p-webrtc-direct"],
    [277, 0, "p2p-stardust"],
    [280, 0, "webrtc-direct"],
    [281, 0, "webrtc"],
    [290, 0, "p2p-circuit"],
    [301, 0, "udt"],
    [302, 0, "utp"],
    [400, V, "unix", false, true],
    // `ipfs` is added before `p2p` for legacy support.
    // All text representations will default to `p2p`, but `ipfs` will
    // still be supported
    [421, V, "ipfs"],
    // `p2p` is the preferred name for 421, and is now the default
    [421, V, "p2p"],
    [443, 0, "https"],
    [444, 96, "onion"],
    [445, 296, "onion3"],
    [446, V, "garlic64"],
    [448, 0, "tls"],
    [449, V, "sni"],
    [460, 0, "quic"],
    [461, 0, "quic-v1"],
    [465, 0, "webtransport"],
    [466, V, "certhash"],
    [477, 0, "ws"],
    [478, 0, "wss"],
    [479, 0, "p2p-websocket-star"],
    [480, 0, "http"],
    [481, V, "http-path"],
    [777, V, "memory"]
  ];
  table.forEach((row) => {
    const proto = createProtocol(...row);
    codes[proto.code] = proto;
    names[proto.name] = proto;
  });
  function createProtocol(code2, size, name3, resolvable, path) {
    return {
      code: code2,
      size,
      name: name3,
      resolvable: Boolean(resolvable),
      path: Boolean(path)
    };
  }
  function getProtocol(proto) {
    if (typeof proto === "number") {
      if (codes[proto] != null) {
        return codes[proto];
      }
      throw new Error(`no protocol with code: ${proto}`);
    } else if (typeof proto === "string") {
      if (names[proto] != null) {
        return names[proto];
      }
      throw new Error(`no protocol with name: ${proto}`);
    }
    throw new Error(`invalid protocol id type: ${typeof proto}`);
  }

  // node_modules/@multiformats/multiaddr/dist/src/convert.js
  var ip4Protocol = getProtocol("ip4");
  var ip6Protocol = getProtocol("ip6");
  var ipcidrProtocol = getProtocol("ipcidr");
  function convertToString(proto, buf) {
    const protocol = getProtocol(proto);
    switch (protocol.code) {
      case 4:
      // ipv4
      case 41:
        return bytes2ip(buf);
      case 42:
        return bytes2str(buf);
      case 43:
        return toString2(buf, "base10");
      case 6:
      // tcp
      case 273:
      // udp
      case 33:
      // dccp
      case 132:
        return bytes2port(buf).toString();
      case 53:
      // dns
      case 54:
      // dns4
      case 55:
      // dns6
      case 56:
      // dnsaddr
      case 400:
      // unix
      case 449:
      // sni
      case 777:
        return bytes2str(buf);
      case 421:
        return bytes2mh(buf);
      case 444:
        return bytes2onion(buf);
      case 445:
        return bytes2onion(buf);
      case 466:
        return bytes2mb(buf);
      case 481:
        return globalThis.encodeURIComponent(bytes2str(buf));
      default:
        return toString2(buf, "base16");
    }
  }
  function convertToBytes(proto, str) {
    const protocol = getProtocol(proto);
    switch (protocol.code) {
      case 4:
        return ip2bytes(str);
      case 41:
        return ip2bytes(str);
      case 42:
        return str2bytes(str);
      case 43:
        return fromString2(str, "base10");
      case 6:
      // tcp
      case 273:
      // udp
      case 33:
      // dccp
      case 132:
        return port2bytes(parseInt(str, 10));
      case 53:
      // dns
      case 54:
      // dns4
      case 55:
      // dns6
      case 56:
      // dnsaddr
      case 400:
      // unix
      case 449:
      // sni
      case 777:
        return str2bytes(str);
      case 421:
        return mh2bytes(str);
      case 444:
        return onion2bytes(str);
      case 445:
        return onion32bytes(str);
      case 466:
        return mb2bytes(str);
      case 481:
        return str2bytes(globalThis.decodeURIComponent(str));
      default:
        return fromString2(str, "base16");
    }
  }
  function convertToIpNet(multiaddr2) {
    let mask;
    let addr;
    multiaddr2.stringTuples().forEach(([code2, value]) => {
      if (code2 === ip4Protocol.code || code2 === ip6Protocol.code) {
        addr = value;
      }
      if (code2 === ipcidrProtocol.code) {
        mask = value;
      }
    });
    if (mask == null || addr == null) {
      throw new Error("Invalid multiaddr");
    }
    return new IpNet(addr, mask);
  }
  var decoders2 = Object.values(bases).map((c) => c.decoder);
  var anybaseDecoder = function() {
    let acc = decoders2[0].or(decoders2[1]);
    decoders2.slice(2).forEach((d2) => acc = acc.or(d2));
    return acc;
  }();
  function ip2bytes(ipString) {
    if (!isIP(ipString)) {
      throw new Error("invalid ip address");
    }
    return toBytes2(ipString);
  }
  function bytes2ip(ipBuff) {
    const ipString = toString3(ipBuff, 0, ipBuff.length);
    if (ipString == null) {
      throw new Error("ipBuff is required");
    }
    if (!isIP(ipString)) {
      throw new Error("invalid ip address");
    }
    return ipString;
  }
  function port2bytes(port) {
    const buf = new ArrayBuffer(2);
    const view = new DataView(buf);
    view.setUint16(0, port);
    return new Uint8Array(buf);
  }
  function bytes2port(buf) {
    const view = new DataView(buf.buffer);
    return view.getUint16(buf.byteOffset);
  }
  function str2bytes(str) {
    const buf = fromString2(str);
    const size = Uint8Array.from(encode5(buf.length));
    return concat([size, buf], size.length + buf.length);
  }
  function bytes2str(buf) {
    const size = decode6(buf);
    buf = buf.slice(encodingLength2(size));
    if (buf.length !== size) {
      throw new Error("inconsistent lengths");
    }
    return toString2(buf);
  }
  function mh2bytes(hash) {
    let mh;
    if (hash[0] === "Q" || hash[0] === "1") {
      mh = decode4(base58btc.decode(`z${hash}`)).bytes;
    } else {
      mh = CID.parse(hash).multihash.bytes;
    }
    const size = Uint8Array.from(encode5(mh.length));
    return concat([size, mh], size.length + mh.length);
  }
  function mb2bytes(mbstr) {
    const mb = anybaseDecoder.decode(mbstr);
    const size = Uint8Array.from(encode5(mb.length));
    return concat([size, mb], size.length + mb.length);
  }
  function bytes2mb(buf) {
    const size = decode6(buf);
    const hash = buf.slice(encodingLength2(size));
    if (hash.length !== size) {
      throw new Error("inconsistent lengths");
    }
    return "u" + toString2(hash, "base64url");
  }
  function bytes2mh(buf) {
    const size = decode6(buf);
    const address = buf.slice(encodingLength2(size));
    if (address.length !== size) {
      throw new Error("inconsistent lengths");
    }
    return toString2(address, "base58btc");
  }
  function onion2bytes(str) {
    const addr = str.split(":");
    if (addr.length !== 2) {
      throw new Error(`failed to parse onion addr: ["'${addr.join('", "')}'"]' does not contain a port number`);
    }
    if (addr[0].length !== 16) {
      throw new Error(`failed to parse onion addr: ${addr[0]} not a Tor onion address.`);
    }
    const buf = base32.decode("b" + addr[0]);
    const port = parseInt(addr[1], 10);
    if (port < 1 || port > 65536) {
      throw new Error("Port number is not in range(1, 65536)");
    }
    const portBuf = port2bytes(port);
    return concat([buf, portBuf], buf.length + portBuf.length);
  }
  function onion32bytes(str) {
    const addr = str.split(":");
    if (addr.length !== 2) {
      throw new Error(`failed to parse onion addr: ["'${addr.join('", "')}'"]' does not contain a port number`);
    }
    if (addr[0].length !== 56) {
      throw new Error(`failed to parse onion addr: ${addr[0]} not a Tor onion3 address.`);
    }
    const buf = base32.decode(`b${addr[0]}`);
    const port = parseInt(addr[1], 10);
    if (port < 1 || port > 65536) {
      throw new Error("Port number is not in range(1, 65536)");
    }
    const portBuf = port2bytes(port);
    return concat([buf, portBuf], buf.length + portBuf.length);
  }
  function bytes2onion(buf) {
    const addrBytes = buf.slice(0, buf.length - 2);
    const portBytes = buf.slice(buf.length - 2);
    const addr = toString2(addrBytes, "base32");
    const port = bytes2port(portBytes);
    return `${addr}:${port}`;
  }

  // node_modules/@multiformats/multiaddr/dist/src/codec.js
  function stringToMultiaddrParts(str) {
    str = cleanPath(str);
    const tuples = [];
    const stringTuples = [];
    let path = null;
    const parts = str.split("/").slice(1);
    if (parts.length === 1 && parts[0] === "") {
      return {
        bytes: new Uint8Array(),
        string: "/",
        tuples: [],
        stringTuples: [],
        path: null
      };
    }
    for (let p = 0; p < parts.length; p++) {
      const part = parts[p];
      const proto = getProtocol(part);
      if (proto.size === 0) {
        tuples.push([proto.code]);
        stringTuples.push([proto.code]);
        continue;
      }
      p++;
      if (p >= parts.length) {
        throw new ParseError("invalid address: " + str);
      }
      if (proto.path === true) {
        path = cleanPath(parts.slice(p).join("/"));
        tuples.push([proto.code, convertToBytes(proto.code, path)]);
        stringTuples.push([proto.code, path]);
        break;
      }
      const bytes = convertToBytes(proto.code, parts[p]);
      tuples.push([proto.code, bytes]);
      stringTuples.push([proto.code, convertToString(proto.code, bytes)]);
    }
    return {
      string: stringTuplesToString(stringTuples),
      bytes: tuplesToBytes(tuples),
      tuples,
      stringTuples,
      path
    };
  }
  function bytesToMultiaddrParts(bytes) {
    const tuples = [];
    const stringTuples = [];
    let path = null;
    let i = 0;
    while (i < bytes.length) {
      const code2 = decode6(bytes, i);
      const n = encodingLength2(code2);
      const p = getProtocol(code2);
      const size = sizeForAddr(p, bytes.slice(i + n));
      if (size === 0) {
        tuples.push([code2]);
        stringTuples.push([code2]);
        i += n;
        continue;
      }
      const addr = bytes.slice(i + n, i + n + size);
      i += size + n;
      if (i > bytes.length) {
        throw new ParseError("Invalid address Uint8Array: " + toString2(bytes, "base16"));
      }
      tuples.push([code2, addr]);
      const stringAddr = convertToString(code2, addr);
      stringTuples.push([code2, stringAddr]);
      if (p.path === true) {
        path = stringAddr;
        break;
      }
    }
    return {
      bytes: Uint8Array.from(bytes),
      string: stringTuplesToString(stringTuples),
      tuples,
      stringTuples,
      path
    };
  }
  function stringTuplesToString(tuples) {
    const parts = [];
    tuples.map((tup) => {
      const proto = getProtocol(tup[0]);
      parts.push(proto.name);
      if (tup.length > 1 && tup[1] != null) {
        parts.push(tup[1]);
      }
      return null;
    });
    return cleanPath(parts.join("/"));
  }
  function tuplesToBytes(tuples) {
    return concat(tuples.map((tup) => {
      const proto = getProtocol(tup[0]);
      let buf = Uint8Array.from(encode5(proto.code));
      if (tup.length > 1 && tup[1] != null) {
        buf = concat([buf, tup[1]]);
      }
      return buf;
    }));
  }
  function sizeForAddr(p, addr) {
    if (p.size > 0) {
      return p.size / 8;
    } else if (p.size === 0) {
      return 0;
    } else {
      const size = decode6(addr instanceof Uint8Array ? addr : Uint8Array.from(addr));
      return size + encodingLength2(size);
    }
  }
  function cleanPath(str) {
    return "/" + str.trim().split("/").filter((a) => a).join("/");
  }
  var ParseError = class extends Error {
    static name = "ParseError";
    name = "ParseError";
    constructor(str) {
      super(`Error parsing address: ${str}`);
    }
  };

  // node_modules/@multiformats/multiaddr/dist/src/multiaddr.js
  var import_browser_shims130 = __toESM(require_browser_shims(), 1);
  var inspect2 = Symbol.for("nodejs.util.inspect.custom");
  var symbol2 = Symbol.for("@multiformats/js-multiaddr/multiaddr");
  var DNS_CODES = [
    getProtocol("dns").code,
    getProtocol("dns4").code,
    getProtocol("dns6").code,
    getProtocol("dnsaddr").code
  ];
  var NoAvailableResolverError = class extends Error {
    constructor(message2 = "No available resolver") {
      super(message2);
      this.name = "NoAvailableResolverError";
    }
  };
  var Multiaddr = class _Multiaddr {
    bytes;
    #string;
    #tuples;
    #stringTuples;
    #path;
    [symbol2] = true;
    constructor(addr) {
      if (addr == null) {
        addr = "";
      }
      let parts;
      if (addr instanceof Uint8Array) {
        parts = bytesToMultiaddrParts(addr);
      } else if (typeof addr === "string") {
        if (addr.length > 0 && addr.charAt(0) !== "/") {
          throw new Error(`multiaddr "${addr}" must start with a "/"`);
        }
        parts = stringToMultiaddrParts(addr);
      } else if (isMultiaddr(addr)) {
        parts = bytesToMultiaddrParts(addr.bytes);
      } else {
        throw new Error("addr must be a string, Buffer, or another Multiaddr");
      }
      this.bytes = parts.bytes;
      this.#string = parts.string;
      this.#tuples = parts.tuples;
      this.#stringTuples = parts.stringTuples;
      this.#path = parts.path;
    }
    toString() {
      return this.#string;
    }
    toJSON() {
      return this.toString();
    }
    toOptions() {
      let family;
      let transport;
      let host;
      let port;
      let zone = "";
      const tcp = getProtocol("tcp");
      const udp = getProtocol("udp");
      const ip4 = getProtocol("ip4");
      const ip6 = getProtocol("ip6");
      const dns6 = getProtocol("dns6");
      const ip6zone = getProtocol("ip6zone");
      for (const [code2, value] of this.stringTuples()) {
        if (code2 === ip6zone.code) {
          zone = `%${value ?? ""}`;
        }
        if (DNS_CODES.includes(code2)) {
          transport = tcp.name === "tcp" ? "tcp" : "udp";
          port = 443;
          host = `${value ?? ""}${zone}`;
          family = code2 === dns6.code ? 6 : 4;
        }
        if (code2 === tcp.code || code2 === udp.code) {
          transport = getProtocol(code2).name === "tcp" ? "tcp" : "udp";
          port = parseInt(value ?? "");
        }
        if (code2 === ip4.code || code2 === ip6.code) {
          transport = getProtocol(code2).name === "tcp" ? "tcp" : "udp";
          host = `${value ?? ""}${zone}`;
          family = code2 === ip6.code ? 6 : 4;
        }
      }
      if (family == null || transport == null || host == null || port == null) {
        throw new Error('multiaddr must have a valid format: "/{ip4, ip6, dns4, dns6, dnsaddr}/{address}/{tcp, udp}/{port}".');
      }
      const opts = {
        family,
        host,
        transport,
        port
      };
      return opts;
    }
    protos() {
      return this.#tuples.map(([code2]) => Object.assign({}, getProtocol(code2)));
    }
    protoCodes() {
      return this.#tuples.map(([code2]) => code2);
    }
    protoNames() {
      return this.#tuples.map(([code2]) => getProtocol(code2).name);
    }
    tuples() {
      return this.#tuples.map(([code2, value]) => {
        if (value == null) {
          return [code2];
        }
        return [code2, value];
      });
    }
    stringTuples() {
      return this.#stringTuples.map(([code2, value]) => {
        if (value == null) {
          return [code2];
        }
        return [code2, value];
      });
    }
    encapsulate(addr) {
      addr = new _Multiaddr(addr);
      return new _Multiaddr(this.toString() + addr.toString());
    }
    decapsulate(addr) {
      const addrString = addr.toString();
      const s2 = this.toString();
      const i = s2.lastIndexOf(addrString);
      if (i < 0) {
        throw new Error(`Address ${this.toString()} does not contain subaddress: ${addr.toString()}`);
      }
      return new _Multiaddr(s2.slice(0, i));
    }
    decapsulateCode(code2) {
      const tuples = this.tuples();
      for (let i = tuples.length - 1; i >= 0; i--) {
        if (tuples[i][0] === code2) {
          return new _Multiaddr(tuplesToBytes(tuples.slice(0, i)));
        }
      }
      return this;
    }
    getPeerId() {
      try {
        let tuples = [];
        this.stringTuples().forEach(([code2, name3]) => {
          if (code2 === names.p2p.code) {
            tuples.push([code2, name3]);
          }
          if (code2 === names["p2p-circuit"].code) {
            tuples = [];
          }
        });
        const tuple = tuples.pop();
        if ((tuple == null ? void 0 : tuple[1]) != null) {
          const peerIdStr = tuple[1];
          if (peerIdStr[0] === "Q" || peerIdStr[0] === "1") {
            return toString2(base58btc.decode(`z${peerIdStr}`), "base58btc");
          }
          return toString2(CID.parse(peerIdStr).multihash.bytes, "base58btc");
        }
        return null;
      } catch (e) {
        return null;
      }
    }
    getPath() {
      return this.#path;
    }
    equals(addr) {
      return equals3(this.bytes, addr.bytes);
    }
    async resolve(options) {
      const resolvableProto = this.protos().find((p) => p.resolvable);
      if (resolvableProto == null) {
        return [this];
      }
      const resolver = resolvers.get(resolvableProto.name);
      if (resolver == null) {
        throw new NoAvailableResolverError(`no available resolver for ${resolvableProto.name}`);
      }
      const result = await resolver(this, options);
      return result.map((str) => multiaddr(str));
    }
    nodeAddress() {
      const options = this.toOptions();
      if (options.transport !== "tcp" && options.transport !== "udp") {
        throw new Error(`multiaddr must have a valid format - no protocol with name: "${options.transport}". Must have a valid transport protocol: "{tcp, udp}"`);
      }
      return {
        family: options.family,
        address: options.host,
        port: options.port
      };
    }
    isThinWaistAddress(addr) {
      const protos = (addr ?? this).protos();
      if (protos.length !== 2) {
        return false;
      }
      if (protos[0].code !== 4 && protos[0].code !== 41) {
        return false;
      }
      if (protos[1].code !== 6 && protos[1].code !== 273) {
        return false;
      }
      return true;
    }
    /**
     * Returns Multiaddr as a human-readable string
     * https://nodejs.org/api/util.html#utilinspectcustom
     *
     * @example
     * ```js
     * import { multiaddr } from '@multiformats/multiaddr'
     *
     * console.info(multiaddr('/ip4/127.0.0.1/tcp/4001'))
     * // 'Multiaddr(/ip4/127.0.0.1/tcp/4001)'
     * ```
     */
    [inspect2]() {
      return `Multiaddr(${this.#string})`;
    }
  };

  // node_modules/@multiformats/multiaddr/dist/src/filter/multiaddr-filter.js
  var import_browser_shims131 = __toESM(require_browser_shims(), 1);

  // node_modules/@multiformats/multiaddr/dist/src/index.js
  var resolvers = /* @__PURE__ */ new Map();
  function isMultiaddr(value) {
    return Boolean(value == null ? void 0 : value[symbol2]);
  }
  function multiaddr(addr) {
    return new Multiaddr(addr);
  }

  // node_modules/@multiformats/multiaddr/dist/src/resolvers/dnsaddr.js
  var MAX_RECURSIVE_DEPTH = 32;
  var { code: dnsaddrCode } = getProtocol("dnsaddr");
  var RecursionLimitError = class extends Error {
    constructor(message2 = "Max recursive depth reached") {
      super(message2);
      this.name = "RecursionLimitError";
    }
  };
  var dnsaddrResolver = async function dnsaddrResolver2(ma, options = {}) {
    const recursionLimit = options.maxRecursiveDepth ?? MAX_RECURSIVE_DEPTH;
    if (recursionLimit === 0) {
      throw new RecursionLimitError("Max recursive depth reached");
    }
    const [, hostname] = ma.stringTuples().find(([proto]) => proto === dnsaddrCode) ?? [];
    const resolver = (options == null ? void 0 : options.dns) ?? dns();
    const result = await resolver.query(`_dnsaddr.${hostname}`, {
      signal: options == null ? void 0 : options.signal,
      types: [
        RecordType.TXT
      ]
    });
    const peerId2 = ma.getPeerId();
    const output = [];
    for (const answer of result.Answer) {
      const addr = answer.data.replace(/["']/g, "").trim().split("=")[1];
      if (addr == null) {
        continue;
      }
      if (peerId2 != null && !addr.includes(peerId2)) {
        continue;
      }
      const ma2 = multiaddr(addr);
      if (addr.startsWith("/dnsaddr")) {
        const resolved = await ma2.resolve({
          ...options,
          maxRecursiveDepth: recursionLimit - 1
        });
        output.push(...resolved.map((ma3) => ma3.toString()));
      } else {
        output.push(ma2.toString());
      }
    }
    return output;
  };

  // node_modules/libp2p/dist/src/config.js
  var DefaultConfig = {
    addresses: {
      listen: [],
      announce: [],
      noAnnounce: [],
      announceFilter: (multiaddrs) => multiaddrs
    },
    connectionManager: {
      resolvers: {
        dnsaddr: dnsaddrResolver
      }
    },
    transportManager: {
      faultTolerance: FaultTolerance.FATAL_ALL
    }
  };
  async function validateConfig(opts) {
    var _a2, _b2;
    const resultingOptions = mergeOptions(DefaultConfig, opts);
    if (resultingOptions.connectionProtector === null && ((_b2 = (_a2 = globalThis.process) == null ? void 0 : _a2.env) == null ? void 0 : _b2.LIBP2P_FORCE_PNET) != null) {
      throw new InvalidParametersError("Private network is enforced, but no protector was provided");
    }
    return resultingOptions;
  }

  // node_modules/libp2p/dist/src/libp2p.js
  var import_browser_shims271 = __toESM(require_browser_shims(), 1);

  // node_modules/@libp2p/logger/dist/src/index.js
  var import_browser_shims140 = __toESM(require_browser_shims(), 1);

  // node_modules/weald/dist/src/index.js
  var import_browser_shims139 = __toESM(require_browser_shims(), 1);

  // node_modules/weald/dist/src/browser.js
  var import_browser_shims138 = __toESM(require_browser_shims(), 1);

  // node_modules/weald/node_modules/ms/dist/index.mjs
  var import_browser_shims136 = __toESM(require_browser_shims(), 1);
  var s = 1e3;
  var m = s * 60;
  var h = m * 60;
  var d = h * 24;
  var w = d * 7;
  var y = d * 365.25;
  function ms(value, options) {
    try {
      if (typeof value === "string" && value.length > 0) {
        return parse(value);
      } else if (typeof value === "number" && isFinite(value)) {
        return (options == null ? void 0 : options.long) ? fmtLong(value) : fmtShort(value);
      }
      throw new Error("Value is not a string or number.");
    } catch (error) {
      const message2 = isError(error) ? `${error.message}. value=${JSON.stringify(value)}` : "An unknown error has occured.";
      throw new Error(message2);
    }
  }
  function parse(str) {
    str = String(str);
    if (str.length > 100) {
      throw new Error("Value exceeds the maximum length of 100 characters.");
    }
    const match = /^(-?(?:\d+)?\.?\d+) *(milliseconds?|msecs?|ms|seconds?|secs?|s|minutes?|mins?|m|hours?|hrs?|h|days?|d|weeks?|w|years?|yrs?|y)?$/i.exec(str);
    if (!match) {
      return NaN;
    }
    const n = parseFloat(match[1]);
    const type = (match[2] || "ms").toLowerCase();
    switch (type) {
      case "years":
      case "year":
      case "yrs":
      case "yr":
      case "y":
        return n * y;
      case "weeks":
      case "week":
      case "w":
        return n * w;
      case "days":
      case "day":
      case "d":
        return n * d;
      case "hours":
      case "hour":
      case "hrs":
      case "hr":
      case "h":
        return n * h;
      case "minutes":
      case "minute":
      case "mins":
      case "min":
      case "m":
        return n * m;
      case "seconds":
      case "second":
      case "secs":
      case "sec":
      case "s":
        return n * s;
      case "milliseconds":
      case "millisecond":
      case "msecs":
      case "msec":
      case "ms":
        return n;
      default:
        throw new Error(`The unit ${type} was matched, but no matching case exists.`);
    }
  }
  var dist_default = ms;
  function fmtShort(ms2) {
    const msAbs = Math.abs(ms2);
    if (msAbs >= d) {
      return `${Math.round(ms2 / d)}d`;
    }
    if (msAbs >= h) {
      return `${Math.round(ms2 / h)}h`;
    }
    if (msAbs >= m) {
      return `${Math.round(ms2 / m)}m`;
    }
    if (msAbs >= s) {
      return `${Math.round(ms2 / s)}s`;
    }
    return `${ms2}ms`;
  }
  function fmtLong(ms2) {
    const msAbs = Math.abs(ms2);
    if (msAbs >= d) {
      return plural(ms2, msAbs, d, "day");
    }
    if (msAbs >= h) {
      return plural(ms2, msAbs, h, "hour");
    }
    if (msAbs >= m) {
      return plural(ms2, msAbs, m, "minute");
    }
    if (msAbs >= s) {
      return plural(ms2, msAbs, s, "second");
    }
    return `${ms2} ms`;
  }
  function plural(ms2, msAbs, n, name3) {
    const isPlural = msAbs >= n * 1.5;
    return `${Math.round(ms2 / n)} ${name3}${isPlural ? "s" : ""}`;
  }
  function isError(error) {
    return typeof error === "object" && error !== null && "message" in error;
  }

  // node_modules/weald/dist/src/common.js
  var import_browser_shims137 = __toESM(require_browser_shims(), 1);
  function setup(env) {
    createDebug.debug = createDebug;
    createDebug.default = createDebug;
    createDebug.coerce = coerce2;
    createDebug.disable = disable;
    createDebug.enable = enable;
    createDebug.enabled = enabled;
    createDebug.humanize = dist_default;
    createDebug.destroy = destroy;
    Object.keys(env).forEach((key) => {
      createDebug[key] = env[key];
    });
    createDebug.names = [];
    createDebug.skips = [];
    createDebug.formatters = {};
    function selectColor(namespace) {
      let hash = 0;
      for (let i = 0; i < namespace.length; i++) {
        hash = (hash << 5) - hash + namespace.charCodeAt(i);
        hash |= 0;
      }
      return createDebug.colors[Math.abs(hash) % createDebug.colors.length];
    }
    createDebug.selectColor = selectColor;
    function createDebug(namespace) {
      let prevTime;
      let enableOverride = null;
      let namespacesCache;
      let enabledCache;
      function debug(...args) {
        if (!debug.enabled) {
          return;
        }
        const self = debug;
        const curr = Number(/* @__PURE__ */ new Date());
        const ms2 = curr - (prevTime || curr);
        self.diff = ms2;
        self.prev = prevTime;
        self.curr = curr;
        prevTime = curr;
        args[0] = createDebug.coerce(args[0]);
        if (typeof args[0] !== "string") {
          args.unshift("%O");
        }
        let index = 0;
        args[0] = args[0].replace(/%([a-zA-Z%])/g, (match, format2) => {
          if (match === "%%") {
            return "%";
          }
          index++;
          const formatter = createDebug.formatters[format2];
          if (typeof formatter === "function") {
            const val = args[index];
            match = formatter.call(self, val);
            args.splice(index, 1);
            index--;
          }
          return match;
        });
        createDebug.formatArgs.call(self, args);
        const logFn = self.log || createDebug.log;
        logFn.apply(self, args);
      }
      debug.namespace = namespace;
      debug.useColors = createDebug.useColors();
      debug.color = createDebug.selectColor(namespace);
      debug.extend = extend;
      debug.destroy = createDebug.destroy;
      Object.defineProperty(debug, "enabled", {
        enumerable: true,
        configurable: false,
        get: () => {
          if (enableOverride !== null) {
            return enableOverride;
          }
          if (namespacesCache !== createDebug.namespaces) {
            namespacesCache = createDebug.namespaces;
            enabledCache = createDebug.enabled(namespace);
          }
          return enabledCache;
        },
        set: (v) => {
          enableOverride = v;
        }
      });
      if (typeof createDebug.init === "function") {
        createDebug.init(debug);
      }
      return debug;
    }
    function extend(namespace, delimiter) {
      const newDebug = createDebug(this.namespace + (typeof delimiter === "undefined" ? ":" : delimiter) + namespace);
      newDebug.log = this.log;
      return newDebug;
    }
    function enable(namespaces) {
      createDebug.save(namespaces);
      createDebug.namespaces = namespaces;
      createDebug.names = [];
      createDebug.skips = [];
      let i;
      const split2 = (typeof namespaces === "string" ? namespaces : "").split(/[\s,]+/);
      const len = split2.length;
      for (i = 0; i < len; i++) {
        if (!split2[i]) {
          continue;
        }
        namespaces = split2[i].replace(/\*/g, ".*?");
        if (namespaces[0] === "-") {
          createDebug.skips.push(new RegExp("^" + namespaces.substr(1) + "$"));
        } else {
          createDebug.names.push(new RegExp("^" + namespaces + "$"));
        }
      }
    }
    function disable() {
      const namespaces = [
        ...createDebug.names.map(toNamespace),
        ...createDebug.skips.map(toNamespace).map((namespace) => "-" + namespace)
      ].join(",");
      createDebug.enable("");
      return namespaces;
    }
    function enabled(name3) {
      if (name3[name3.length - 1] === "*") {
        return true;
      }
      let i;
      let len;
      for (i = 0, len = createDebug.skips.length; i < len; i++) {
        if (createDebug.skips[i].test(name3)) {
          return false;
        }
      }
      for (i = 0, len = createDebug.names.length; i < len; i++) {
        if (createDebug.names[i].test(name3)) {
          return true;
        }
      }
      return false;
    }
    function toNamespace(regexp) {
      return regexp.toString().substring(2, regexp.toString().length - 2).replace(/\.\*\?$/, "*");
    }
    function coerce2(val) {
      if (val instanceof Error) {
        return val.stack ?? val.message;
      }
      return val;
    }
    function destroy() {
      console.warn("Instance method `debug.destroy()` is deprecated and no longer does anything. It will be removed in the next major version of `debug`.");
    }
    createDebug.setupFormatters(createDebug.formatters);
    createDebug.enable(createDebug.load());
    return createDebug;
  }

  // node_modules/weald/dist/src/browser.js
  var storage = localstorage();
  var colors = [
    "#0000CC",
    "#0000FF",
    "#0033CC",
    "#0033FF",
    "#0066CC",
    "#0066FF",
    "#0099CC",
    "#0099FF",
    "#00CC00",
    "#00CC33",
    "#00CC66",
    "#00CC99",
    "#00CCCC",
    "#00CCFF",
    "#3300CC",
    "#3300FF",
    "#3333CC",
    "#3333FF",
    "#3366CC",
    "#3366FF",
    "#3399CC",
    "#3399FF",
    "#33CC00",
    "#33CC33",
    "#33CC66",
    "#33CC99",
    "#33CCCC",
    "#33CCFF",
    "#6600CC",
    "#6600FF",
    "#6633CC",
    "#6633FF",
    "#66CC00",
    "#66CC33",
    "#9900CC",
    "#9900FF",
    "#9933CC",
    "#9933FF",
    "#99CC00",
    "#99CC33",
    "#CC0000",
    "#CC0033",
    "#CC0066",
    "#CC0099",
    "#CC00CC",
    "#CC00FF",
    "#CC3300",
    "#CC3333",
    "#CC3366",
    "#CC3399",
    "#CC33CC",
    "#CC33FF",
    "#CC6600",
    "#CC6633",
    "#CC9900",
    "#CC9933",
    "#CCCC00",
    "#CCCC33",
    "#FF0000",
    "#FF0033",
    "#FF0066",
    "#FF0099",
    "#FF00CC",
    "#FF00FF",
    "#FF3300",
    "#FF3333",
    "#FF3366",
    "#FF3399",
    "#FF33CC",
    "#FF33FF",
    "#FF6600",
    "#FF6633",
    "#FF9900",
    "#FF9933",
    "#FFCC00",
    "#FFCC33"
  ];
  function useColors() {
    var _a2, _b2, _c, _d, _e;
    if (typeof window !== "undefined" && window.process && (window.process.type === "renderer" || window.process.__nwjs)) {
      return true;
    }
    if (typeof navigator !== "undefined" && ((_a2 = navigator.userAgent) == null ? void 0 : _a2.toLowerCase().match(/(edge|trident)\/(\d+)/)) != null) {
      return false;
    }
    return typeof document !== "undefined" && ((_c = (_b2 = document.documentElement) == null ? void 0 : _b2.style) == null ? void 0 : _c.WebkitAppearance) || // Is firebug? http://stackoverflow.com/a/398120/376773
    // @ts-expect-error window.console.firebug and window.console.exception are not in the types
    typeof window !== "undefined" && window.console && (window.console.firebug || window.console.exception && window.console.table) || // Is firefox >= v31?
    // https://developer.mozilla.org/en-US/docs/Tools/Web_Console#Styling_messages
    typeof navigator !== "undefined" && ((_d = navigator.userAgent) == null ? void 0 : _d.toLowerCase().match(/firefox\/(\d+)/)) != null && parseInt(RegExp.$1, 10) >= 31 || // Double check webkit in userAgent just in case we are in a worker
    typeof navigator !== "undefined" && ((_e = navigator.userAgent) == null ? void 0 : _e.toLowerCase().match(/applewebkit\/(\d+)/));
  }
  function formatArgs(args) {
    args[0] = (this.useColors ? "%c" : "") + this.namespace + (this.useColors ? " %c" : " ") + args[0] + (this.useColors ? "%c " : " ") + "+" + dist_default(this.diff);
    if (!this.useColors) {
      return;
    }
    const c = "color: " + this.color;
    args.splice(1, 0, c, "color: inherit");
    let index = 0;
    let lastC = 0;
    args[0].replace(/%[a-zA-Z%]/g, (match) => {
      if (match === "%%") {
        return;
      }
      index++;
      if (match === "%c") {
        lastC = index;
      }
    });
    args.splice(lastC, 0, c);
  }
  var log = console.debug ?? console.log ?? (() => {
  });
  function save(namespaces) {
    try {
      if (namespaces) {
        storage == null ? void 0 : storage.setItem("debug", namespaces);
      } else {
        storage == null ? void 0 : storage.removeItem("debug");
      }
    } catch (error) {
    }
  }
  function load() {
    let r;
    try {
      r = storage == null ? void 0 : storage.getItem("debug");
    } catch (error) {
    }
    if (!r && typeof globalThis.process !== "undefined" && "env" in globalThis.process) {
      r = globalThis.process.env.DEBUG;
    }
    return r;
  }
  function localstorage() {
    try {
      return localStorage;
    } catch (error) {
    }
  }
  function setupFormatters(formatters) {
    formatters.j = function(v) {
      try {
        return JSON.stringify(v);
      } catch (error) {
        return "[UnexpectedJSONParseError]: " + error.message;
      }
    };
  }
  var browser_default = setup({ formatArgs, save, load, useColors, setupFormatters, colors, storage, log });

  // node_modules/weald/dist/src/index.js
  var src_default = browser_default;

  // node_modules/@libp2p/logger/dist/src/index.js
  src_default.formatters.b = (v) => {
    return v == null ? "undefined" : base58btc.baseEncode(v);
  };
  src_default.formatters.t = (v) => {
    return v == null ? "undefined" : base32.baseEncode(v);
  };
  src_default.formatters.m = (v) => {
    return v == null ? "undefined" : base64.baseEncode(v);
  };
  src_default.formatters.p = (v) => {
    return v == null ? "undefined" : v.toString();
  };
  src_default.formatters.c = (v) => {
    return v == null ? "undefined" : v.toString();
  };
  src_default.formatters.k = (v) => {
    return v == null ? "undefined" : v.toString();
  };
  src_default.formatters.a = (v) => {
    return v == null ? "undefined" : v.toString();
  };
  src_default.formatters.e = (v) => {
    return v == null ? "undefined" : notEmpty(v.stack) ?? notEmpty(v.message) ?? v.toString();
  };
  function createDisabledLogger(namespace) {
    const logger2 = () => {
    };
    logger2.enabled = false;
    logger2.color = "";
    logger2.diff = 0;
    logger2.log = () => {
    };
    logger2.namespace = namespace;
    logger2.destroy = () => true;
    logger2.extend = () => logger2;
    return logger2;
  }
  function defaultLogger() {
    return {
      forComponent(name3) {
        return logger(name3);
      }
    };
  }
  function logger(name3) {
    let trace = createDisabledLogger(`${name3}:trace`);
    if (src_default.enabled(`${name3}:trace`) && src_default.names.map((r) => r.toString()).find((n) => n.includes(":trace")) != null) {
      trace = src_default(`${name3}:trace`);
    }
    return Object.assign(src_default(name3), {
      error: src_default(`${name3}:error`),
      trace
    });
  }
  function notEmpty(str) {
    if (str == null) {
      return;
    }
    str = str.trim();
    if (str.length === 0) {
      return;
    }
    return str;
  }

  // node_modules/@libp2p/peer-collections/dist/src/index.js
  var import_browser_shims154 = __toESM(require_browser_shims(), 1);

  // node_modules/@libp2p/peer-collections/dist/src/map.js
  var import_browser_shims142 = __toESM(require_browser_shims(), 1);

  // node_modules/@libp2p/peer-collections/dist/src/util.js
  var import_browser_shims141 = __toESM(require_browser_shims(), 1);
  function mapIterable(iter, map3) {
    const iterator = {
      [Symbol.iterator]: () => {
        return iterator;
      },
      next: () => {
        const next = iter.next();
        const val = next.value;
        if (next.done === true || val == null) {
          const result = {
            done: true,
            value: void 0
          };
          return result;
        }
        return {
          done: false,
          value: map3(val)
        };
      }
    };
    return iterator;
  }
  function peerIdFromString2(str) {
    const multihash = decode4(base58btc.decode(`z${str}`));
    return peerIdFromMultihash(multihash);
  }

  // node_modules/@libp2p/peer-collections/dist/src/map.js
  var PeerMap = class {
    map;
    constructor(map3) {
      this.map = /* @__PURE__ */ new Map();
      if (map3 != null) {
        for (const [key, value] of map3.entries()) {
          this.map.set(key.toString(), { key, value });
        }
      }
    }
    [Symbol.iterator]() {
      return this.entries();
    }
    clear() {
      this.map.clear();
    }
    delete(peer) {
      return this.map.delete(peer.toString());
    }
    entries() {
      return mapIterable(this.map.entries(), (val) => {
        return [val[1].key, val[1].value];
      });
    }
    forEach(fn) {
      this.map.forEach((value, key) => {
        fn(value.value, value.key, this);
      });
    }
    get(peer) {
      var _a2;
      return (_a2 = this.map.get(peer.toString())) == null ? void 0 : _a2.value;
    }
    has(peer) {
      return this.map.has(peer.toString());
    }
    set(peer, value) {
      this.map.set(peer.toString(), { key: peer, value });
    }
    keys() {
      return mapIterable(this.map.values(), (val) => {
        return val.key;
      });
    }
    values() {
      return mapIterable(this.map.values(), (val) => val.value);
    }
    get size() {
      return this.map.size;
    }
  };

  // node_modules/@libp2p/peer-collections/dist/src/set.js
  var import_browser_shims143 = __toESM(require_browser_shims(), 1);
  var PeerSet = class _PeerSet {
    set;
    constructor(set) {
      this.set = /* @__PURE__ */ new Set();
      if (set != null) {
        for (const key of set) {
          this.set.add(key.toString());
        }
      }
    }
    get size() {
      return this.set.size;
    }
    [Symbol.iterator]() {
      return this.values();
    }
    add(peer) {
      this.set.add(peer.toString());
    }
    clear() {
      this.set.clear();
    }
    delete(peer) {
      this.set.delete(peer.toString());
    }
    entries() {
      return mapIterable(this.set.entries(), (val) => {
        const peerId2 = peerIdFromString2(val[0]);
        return [peerId2, peerId2];
      });
    }
    forEach(predicate) {
      this.set.forEach((str) => {
        const peerId2 = peerIdFromString2(str);
        predicate(peerId2, peerId2, this);
      });
    }
    has(peer) {
      return this.set.has(peer.toString());
    }
    values() {
      return mapIterable(this.set.values(), (val) => {
        return peerIdFromString2(val);
      });
    }
    intersection(other) {
      const output = new _PeerSet();
      for (const peerId2 of other) {
        if (this.has(peerId2)) {
          output.add(peerId2);
        }
      }
      return output;
    }
    difference(other) {
      const output = new _PeerSet();
      for (const peerId2 of this) {
        if (!other.has(peerId2)) {
          output.add(peerId2);
        }
      }
      return output;
    }
    union(other) {
      const output = new _PeerSet();
      for (const peerId2 of other) {
        output.add(peerId2);
      }
      for (const peerId2 of this) {
        output.add(peerId2);
      }
      return output;
    }
  };

  // node_modules/@libp2p/utils/dist/src/filters/index.js
  var import_browser_shims152 = __toESM(require_browser_shims(), 1);

  // node_modules/@libp2p/crypto/dist/src/index.js
  var import_browser_shims144 = __toESM(require_browser_shims(), 1);

  // node_modules/@libp2p/utils/dist/src/filters/hashes.js
  var import_browser_shims146 = __toESM(require_browser_shims(), 1);

  // node_modules/@sindresorhus/fnv1a/index.js
  var import_browser_shims145 = __toESM(require_browser_shims(), 1);
  var FNV_PRIMES = {
    32: 16777619n,
    64: 1099511628211n,
    128: 309485009821345068724781371n,
    256: 374144419156711147060143317175368453031918731002211n,
    512: 35835915874844867368919076489095108449946327955754392558399825615420669938882575126094039892345713852759n,
    1024: 5016456510113118655434598811035278955030765345404790744303017523831112055108147451509157692220295382716162651878526895249385292291816524375083746691371804094271873160484737966720260389217684476157468082573n
  };
  var FNV_OFFSETS = {
    32: 2166136261n,
    64: 14695981039346656037n,
    128: 144066263297769815596495629667062367629n,
    256: 100029257958052580907070968620625704837092796014241193945225284501741471925557n,
    512: 9659303129496669498009435400716310466090418745672637896108374329434462657994582932197716438449813051892206539805784495328239340083876191928701583869517785n,
    1024: 14197795064947621068722070641403218320880622795441933960878474914617582723252296732303717722150864096521202355549365628174669108571814760471015076148029755969804077320157692458563003215304957150157403644460363550505412711285966361610267868082893823963790439336411086884584107735010676915n
  };
  var cachedEncoder = new globalThis.TextEncoder();
  function fnv1aUint8Array(uint8Array, size) {
    const fnvPrime = FNV_PRIMES[size];
    let hash = FNV_OFFSETS[size];
    for (let index = 0; index < uint8Array.length; index++) {
      hash ^= BigInt(uint8Array[index]);
      hash = BigInt.asUintN(size, hash * fnvPrime);
    }
    return hash;
  }
  function fnv1aEncodeInto(string3, size, utf8Buffer) {
    if (utf8Buffer.length === 0) {
      throw new Error("The `utf8Buffer` option must have a length greater than zero");
    }
    const fnvPrime = FNV_PRIMES[size];
    let hash = FNV_OFFSETS[size];
    let remaining = string3;
    while (remaining.length > 0) {
      const result = cachedEncoder.encodeInto(remaining, utf8Buffer);
      remaining = remaining.slice(result.read);
      for (let index = 0; index < result.written; index++) {
        hash ^= BigInt(utf8Buffer[index]);
        hash = BigInt.asUintN(size, hash * fnvPrime);
      }
    }
    return hash;
  }
  function fnv1a(value, { size = 32, utf8Buffer } = {}) {
    if (!FNV_PRIMES[size]) {
      throw new Error("The `size` option must be one of 32, 64, 128, 256, 512, or 1024");
    }
    if (typeof value === "string") {
      if (utf8Buffer) {
        return fnv1aEncodeInto(value, size, utf8Buffer);
      }
      value = cachedEncoder.encode(value);
    }
    return fnv1aUint8Array(value, size);
  }

  // node_modules/@libp2p/utils/dist/src/filters/hashes.js
  var fnv1a2 = {
    hash: (input) => {
      return Number(fnv1a(input, {
        size: 32
      }));
    },
    hashV: (input, seed) => {
      return numberToBuffer(fnv1a2.hash(input, seed));
    }
  };
  function numberToBuffer(num) {
    let hex = num.toString(16);
    if (hex.length % 2 === 1) {
      hex = `0${hex}`;
    }
    return fromString2(hex, "base16");
  }

  // node_modules/@libp2p/utils/dist/src/filters/cuckoo-filter.js
  var import_browser_shims150 = __toESM(require_browser_shims(), 1);

  // node_modules/@libp2p/utils/dist/src/filters/bucket.js
  var import_browser_shims149 = __toESM(require_browser_shims(), 1);

  // node_modules/@libp2p/utils/dist/src/filters/fingerprint.js
  var import_browser_shims147 = __toESM(require_browser_shims(), 1);
  var MAX_FINGERPRINT_SIZE = 64;
  var Fingerprint = class {
    fp;
    h;
    seed;
    constructor(buf, hash, seed, fingerprintSize = 2) {
      if (fingerprintSize > MAX_FINGERPRINT_SIZE) {
        throw new TypeError("Invalid Fingerprint Size");
      }
      const fnv = hash.hashV(buf, seed);
      const fp = alloc(fingerprintSize);
      for (let i = 0; i < fp.length; i++) {
        fp[i] = fnv[i];
      }
      if (fp.length === 0) {
        fp[0] = 7;
      }
      this.fp = fp;
      this.h = hash;
      this.seed = seed;
    }
    hash() {
      return this.h.hash(this.fp, this.seed);
    }
    equals(other) {
      if (!((other == null ? void 0 : other.fp) instanceof Uint8Array)) {
        return false;
      }
      return equals3(this.fp, other.fp);
    }
  };

  // node_modules/@libp2p/utils/dist/src/filters/utils.js
  var import_browser_shims148 = __toESM(require_browser_shims(), 1);
  function getRandomInt(min, max) {
    return Math.floor(Math.random() * (max - min)) + min;
  }

  // node_modules/@libp2p/utils/dist/src/filters/bucket.js
  var Bucket = class {
    contents;
    constructor(size) {
      this.contents = new Array(size).fill(null);
    }
    has(fingerprint) {
      if (!(fingerprint instanceof Fingerprint)) {
        throw new TypeError("Invalid Fingerprint");
      }
      return this.contents.some((fp) => {
        return fingerprint.equals(fp);
      });
    }
    add(fingerprint) {
      if (!(fingerprint instanceof Fingerprint)) {
        throw new TypeError("Invalid Fingerprint");
      }
      for (let i = 0; i < this.contents.length; i++) {
        if (this.contents[i] == null) {
          this.contents[i] = fingerprint;
          return true;
        }
      }
      return true;
    }
    swap(fingerprint) {
      if (!(fingerprint instanceof Fingerprint)) {
        throw new TypeError("Invalid Fingerprint");
      }
      const i = getRandomInt(0, this.contents.length - 1);
      const current = this.contents[i];
      this.contents[i] = fingerprint;
      return current;
    }
    remove(fingerprint) {
      if (!(fingerprint instanceof Fingerprint)) {
        throw new TypeError("Invalid Fingerprint");
      }
      const found = this.contents.findIndex((fp) => {
        return fingerprint.equals(fp);
      });
      if (found > -1) {
        this.contents[found] = null;
        return true;
      } else {
        return false;
      }
    }
  };

  // node_modules/@libp2p/utils/dist/src/filters/cuckoo-filter.js
  var maxCuckooCount = 500;
  var CuckooFilter = class {
    bucketSize;
    filterSize;
    fingerprintSize;
    buckets;
    count;
    hash;
    seed;
    constructor(init) {
      this.filterSize = init.filterSize;
      this.bucketSize = init.bucketSize ?? 4;
      this.fingerprintSize = init.fingerprintSize ?? 2;
      this.count = 0;
      this.buckets = [];
      this.hash = init.hash ?? fnv1a2;
      this.seed = init.seed ?? getRandomInt(0, Math.pow(2, 10));
    }
    add(item) {
      if (typeof item === "string") {
        item = fromString2(item);
      }
      const fingerprint = new Fingerprint(item, this.hash, this.seed, this.fingerprintSize);
      const j = this.hash.hash(item, this.seed) % this.filterSize;
      const k = (j ^ fingerprint.hash()) % this.filterSize;
      if (this.buckets[j] == null) {
        this.buckets[j] = new Bucket(this.bucketSize);
      }
      if (this.buckets[k] == null) {
        this.buckets[k] = new Bucket(this.bucketSize);
      }
      if (this.buckets[j].add(fingerprint) || this.buckets[k].add(fingerprint)) {
        this.count++;
        return true;
      }
      const rand = [j, k];
      let i = rand[getRandomInt(0, rand.length - 1)];
      if (this.buckets[i] == null) {
        this.buckets[i] = new Bucket(this.bucketSize);
      }
      for (let n = 0; n < maxCuckooCount; n++) {
        const swapped = this.buckets[i].swap(fingerprint);
        if (swapped == null) {
          continue;
        }
        i = (i ^ swapped.hash()) % this.filterSize;
        if (this.buckets[i] == null) {
          this.buckets[i] = new Bucket(this.bucketSize);
        }
        if (this.buckets[i].add(swapped)) {
          this.count++;
          return true;
        } else {
          continue;
        }
      }
      return false;
    }
    has(item) {
      var _a2, _b2;
      if (typeof item === "string") {
        item = fromString2(item);
      }
      const fingerprint = new Fingerprint(item, this.hash, this.seed, this.fingerprintSize);
      const j = this.hash.hash(item, this.seed) % this.filterSize;
      const inJ = ((_a2 = this.buckets[j]) == null ? void 0 : _a2.has(fingerprint)) ?? false;
      if (inJ) {
        return inJ;
      }
      const k = (j ^ fingerprint.hash()) % this.filterSize;
      return ((_b2 = this.buckets[k]) == null ? void 0 : _b2.has(fingerprint)) ?? false;
    }
    remove(item) {
      var _a2, _b2;
      if (typeof item === "string") {
        item = fromString2(item);
      }
      const fingerprint = new Fingerprint(item, this.hash, this.seed, this.fingerprintSize);
      const j = this.hash.hash(item, this.seed) % this.filterSize;
      const inJ = ((_a2 = this.buckets[j]) == null ? void 0 : _a2.remove(fingerprint)) ?? false;
      if (inJ) {
        this.count--;
        return inJ;
      }
      const k = (j ^ fingerprint.hash()) % this.filterSize;
      const inK = ((_b2 = this.buckets[k]) == null ? void 0 : _b2.remove(fingerprint)) ?? false;
      if (inK) {
        this.count--;
      }
      return inK;
    }
    get reliable() {
      return Math.floor(100 * (this.count / this.filterSize)) <= 90;
    }
  };
  var MAX_LOAD = {
    1: 0.5,
    2: 0.84,
    4: 0.95,
    8: 0.98
  };
  function calculateBucketSize(errorRate = 1e-3) {
    if (errorRate > 2e-3) {
      return 2;
    }
    if (errorRate > 1e-5) {
      return 4;
    }
    return 8;
  }
  function optimize(maxItems, errorRate = 1e-3) {
    const bucketSize = calculateBucketSize(errorRate);
    const load2 = MAX_LOAD[bucketSize];
    const filterSize = Math.round(maxItems / load2);
    const fingerprintSize = Math.min(Math.ceil(Math.log2(1 / errorRate) + Math.log2(2 * bucketSize)), MAX_FINGERPRINT_SIZE);
    return {
      filterSize,
      bucketSize,
      fingerprintSize
    };
  }

  // node_modules/@libp2p/utils/dist/src/filters/scalable-cuckoo-filter.js
  var import_browser_shims151 = __toESM(require_browser_shims(), 1);
  var ScalableCuckooFilter = class {
    filterSize;
    bucketSize;
    fingerprintSize;
    scale;
    filterSeries;
    hash;
    seed;
    constructor(init) {
      this.bucketSize = init.bucketSize ?? 4;
      this.filterSize = init.filterSize ?? (1 << 18) / this.bucketSize;
      this.fingerprintSize = init.fingerprintSize ?? 2;
      this.scale = init.scale ?? 2;
      this.hash = init.hash ?? fnv1a2;
      this.seed = init.seed ?? getRandomInt(0, Math.pow(2, 10));
      this.filterSeries = [
        new CuckooFilter({
          filterSize: this.filterSize,
          bucketSize: this.bucketSize,
          fingerprintSize: this.fingerprintSize,
          hash: this.hash,
          seed: this.seed
        })
      ];
    }
    add(item) {
      if (typeof item === "string") {
        item = fromString2(item);
      }
      if (this.has(item)) {
        return true;
      }
      let current = this.filterSeries.find((cuckoo) => {
        return cuckoo.reliable;
      });
      if (current == null) {
        const curSize = this.filterSize * Math.pow(this.scale, this.filterSeries.length);
        current = new CuckooFilter({
          filterSize: curSize,
          bucketSize: this.bucketSize,
          fingerprintSize: this.fingerprintSize,
          hash: this.hash,
          seed: this.seed
        });
        this.filterSeries.push(current);
      }
      return current.add(item);
    }
    has(item) {
      if (typeof item === "string") {
        item = fromString2(item);
      }
      for (let i = 0; i < this.filterSeries.length; i++) {
        if (this.filterSeries[i].has(item)) {
          return true;
        }
      }
      return false;
    }
    remove(item) {
      if (typeof item === "string") {
        item = fromString2(item);
      }
      for (let i = 0; i < this.filterSeries.length; i++) {
        if (this.filterSeries[i].remove(item)) {
          return true;
        }
      }
      return false;
    }
    get count() {
      return this.filterSeries.reduce((acc, curr) => {
        return acc + curr.count;
      }, 0);
    }
  };
  function createScalableCuckooFilter(maxItems, errorRate = 1e-3, options) {
    return new ScalableCuckooFilter({
      ...optimize(maxItems, errorRate),
      ...options ?? {}
    });
  }

  // node_modules/@libp2p/peer-collections/dist/src/tracked-map.js
  var import_browser_shims153 = __toESM(require_browser_shims(), 1);
  var TrackedPeerMap = class extends PeerMap {
    metric;
    constructor(init) {
      super();
      const { name: name3, metrics } = init;
      this.metric = metrics.registerMetric(name3);
      this.updateComponentMetric();
    }
    set(key, value) {
      super.set(key, value);
      this.updateComponentMetric();
      return this;
    }
    delete(key) {
      const deleted = super.delete(key);
      this.updateComponentMetric();
      return deleted;
    }
    clear() {
      super.clear();
      this.updateComponentMetric();
    }
    updateComponentMetric() {
      this.metric.update(this.size);
    }
  };
  function trackedPeerMap(config) {
    const { name: name3, metrics } = config;
    let map3;
    if (metrics != null) {
      map3 = new TrackedPeerMap({ name: name3, metrics });
    } else {
      map3 = new PeerMap();
    }
    return map3;
  }

  // node_modules/@libp2p/peer-store/dist/src/index.js
  var import_browser_shims191 = __toESM(require_browser_shims(), 1);

  // node_modules/@libp2p/peer-record/dist/src/index.js
  var import_browser_shims162 = __toESM(require_browser_shims(), 1);

  // node_modules/@libp2p/peer-record/dist/src/envelope/index.js
  var import_browser_shims157 = __toESM(require_browser_shims(), 1);

  // node_modules/@libp2p/peer-record/dist/src/envelope/envelope.js
  var import_browser_shims155 = __toESM(require_browser_shims(), 1);
  var Envelope;
  (function(Envelope2) {
    let _codec;
    Envelope2.codec = () => {
      if (_codec == null) {
        _codec = message((obj, w2, opts = {}) => {
          if (opts.lengthDelimited !== false) {
            w2.fork();
          }
          if (obj.publicKey != null && obj.publicKey.byteLength > 0) {
            w2.uint32(10);
            w2.bytes(obj.publicKey);
          }
          if (obj.payloadType != null && obj.payloadType.byteLength > 0) {
            w2.uint32(18);
            w2.bytes(obj.payloadType);
          }
          if (obj.payload != null && obj.payload.byteLength > 0) {
            w2.uint32(26);
            w2.bytes(obj.payload);
          }
          if (obj.signature != null && obj.signature.byteLength > 0) {
            w2.uint32(42);
            w2.bytes(obj.signature);
          }
          if (opts.lengthDelimited !== false) {
            w2.ldelim();
          }
        }, (reader, length4, opts = {}) => {
          const obj = {
            publicKey: alloc(0),
            payloadType: alloc(0),
            payload: alloc(0),
            signature: alloc(0)
          };
          const end = length4 == null ? reader.len : reader.pos + length4;
          while (reader.pos < end) {
            const tag = reader.uint32();
            switch (tag >>> 3) {
              case 1: {
                obj.publicKey = reader.bytes();
                break;
              }
              case 2: {
                obj.payloadType = reader.bytes();
                break;
              }
              case 3: {
                obj.payload = reader.bytes();
                break;
              }
              case 5: {
                obj.signature = reader.bytes();
                break;
              }
              default: {
                reader.skipType(tag & 7);
                break;
              }
            }
          }
          return obj;
        });
      }
      return _codec;
    };
    Envelope2.encode = (obj) => {
      return encodeMessage(obj, Envelope2.codec());
    };
    Envelope2.decode = (buf, opts) => {
      return decodeMessage(buf, Envelope2.codec(), opts);
    };
  })(Envelope || (Envelope = {}));

  // node_modules/@libp2p/peer-record/dist/src/envelope/errors.js
  var import_browser_shims156 = __toESM(require_browser_shims(), 1);
  var InvalidSignatureError = class extends Error {
    constructor(message2 = "Invalid signature") {
      super(message2);
      this.name = "InvalidSignatureError";
    }
  };

  // node_modules/@libp2p/peer-record/dist/src/envelope/index.js
  var RecordEnvelope = class _RecordEnvelope {
    /**
     * Unmarshal a serialized Envelope protobuf message
     */
    static createFromProtobuf = (data) => {
      const envelopeData = Envelope.decode(data);
      const publicKey = publicKeyFromProtobuf(envelopeData.publicKey);
      return new _RecordEnvelope({
        publicKey,
        payloadType: envelopeData.payloadType,
        payload: envelopeData.payload,
        signature: envelopeData.signature
      });
    };
    /**
     * Seal marshals the given Record, places the marshaled bytes inside an Envelope
     * and signs it with the given peerId's private key
     */
    static seal = async (record, privateKey, options) => {
      if (privateKey == null) {
        throw new Error("Missing private key");
      }
      const domain = record.domain;
      const payloadType = record.codec;
      const payload = record.marshal();
      const signData = formatSignaturePayload(domain, payloadType, payload);
      const signature = await privateKey.sign(signData.subarray(), options);
      return new _RecordEnvelope({
        publicKey: privateKey.publicKey,
        payloadType,
        payload,
        signature
      });
    };
    /**
     * Open and certify a given marshaled envelope.
     * Data is unmarshaled and the signature validated for the given domain.
     */
    static openAndCertify = async (data, domain, options) => {
      const envelope = _RecordEnvelope.createFromProtobuf(data);
      const valid = await envelope.validate(domain, options);
      if (!valid) {
        throw new InvalidSignatureError("Envelope signature is not valid for the given domain");
      }
      return envelope;
    };
    publicKey;
    payloadType;
    payload;
    signature;
    marshaled;
    /**
     * The Envelope is responsible for keeping an arbitrary signed record
     * by a libp2p peer.
     */
    constructor(init) {
      const { publicKey, payloadType, payload, signature } = init;
      this.publicKey = publicKey;
      this.payloadType = payloadType;
      this.payload = payload;
      this.signature = signature;
    }
    /**
     * Marshal the envelope content
     */
    marshal() {
      if (this.marshaled == null) {
        this.marshaled = Envelope.encode({
          publicKey: publicKeyToProtobuf(this.publicKey),
          payloadType: this.payloadType,
          payload: this.payload.subarray(),
          signature: this.signature
        });
      }
      return this.marshaled;
    }
    /**
     * Verifies if the other Envelope is identical to this one
     */
    equals(other) {
      if (other == null) {
        return false;
      }
      return equals3(this.marshal(), other.marshal());
    }
    /**
     * Validate envelope data signature for the given domain
     */
    async validate(domain, options) {
      const signData = formatSignaturePayload(domain, this.payloadType, this.payload);
      return this.publicKey.verify(signData.subarray(), this.signature, options);
    }
  };
  var formatSignaturePayload = (domain, payloadType, payload) => {
    const domainUint8Array = fromString2(domain);
    const domainLength = encode5(domainUint8Array.byteLength);
    const payloadTypeLength = encode5(payloadType.length);
    const payloadLength = encode5(payload.length);
    return new Uint8ArrayList(domainLength, domainUint8Array, payloadTypeLength, payloadType, payloadLength, payload);
  };

  // node_modules/@libp2p/peer-record/dist/src/peer-record/index.js
  var import_browser_shims161 = __toESM(require_browser_shims(), 1);

  // node_modules/@libp2p/utils/dist/src/array-equals.js
  var import_browser_shims158 = __toESM(require_browser_shims(), 1);
  function arrayEquals(a, b) {
    const sort2 = (a2, b2) => a2.toString().localeCompare(b2.toString());
    if (a.length !== b.length) {
      return false;
    }
    b.sort(sort2);
    return a.sort(sort2).every((item, index) => b[index].equals(item));
  }

  // node_modules/@libp2p/peer-record/dist/src/peer-record/consts.js
  var import_browser_shims159 = __toESM(require_browser_shims(), 1);
  var ENVELOPE_DOMAIN_PEER_RECORD = "libp2p-peer-record";
  var ENVELOPE_PAYLOAD_TYPE_PEER_RECORD = Uint8Array.from([3, 1]);

  // node_modules/@libp2p/peer-record/dist/src/peer-record/peer-record.js
  var import_browser_shims160 = __toESM(require_browser_shims(), 1);
  var PeerRecord;
  (function(PeerRecord3) {
    let AddressInfo;
    (function(AddressInfo2) {
      let _codec2;
      AddressInfo2.codec = () => {
        if (_codec2 == null) {
          _codec2 = message((obj, w2, opts = {}) => {
            if (opts.lengthDelimited !== false) {
              w2.fork();
            }
            if (obj.multiaddr != null && obj.multiaddr.byteLength > 0) {
              w2.uint32(10);
              w2.bytes(obj.multiaddr);
            }
            if (opts.lengthDelimited !== false) {
              w2.ldelim();
            }
          }, (reader, length4, opts = {}) => {
            const obj = {
              multiaddr: alloc(0)
            };
            const end = length4 == null ? reader.len : reader.pos + length4;
            while (reader.pos < end) {
              const tag = reader.uint32();
              switch (tag >>> 3) {
                case 1: {
                  obj.multiaddr = reader.bytes();
                  break;
                }
                default: {
                  reader.skipType(tag & 7);
                  break;
                }
              }
            }
            return obj;
          });
        }
        return _codec2;
      };
      AddressInfo2.encode = (obj) => {
        return encodeMessage(obj, AddressInfo2.codec());
      };
      AddressInfo2.decode = (buf, opts) => {
        return decodeMessage(buf, AddressInfo2.codec(), opts);
      };
    })(AddressInfo = PeerRecord3.AddressInfo || (PeerRecord3.AddressInfo = {}));
    let _codec;
    PeerRecord3.codec = () => {
      if (_codec == null) {
        _codec = message((obj, w2, opts = {}) => {
          if (opts.lengthDelimited !== false) {
            w2.fork();
          }
          if (obj.peerId != null && obj.peerId.byteLength > 0) {
            w2.uint32(10);
            w2.bytes(obj.peerId);
          }
          if (obj.seq != null && obj.seq !== 0n) {
            w2.uint32(16);
            w2.uint64(obj.seq);
          }
          if (obj.addresses != null) {
            for (const value of obj.addresses) {
              w2.uint32(26);
              PeerRecord3.AddressInfo.codec().encode(value, w2);
            }
          }
          if (opts.lengthDelimited !== false) {
            w2.ldelim();
          }
        }, (reader, length4, opts = {}) => {
          var _a2, _b2;
          const obj = {
            peerId: alloc(0),
            seq: 0n,
            addresses: []
          };
          const end = length4 == null ? reader.len : reader.pos + length4;
          while (reader.pos < end) {
            const tag = reader.uint32();
            switch (tag >>> 3) {
              case 1: {
                obj.peerId = reader.bytes();
                break;
              }
              case 2: {
                obj.seq = reader.uint64();
                break;
              }
              case 3: {
                if (((_a2 = opts.limits) == null ? void 0 : _a2.addresses) != null && obj.addresses.length === opts.limits.addresses) {
                  throw new MaxLengthError('Decode error - map field "addresses" had too many elements');
                }
                obj.addresses.push(PeerRecord3.AddressInfo.codec().decode(reader, reader.uint32(), {
                  limits: (_b2 = opts.limits) == null ? void 0 : _b2.addresses$
                }));
                break;
              }
              default: {
                reader.skipType(tag & 7);
                break;
              }
            }
          }
          return obj;
        });
      }
      return _codec;
    };
    PeerRecord3.encode = (obj) => {
      return encodeMessage(obj, PeerRecord3.codec());
    };
    PeerRecord3.decode = (buf, opts) => {
      return decodeMessage(buf, PeerRecord3.codec(), opts);
    };
  })(PeerRecord || (PeerRecord = {}));

  // node_modules/@libp2p/peer-record/dist/src/peer-record/index.js
  var PeerRecord2 = class _PeerRecord {
    /**
     * Unmarshal Peer Record Protobuf
     */
    static createFromProtobuf = (buf) => {
      const peerRecord = PeerRecord.decode(buf);
      const peerId2 = peerIdFromMultihash(decode4(peerRecord.peerId));
      const multiaddrs = (peerRecord.addresses ?? []).map((a) => multiaddr(a.multiaddr));
      const seqNumber = peerRecord.seq;
      return new _PeerRecord({ peerId: peerId2, multiaddrs, seqNumber });
    };
    static DOMAIN = ENVELOPE_DOMAIN_PEER_RECORD;
    static CODEC = ENVELOPE_PAYLOAD_TYPE_PEER_RECORD;
    peerId;
    multiaddrs;
    seqNumber;
    domain = _PeerRecord.DOMAIN;
    codec = _PeerRecord.CODEC;
    marshaled;
    constructor(init) {
      const { peerId: peerId2, multiaddrs, seqNumber } = init;
      this.peerId = peerId2;
      this.multiaddrs = multiaddrs ?? [];
      this.seqNumber = seqNumber ?? BigInt(Date.now());
    }
    /**
     * Marshal a record to be used in an envelope
     */
    marshal() {
      if (this.marshaled == null) {
        this.marshaled = PeerRecord.encode({
          peerId: this.peerId.toMultihash().bytes,
          seq: BigInt(this.seqNumber),
          addresses: this.multiaddrs.map((m2) => ({
            multiaddr: m2.bytes
          }))
        });
      }
      return this.marshaled;
    }
    /**
     * Returns true if `this` record equals the `other`
     */
    equals(other) {
      if (!(other instanceof _PeerRecord)) {
        return false;
      }
      if (!this.peerId.equals(other.peerId)) {
        return false;
      }
      if (this.seqNumber !== other.seqNumber) {
        return false;
      }
      if (!arrayEquals(this.multiaddrs, other.multiaddrs)) {
        return false;
      }
      return true;
    }
  };

  // node_modules/it-all/dist/src/index.js
  var import_browser_shims163 = __toESM(require_browser_shims(), 1);
  function isAsyncIterable(thing) {
    return thing[Symbol.asyncIterator] != null;
  }
  function all(source) {
    if (isAsyncIterable(source)) {
      return (async () => {
        const arr2 = [];
        for await (const entry of source) {
          arr2.push(entry);
        }
        return arr2;
      })();
    }
    const arr = [];
    for (const entry of source) {
      arr.push(entry);
    }
    return arr;
  }
  var src_default2 = all;

  // node_modules/@libp2p/peer-store/dist/src/store.js
  var import_browser_shims190 = __toESM(require_browser_shims(), 1);

  // node_modules/mortice/dist/src/index.js
  var import_browser_shims181 = __toESM(require_browser_shims(), 1);

  // node_modules/it-queue/dist/src/index.js
  var import_browser_shims174 = __toESM(require_browser_shims(), 1);

  // node_modules/abort-error/dist/src/index.js
  var import_browser_shims164 = __toESM(require_browser_shims(), 1);
  var AbortError3 = class extends Error {
    static name = "AbortError";
    name = "AbortError";
    constructor(message2 = "The operation was aborted", ...rest) {
      super(message2, ...rest);
    }
  };

  // node_modules/it-pushable/dist/src/index.js
  var import_browser_shims167 = __toESM(require_browser_shims(), 1);

  // node_modules/p-defer/index.js
  var import_browser_shims165 = __toESM(require_browser_shims(), 1);
  function pDefer() {
    const deferred = {};
    deferred.promise = new Promise((resolve, reject) => {
      deferred.resolve = resolve;
      deferred.reject = reject;
    });
    return deferred;
  }

  // node_modules/it-pushable/dist/src/fifo.js
  var import_browser_shims166 = __toESM(require_browser_shims(), 1);
  var FixedFIFO = class {
    buffer;
    mask;
    top;
    btm;
    next;
    constructor(hwm) {
      if (!(hwm > 0) || (hwm - 1 & hwm) !== 0) {
        throw new Error("Max size for a FixedFIFO should be a power of two");
      }
      this.buffer = new Array(hwm);
      this.mask = hwm - 1;
      this.top = 0;
      this.btm = 0;
      this.next = null;
    }
    push(data) {
      if (this.buffer[this.top] !== void 0) {
        return false;
      }
      this.buffer[this.top] = data;
      this.top = this.top + 1 & this.mask;
      return true;
    }
    shift() {
      const last = this.buffer[this.btm];
      if (last === void 0) {
        return void 0;
      }
      this.buffer[this.btm] = void 0;
      this.btm = this.btm + 1 & this.mask;
      return last;
    }
    isEmpty() {
      return this.buffer[this.btm] === void 0;
    }
  };
  var FIFO = class {
    size;
    hwm;
    head;
    tail;
    constructor(options = {}) {
      this.hwm = options.splitLimit ?? 16;
      this.head = new FixedFIFO(this.hwm);
      this.tail = this.head;
      this.size = 0;
    }
    calculateSize(obj) {
      if ((obj == null ? void 0 : obj.byteLength) != null) {
        return obj.byteLength;
      }
      return 1;
    }
    push(val) {
      if ((val == null ? void 0 : val.value) != null) {
        this.size += this.calculateSize(val.value);
      }
      if (!this.head.push(val)) {
        const prev = this.head;
        this.head = prev.next = new FixedFIFO(2 * this.head.buffer.length);
        this.head.push(val);
      }
    }
    shift() {
      let val = this.tail.shift();
      if (val === void 0 && this.tail.next != null) {
        const next = this.tail.next;
        this.tail.next = null;
        this.tail = next;
        val = this.tail.shift();
      }
      if ((val == null ? void 0 : val.value) != null) {
        this.size -= this.calculateSize(val.value);
      }
      return val;
    }
    isEmpty() {
      return this.head.isEmpty();
    }
  };

  // node_modules/it-pushable/dist/src/index.js
  var AbortError4 = class extends Error {
    type;
    code;
    constructor(message2, code2) {
      super(message2 ?? "The operation was aborted");
      this.type = "aborted";
      this.code = code2 ?? "ABORT_ERR";
    }
  };
  function pushable(options = {}) {
    const getNext = (buffer) => {
      const next = buffer.shift();
      if (next == null) {
        return { done: true };
      }
      if (next.error != null) {
        throw next.error;
      }
      return {
        done: next.done === true,
        // @ts-expect-error if done is false, value will be present
        value: next.value
      };
    };
    return _pushable(getNext, options);
  }
  function _pushable(getNext, options) {
    options = options ?? {};
    let onEnd = options.onEnd;
    let buffer = new FIFO();
    let pushable2;
    let onNext;
    let ended;
    let drain2 = pDefer();
    const waitNext = async () => {
      try {
        if (!buffer.isEmpty()) {
          return getNext(buffer);
        }
        if (ended) {
          return { done: true };
        }
        return await new Promise((resolve, reject) => {
          onNext = (next) => {
            onNext = null;
            buffer.push(next);
            try {
              resolve(getNext(buffer));
            } catch (err) {
              reject(err);
            }
            return pushable2;
          };
        });
      } finally {
        if (buffer.isEmpty()) {
          queueMicrotask(() => {
            drain2.resolve();
            drain2 = pDefer();
          });
        }
      }
    };
    const bufferNext = (next) => {
      if (onNext != null) {
        return onNext(next);
      }
      buffer.push(next);
      return pushable2;
    };
    const bufferError = (err) => {
      buffer = new FIFO();
      if (onNext != null) {
        return onNext({ error: err });
      }
      buffer.push({ error: err });
      return pushable2;
    };
    const push = (value) => {
      if (ended) {
        return pushable2;
      }
      if ((options == null ? void 0 : options.objectMode) !== true && (value == null ? void 0 : value.byteLength) == null) {
        throw new Error("objectMode was not true but tried to push non-Uint8Array value");
      }
      return bufferNext({ done: false, value });
    };
    const end = (err) => {
      if (ended)
        return pushable2;
      ended = true;
      return err != null ? bufferError(err) : bufferNext({ done: true });
    };
    const _return = () => {
      buffer = new FIFO();
      end();
      return { done: true };
    };
    const _throw = (err) => {
      end(err);
      return { done: true };
    };
    pushable2 = {
      [Symbol.asyncIterator]() {
        return this;
      },
      next: waitNext,
      return: _return,
      throw: _throw,
      push,
      end,
      get readableLength() {
        return buffer.size;
      },
      onEmpty: async (options2) => {
        const signal = options2 == null ? void 0 : options2.signal;
        signal == null ? void 0 : signal.throwIfAborted();
        if (buffer.isEmpty()) {
          return;
        }
        let cancel;
        let listener;
        if (signal != null) {
          cancel = new Promise((resolve, reject) => {
            listener = () => {
              reject(new AbortError4());
            };
            signal.addEventListener("abort", listener);
          });
        }
        try {
          await Promise.race([
            drain2.promise,
            cancel
          ]);
        } finally {
          if (listener != null && signal != null) {
            signal == null ? void 0 : signal.removeEventListener("abort", listener);
          }
        }
      }
    };
    if (onEnd == null) {
      return pushable2;
    }
    const _pushable2 = pushable2;
    pushable2 = {
      [Symbol.asyncIterator]() {
        return this;
      },
      next() {
        return _pushable2.next();
      },
      throw(err) {
        _pushable2.throw(err);
        if (onEnd != null) {
          onEnd(err);
          onEnd = void 0;
        }
        return { done: true };
      },
      return() {
        _pushable2.return();
        if (onEnd != null) {
          onEnd();
          onEnd = void 0;
        }
        return { done: true };
      },
      push,
      end(err) {
        _pushable2.end(err);
        if (onEnd != null) {
          onEnd(err);
          onEnd = void 0;
        }
        return pushable2;
      },
      get readableLength() {
        return _pushable2.readableLength;
      },
      onEmpty: (opts) => {
        return _pushable2.onEmpty(opts);
      }
    };
    return pushable2;
  }

  // node_modules/race-event/dist/src/index.js
  var import_browser_shims168 = __toESM(require_browser_shims(), 1);
  var AbortError5 = class extends Error {
    type;
    code;
    constructor(message2, code2) {
      super(message2 ?? "The operation was aborted");
      this.type = "aborted";
      this.name = "AbortError";
      this.code = code2 ?? "ABORT_ERR";
    }
  };
  async function raceEvent(emitter, eventName, signal, opts) {
    const error = new AbortError5(opts == null ? void 0 : opts.errorMessage, opts == null ? void 0 : opts.errorCode);
    if ((signal == null ? void 0 : signal.aborted) === true) {
      return Promise.reject(error);
    }
    return new Promise((resolve, reject) => {
      function removeListeners() {
        signal == null ? void 0 : signal.removeEventListener("abort", abortListener);
        emitter.removeEventListener(eventName, eventListener);
        if ((opts == null ? void 0 : opts.errorEvent) != null) {
          emitter.removeEventListener(opts.errorEvent, errorEventListener);
        }
      }
      const eventListener = (evt) => {
        var _a2;
        try {
          if (((_a2 = opts == null ? void 0 : opts.filter) == null ? void 0 : _a2.call(opts, evt)) === false) {
            return;
          }
        } catch (err) {
          removeListeners();
          reject(err);
          return;
        }
        removeListeners();
        resolve(evt);
      };
      const errorEventListener = (evt) => {
        removeListeners();
        reject(evt.detail);
      };
      const abortListener = () => {
        removeListeners();
        reject(error);
      };
      signal == null ? void 0 : signal.addEventListener("abort", abortListener);
      emitter.addEventListener(eventName, eventListener);
      if ((opts == null ? void 0 : opts.errorEvent) != null) {
        emitter.addEventListener(opts.errorEvent, errorEventListener);
      }
    });
  }

  // node_modules/it-queue/dist/src/errors.js
  var import_browser_shims169 = __toESM(require_browser_shims(), 1);
  var QueueFullError = class extends Error {
    static name = "QueueFullError";
    constructor(message2 = "The queue was full") {
      super(message2);
      this.name = "QueueFullError";
    }
  };

  // node_modules/it-queue/dist/src/job.js
  var import_browser_shims172 = __toESM(require_browser_shims(), 1);

  // node_modules/race-signal/dist/src/index.js
  var import_browser_shims170 = __toESM(require_browser_shims(), 1);
  var AbortError6 = class extends Error {
    type;
    code;
    constructor(message2, code2, name3) {
      super(message2 ?? "The operation was aborted");
      this.type = "aborted";
      this.name = name3 ?? "AbortError";
      this.code = code2 ?? "ABORT_ERR";
    }
  };
  async function raceSignal(promise, signal, opts) {
    if (signal == null) {
      return promise;
    }
    if (signal.aborted) {
      promise.catch(() => {
      });
      return Promise.reject(new AbortError6(opts == null ? void 0 : opts.errorMessage, opts == null ? void 0 : opts.errorCode, opts == null ? void 0 : opts.errorName));
    }
    let listener;
    const error = new AbortError6(opts == null ? void 0 : opts.errorMessage, opts == null ? void 0 : opts.errorCode, opts == null ? void 0 : opts.errorName);
    try {
      return await Promise.race([
        promise,
        new Promise((resolve, reject) => {
          listener = () => {
            reject(error);
          };
          signal.addEventListener("abort", listener);
        })
      ]);
    } finally {
      if (listener != null) {
        signal.removeEventListener("abort", listener);
      }
    }
  }

  // node_modules/it-queue/dist/src/recipient.js
  var import_browser_shims171 = __toESM(require_browser_shims(), 1);
  var JobRecipient = class {
    deferred;
    signal;
    constructor(signal) {
      var _a2;
      this.signal = signal;
      this.deferred = Promise.withResolvers();
      this.onAbort = this.onAbort.bind(this);
      (_a2 = this.signal) == null ? void 0 : _a2.addEventListener("abort", this.onAbort);
    }
    onAbort() {
      var _a2;
      this.deferred.reject(((_a2 = this.signal) == null ? void 0 : _a2.reason) ?? new AbortError3());
    }
    cleanup() {
      var _a2;
      (_a2 = this.signal) == null ? void 0 : _a2.removeEventListener("abort", this.onAbort);
    }
  };

  // node_modules/it-queue/dist/src/job.js
  function randomId() {
    return `${parseInt(String(Math.random() * 1e9), 10).toString()}${Date.now()}`;
  }
  var Job = class {
    id;
    fn;
    options;
    recipients;
    status;
    timeline;
    controller;
    constructor(fn, options) {
      this.id = randomId();
      this.status = "queued";
      this.fn = fn;
      this.options = options;
      this.recipients = [];
      this.timeline = {
        created: Date.now()
      };
      this.controller = new AbortController();
      setMaxListeners(Infinity, this.controller.signal);
      this.onAbort = this.onAbort.bind(this);
    }
    abort(err) {
      this.controller.abort(err);
    }
    onAbort() {
      const allAborted = this.recipients.reduce((acc, curr) => {
        var _a2;
        return acc && ((_a2 = curr.signal) == null ? void 0 : _a2.aborted) === true;
      }, true);
      if (allAborted) {
        this.controller.abort(new AbortError3());
        this.cleanup();
      }
    }
    async join(options = {}) {
      var _a2;
      const recipient = new JobRecipient(options.signal);
      this.recipients.push(recipient);
      (_a2 = options.signal) == null ? void 0 : _a2.addEventListener("abort", this.onAbort);
      return recipient.deferred.promise;
    }
    async run() {
      this.status = "running";
      this.timeline.started = Date.now();
      try {
        this.controller.signal.throwIfAborted();
        const result = await raceSignal(this.fn({
          ...this.options ?? {},
          signal: this.controller.signal
        }), this.controller.signal);
        this.recipients.forEach((recipient) => {
          recipient.deferred.resolve(result);
        });
        this.status = "complete";
      } catch (err) {
        this.recipients.forEach((recipient) => {
          recipient.deferred.reject(err);
        });
        this.status = "errored";
      } finally {
        this.timeline.finished = Date.now();
        this.cleanup();
      }
    }
    cleanup() {
      this.recipients.forEach((recipient) => {
        var _a2;
        recipient.cleanup();
        (_a2 = recipient.signal) == null ? void 0 : _a2.removeEventListener("abort", this.onAbort);
      });
    }
  };

  // node_modules/it-queue/dist/src/utils.js
  var import_browser_shims173 = __toESM(require_browser_shims(), 1);
  function debounce(func2, wait) {
    let timeout;
    const output = function() {
      const later = function() {
        timeout = void 0;
        void func2();
      };
      clearTimeout(timeout);
      timeout = setTimeout(later, wait);
    };
    output.start = () => {
    };
    output.stop = () => {
      clearTimeout(timeout);
    };
    return output;
  }

  // node_modules/it-queue/dist/src/index.js
  var Queue = class extends TypedEventEmitter {
    concurrency;
    maxSize;
    queue;
    pending;
    sort;
    autoStart;
    constructor(init = {}) {
      super();
      this.concurrency = init.concurrency ?? Number.POSITIVE_INFINITY;
      this.maxSize = init.maxSize ?? Number.POSITIVE_INFINITY;
      this.pending = 0;
      this.autoStart = init.autoStart ?? true;
      this.sort = init.sort;
      this.queue = [];
      this.emitEmpty = debounce(this.emitEmpty.bind(this), 1);
      this.emitIdle = debounce(this.emitIdle.bind(this), 1);
    }
    [Symbol.asyncIterator]() {
      return this.toGenerator();
    }
    emitEmpty() {
      if (this.size !== 0) {
        return;
      }
      this.safeDispatchEvent("empty");
    }
    emitIdle() {
      if (this.running !== 0) {
        return;
      }
      this.safeDispatchEvent("idle");
    }
    tryToStartAnother() {
      if (this.size === 0) {
        this.emitEmpty();
        if (this.running === 0) {
          this.emitIdle();
        }
        return false;
      }
      if (this.pending < this.concurrency) {
        let job;
        for (const j of this.queue) {
          if (j.status === "queued") {
            job = j;
            break;
          }
        }
        if (job == null) {
          return false;
        }
        this.safeDispatchEvent("active");
        this.pending++;
        void job.run().finally(() => {
          for (let i = 0; i < this.queue.length; i++) {
            if (this.queue[i] === job) {
              this.queue.splice(i, 1);
              break;
            }
          }
          this.pending--;
          this.safeDispatchEvent("next");
          if (this.autoStart) {
            this.tryToStartAnother();
          }
        });
        return true;
      }
      return false;
    }
    enqueue(job) {
      this.queue.push(job);
      if (this.sort != null) {
        this.queue.sort(this.sort);
      }
    }
    /**
     * Start the queue. If the `autoStart` parameter passed to the constructor was
     * not `false` this is a no-op
     */
    start() {
      if (this.autoStart !== false) {
        return;
      }
      this.autoStart = true;
      this.tryToStartAnother();
    }
    /**
     * Prevent further jobs from running - call `.start` to start the queue again
     */
    pause() {
      this.autoStart = false;
    }
    /**
     * Adds a sync or async task to the queue. Always returns a promise.
     */
    async add(fn, options) {
      var _a2;
      (_a2 = options == null ? void 0 : options.signal) == null ? void 0 : _a2.throwIfAborted();
      if (this.size === this.maxSize) {
        throw new QueueFullError();
      }
      const job = new Job(fn, options);
      this.enqueue(job);
      this.safeDispatchEvent("add");
      if (this.autoStart) {
        this.tryToStartAnother();
      }
      return job.join(options).then((result) => {
        this.safeDispatchEvent("success", { detail: { job, result } });
        return result;
      }).catch((err) => {
        if (job.status === "queued") {
          for (let i = 0; i < this.queue.length; i++) {
            if (this.queue[i] === job) {
              this.queue.splice(i, 1);
              break;
            }
          }
        }
        this.safeDispatchEvent("failure", { detail: { job, error: err } });
        throw err;
      });
    }
    /**
     * Clear the queue
     */
    clear() {
      this.queue.splice(0, this.queue.length);
    }
    /**
     * Abort all jobs in the queue and clear it
     */
    abort() {
      this.queue.forEach((job) => {
        job.abort(new AbortError3());
      });
      this.clear();
    }
    /**
     * Can be called multiple times. Useful if you for example add additional items at a later time.
     *
     * @returns A promise that settles when the queue becomes empty.
     */
    async onEmpty(options) {
      if (this.size === 0) {
        return;
      }
      await raceEvent(this, "empty", options == null ? void 0 : options.signal);
    }
    /**
     * @returns A promise that settles when the queue size is less than the given
     * limit: `queue.size < limit`.
     *
     * If you want to avoid having the queue grow beyond a certain size you can
     * `await queue.onSizeLessThan()` before adding a new item.
     *
     * Note that this only limits the number of items waiting to start. There
     * could still be up to `concurrency` jobs already running that this call does
     * not include in its calculation.
     */
    async onSizeLessThan(limit, options) {
      if (this.size < limit) {
        return;
      }
      await raceEvent(this, "next", options == null ? void 0 : options.signal, {
        filter: () => this.size < limit
      });
    }
    /**
     * The difference with `.onEmpty` is that `.onIdle` guarantees that all work
     * from the queue has finished. `.onEmpty` merely signals that the queue is
     * empty, but it could mean that some promises haven't completed yet.
     *
     * @returns A promise that settles when the queue becomes empty, and all
     * promises have completed; `queue.size === 0 && queue.pending === 0`.
     */
    async onIdle(options) {
      if (this.pending === 0 && this.size === 0) {
        return;
      }
      await raceEvent(this, "idle", options == null ? void 0 : options.signal);
    }
    /**
     * Size of the queue including running items
     */
    get size() {
      return this.queue.length;
    }
    /**
     * The number of queued items waiting to run.
     */
    get queued() {
      return this.queue.length - this.pending;
    }
    /**
     * The number of items currently running.
     */
    get running() {
      return this.pending;
    }
    /**
     * Returns an async generator that makes it easy to iterate over the results
     * of jobs added to the queue.
     *
     * The generator will end when the queue becomes idle, that is there are no
     * jobs running and no jobs that have yet to run.
     *
     * If you need to keep the queue open indefinitely, consider using it-pushable
     * instead.
     */
    async *toGenerator(options) {
      var _a2, _b2, _c;
      (_a2 = options == null ? void 0 : options.signal) == null ? void 0 : _a2.throwIfAborted();
      const stream = pushable({
        objectMode: true
      });
      const cleanup = (err) => {
        if (err != null) {
          this.abort();
        } else {
          this.clear();
        }
        stream.end(err);
      };
      const onQueueJobComplete = (evt) => {
        if (evt.detail != null) {
          stream.push(evt.detail.result);
        }
      };
      const onQueueError = (evt) => {
        cleanup(evt.detail.error);
      };
      const onQueueIdle = () => {
        cleanup();
      };
      const onSignalAbort = () => {
        cleanup(new AbortError3("Queue aborted"));
      };
      this.addEventListener("success", onQueueJobComplete);
      this.addEventListener("failure", onQueueError);
      this.addEventListener("idle", onQueueIdle);
      (_b2 = options == null ? void 0 : options.signal) == null ? void 0 : _b2.addEventListener("abort", onSignalAbort);
      try {
        yield* stream;
      } finally {
        this.removeEventListener("success", onQueueJobComplete);
        this.removeEventListener("failure", onQueueError);
        this.removeEventListener("idle", onQueueIdle);
        (_c = options == null ? void 0 : options.signal) == null ? void 0 : _c.removeEventListener("abort", onSignalAbort);
        cleanup();
      }
    }
  };

  // node_modules/mortice/dist/src/mortice.js
  var import_browser_shims180 = __toESM(require_browser_shims(), 1);

  // node_modules/mortice/dist/src/browser.js
  var import_browser_shims179 = __toESM(require_browser_shims(), 1);

  // node_modules/mortice/dist/src/constants.js
  var import_browser_shims175 = __toESM(require_browser_shims(), 1);
  var WORKER_REQUEST_READ_LOCK = "lock:worker:request-read";
  var WORKER_ABORT_READ_LOCK_REQUEST = "lock:worker:abort-read-request";
  var WORKER_RELEASE_READ_LOCK = "lock:worker:release-read";
  var MASTER_GRANT_READ_LOCK = "lock:master:grant-read";
  var MASTER_READ_LOCK_ERROR = "lock:master:error-read";
  var WORKER_REQUEST_WRITE_LOCK = "lock:worker:request-write";
  var WORKER_ABORT_WRITE_LOCK_REQUEST = "lock:worker:abort-write-request";
  var WORKER_RELEASE_WRITE_LOCK = "lock:worker:release-write";
  var MASTER_GRANT_WRITE_LOCK = "lock:master:grant-write";
  var MASTER_WRITE_LOCK_ERROR = "lock:master:error-write";
  var WORKER_FINALIZE = "lock:worker:finalize";
  var BROADCAST_CHANNEL_NAME = "mortice";
  var defaultOptions = {
    singleProcess: false
  };

  // node_modules/mortice/dist/src/main/channel.js
  var import_browser_shims176 = __toESM(require_browser_shims(), 1);
  var handleChannelWorkerLockRequest = (emitter, channel, masterEvent, abortMasterEvent, requestType, abortType, errorType, releaseType, grantType) => {
    return (event) => {
      if (event.data == null) {
        return;
      }
      const requestEvent = {
        type: event.data.type,
        name: event.data.name,
        identifier: event.data.identifier
      };
      if (requestEvent.type === requestType) {
        emitter.safeDispatchEvent(masterEvent, {
          detail: {
            name: requestEvent.name,
            identifier: requestEvent.identifier,
            handler: async () => {
              channel.postMessage({
                type: grantType,
                name: requestEvent.name,
                identifier: requestEvent.identifier
              });
              await new Promise((resolve) => {
                const releaseEventListener = (event2) => {
                  if ((event2 == null ? void 0 : event2.data) == null) {
                    return;
                  }
                  const releaseEvent = {
                    type: event2.data.type,
                    name: event2.data.name,
                    identifier: event2.data.identifier
                  };
                  if (releaseEvent.type === releaseType && releaseEvent.identifier === requestEvent.identifier) {
                    channel.removeEventListener("message", releaseEventListener);
                    resolve();
                  }
                };
                channel.addEventListener("message", releaseEventListener);
              });
            },
            onError: (err) => {
              channel.postMessage({
                type: errorType,
                name: requestEvent.name,
                identifier: requestEvent.identifier,
                error: {
                  message: err.message,
                  name: err.name,
                  stack: err.stack
                }
              });
            }
          }
        });
      }
      if (requestEvent.type === abortType) {
        emitter.safeDispatchEvent(abortMasterEvent, {
          detail: {
            name: requestEvent.name,
            identifier: requestEvent.identifier
          }
        });
      }
      if (requestEvent.type === WORKER_FINALIZE) {
        emitter.safeDispatchEvent("finalizeRequest", {
          detail: {
            name: requestEvent.name
          }
        });
      }
    };
  };

  // node_modules/mortice/dist/src/workers/channel.js
  var import_browser_shims178 = __toESM(require_browser_shims(), 1);

  // node_modules/mortice/dist/src/utils.js
  var import_browser_shims177 = __toESM(require_browser_shims(), 1);
  var nanoid = (size = 10) => {
    return Math.random().toString().substring(2, size + 2);
  };

  // node_modules/mortice/dist/src/workers/channel.js
  var MorticeChannelWorker = class {
    name;
    channel;
    constructor(name3) {
      this.name = name3;
      this.channel = new BroadcastChannel(BROADCAST_CHANNEL_NAME);
    }
    readLock(options) {
      return this.sendRequest(WORKER_REQUEST_READ_LOCK, WORKER_ABORT_READ_LOCK_REQUEST, MASTER_GRANT_READ_LOCK, MASTER_READ_LOCK_ERROR, WORKER_RELEASE_READ_LOCK, options);
    }
    writeLock(options) {
      return this.sendRequest(WORKER_REQUEST_WRITE_LOCK, WORKER_ABORT_WRITE_LOCK_REQUEST, MASTER_GRANT_WRITE_LOCK, MASTER_WRITE_LOCK_ERROR, WORKER_RELEASE_WRITE_LOCK, options);
    }
    finalize() {
      this.channel.postMessage({
        type: WORKER_FINALIZE,
        name: this.name
      });
      this.channel.close();
    }
    async sendRequest(requestType, abortType, grantType, errorType, releaseType, options) {
      var _a2;
      (_a2 = options == null ? void 0 : options.signal) == null ? void 0 : _a2.throwIfAborted();
      const id = nanoid();
      this.channel.postMessage({
        type: requestType,
        identifier: id,
        name: this.name
      });
      return new Promise((resolve, reject) => {
        var _a3;
        const abortListener = () => {
          this.channel.postMessage({
            type: abortType,
            identifier: id,
            name: this.name
          });
        };
        (_a3 = options == null ? void 0 : options.signal) == null ? void 0 : _a3.addEventListener("abort", abortListener, {
          once: true
        });
        const listener = (event) => {
          var _a4, _b2, _c, _d;
          if (((_a4 = event.data) == null ? void 0 : _a4.identifier) !== id) {
            return;
          }
          if (((_b2 = event.data) == null ? void 0 : _b2.type) === grantType) {
            this.channel.removeEventListener("message", listener);
            (_c = options == null ? void 0 : options.signal) == null ? void 0 : _c.removeEventListener("abort", abortListener);
            resolve(() => {
              this.channel.postMessage({
                type: releaseType,
                identifier: id,
                name: this.name
              });
            });
          }
          if (event.data.type === errorType) {
            this.channel.removeEventListener("message", listener);
            (_d = options == null ? void 0 : options.signal) == null ? void 0 : _d.removeEventListener("abort", abortListener);
            const err = new Error();
            if (event.data.error != null) {
              err.message = event.data.error.message;
              err.name = event.data.error.name;
              err.stack = event.data.error.stack;
            }
            reject(err);
          }
        };
        this.channel.addEventListener("message", listener);
      });
    }
  };

  // node_modules/mortice/dist/src/browser.js
  var browser_default2 = (options) => {
    options = Object.assign({}, defaultOptions, options);
    const isPrimary = Boolean(globalThis.document) || options.singleProcess;
    if (isPrimary) {
      const channel = new BroadcastChannel(BROADCAST_CHANNEL_NAME);
      const emitter = new TypedEventEmitter();
      channel.addEventListener("message", handleChannelWorkerLockRequest(emitter, channel, "requestReadLock", "abortReadLockRequest", WORKER_REQUEST_READ_LOCK, WORKER_ABORT_READ_LOCK_REQUEST, MASTER_READ_LOCK_ERROR, WORKER_RELEASE_READ_LOCK, MASTER_GRANT_READ_LOCK));
      channel.addEventListener("message", handleChannelWorkerLockRequest(emitter, channel, "requestWriteLock", "abortWriteLockRequest", WORKER_REQUEST_WRITE_LOCK, WORKER_ABORT_WRITE_LOCK_REQUEST, MASTER_WRITE_LOCK_ERROR, WORKER_RELEASE_WRITE_LOCK, MASTER_GRANT_WRITE_LOCK));
      return emitter;
    }
    return new MorticeChannelWorker(options.name);
  };

  // node_modules/mortice/dist/src/mortice.js
  var mutexes = /* @__PURE__ */ new Map();
  var implementation;
  function isMortice(obj) {
    return typeof (obj == null ? void 0 : obj.readLock) === "function" && typeof (obj == null ? void 0 : obj.writeLock) === "function";
  }
  function getImplementation(opts) {
    if (implementation == null) {
      implementation = browser_default2(opts);
      if (!isMortice(implementation)) {
        const emitter = implementation;
        emitter.addEventListener("requestReadLock", (event) => {
          const mutexName = event.detail.name;
          const identifier = event.detail.identifier;
          const mutex = mutexes.get(mutexName);
          if (mutex == null) {
            return;
          }
          const abortController = new AbortController();
          const abortListener = (event2) => {
            if (event2.detail.name !== mutexName || event2.detail.identifier !== identifier) {
              return;
            }
            abortController.abort();
          };
          emitter.addEventListener("abortReadLockRequest", abortListener);
          void mutex.readLock({
            signal: abortController.signal
          }).then(async (release) => {
            await event.detail.handler().finally(() => {
              release();
            });
          }).catch((err) => {
            event.detail.onError(err);
          }).finally(() => {
            emitter.removeEventListener("abortReadLockRequest", abortListener);
          });
        });
        emitter.addEventListener("requestWriteLock", (event) => {
          const mutexName = event.detail.name;
          const identifier = event.detail.identifier;
          const mutex = mutexes.get(mutexName);
          if (mutex == null) {
            return;
          }
          const abortController = new AbortController();
          const abortListener = (event2) => {
            if (event2.detail.name !== mutexName || event2.detail.identifier !== identifier) {
              return;
            }
            abortController.abort();
          };
          emitter.addEventListener("abortWriteLockRequest", abortListener);
          void mutex.writeLock({
            signal: abortController.signal
          }).then(async (release) => {
            await event.detail.handler().finally(() => {
              release();
            });
          }).catch((err) => {
            event.detail.onError(err);
          }).finally(() => {
            emitter.removeEventListener("abortWriteLockRequest", abortListener);
          });
        });
        emitter.addEventListener("finalizeRequest", (event) => {
          const mutexName = event.detail.name;
          const mutex = mutexes.get(mutexName);
          if (mutex == null) {
            return;
          }
          mutex.finalize();
        });
      }
    }
    return implementation;
  }
  async function createReleasable(queue, options) {
    var _a2;
    let res;
    let rej;
    const p = new Promise((resolve, reject) => {
      res = resolve;
      rej = reject;
    });
    const listener = () => {
      rej(new AbortError3());
    };
    (_a2 = options == null ? void 0 : options.signal) == null ? void 0 : _a2.addEventListener("abort", listener, {
      once: true
    });
    queue.add(async () => {
      await new Promise((resolve) => {
        res(() => {
          var _a3;
          (_a3 = options == null ? void 0 : options.signal) == null ? void 0 : _a3.removeEventListener("abort", listener);
          resolve();
        });
      });
    }, {
      signal: options == null ? void 0 : options.signal
    }).catch((err) => {
      rej(err);
    });
    return p;
  }
  var createMutex = (name3, options) => {
    let mutex = mutexes.get(name3);
    if (mutex != null) {
      return mutex;
    }
    const implementation2 = getImplementation(options);
    if (isMortice(implementation2)) {
      mutex = implementation2;
      mutexes.set(name3, mutex);
      return mutex;
    }
    const masterQueue = new Queue({
      concurrency: 1
    });
    let readQueue;
    mutex = {
      async readLock(opts) {
        if (readQueue != null) {
          return createReleasable(readQueue, opts);
        }
        readQueue = new Queue({
          concurrency: options.concurrency,
          autoStart: false
        });
        const localReadQueue = readQueue;
        const readPromise = createReleasable(readQueue, opts);
        void masterQueue.add(async () => {
          localReadQueue.start();
          await localReadQueue.onIdle().then(() => {
            if (readQueue === localReadQueue) {
              readQueue = null;
            }
          });
        });
        return readPromise;
      },
      async writeLock(opts) {
        readQueue = null;
        return createReleasable(masterQueue, opts);
      },
      finalize: () => {
        mutexes.delete(name3);
      },
      queue: masterQueue
    };
    mutexes.set(name3, mutex);
    return mutex;
  };

  // node_modules/mortice/dist/src/index.js
  var defaultOptions2 = {
    name: "lock",
    concurrency: Infinity,
    singleProcess: false
  };
  function createMortice(options) {
    const opts = Object.assign({}, defaultOptions2, options);
    return createMutex(opts.name, opts);
  }

  // node_modules/@libp2p/peer-store/dist/src/constants.js
  var import_browser_shims182 = __toESM(require_browser_shims(), 1);
  var MAX_ADDRESS_AGE = 36e5;
  var MAX_PEER_AGE = 216e5;

  // node_modules/@libp2p/peer-store/dist/src/pb/peer.js
  var import_browser_shims183 = __toESM(require_browser_shims(), 1);
  var Peer;
  (function(Peer2) {
    let Peer$metadataEntry;
    (function(Peer$metadataEntry2) {
      let _codec2;
      Peer$metadataEntry2.codec = () => {
        if (_codec2 == null) {
          _codec2 = message((obj, w2, opts = {}) => {
            if (opts.lengthDelimited !== false) {
              w2.fork();
            }
            if (obj.key != null && obj.key !== "") {
              w2.uint32(10);
              w2.string(obj.key);
            }
            if (obj.value != null && obj.value.byteLength > 0) {
              w2.uint32(18);
              w2.bytes(obj.value);
            }
            if (opts.lengthDelimited !== false) {
              w2.ldelim();
            }
          }, (reader, length4, opts = {}) => {
            const obj = {
              key: "",
              value: alloc(0)
            };
            const end = length4 == null ? reader.len : reader.pos + length4;
            while (reader.pos < end) {
              const tag = reader.uint32();
              switch (tag >>> 3) {
                case 1: {
                  obj.key = reader.string();
                  break;
                }
                case 2: {
                  obj.value = reader.bytes();
                  break;
                }
                default: {
                  reader.skipType(tag & 7);
                  break;
                }
              }
            }
            return obj;
          });
        }
        return _codec2;
      };
      Peer$metadataEntry2.encode = (obj) => {
        return encodeMessage(obj, Peer$metadataEntry2.codec());
      };
      Peer$metadataEntry2.decode = (buf, opts) => {
        return decodeMessage(buf, Peer$metadataEntry2.codec(), opts);
      };
    })(Peer$metadataEntry = Peer2.Peer$metadataEntry || (Peer2.Peer$metadataEntry = {}));
    let Peer$tagsEntry;
    (function(Peer$tagsEntry2) {
      let _codec2;
      Peer$tagsEntry2.codec = () => {
        if (_codec2 == null) {
          _codec2 = message((obj, w2, opts = {}) => {
            if (opts.lengthDelimited !== false) {
              w2.fork();
            }
            if (obj.key != null && obj.key !== "") {
              w2.uint32(10);
              w2.string(obj.key);
            }
            if (obj.value != null) {
              w2.uint32(18);
              Tag.codec().encode(obj.value, w2);
            }
            if (opts.lengthDelimited !== false) {
              w2.ldelim();
            }
          }, (reader, length4, opts = {}) => {
            var _a2;
            const obj = {
              key: ""
            };
            const end = length4 == null ? reader.len : reader.pos + length4;
            while (reader.pos < end) {
              const tag = reader.uint32();
              switch (tag >>> 3) {
                case 1: {
                  obj.key = reader.string();
                  break;
                }
                case 2: {
                  obj.value = Tag.codec().decode(reader, reader.uint32(), {
                    limits: (_a2 = opts.limits) == null ? void 0 : _a2.value
                  });
                  break;
                }
                default: {
                  reader.skipType(tag & 7);
                  break;
                }
              }
            }
            return obj;
          });
        }
        return _codec2;
      };
      Peer$tagsEntry2.encode = (obj) => {
        return encodeMessage(obj, Peer$tagsEntry2.codec());
      };
      Peer$tagsEntry2.decode = (buf, opts) => {
        return decodeMessage(buf, Peer$tagsEntry2.codec(), opts);
      };
    })(Peer$tagsEntry = Peer2.Peer$tagsEntry || (Peer2.Peer$tagsEntry = {}));
    let _codec;
    Peer2.codec = () => {
      if (_codec == null) {
        _codec = message((obj, w2, opts = {}) => {
          if (opts.lengthDelimited !== false) {
            w2.fork();
          }
          if (obj.addresses != null) {
            for (const value of obj.addresses) {
              w2.uint32(10);
              Address.codec().encode(value, w2);
            }
          }
          if (obj.protocols != null) {
            for (const value of obj.protocols) {
              w2.uint32(18);
              w2.string(value);
            }
          }
          if (obj.publicKey != null) {
            w2.uint32(34);
            w2.bytes(obj.publicKey);
          }
          if (obj.peerRecordEnvelope != null) {
            w2.uint32(42);
            w2.bytes(obj.peerRecordEnvelope);
          }
          if (obj.metadata != null && obj.metadata.size !== 0) {
            for (const [key, value] of obj.metadata.entries()) {
              w2.uint32(50);
              Peer2.Peer$metadataEntry.codec().encode({ key, value }, w2);
            }
          }
          if (obj.tags != null && obj.tags.size !== 0) {
            for (const [key, value] of obj.tags.entries()) {
              w2.uint32(58);
              Peer2.Peer$tagsEntry.codec().encode({ key, value }, w2);
            }
          }
          if (obj.updated != null) {
            w2.uint32(64);
            w2.uint64Number(obj.updated);
          }
          if (opts.lengthDelimited !== false) {
            w2.ldelim();
          }
        }, (reader, length4, opts = {}) => {
          var _a2, _b2, _c, _d, _e, _f;
          const obj = {
            addresses: [],
            protocols: [],
            metadata: /* @__PURE__ */ new Map(),
            tags: /* @__PURE__ */ new Map()
          };
          const end = length4 == null ? reader.len : reader.pos + length4;
          while (reader.pos < end) {
            const tag = reader.uint32();
            switch (tag >>> 3) {
              case 1: {
                if (((_a2 = opts.limits) == null ? void 0 : _a2.addresses) != null && obj.addresses.length === opts.limits.addresses) {
                  throw new MaxLengthError('Decode error - map field "addresses" had too many elements');
                }
                obj.addresses.push(Address.codec().decode(reader, reader.uint32(), {
                  limits: (_b2 = opts.limits) == null ? void 0 : _b2.addresses$
                }));
                break;
              }
              case 2: {
                if (((_c = opts.limits) == null ? void 0 : _c.protocols) != null && obj.protocols.length === opts.limits.protocols) {
                  throw new MaxLengthError('Decode error - map field "protocols" had too many elements');
                }
                obj.protocols.push(reader.string());
                break;
              }
              case 4: {
                obj.publicKey = reader.bytes();
                break;
              }
              case 5: {
                obj.peerRecordEnvelope = reader.bytes();
                break;
              }
              case 6: {
                if (((_d = opts.limits) == null ? void 0 : _d.metadata) != null && obj.metadata.size === opts.limits.metadata) {
                  throw new MaxSizeError('Decode error - map field "metadata" had too many elements');
                }
                const entry = Peer2.Peer$metadataEntry.codec().decode(reader, reader.uint32());
                obj.metadata.set(entry.key, entry.value);
                break;
              }
              case 7: {
                if (((_e = opts.limits) == null ? void 0 : _e.tags) != null && obj.tags.size === opts.limits.tags) {
                  throw new MaxSizeError('Decode error - map field "tags" had too many elements');
                }
                const entry = Peer2.Peer$tagsEntry.codec().decode(reader, reader.uint32(), {
                  limits: {
                    value: (_f = opts.limits) == null ? void 0 : _f.tags$value
                  }
                });
                obj.tags.set(entry.key, entry.value);
                break;
              }
              case 8: {
                obj.updated = reader.uint64Number();
                break;
              }
              default: {
                reader.skipType(tag & 7);
                break;
              }
            }
          }
          return obj;
        });
      }
      return _codec;
    };
    Peer2.encode = (obj) => {
      return encodeMessage(obj, Peer2.codec());
    };
    Peer2.decode = (buf, opts) => {
      return decodeMessage(buf, Peer2.codec(), opts);
    };
  })(Peer || (Peer = {}));
  var Address;
  (function(Address2) {
    let _codec;
    Address2.codec = () => {
      if (_codec == null) {
        _codec = message((obj, w2, opts = {}) => {
          if (opts.lengthDelimited !== false) {
            w2.fork();
          }
          if (obj.multiaddr != null && obj.multiaddr.byteLength > 0) {
            w2.uint32(10);
            w2.bytes(obj.multiaddr);
          }
          if (obj.isCertified != null) {
            w2.uint32(16);
            w2.bool(obj.isCertified);
          }
          if (obj.observed != null) {
            w2.uint32(24);
            w2.uint64Number(obj.observed);
          }
          if (opts.lengthDelimited !== false) {
            w2.ldelim();
          }
        }, (reader, length4, opts = {}) => {
          const obj = {
            multiaddr: alloc(0)
          };
          const end = length4 == null ? reader.len : reader.pos + length4;
          while (reader.pos < end) {
            const tag = reader.uint32();
            switch (tag >>> 3) {
              case 1: {
                obj.multiaddr = reader.bytes();
                break;
              }
              case 2: {
                obj.isCertified = reader.bool();
                break;
              }
              case 3: {
                obj.observed = reader.uint64Number();
                break;
              }
              default: {
                reader.skipType(tag & 7);
                break;
              }
            }
          }
          return obj;
        });
      }
      return _codec;
    };
    Address2.encode = (obj) => {
      return encodeMessage(obj, Address2.codec());
    };
    Address2.decode = (buf, opts) => {
      return decodeMessage(buf, Address2.codec(), opts);
    };
  })(Address || (Address = {}));
  var Tag;
  (function(Tag2) {
    let _codec;
    Tag2.codec = () => {
      if (_codec == null) {
        _codec = message((obj, w2, opts = {}) => {
          if (opts.lengthDelimited !== false) {
            w2.fork();
          }
          if (obj.value != null && obj.value !== 0) {
            w2.uint32(8);
            w2.uint32(obj.value);
          }
          if (obj.expiry != null) {
            w2.uint32(16);
            w2.uint64(obj.expiry);
          }
          if (opts.lengthDelimited !== false) {
            w2.ldelim();
          }
        }, (reader, length4, opts = {}) => {
          const obj = {
            value: 0
          };
          const end = length4 == null ? reader.len : reader.pos + length4;
          while (reader.pos < end) {
            const tag = reader.uint32();
            switch (tag >>> 3) {
              case 1: {
                obj.value = reader.uint32();
                break;
              }
              case 2: {
                obj.expiry = reader.uint64();
                break;
              }
              default: {
                reader.skipType(tag & 7);
                break;
              }
            }
          }
          return obj;
        });
      }
      return _codec;
    };
    Tag2.encode = (obj) => {
      return encodeMessage(obj, Tag2.codec());
    };
    Tag2.decode = (buf, opts) => {
      return decodeMessage(buf, Tag2.codec(), opts);
    };
  })(Tag || (Tag = {}));

  // node_modules/@libp2p/peer-store/dist/src/utils/bytes-to-peer.js
  var import_browser_shims184 = __toESM(require_browser_shims(), 1);
  function populatePublicKey(peerId2, protobuf) {
    if (peerId2.publicKey != null || protobuf.publicKey == null) {
      return peerId2;
    }
    let digest2;
    if (peerId2.type === "RSA") {
      digest2 = peerId2.toMultihash();
    }
    const publicKey = publicKeyFromProtobuf(protobuf.publicKey, digest2);
    return peerIdFromPublicKey(publicKey);
  }
  function bytesToPeer(peerId2, buf, maxAddressAge) {
    const peer = Peer.decode(buf);
    return pbToPeer(peerId2, peer, maxAddressAge);
  }
  function pbToPeer(peerId2, peer, maxAddressAge) {
    const tags = /* @__PURE__ */ new Map();
    const now = BigInt(Date.now());
    for (const [key, tag] of peer.tags.entries()) {
      if (tag.expiry != null && tag.expiry < now) {
        continue;
      }
      tags.set(key, tag);
    }
    return {
      ...peer,
      id: populatePublicKey(peerId2, peer),
      addresses: peer.addresses.filter(({ observed }) => observed != null && observed > Date.now() - maxAddressAge).map(({ multiaddr: ma, isCertified }) => {
        return {
          multiaddr: multiaddr(ma),
          isCertified: isCertified ?? false
        };
      }),
      metadata: peer.metadata,
      peerRecordEnvelope: peer.peerRecordEnvelope ?? void 0,
      tags
    };
  }

  // node_modules/@libp2p/peer-store/dist/src/utils/peer-equals.js
  var import_browser_shims185 = __toESM(require_browser_shims(), 1);
  function peerEquals(peerA, peerB) {
    return addressesEqual(peerA.addresses, peerB.addresses) && protocolsEqual(peerA.protocols, peerB.protocols) && publicKeyEqual(peerA.publicKey, peerB.publicKey) && peerRecordEnvelope(peerA.peerRecordEnvelope, peerB.peerRecordEnvelope) && metadataEqual(peerA.metadata, peerB.metadata) && tagsEqual(peerA.tags, peerB.tags);
  }
  function addressesEqual(addressesA, addressesB) {
    return compareArrays(addressesA, addressesB, (a, b) => {
      if (a.isCertified !== b.isCertified) {
        return false;
      }
      if (!equals3(a.multiaddr, b.multiaddr)) {
        return false;
      }
      return true;
    });
  }
  function protocolsEqual(protocolsA, protocolsB) {
    return compareArrays(protocolsA, protocolsB, (a, b) => a === b);
  }
  function publicKeyEqual(publicKeyA, publicKeyB) {
    return compareOptionalUint8Arrays(publicKeyA, publicKeyB);
  }
  function peerRecordEnvelope(envelopeA, envelopeB) {
    return compareOptionalUint8Arrays(envelopeA, envelopeB);
  }
  function metadataEqual(metadataA, metadataB) {
    return compareMaps(metadataA, metadataB, (a, b) => equals3(a, b));
  }
  function tagsEqual(metadataA, metadataB) {
    return compareMaps(metadataA, metadataB, (a, b) => a.value === b.value && a.expiry === b.expiry);
  }
  function compareOptionalUint8Arrays(arrA, arrB) {
    if (arrA == null && arrB == null) {
      return true;
    }
    if (arrA != null && arrB != null) {
      return equals3(arrA, arrB);
    }
    return false;
  }
  function compareArrays(arrA, arrB, compare2) {
    if (arrA.length !== arrB.length) {
      return false;
    }
    for (let i = 0; i < arrA.length; i++) {
      if (!compare2(arrA[i], arrB[i])) {
        return false;
      }
    }
    return true;
  }
  function compareMaps(mapA, mapB, compare2) {
    if (mapA.size !== mapB.size) {
      return false;
    }
    for (const [key, value] of mapA.entries()) {
      const valueB = mapB.get(key);
      if (valueB == null) {
        return false;
      }
      if (!compare2(value, valueB)) {
        return false;
      }
    }
    return true;
  }

  // node_modules/@libp2p/peer-store/dist/src/utils/peer-id-to-datastore-key.js
  var import_browser_shims187 = __toESM(require_browser_shims(), 1);

  // node_modules/interface-datastore/dist/src/key.js
  var import_browser_shims186 = __toESM(require_browser_shims(), 1);
  var pathSepS = "/";
  var pathSepB = new TextEncoder().encode(pathSepS);
  var pathSep = pathSepB[0];
  var Key = class _Key {
    _buf;
    /**
     * @param {string | Uint8Array} s
     * @param {boolean} [clean]
     */
    constructor(s2, clean3) {
      if (typeof s2 === "string") {
        this._buf = fromString2(s2);
      } else if (s2 instanceof Uint8Array) {
        this._buf = s2;
      } else {
        throw new Error("Invalid key, should be String of Uint8Array");
      }
      if (clean3 == null) {
        clean3 = true;
      }
      if (clean3) {
        this.clean();
      }
      if (this._buf.byteLength === 0 || this._buf[0] !== pathSep) {
        throw new Error("Invalid key");
      }
    }
    /**
     * Convert to the string representation
     *
     * @param {import('uint8arrays/to-string').SupportedEncodings} [encoding] - The encoding to use.
     * @returns {string}
     */
    toString(encoding = "utf8") {
      return toString2(this._buf, encoding);
    }
    /**
     * Return the Uint8Array representation of the key
     *
     * @returns {Uint8Array}
     */
    uint8Array() {
      return this._buf;
    }
    /**
     * Return string representation of the key
     *
     * @returns {string}
     */
    get [Symbol.toStringTag]() {
      return `Key(${this.toString()})`;
    }
    /**
     * Constructs a key out of a namespace array.
     *
     * @param {Array<string>} list - The array of namespaces
     * @returns {Key}
     *
     * @example
     * ```js
     * Key.withNamespaces(['one', 'two'])
     * // => Key('/one/two')
     * ```
     */
    static withNamespaces(list) {
      return new _Key(list.join(pathSepS));
    }
    /**
     * Returns a randomly (uuid) generated key.
     *
     * @returns {Key}
     *
     * @example
     * ```js
     * Key.random()
     * // => Key('/344502982398')
     * ```
     */
    static random() {
      return new _Key(Math.random().toString().substring(2));
    }
    /**
     * @param {*} other
     */
    static asKey(other) {
      if (other instanceof Uint8Array || typeof other === "string") {
        return new _Key(other);
      }
      if (typeof other.uint8Array === "function") {
        return new _Key(other.uint8Array());
      }
      return null;
    }
    /**
     * Cleanup the current key
     *
     * @returns {void}
     */
    clean() {
      if (this._buf == null || this._buf.byteLength === 0) {
        this._buf = pathSepB;
      }
      if (this._buf[0] !== pathSep) {
        const bytes = new Uint8Array(this._buf.byteLength + 1);
        bytes.fill(pathSep, 0, 1);
        bytes.set(this._buf, 1);
        this._buf = bytes;
      }
      while (this._buf.byteLength > 1 && this._buf[this._buf.byteLength - 1] === pathSep) {
        this._buf = this._buf.subarray(0, -1);
      }
    }
    /**
     * Check if the given key is sorted lower than ourself.
     *
     * @param {Key} key - The other Key to check against
     * @returns {boolean}
     */
    less(key) {
      const list1 = this.list();
      const list2 = key.list();
      for (let i = 0; i < list1.length; i++) {
        if (list2.length < i + 1) {
          return false;
        }
        const c1 = list1[i];
        const c2 = list2[i];
        if (c1 < c2) {
          return true;
        } else if (c1 > c2) {
          return false;
        }
      }
      return list1.length < list2.length;
    }
    /**
     * Returns the key with all parts in reversed order.
     *
     * @returns {Key}
     *
     * @example
     * ```js
     * new Key('/Comedy/MontyPython/Actor:JohnCleese').reverse()
     * // => Key('/Actor:JohnCleese/MontyPython/Comedy')
     * ```
     */
    reverse() {
      return _Key.withNamespaces(this.list().slice().reverse());
    }
    /**
     * Returns the `namespaces` making up this Key.
     *
     * @returns {Array<string>}
     */
    namespaces() {
      return this.list();
    }
    /**
     * Returns the "base" namespace of this key.
     *
     * @returns {string}
     *
     * @example
     * ```js
     * new Key('/Comedy/MontyPython/Actor:JohnCleese').baseNamespace()
     * // => 'Actor:JohnCleese'
     * ```
     */
    baseNamespace() {
      const ns = this.namespaces();
      return ns[ns.length - 1];
    }
    /**
     * Returns the `list` representation of this key.
     *
     * @returns {Array<string>}
     *
     * @example
     * ```js
     * new Key('/Comedy/MontyPython/Actor:JohnCleese').list()
     * // => ['Comedy', 'MontyPythong', 'Actor:JohnCleese']
     * ```
     */
    list() {
      return this.toString().split(pathSepS).slice(1);
    }
    /**
     * Returns the "type" of this key (value of last namespace).
     *
     * @returns {string}
     *
     * @example
     * ```js
     * new Key('/Comedy/MontyPython/Actor:JohnCleese').type()
     * // => 'Actor'
     * ```
     */
    type() {
      return namespaceType(this.baseNamespace());
    }
    /**
     * Returns the "name" of this key (field of last namespace).
     *
     * @returns {string}
     *
     * @example
     * ```js
     * new Key('/Comedy/MontyPython/Actor:JohnCleese').name()
     * // => 'JohnCleese'
     * ```
     */
    name() {
      return namespaceValue(this.baseNamespace());
    }
    /**
     * Returns an "instance" of this type key (appends value to namespace).
     *
     * @param {string} s - The string to append.
     * @returns {Key}
     *
     * @example
     * ```js
     * new Key('/Comedy/MontyPython/Actor').instance('JohnClesse')
     * // => Key('/Comedy/MontyPython/Actor:JohnCleese')
     * ```
     */
    instance(s2) {
      return new _Key(this.toString() + ":" + s2);
    }
    /**
     * Returns the "path" of this key (parent + type).
     *
     * @returns {Key}
     *
     * @example
     * ```js
     * new Key('/Comedy/MontyPython/Actor:JohnCleese').path()
     * // => Key('/Comedy/MontyPython/Actor')
     * ```
     */
    path() {
      let p = this.parent().toString();
      if (!p.endsWith(pathSepS)) {
        p += pathSepS;
      }
      p += this.type();
      return new _Key(p);
    }
    /**
     * Returns the `parent` Key of this Key.
     *
     * @returns {Key}
     *
     * @example
     * ```js
     * new Key("/Comedy/MontyPython/Actor:JohnCleese").parent()
     * // => Key("/Comedy/MontyPython")
     * ```
     */
    parent() {
      const list = this.list();
      if (list.length === 1) {
        return new _Key(pathSepS);
      }
      return new _Key(list.slice(0, -1).join(pathSepS));
    }
    /**
     * Returns the `child` Key of this Key.
     *
     * @param {Key} key - The child Key to add
     * @returns {Key}
     *
     * @example
     * ```js
     * new Key('/Comedy/MontyPython').child(new Key('Actor:JohnCleese'))
     * // => Key('/Comedy/MontyPython/Actor:JohnCleese')
     * ```
     */
    child(key) {
      if (this.toString() === pathSepS) {
        return key;
      } else if (key.toString() === pathSepS) {
        return this;
      }
      return new _Key(this.toString() + key.toString(), false);
    }
    /**
     * Returns whether this key is a prefix of `other`
     *
     * @param {Key} other - The other key to test against
     * @returns {boolean}
     *
     * @example
     * ```js
     * new Key('/Comedy').isAncestorOf('/Comedy/MontyPython')
     * // => true
     * ```
     */
    isAncestorOf(other) {
      if (other.toString() === this.toString()) {
        return false;
      }
      return other.toString().startsWith(this.toString());
    }
    /**
     * Returns whether this key is a contains another as prefix.
     *
     * @param {Key} other - The other Key to test against
     * @returns {boolean}
     *
     * @example
     * ```js
     * new Key('/Comedy/MontyPython').isDecendantOf('/Comedy')
     * // => true
     * ```
     */
    isDecendantOf(other) {
      if (other.toString() === this.toString()) {
        return false;
      }
      return this.toString().startsWith(other.toString());
    }
    /**
     * Checks if this key has only one namespace.
     *
     * @returns {boolean}
     */
    isTopLevel() {
      return this.list().length === 1;
    }
    /**
     * Concats one or more Keys into one new Key.
     *
     * @param {Array<Key>} keys - The array of keys to concatenate
     * @returns {Key}
     */
    concat(...keys) {
      return _Key.withNamespaces([...this.namespaces(), ...flatten(keys.map((key) => key.namespaces()))]);
    }
  };
  function namespaceType(ns) {
    const parts = ns.split(":");
    if (parts.length < 2) {
      return "";
    }
    return parts.slice(0, -1).join(":");
  }
  function namespaceValue(ns) {
    const parts = ns.split(":");
    return parts[parts.length - 1];
  }
  function flatten(arr) {
    return [].concat(...arr);
  }

  // node_modules/@libp2p/peer-store/dist/src/utils/peer-id-to-datastore-key.js
  var NAMESPACE_COMMON = "/peers/";
  function peerIdToDatastoreKey(peerId2) {
    if (!isPeerId(peerId2) || peerId2.type == null) {
      throw new InvalidParametersError("Invalid PeerId");
    }
    const b32key = peerId2.toCID().toString();
    return new Key(`${NAMESPACE_COMMON}${b32key}`);
  }

  // node_modules/@libp2p/peer-store/dist/src/utils/to-peer-pb.js
  var import_browser_shims189 = __toESM(require_browser_shims(), 1);

  // node_modules/@libp2p/peer-store/dist/src/utils/dedupe-addresses.js
  var import_browser_shims188 = __toESM(require_browser_shims(), 1);
  async function dedupeFilterAndSortAddresses(peerId2, filter2, addresses, existingAddresses, options) {
    const addressMap = /* @__PURE__ */ new Map();
    for (const addr of addresses) {
      if (addr == null) {
        continue;
      }
      if (addr.multiaddr instanceof Uint8Array) {
        addr.multiaddr = multiaddr(addr.multiaddr);
      }
      if (!isMultiaddr(addr.multiaddr)) {
        throw new InvalidParametersError("Multiaddr was invalid");
      }
      if (!await filter2(peerId2, addr.multiaddr, options)) {
        continue;
      }
      const isCertified = addr.isCertified ?? false;
      const maStr = addr.multiaddr.toString();
      const existingAddr = addressMap.get(maStr);
      if (existingAddr != null) {
        addr.isCertified = existingAddr.isCertified || isCertified;
      } else {
        addressMap.set(maStr, {
          multiaddr: addr.multiaddr,
          isCertified
        });
      }
    }
    return [...addressMap.values()].sort((a, b) => {
      return a.multiaddr.toString().localeCompare(b.multiaddr.toString());
    }).map(({ isCertified, multiaddr: ma }) => {
      const addrPeer = ma.getPeerId();
      if (peerId2.equals(addrPeer)) {
        ma = ma.decapsulate(multiaddr(`/p2p/${peerId2}`));
      }
      return {
        isCertified,
        multiaddr: ma.bytes
      };
    });
  }

  // node_modules/@libp2p/peer-store/dist/src/utils/to-peer-pb.js
  async function toPeerPB(peerId2, data, strategy, options) {
    var _a2, _b2;
    if (data == null) {
      throw new InvalidParametersError("Invalid PeerData");
    }
    if (data.publicKey != null && peerId2.publicKey != null && !data.publicKey.equals(peerId2.publicKey)) {
      throw new InvalidParametersError("publicKey bytes do not match peer id publicKey bytes");
    }
    const existingPeer = (_a2 = options.existingPeer) == null ? void 0 : _a2.peer;
    if (existingPeer != null && !peerId2.equals(existingPeer.id)) {
      throw new InvalidParametersError("peer id did not match existing peer id");
    }
    let addresses = (existingPeer == null ? void 0 : existingPeer.addresses) ?? [];
    let protocols = new Set((existingPeer == null ? void 0 : existingPeer.protocols) ?? []);
    let metadata = (existingPeer == null ? void 0 : existingPeer.metadata) ?? /* @__PURE__ */ new Map();
    let tags = (existingPeer == null ? void 0 : existingPeer.tags) ?? /* @__PURE__ */ new Map();
    let peerRecordEnvelope2 = existingPeer == null ? void 0 : existingPeer.peerRecordEnvelope;
    if (strategy === "patch") {
      if (data.multiaddrs != null || data.addresses != null) {
        addresses = [];
        if (data.multiaddrs != null) {
          addresses.push(...data.multiaddrs.map((multiaddr2) => ({
            isCertified: false,
            multiaddr: multiaddr2
          })));
        }
        if (data.addresses != null) {
          addresses.push(...data.addresses);
        }
      }
      if (data.protocols != null) {
        protocols = new Set(data.protocols);
      }
      if (data.metadata != null) {
        const metadataEntries = data.metadata instanceof Map ? [...data.metadata.entries()] : Object.entries(data.metadata);
        metadata = createSortedMap(metadataEntries, {
          validate: validateMetadata
        });
      }
      if (data.tags != null) {
        const tagsEntries = data.tags instanceof Map ? [...data.tags.entries()] : Object.entries(data.tags);
        tags = createSortedMap(tagsEntries, {
          validate: validateTag,
          map: mapTag
        });
      }
      if (data.peerRecordEnvelope != null) {
        peerRecordEnvelope2 = data.peerRecordEnvelope;
      }
    }
    if (strategy === "merge") {
      if (data.multiaddrs != null) {
        addresses.push(...data.multiaddrs.map((multiaddr2) => ({
          isCertified: false,
          multiaddr: multiaddr2
        })));
      }
      if (data.addresses != null) {
        addresses.push(...data.addresses);
      }
      if (data.protocols != null) {
        protocols = /* @__PURE__ */ new Set([...protocols, ...data.protocols]);
      }
      if (data.metadata != null) {
        const metadataEntries = data.metadata instanceof Map ? [...data.metadata.entries()] : Object.entries(data.metadata);
        for (const [key, value] of metadataEntries) {
          if (value == null) {
            metadata.delete(key);
          } else {
            metadata.set(key, value);
          }
        }
        metadata = createSortedMap([...metadata.entries()], {
          validate: validateMetadata
        });
      }
      if (data.tags != null) {
        const tagsEntries = data.tags instanceof Map ? [...data.tags.entries()] : Object.entries(data.tags);
        const mergedTags = new Map(tags);
        for (const [key, value] of tagsEntries) {
          if (value == null) {
            mergedTags.delete(key);
          } else {
            mergedTags.set(key, value);
          }
        }
        tags = createSortedMap([...mergedTags.entries()], {
          validate: validateTag,
          map: mapTag
        });
      }
      if (data.peerRecordEnvelope != null) {
        peerRecordEnvelope2 = data.peerRecordEnvelope;
      }
    }
    let publicKey;
    if ((existingPeer == null ? void 0 : existingPeer.id.publicKey) != null) {
      publicKey = publicKeyToProtobuf(existingPeer.id.publicKey);
    } else if (data.publicKey != null) {
      publicKey = publicKeyToProtobuf(data.publicKey);
    } else if (peerId2.publicKey != null) {
      publicKey = publicKeyToProtobuf(peerId2.publicKey);
    }
    const output = {
      addresses: await dedupeFilterAndSortAddresses(peerId2, options.addressFilter ?? (async () => true), addresses, (_b2 = options.existingPeer) == null ? void 0 : _b2.peerPB.addresses, options),
      protocols: [...protocols.values()].sort((a, b) => {
        return a.localeCompare(b);
      }),
      metadata,
      tags,
      publicKey,
      peerRecordEnvelope: peerRecordEnvelope2
    };
    output.addresses.forEach((addr) => {
      var _a3, _b3, _c;
      addr.observed = ((_c = (_b3 = (_a3 = options.existingPeer) == null ? void 0 : _a3.peerPB.addresses) == null ? void 0 : _b3.find((addr2) => equals3(addr2.multiaddr, addr2.multiaddr))) == null ? void 0 : _c.observed) ?? Date.now();
    });
    if (peerId2.type !== "RSA") {
      delete output.publicKey;
    }
    return output;
  }
  function createSortedMap(entries, options) {
    var _a2;
    const output = /* @__PURE__ */ new Map();
    for (const [key, value] of entries) {
      if (value == null) {
        continue;
      }
      options.validate(key, value);
    }
    for (const [key, value] of entries.sort(([a], [b]) => {
      return a.localeCompare(b);
    })) {
      if (value != null) {
        output.set(key, ((_a2 = options.map) == null ? void 0 : _a2.call(options, key, value)) ?? value);
      }
    }
    return output;
  }
  function validateMetadata(key, value) {
    if (typeof key !== "string") {
      throw new InvalidParametersError("Metadata key must be a string");
    }
    if (!(value instanceof Uint8Array)) {
      throw new InvalidParametersError("Metadata value must be a Uint8Array");
    }
  }
  function validateTag(key, tag) {
    if (typeof key !== "string") {
      throw new InvalidParametersError("Tag name must be a string");
    }
    if (tag.value != null) {
      if (parseInt(`${tag.value}`, 10) !== tag.value) {
        throw new InvalidParametersError("Tag value must be an integer");
      }
      if (tag.value < 0 || tag.value > 100) {
        throw new InvalidParametersError("Tag value must be between 0-100");
      }
    }
    if (tag.ttl != null) {
      if (parseInt(`${tag.ttl}`, 10) !== tag.ttl) {
        throw new InvalidParametersError("Tag ttl must be an integer");
      }
      if (tag.ttl < 0) {
        throw new InvalidParametersError("Tag ttl must be between greater than 0");
      }
    }
  }
  function mapTag(key, tag) {
    let expiry;
    if (tag.expiry != null) {
      expiry = tag.expiry;
    }
    if (tag.ttl != null) {
      expiry = BigInt(Date.now() + Number(tag.ttl));
    }
    const output = {
      value: tag.value ?? 0
    };
    if (expiry != null) {
      output.expiry = expiry;
    }
    return output;
  }

  // node_modules/@libp2p/peer-store/dist/src/store.js
  function keyToPeerId(key) {
    const base32Str = key.toString().split("/")[2];
    const buf = CID.parse(base32Str, base32);
    return peerIdFromCID(buf);
  }
  function decodePeer(key, value, maxAddressAge) {
    const peerId2 = keyToPeerId(key);
    return bytesToPeer(peerId2, value, maxAddressAge);
  }
  function mapQuery(query, maxAddressAge) {
    return {
      prefix: NAMESPACE_COMMON,
      filters: (query.filters ?? []).map((fn) => ({ key, value }) => {
        return fn(decodePeer(key, value, maxAddressAge));
      }),
      orders: (query.orders ?? []).map((fn) => (a, b) => {
        return fn(decodePeer(a.key, a.value, maxAddressAge), decodePeer(b.key, b.value, maxAddressAge));
      })
    };
  }
  var PersistentStore = class {
    peerId;
    datastore;
    locks;
    addressFilter;
    log;
    maxAddressAge;
    maxPeerAge;
    constructor(components, init = {}) {
      this.log = components.logger.forComponent("libp2p:peer-store");
      this.peerId = components.peerId;
      this.datastore = components.datastore;
      this.addressFilter = init.addressFilter;
      this.locks = trackedPeerMap({
        name: "libp2p_peer_store_locks",
        metrics: components.metrics
      });
      this.maxAddressAge = init.maxAddressAge ?? MAX_ADDRESS_AGE;
      this.maxPeerAge = init.maxPeerAge ?? MAX_PEER_AGE;
    }
    getLock(peerId2) {
      let lock = this.locks.get(peerId2);
      if (lock == null) {
        lock = {
          refs: 0,
          lock: createMortice({
            name: peerId2.toString(),
            singleProcess: true
          })
        };
        this.locks.set(peerId2, lock);
      }
      lock.refs++;
      return lock;
    }
    maybeRemoveLock(peerId2, lock) {
      lock.refs--;
      if (lock.refs === 0) {
        lock.lock.finalize();
        this.locks.delete(peerId2);
      }
    }
    async getReadLock(peerId2, options) {
      const lock = this.getLock(peerId2);
      try {
        const release = await lock.lock.readLock(options);
        return () => {
          release();
          this.maybeRemoveLock(peerId2, lock);
        };
      } catch (err) {
        this.maybeRemoveLock(peerId2, lock);
        throw err;
      }
    }
    async getWriteLock(peerId2, options) {
      const lock = this.getLock(peerId2);
      try {
        const release = await lock.lock.writeLock(options);
        return () => {
          release();
          this.maybeRemoveLock(peerId2, lock);
        };
      } catch (err) {
        this.maybeRemoveLock(peerId2, lock);
        throw err;
      }
    }
    async has(peerId2, options) {
      try {
        await this.load(peerId2, options);
        return true;
      } catch (err) {
        if (err.name !== "NotFoundError") {
          throw err;
        }
      }
      return false;
    }
    async delete(peerId2, options) {
      if (this.peerId.equals(peerId2)) {
        return;
      }
      await this.datastore.delete(peerIdToDatastoreKey(peerId2), options);
    }
    async load(peerId2, options) {
      const key = peerIdToDatastoreKey(peerId2);
      const buf = await this.datastore.get(key, options);
      const peer = Peer.decode(buf);
      if (this.#peerIsExpired(peerId2, peer)) {
        await this.datastore.delete(key, options);
        throw new NotFoundError();
      }
      return pbToPeer(peerId2, peer, this.peerId.equals(peerId2) ? Infinity : this.maxAddressAge);
    }
    async save(peerId2, data, options) {
      const existingPeer = await this.#findExistingPeer(peerId2, options);
      const peerPb = await toPeerPB(peerId2, data, "patch", {
        ...options,
        addressFilter: this.addressFilter
      });
      return this.#saveIfDifferent(peerId2, peerPb, existingPeer);
    }
    async patch(peerId2, data, options) {
      const existingPeer = await this.#findExistingPeer(peerId2, options);
      const peerPb = await toPeerPB(peerId2, data, "patch", {
        ...options,
        addressFilter: this.addressFilter,
        existingPeer
      });
      return this.#saveIfDifferent(peerId2, peerPb, existingPeer);
    }
    async merge(peerId2, data, options) {
      const existingPeer = await this.#findExistingPeer(peerId2, options);
      const peerPb = await toPeerPB(peerId2, data, "merge", {
        addressFilter: this.addressFilter,
        existingPeer
      });
      return this.#saveIfDifferent(peerId2, peerPb, existingPeer);
    }
    async *all(options) {
      for await (const { key, value } of this.datastore.query(mapQuery(options ?? {}, this.maxAddressAge), options)) {
        const peerId2 = keyToPeerId(key);
        if (peerId2.equals(this.peerId)) {
          continue;
        }
        const peer = Peer.decode(value);
        if (this.#peerIsExpired(peerId2, peer)) {
          await this.datastore.delete(key, options);
          continue;
        }
        yield pbToPeer(peerId2, peer, this.peerId.equals(peerId2) ? Infinity : this.maxAddressAge);
      }
    }
    async #findExistingPeer(peerId2, options) {
      try {
        const key = peerIdToDatastoreKey(peerId2);
        const buf = await this.datastore.get(key, options);
        const peerPB = Peer.decode(buf);
        if (this.#peerIsExpired(peerId2, peerPB)) {
          await this.datastore.delete(key, options);
          throw new NotFoundError();
        }
        return {
          peerPB,
          peer: pbToPeer(peerId2, peerPB, this.maxAddressAge)
        };
      } catch (err) {
        if (err.name !== "NotFoundError") {
          this.log.error("invalid peer data found in peer store - %e", err);
        }
      }
    }
    async #saveIfDifferent(peerId2, peer, existingPeer, options) {
      peer.updated = Date.now();
      const buf = Peer.encode(peer);
      await this.datastore.put(peerIdToDatastoreKey(peerId2), buf, options);
      return {
        peer: pbToPeer(peerId2, peer, this.maxAddressAge),
        previous: existingPeer == null ? void 0 : existingPeer.peer,
        updated: existingPeer == null || !peerEquals(peer, existingPeer.peerPB)
      };
    }
    #peerIsExpired(peerId2, peer) {
      if (peer.updated == null) {
        return true;
      }
      if (this.peerId.equals(peerId2)) {
        return false;
      }
      const expired = peer.updated < Date.now() - this.maxPeerAge;
      const minAddressObserved = Date.now() - this.maxAddressAge;
      const addrs = peer.addresses.filter((addr) => {
        return addr.observed != null && addr.observed > minAddressObserved;
      });
      return expired && addrs.length === 0;
    }
  };

  // node_modules/@libp2p/peer-store/dist/src/index.js
  var PersistentPeerStore = class {
    store;
    events;
    peerId;
    log;
    constructor(components, init = {}) {
      this.log = components.logger.forComponent("libp2p:peer-store");
      this.events = components.events;
      this.peerId = components.peerId;
      this.store = new PersistentStore(components, init);
    }
    [Symbol.toStringTag] = "@libp2p/peer-store";
    async forEach(fn, query) {
      for await (const peer of this.store.all(query)) {
        fn(peer);
      }
    }
    async all(query) {
      return src_default2(this.store.all(query));
    }
    async delete(peerId2, options) {
      const release = await this.store.getReadLock(peerId2, options);
      try {
        await this.store.delete(peerId2, options);
      } finally {
        release();
      }
    }
    async has(peerId2, options) {
      const release = await this.store.getReadLock(peerId2, options);
      try {
        return await this.store.has(peerId2, options);
      } finally {
        this.log.trace("has release read lock");
        release == null ? void 0 : release();
      }
    }
    async get(peerId2, options) {
      const release = await this.store.getReadLock(peerId2, options);
      try {
        return await this.store.load(peerId2, options);
      } finally {
        release == null ? void 0 : release();
      }
    }
    async getInfo(peerId2, options) {
      const peer = await this.get(peerId2, options);
      return {
        id: peer.id,
        multiaddrs: peer.addresses.map(({ multiaddr: multiaddr2 }) => multiaddr2)
      };
    }
    async save(id, data, options) {
      const release = await this.store.getWriteLock(id, options);
      try {
        const result = await this.store.save(id, data, options);
        this.#emitIfUpdated(id, result);
        return result.peer;
      } finally {
        release == null ? void 0 : release();
      }
    }
    async patch(id, data, options) {
      const release = await this.store.getWriteLock(id, options);
      try {
        const result = await this.store.patch(id, data, options);
        this.#emitIfUpdated(id, result);
        return result.peer;
      } finally {
        release == null ? void 0 : release();
      }
    }
    async merge(id, data, options) {
      const release = await this.store.getWriteLock(id, options);
      try {
        const result = await this.store.merge(id, data, options);
        this.#emitIfUpdated(id, result);
        return result.peer;
      } finally {
        release == null ? void 0 : release();
      }
    }
    async consumePeerRecord(buf, arg1, arg2) {
      const expectedPeer = isPeerId(arg1) ? arg1 : isPeerId(arg1 == null ? void 0 : arg1.expectedPeer) ? arg1.expectedPeer : void 0;
      const options = isPeerId(arg1) ? arg2 : arg1 === void 0 ? arg2 : arg1;
      const envelope = await RecordEnvelope.openAndCertify(buf, PeerRecord2.DOMAIN, options);
      const peerId2 = peerIdFromCID(envelope.publicKey.toCID());
      if ((expectedPeer == null ? void 0 : expectedPeer.equals(peerId2)) === false) {
        this.log("envelope peer id was not the expected peer id - expected: %p received: %p", expectedPeer, peerId2);
        return false;
      }
      const peerRecord = PeerRecord2.createFromProtobuf(envelope.payload);
      let peer;
      try {
        peer = await this.get(peerId2, options);
      } catch (err) {
        if (err.name !== "NotFoundError") {
          throw err;
        }
      }
      if ((peer == null ? void 0 : peer.peerRecordEnvelope) != null) {
        const storedEnvelope = RecordEnvelope.createFromProtobuf(peer.peerRecordEnvelope);
        const storedRecord = PeerRecord2.createFromProtobuf(storedEnvelope.payload);
        if (storedRecord.seqNumber >= peerRecord.seqNumber) {
          this.log("sequence number was lower or equal to existing sequence number - stored: %d received: %d", storedRecord.seqNumber, peerRecord.seqNumber);
          return false;
        }
      }
      await this.patch(peerRecord.peerId, {
        peerRecordEnvelope: buf,
        addresses: peerRecord.multiaddrs.map((multiaddr2) => ({
          isCertified: true,
          multiaddr: multiaddr2
        }))
      }, options);
      return true;
    }
    #emitIfUpdated(id, result) {
      if (!result.updated) {
        return;
      }
      if (this.peerId.equals(id)) {
        this.events.safeDispatchEvent("self:peer:update", { detail: result });
      } else {
        this.events.safeDispatchEvent("peer:update", { detail: result });
      }
    }
  };
  function persistentPeerStore(components, init = {}) {
    return new PersistentPeerStore(components, init);
  }

  // node_modules/datastore-core/dist/src/memory.js
  var import_browser_shims200 = __toESM(require_browser_shims(), 1);

  // node_modules/interface-store/dist/src/index.js
  var import_browser_shims193 = __toESM(require_browser_shims(), 1);

  // node_modules/interface-store/dist/src/errors.js
  var import_browser_shims192 = __toESM(require_browser_shims(), 1);
  var NotFoundError2 = class _NotFoundError extends Error {
    static name = "NotFoundError";
    static code = "ERR_NOT_FOUND";
    name = _NotFoundError.name;
    code = _NotFoundError.code;
    constructor(message2 = "Not Found") {
      super(message2);
    }
  };

  // node_modules/datastore-core/dist/src/base.js
  var import_browser_shims199 = __toESM(require_browser_shims(), 1);

  // node_modules/it-drain/dist/src/index.js
  var import_browser_shims194 = __toESM(require_browser_shims(), 1);
  function isAsyncIterable2(thing) {
    return thing[Symbol.asyncIterator] != null;
  }
  function drain(source) {
    if (isAsyncIterable2(source)) {
      return (async () => {
        for await (const _ of source) {
        }
      })();
    } else {
      for (const _ of source) {
      }
    }
  }
  var src_default3 = drain;

  // node_modules/it-filter/dist/src/index.js
  var import_browser_shims196 = __toESM(require_browser_shims(), 1);

  // node_modules/it-peekable/dist/src/index.js
  var import_browser_shims195 = __toESM(require_browser_shims(), 1);
  function peekable(iterable) {
    const [iterator, symbol3] = iterable[Symbol.asyncIterator] != null ? [iterable[Symbol.asyncIterator](), Symbol.asyncIterator] : [iterable[Symbol.iterator](), Symbol.iterator];
    const queue = [];
    return {
      peek: () => {
        return iterator.next();
      },
      push: (value) => {
        queue.push(value);
      },
      next: () => {
        if (queue.length > 0) {
          return {
            done: false,
            value: queue.shift()
          };
        }
        return iterator.next();
      },
      [symbol3]() {
        return this;
      }
    };
  }
  var src_default4 = peekable;

  // node_modules/it-filter/dist/src/index.js
  function isAsyncIterable3(thing) {
    return thing[Symbol.asyncIterator] != null;
  }
  function filter(source, fn) {
    let index = 0;
    if (isAsyncIterable3(source)) {
      return async function* () {
        for await (const entry of source) {
          if (await fn(entry, index++)) {
            yield entry;
          }
        }
      }();
    }
    const peekable2 = src_default4(source);
    const { value, done } = peekable2.next();
    if (done === true) {
      return function* () {
      }();
    }
    const res = fn(value, index++);
    if (typeof res.then === "function") {
      return async function* () {
        if (await res) {
          yield value;
        }
        for (const entry of peekable2) {
          if (await fn(entry, index++)) {
            yield entry;
          }
        }
      }();
    }
    const func2 = fn;
    return function* () {
      if (res === true) {
        yield value;
      }
      for (const entry of peekable2) {
        if (func2(entry, index++)) {
          yield entry;
        }
      }
    }();
  }
  var src_default5 = filter;

  // node_modules/it-sort/dist/src/index.js
  var import_browser_shims197 = __toESM(require_browser_shims(), 1);
  function isAsyncIterable4(thing) {
    return thing[Symbol.asyncIterator] != null;
  }
  function sort(source, sorter) {
    if (isAsyncIterable4(source)) {
      return async function* () {
        const arr = await src_default2(source);
        yield* arr.sort(sorter);
      }();
    }
    return function* () {
      const arr = src_default2(source);
      yield* arr.sort(sorter);
    }();
  }
  var src_default6 = sort;

  // node_modules/it-take/dist/src/index.js
  var import_browser_shims198 = __toESM(require_browser_shims(), 1);
  function isAsyncIterable5(thing) {
    return thing[Symbol.asyncIterator] != null;
  }
  function take(source, limit) {
    if (isAsyncIterable5(source)) {
      return async function* () {
        let items = 0;
        if (limit < 1) {
          return;
        }
        for await (const entry of source) {
          yield entry;
          items++;
          if (items === limit) {
            return;
          }
        }
      }();
    }
    return function* () {
      let items = 0;
      if (limit < 1) {
        return;
      }
      for (const entry of source) {
        yield entry;
        items++;
        if (items === limit) {
          return;
        }
      }
    }();
  }
  var src_default7 = take;

  // node_modules/datastore-core/dist/src/base.js
  var BaseDatastore = class {
    put(key, val, options) {
      return Promise.reject(new Error(".put is not implemented"));
    }
    get(key, options) {
      return Promise.reject(new Error(".get is not implemented"));
    }
    has(key, options) {
      return Promise.reject(new Error(".has is not implemented"));
    }
    delete(key, options) {
      return Promise.reject(new Error(".delete is not implemented"));
    }
    async *putMany(source, options = {}) {
      for await (const { key, value } of source) {
        await this.put(key, value, options);
        yield key;
      }
    }
    async *getMany(source, options = {}) {
      for await (const key of source) {
        yield {
          key,
          value: await this.get(key, options)
        };
      }
    }
    async *deleteMany(source, options = {}) {
      for await (const key of source) {
        await this.delete(key, options);
        yield key;
      }
    }
    batch() {
      let puts = [];
      let dels = [];
      return {
        put(key, value) {
          puts.push({ key, value });
        },
        delete(key) {
          dels.push(key);
        },
        commit: async (options) => {
          await src_default3(this.putMany(puts, options));
          puts = [];
          await src_default3(this.deleteMany(dels, options));
          dels = [];
        }
      };
    }
    /**
     * Extending classes should override `query` or implement this method
     */
    // eslint-disable-next-line require-yield
    async *_all(q, options) {
      throw new Error("._all is not implemented");
    }
    /**
     * Extending classes should override `queryKeys` or implement this method
     */
    // eslint-disable-next-line require-yield
    async *_allKeys(q, options) {
      throw new Error("._allKeys is not implemented");
    }
    query(q, options) {
      let it = this._all(q, options);
      if (q.prefix != null) {
        const prefix = q.prefix;
        it = src_default5(it, (e) => e.key.toString().startsWith(prefix));
      }
      if (Array.isArray(q.filters)) {
        it = q.filters.reduce((it2, f) => src_default5(it2, f), it);
      }
      if (Array.isArray(q.orders)) {
        it = q.orders.reduce((it2, f) => src_default6(it2, f), it);
      }
      if (q.offset != null) {
        let i = 0;
        const offset = q.offset;
        it = src_default5(it, () => i++ >= offset);
      }
      if (q.limit != null) {
        it = src_default7(it, q.limit);
      }
      return it;
    }
    queryKeys(q, options) {
      let it = this._allKeys(q, options);
      if (q.prefix != null) {
        const prefix = q.prefix;
        it = src_default5(it, (key) => key.toString().startsWith(prefix));
      }
      if (Array.isArray(q.filters)) {
        it = q.filters.reduce((it2, f) => src_default5(it2, f), it);
      }
      if (Array.isArray(q.orders)) {
        it = q.orders.reduce((it2, f) => src_default6(it2, f), it);
      }
      if (q.offset != null) {
        const offset = q.offset;
        let i = 0;
        it = src_default5(it, () => i++ >= offset);
      }
      if (q.limit != null) {
        it = src_default7(it, q.limit);
      }
      return it;
    }
  };

  // node_modules/datastore-core/dist/src/memory.js
  var MemoryDatastore = class extends BaseDatastore {
    data;
    constructor() {
      super();
      this.data = /* @__PURE__ */ new Map();
    }
    put(key, val, options) {
      var _a2;
      (_a2 = options == null ? void 0 : options.signal) == null ? void 0 : _a2.throwIfAborted();
      this.data.set(key.toString(), val);
      return key;
    }
    get(key, options) {
      var _a2;
      (_a2 = options == null ? void 0 : options.signal) == null ? void 0 : _a2.throwIfAborted();
      const result = this.data.get(key.toString());
      if (result == null) {
        throw new NotFoundError2();
      }
      return result;
    }
    has(key, options) {
      var _a2;
      (_a2 = options == null ? void 0 : options.signal) == null ? void 0 : _a2.throwIfAborted();
      return this.data.has(key.toString());
    }
    delete(key, options) {
      var _a2;
      (_a2 = options == null ? void 0 : options.signal) == null ? void 0 : _a2.throwIfAborted();
      this.data.delete(key.toString());
    }
    *_all(q, options) {
      var _a2, _b2;
      (_a2 = options == null ? void 0 : options.signal) == null ? void 0 : _a2.throwIfAborted();
      for (const [key, value] of this.data.entries()) {
        yield { key: new Key(key), value };
        (_b2 = options == null ? void 0 : options.signal) == null ? void 0 : _b2.throwIfAborted();
      }
    }
    *_allKeys(q, options) {
      var _a2, _b2;
      (_a2 = options == null ? void 0 : options.signal) == null ? void 0 : _a2.throwIfAborted();
      for (const key of this.data.keys()) {
        yield new Key(key);
        (_b2 = options == null ? void 0 : options.signal) == null ? void 0 : _b2.throwIfAborted();
      }
    }
  };

  // node_modules/libp2p/dist/src/address-manager/index.js
  var import_browser_shims214 = __toESM(require_browser_shims(), 1);

  // node_modules/@libp2p/utils/dist/src/debounce.js
  var import_browser_shims201 = __toESM(require_browser_shims(), 1);
  function debounce2(func2, wait) {
    let timeout;
    const output = function() {
      const later = function() {
        timeout = void 0;
        void func2();
      };
      clearTimeout(timeout);
      timeout = setTimeout(later, wait);
    };
    output.start = () => {
    };
    output.stop = () => {
      clearTimeout(timeout);
    };
    return output;
  }

  // node_modules/@libp2p/utils/dist/src/private-ip.js
  var import_browser_shims202 = __toESM(require_browser_shims(), 1);
  var import_netmask2 = __toESM(require_netmask(), 1);
  var PRIVATE_IP_RANGES = [
    "0.0.0.0/8",
    "10.0.0.0/8",
    "100.64.0.0/10",
    "127.0.0.0/8",
    "169.254.0.0/16",
    "172.16.0.0/12",
    "192.0.0.0/24",
    "192.0.0.0/29",
    "192.0.0.8/32",
    "192.0.0.9/32",
    "192.0.0.10/32",
    "192.0.0.170/32",
    "192.0.0.171/32",
    "192.0.2.0/24",
    "192.31.196.0/24",
    "192.52.193.0/24",
    "192.88.99.0/24",
    "192.168.0.0/16",
    "192.175.48.0/24",
    "198.18.0.0/15",
    "198.51.100.0/24",
    "203.0.113.0/24",
    "240.0.0.0/4",
    "255.255.255.255/32"
  ];
  var NETMASK_RANGES = PRIVATE_IP_RANGES.map((ipRange) => new import_netmask2.Netmask(ipRange));
  function ipv4Check(ipAddr) {
    for (const r of NETMASK_RANGES) {
      if (r.contains(ipAddr)) {
        return true;
      }
    }
    return false;
  }
  function isIpv4MappedIpv6(ipAddr) {
    return /^::ffff:([0-9a-fA-F]{1,4}):([0-9a-fA-F]{1,4})$/.test(ipAddr);
  }
  function ipv4MappedIpv6Check(ipAddr) {
    const parts = ipAddr.split(":");
    if (parts.length < 2) {
      return false;
    }
    const octet34 = parts[parts.length - 1].padStart(4, "0");
    const octet12 = parts[parts.length - 2].padStart(4, "0");
    const ip4 = `${parseInt(octet12.substring(0, 2), 16)}.${parseInt(octet12.substring(2), 16)}.${parseInt(octet34.substring(0, 2), 16)}.${parseInt(octet34.substring(2), 16)}`;
    return ipv4Check(ip4);
  }
  function isIpv4EmbeddedIpv6(ipAddr) {
    return /^::ffff:([0-9]{1,3})\.([0-9]{1,3})\.([0-9]{1,3})\.([0-9]{1,3})$/.test(ipAddr);
  }
  function ipv4EmbeddedIpv6Check(ipAddr) {
    const parts = ipAddr.split(":");
    const ip4 = parts[parts.length - 1];
    return ipv4Check(ip4);
  }
  function ipv6Check(ipAddr) {
    return /^::$/.test(ipAddr) || /^::1$/.test(ipAddr) || /^64:ff9b::([0-9]{1,3})\.([0-9]{1,3})\.([0-9]{1,3})\.([0-9]{1,3})$/.test(ipAddr) || /^100::([0-9a-fA-F]{0,4}):?([0-9a-fA-F]{0,4}):?([0-9a-fA-F]{0,4}):?([0-9a-fA-F]{0,4})$/.test(ipAddr) || /^2001::([0-9a-fA-F]{0,4}):?([0-9a-fA-F]{0,4}):?([0-9a-fA-F]{0,4}):?([0-9a-fA-F]{0,4}):?([0-9a-fA-F]{0,4}):?([0-9a-fA-F]{0,4})$/.test(ipAddr) || /^2001:2[0-9a-fA-F]:([0-9a-fA-F]{0,4}):?([0-9a-fA-F]{0,4}):?([0-9a-fA-F]{0,4}):?([0-9a-fA-F]{0,4}):?([0-9a-fA-F]{0,4}):?([0-9a-fA-F]{0,4})$/.test(ipAddr) || /^2001:db8:([0-9a-fA-F]{0,4}):?([0-9a-fA-F]{0,4}):?([0-9a-fA-F]{0,4}):?([0-9a-fA-F]{0,4}):?([0-9a-fA-F]{0,4}):?([0-9a-fA-F]{0,4})$/.test(ipAddr) || /^2002:([0-9a-fA-F]{0,4}):?([0-9a-fA-F]{0,4}):?([0-9a-fA-F]{0,4}):?([0-9a-fA-F]{0,4}):?([0-9a-fA-F]{0,4}):?([0-9a-fA-F]{0,4}):?([0-9a-fA-F]{0,4})$/.test(ipAddr) || /^f[c-d]([0-9a-fA-F]{2,2}):/i.test(ipAddr) || /^fe[8-9a-bA-B][0-9a-fA-F]:/i.test(ipAddr) || /^ff([0-9a-fA-F]{2,2}):/i.test(ipAddr);
  }
  function isPrivateIp(ip) {
    if (isIPv4(ip)) {
      return ipv4Check(ip);
    } else if (isIpv4MappedIpv6(ip)) {
      return ipv4MappedIpv6Check(ip);
    } else if (isIpv4EmbeddedIpv6(ip)) {
      return ipv4EmbeddedIpv6Check(ip);
    } else if (isIPv6(ip)) {
      return ipv6Check(ip);
    } else {
      return void 0;
    }
  }

  // node_modules/@multiformats/multiaddr-matcher/dist/src/index.js
  var import_browser_shims204 = __toESM(require_browser_shims(), 1);

  // node_modules/@multiformats/multiaddr-matcher/dist/src/utils.js
  var import_browser_shims203 = __toESM(require_browser_shims(), 1);
  var toParts = (ma) => {
    return ma.toString().split("/").slice(1);
  };
  var func = (fn) => {
    return {
      match: (vals) => {
        if (vals.length < 1) {
          return false;
        }
        if (fn(vals[0])) {
          return vals.slice(1);
        }
        return false;
      },
      pattern: "fn"
    };
  };
  var literal = (str) => {
    return {
      match: (vals) => func((val) => val === str).match(vals),
      pattern: str
    };
  };
  var string2 = () => {
    return {
      match: (vals) => func((val) => typeof val === "string").match(vals),
      pattern: "{string}"
    };
  };
  var number = () => {
    return {
      match: (vals) => func((val) => !isNaN(parseInt(val))).match(vals),
      pattern: "{number}"
    };
  };
  var peerId = () => {
    return {
      match: (vals) => {
        if (vals.length < 2) {
          return false;
        }
        if (vals[0] !== "p2p" && vals[0] !== "ipfs") {
          return false;
        }
        if (vals[1].startsWith("Q") || vals[1].startsWith("1")) {
          try {
            base58btc.decode(`z${vals[1]}`);
          } catch (err) {
            return false;
          }
        } else {
          return false;
        }
        return vals.slice(2);
      },
      pattern: "/p2p/{peerid}"
    };
  };
  var certhash = () => {
    return {
      match: (vals) => {
        if (vals.length < 2) {
          return false;
        }
        if (vals[0] !== "certhash") {
          return false;
        }
        try {
          base64url.decode(vals[1]);
        } catch {
          return false;
        }
        return vals.slice(2);
      },
      pattern: "/certhash/{certhash}"
    };
  };
  var optional = (matcher) => {
    return {
      match: (vals) => {
        const result = matcher.match(vals);
        if (result === false) {
          return vals;
        }
        return result;
      },
      pattern: `optional(${matcher.pattern})`
    };
  };
  var or2 = (...matchers) => {
    return {
      match: (vals) => {
        let matches;
        for (const matcher of matchers) {
          const result = matcher.match(vals);
          if (result === false) {
            continue;
          }
          if (matches == null || result.length < matches.length) {
            matches = result;
          }
        }
        if (matches == null) {
          return false;
        }
        return matches;
      },
      pattern: `or(${matchers.map((m2) => m2.pattern).join(", ")})`
    };
  };
  var and = (...matchers) => {
    return {
      match: (vals) => {
        for (const matcher of matchers) {
          const result = matcher.match(vals);
          if (result === false) {
            return false;
          }
          vals = result;
        }
        return vals;
      },
      pattern: `and(${matchers.map((m2) => m2.pattern).join(", ")})`
    };
  };
  function fmt(...matchers) {
    function match(ma) {
      let parts = toParts(ma);
      for (const matcher of matchers) {
        const result = matcher.match(parts);
        if (result === false) {
          return false;
        }
        parts = result;
      }
      return parts;
    }
    function matches(ma) {
      const result = match(ma);
      return result !== false;
    }
    function exactMatch(ma) {
      const result = match(ma);
      if (result === false) {
        return false;
      }
      return result.length === 0;
    }
    return {
      matchers,
      matches,
      exactMatch
    };
  }

  // node_modules/@multiformats/multiaddr-matcher/dist/src/index.js
  var _PEER_ID = peerId();
  var PEER_ID = fmt(_PEER_ID);
  var _DNS4 = and(literal("dns4"), string2());
  var _DNS6 = and(literal("dns6"), string2());
  var _DNSADDR = and(literal("dnsaddr"), string2());
  var _DNS = and(literal("dns"), string2());
  var DNS4 = fmt(_DNS4, optional(peerId()));
  var DNS6 = fmt(_DNS6, optional(peerId()));
  var DNSADDR = fmt(_DNSADDR, optional(peerId()));
  var DNS2 = fmt(or2(_DNS, _DNSADDR, _DNS4, _DNS6), optional(peerId()));
  var _IP4 = and(literal("ip4"), func(isIPv4));
  var _IP6 = and(literal("ip6"), func(isIPv6));
  var _IP = or2(_IP4, _IP6);
  var _IP_OR_DOMAIN = or2(_IP, _DNS, _DNS4, _DNS6, _DNSADDR);
  var IP_OR_DOMAIN = fmt(or2(_IP, and(or2(_DNS, _DNSADDR, _DNS4, _DNS6), optional(peerId()))));
  var IP4 = fmt(_IP4);
  var IP6 = fmt(_IP6);
  var IP = fmt(_IP);
  var _TCP = and(_IP_OR_DOMAIN, literal("tcp"), number());
  var _UDP = and(_IP_OR_DOMAIN, literal("udp"), number());
  var TCP = fmt(and(_TCP, optional(peerId())));
  var UDP = fmt(_UDP);
  var _QUIC = and(_UDP, literal("quic"), optional(peerId()));
  var _QUICV1 = and(_UDP, literal("quic-v1"), optional(peerId()));
  var QUIC_V0_OR_V1 = or2(_QUIC, _QUICV1);
  var QUIC = fmt(_QUIC);
  var QUICV1 = fmt(_QUICV1);
  var _WEB = or2(_IP_OR_DOMAIN, _TCP, _UDP, _QUIC, _QUICV1);
  var _WebSockets = or2(and(_WEB, literal("ws"), optional(peerId())));
  var WebSockets = fmt(_WebSockets);
  var _WebSocketsSecure = or2(and(_WEB, literal("wss"), optional(peerId())), and(_WEB, literal("tls"), optional(and(literal("sni"), string2())), literal("ws"), optional(peerId())));
  var WebSocketsSecure = fmt(_WebSocketsSecure);
  var _WebRTCDirect = and(_UDP, literal("webrtc-direct"), optional(certhash()), optional(certhash()), optional(peerId()));
  var WebRTCDirect = fmt(_WebRTCDirect);
  var _WebTransport = and(_QUICV1, literal("webtransport"), optional(certhash()), optional(certhash()), optional(peerId()));
  var WebTransport = fmt(_WebTransport);
  var _P2P = or2(_WebSockets, _WebSocketsSecure, and(_TCP, optional(peerId())), and(QUIC_V0_OR_V1, optional(peerId())), and(_IP_OR_DOMAIN, optional(peerId())), _WebRTCDirect, _WebTransport, peerId());
  var P2P = fmt(_P2P);
  var _Circuit = and(_P2P, literal("p2p-circuit"), peerId());
  var Circuit = fmt(_Circuit);
  var _WebRTC = or2(and(_P2P, literal("p2p-circuit"), literal("webrtc"), optional(peerId())), and(_P2P, literal("webrtc"), optional(peerId())), and(literal("webrtc"), optional(peerId())));
  var WebRTC = fmt(_WebRTC);
  var _HTTP = or2(and(_IP_OR_DOMAIN, literal("tcp"), number(), literal("http"), optional(peerId())), and(_IP_OR_DOMAIN, literal("http"), optional(peerId())));
  var HTTP = fmt(_HTTP);
  var _HTTPS = or2(and(_IP_OR_DOMAIN, literal("tcp"), or2(and(literal("443"), literal("http")), and(number(), literal("https")), and(number(), literal("tls"), literal("http"))), optional(peerId())), and(_IP_OR_DOMAIN, literal("tls"), literal("http"), optional(peerId())), and(_IP_OR_DOMAIN, literal("https"), optional(peerId())));
  var HTTPS = fmt(_HTTPS);
  var _Memory = or2(and(literal("memory"), string2(), optional(peerId())));
  var Memory = fmt(_Memory);

  // node_modules/libp2p/dist/src/address-manager/dns-mappings.js
  var import_browser_shims206 = __toESM(require_browser_shims(), 1);

  // node_modules/@libp2p/utils/dist/src/tracked-map.js
  var import_browser_shims205 = __toESM(require_browser_shims(), 1);
  var TrackedMap = class extends Map {
    metric;
    constructor(init) {
      super();
      const { name: name3, metrics } = init;
      this.metric = metrics.registerMetric(name3);
      this.updateComponentMetric();
    }
    set(key, value) {
      super.set(key, value);
      this.updateComponentMetric();
      return this;
    }
    delete(key) {
      const deleted = super.delete(key);
      this.updateComponentMetric();
      return deleted;
    }
    clear() {
      super.clear();
      this.updateComponentMetric();
    }
    updateComponentMetric() {
      this.metric.update(this.size);
    }
  };
  function trackedMap(config) {
    const { name: name3, metrics } = config;
    let map3;
    if (metrics != null) {
      map3 = new TrackedMap({ name: name3, metrics });
    } else {
      map3 = /* @__PURE__ */ new Map();
    }
    return map3;
  }

  // node_modules/libp2p/dist/src/address-manager/dns-mappings.js
  var MAX_DATE = 864e13;
  var CODEC_TLS = 448;
  var CODEC_SNI = 449;
  var CODEC_DNS = 53;
  var CODEC_DNS4 = 54;
  var CODEC_DNS6 = 55;
  var CODEC_DNSADDR = 56;
  var DNSMappings = class {
    log;
    mappings;
    constructor(components, init = {}) {
      this.log = components.logger.forComponent("libp2p:address-manager:dns-mappings");
      this.mappings = trackedMap({
        name: "libp2p_address_manager_dns_mappings",
        metrics: components.metrics
      });
    }
    has(ma) {
      const host = this.findHost(ma);
      for (const mapping of this.mappings.values()) {
        if (mapping.domain === host) {
          return true;
        }
      }
      return false;
    }
    add(domain, addresses) {
      addresses.forEach((ip) => {
        this.log("add DNS mapping %s to %s", ip, domain);
        const verified = isPrivateIp(ip) === true;
        this.mappings.set(ip, {
          domain,
          verified,
          expires: verified ? MAX_DATE - Date.now() : 0,
          lastVerified: verified ? MAX_DATE - Date.now() : void 0
        });
      });
    }
    remove(ma) {
      const host = this.findHost(ma);
      let wasConfident = false;
      for (const [ip, mapping] of this.mappings.entries()) {
        if (mapping.domain === host) {
          this.log("removing %s to %s DNS mapping %e", ip, mapping.domain, new Error("where"));
          this.mappings.delete(ip);
          wasConfident = wasConfident || mapping.verified;
        }
      }
      return wasConfident;
    }
    getAll(addresses) {
      const dnsMappedAddresses = [];
      for (let i = 0; i < addresses.length; i++) {
        const address = addresses[i];
        const tuples = address.multiaddr.stringTuples();
        const host = tuples[0][1];
        if (host == null) {
          continue;
        }
        for (const [ip, mapping] of this.mappings.entries()) {
          if (host !== ip) {
            continue;
          }
          const mappedIp = this.maybeAddSNITuple(tuples, mapping.domain);
          if (mappedIp) {
            addresses.splice(i, 1);
            i--;
            dnsMappedAddresses.push({
              multiaddr: multiaddr(`/${tuples.map((tuple) => {
                return [
                  getProtocol(tuple[0]).name,
                  tuple[1]
                ].join("/");
              }).join("/")}`),
              verified: mapping.verified,
              type: "dns-mapping",
              expires: mapping.expires,
              lastVerified: mapping.lastVerified
            });
          }
        }
      }
      return dnsMappedAddresses;
    }
    maybeAddSNITuple(tuples, domain) {
      var _a2;
      for (let j = 0; j < tuples.length; j++) {
        if (tuples[j][0] === CODEC_TLS && ((_a2 = tuples[j + 1]) == null ? void 0 : _a2[0]) !== CODEC_SNI) {
          tuples.splice(j + 1, 0, [CODEC_SNI, domain]);
          return true;
        }
      }
      return false;
    }
    confirm(ma, ttl) {
      const host = this.findHost(ma);
      let startingConfidence = false;
      for (const [ip, mapping] of this.mappings.entries()) {
        if (mapping.domain === host) {
          this.log("marking %s to %s DNS mapping as verified", ip, mapping.domain);
          startingConfidence = mapping.verified;
          mapping.verified = true;
          mapping.expires = Date.now() + ttl;
          mapping.lastVerified = Date.now();
        }
      }
      return startingConfidence;
    }
    unconfirm(ma, ttl) {
      const host = this.findHost(ma);
      let wasConfident = false;
      for (const [ip, mapping] of this.mappings.entries()) {
        if (mapping.domain === host) {
          this.log("removing verification of %s to %s DNS mapping", ip, mapping.domain);
          wasConfident = wasConfident || mapping.verified;
          mapping.verified = false;
          mapping.expires = Date.now() + ttl;
        }
      }
      return wasConfident;
    }
    findHost(ma) {
      for (const tuple of ma.stringTuples()) {
        if (tuple[0] === CODEC_SNI) {
          return tuple[1];
        }
        if (tuple[0] === CODEC_DNS || tuple[0] === CODEC_DNS4 || tuple[0] === CODEC_DNS6 || tuple[0] === CODEC_DNSADDR) {
          return tuple[1];
        }
      }
    }
  };

  // node_modules/libp2p/dist/src/address-manager/ip-mappings.js
  var import_browser_shims207 = __toESM(require_browser_shims(), 1);
  var CODEC_IP4 = 4;
  var CODEC_IP6 = 41;
  var CODEC_TCP = 6;
  var CODEC_UDP = 273;
  var IPMappings = class {
    log;
    mappings;
    constructor(components, init = {}) {
      this.log = components.logger.forComponent("libp2p:address-manager:ip-mappings");
      this.mappings = trackedMap({
        name: "libp2p_address_manager_ip_mappings",
        metrics: components.metrics
      });
    }
    has(ma) {
      const tuples = ma.stringTuples();
      for (const mappings of this.mappings.values()) {
        for (const mapping of mappings) {
          if (mapping.externalIp === tuples[0][1]) {
            return true;
          }
        }
      }
      return false;
    }
    add(internalIp, internalPort, externalIp, externalPort = internalPort, protocol = "tcp") {
      const key = `${internalIp}-${internalPort}-${protocol}`;
      const mappings = this.mappings.get(key) ?? [];
      const mapping = {
        internalIp,
        internalPort,
        externalIp,
        externalPort,
        externalFamily: isIPv4(externalIp) ? 4 : 6,
        protocol,
        verified: false,
        expires: 0
      };
      mappings.push(mapping);
      this.mappings.set(key, mappings);
    }
    remove(ma) {
      const tuples = ma.stringTuples();
      const host = tuples[0][1] ?? "";
      const protocol = tuples[1][0] === CODEC_TCP ? "tcp" : "udp";
      const port = parseInt(tuples[1][1] ?? "0");
      let wasConfident = false;
      for (const [key, mappings] of this.mappings.entries()) {
        for (let i = 0; i < mappings.length; i++) {
          const mapping = mappings[i];
          if (mapping.externalIp === host && mapping.externalPort === port && mapping.protocol === protocol) {
            this.log("removing %s:%s to %s:%s %s IP mapping", mapping.externalIp, mapping.externalPort, host, port, protocol);
            wasConfident = wasConfident || mapping.verified;
            mappings.splice(i, 1);
            i--;
          }
        }
        if (mappings.length === 0) {
          this.mappings.delete(key);
        }
      }
      return wasConfident;
    }
    getAll(addresses) {
      const ipMappedAddresses = [];
      for (const { multiaddr: ma } of addresses) {
        const tuples = ma.stringTuples();
        let tuple;
        if ((tuples[0][0] === CODEC_IP4 || tuples[0][0] === CODEC_IP6) && tuples[1][0] === CODEC_TCP) {
          tuple = `${tuples[0][1]}-${tuples[1][1]}-tcp`;
        } else if ((tuples[0][0] === CODEC_IP4 || tuples[0][0] === CODEC_IP6) && tuples[1][0] === CODEC_UDP) {
          tuple = `${tuples[0][1]}-${tuples[1][1]}-udp`;
        }
        if (tuple == null) {
          continue;
        }
        const mappings = this.mappings.get(tuple);
        if (mappings == null) {
          continue;
        }
        for (const mapping of mappings) {
          tuples[0][0] = mapping.externalFamily === 4 ? CODEC_IP4 : CODEC_IP6;
          tuples[0][1] = mapping.externalIp;
          tuples[1][1] = `${mapping.externalPort}`;
          ipMappedAddresses.push({
            multiaddr: multiaddr(`/${tuples.map((tuple2) => {
              return [
                getProtocol(tuple2[0]).name,
                tuple2[1]
              ].join("/");
            }).join("/")}`),
            verified: mapping.verified,
            type: "ip-mapping",
            expires: mapping.expires,
            lastVerified: mapping.lastVerified
          });
        }
      }
      return ipMappedAddresses;
    }
    confirm(ma, ttl) {
      const tuples = ma.stringTuples();
      const host = tuples[0][1];
      let startingConfidence = false;
      for (const mappings of this.mappings.values()) {
        for (const mapping of mappings) {
          if (mapping.externalIp === host) {
            this.log("marking %s to %s IP mapping as verified", mapping.internalIp, mapping.externalIp);
            startingConfidence = mapping.verified;
            mapping.verified = true;
            mapping.expires = Date.now() + ttl;
            mapping.lastVerified = Date.now();
          }
        }
      }
      return startingConfidence;
    }
    unconfirm(ma, ttl) {
      const tuples = ma.stringTuples();
      const host = tuples[0][1] ?? "";
      const protocol = tuples[1][0] === CODEC_TCP ? "tcp" : "udp";
      const port = parseInt(tuples[1][1] ?? "0");
      let wasConfident = false;
      for (const mappings of this.mappings.values()) {
        for (let i = 0; i < mappings.length; i++) {
          const mapping = mappings[i];
          if (mapping.externalIp === host && mapping.externalPort === port && mapping.protocol === protocol) {
            this.log("removing verification of %s:%s to %s:%s %s IP mapping", mapping.externalIp, mapping.externalPort, host, port, protocol);
            wasConfident = wasConfident || mapping.verified;
            mapping.verified = false;
            mapping.expires = Date.now() + ttl;
          }
        }
      }
      return wasConfident;
    }
  };

  // node_modules/libp2p/dist/src/address-manager/observed-addresses.js
  var import_browser_shims211 = __toESM(require_browser_shims(), 1);

  // node_modules/@libp2p/utils/dist/src/multiaddr/is-link-local.js
  var import_browser_shims208 = __toESM(require_browser_shims(), 1);
  var CODEC_IP42 = 4;
  var CODEC_IP62 = 41;
  function isLinkLocal(ma) {
    try {
      const [[codec, value]] = ma.stringTuples();
      if (value == null) {
        return false;
      }
      if (codec === CODEC_IP42) {
        return value.startsWith("169.254.");
      }
      if (codec === CODEC_IP62) {
        return value.toLowerCase().startsWith("fe80");
      }
    } catch {
    }
    return false;
  }

  // node_modules/@libp2p/utils/dist/src/multiaddr/is-private.js
  var import_browser_shims210 = __toESM(require_browser_shims(), 1);

  // node_modules/@libp2p/utils/dist/src/multiaddr/is-ip-based.js
  var import_browser_shims209 = __toESM(require_browser_shims(), 1);
  var CODEC_IP43 = 4;
  var CODEC_IP63 = 41;
  function isIpBased(ma) {
    try {
      const [[codec]] = ma.stringTuples();
      return codec === CODEC_IP43 || codec === CODEC_IP63;
    } catch {
    }
    return false;
  }

  // node_modules/@libp2p/utils/dist/src/multiaddr/is-private.js
  function isPrivate(ma) {
    try {
      if (!isIpBased(ma)) {
        return false;
      }
      const [[, value]] = ma.stringTuples();
      if (value == null) {
        return false;
      }
      return isPrivateIp(value) ?? false;
    } catch {
    }
    return true;
  }

  // node_modules/libp2p/dist/src/address-manager/observed-addresses.js
  var defaultValues = {
    maxObservedAddresses: 10
  };
  var ObservedAddresses = class {
    log;
    addresses;
    maxObservedAddresses;
    constructor(components, init = {}) {
      this.log = components.logger.forComponent("libp2p:address-manager:observed-addresses");
      this.addresses = trackedMap({
        name: "libp2p_address_manager_observed_addresses",
        metrics: components.metrics
      });
      this.maxObservedAddresses = init.maxObservedAddresses ?? defaultValues.maxObservedAddresses;
    }
    has(ma) {
      return this.addresses.has(ma.toString());
    }
    removePrefixed(prefix) {
      for (const key of this.addresses.keys()) {
        if (key.toString().startsWith(prefix)) {
          this.addresses.delete(key);
        }
      }
    }
    add(ma) {
      if (this.addresses.size === this.maxObservedAddresses) {
        return;
      }
      if (isPrivate(ma) || isLinkLocal(ma)) {
        return;
      }
      this.log("adding observed address %a", ma);
      this.addresses.set(ma.toString(), {
        verified: false,
        expires: 0
      });
    }
    getAll() {
      return Array.from(this.addresses).map(([ma, metadata]) => ({
        multiaddr: multiaddr(ma),
        verified: metadata.verified,
        type: "observed",
        expires: metadata.expires,
        lastVerified: metadata.lastVerified
      }));
    }
    remove(ma) {
      var _a2;
      const startingConfidence = ((_a2 = this.addresses.get(ma.toString())) == null ? void 0 : _a2.verified) ?? false;
      this.log("removing observed address %a", ma);
      this.addresses.delete(ma.toString());
      return startingConfidence;
    }
    confirm(ma, ttl) {
      const addrString = ma.toString();
      const metadata = this.addresses.get(addrString) ?? {
        verified: false,
        expires: Date.now() + ttl,
        lastVerified: Date.now()
      };
      const startingConfidence = metadata.verified;
      metadata.verified = true;
      metadata.expires = Date.now() + ttl;
      metadata.lastVerified = Date.now();
      this.log("marking observed address %a as verified", addrString);
      this.addresses.set(addrString, metadata);
      return startingConfidence;
    }
  };

  // node_modules/libp2p/dist/src/address-manager/transport-addresses.js
  var import_browser_shims213 = __toESM(require_browser_shims(), 1);

  // node_modules/@libp2p/utils/dist/src/multiaddr/is-network-address.js
  var import_browser_shims212 = __toESM(require_browser_shims(), 1);
  var CODEC_IP44 = 4;
  var CODEC_IP64 = 41;
  var CODEC_DNS2 = 53;
  var CODEC_DNS42 = 54;
  var CODEC_DNS62 = 55;
  var CODEC_DNSADDR2 = 56;
  var NETWORK_CODECS = [
    CODEC_IP44,
    CODEC_IP64,
    CODEC_DNS2,
    CODEC_DNS42,
    CODEC_DNS62,
    CODEC_DNSADDR2
  ];
  function isNetworkAddress(ma) {
    try {
      const [[codec]] = ma.stringTuples();
      return NETWORK_CODECS.includes(codec);
    } catch {
    }
    return false;
  }

  // node_modules/libp2p/dist/src/address-manager/transport-addresses.js
  var defaultValues2 = {
    maxObservedAddresses: 10
  };
  var TransportAddresses = class {
    log;
    addresses;
    maxObservedAddresses;
    constructor(components, init = {}) {
      this.log = components.logger.forComponent("libp2p:address-manager:observed-addresses");
      this.addresses = trackedMap({
        name: "libp2p_address_manager_transport_addresses",
        metrics: components.metrics
      });
      this.maxObservedAddresses = init.maxObservedAddresses ?? defaultValues2.maxObservedAddresses;
    }
    get(multiaddr2, ttl) {
      if (isPrivate(multiaddr2)) {
        return {
          multiaddr: multiaddr2,
          verified: true,
          type: "transport",
          expires: Date.now() + ttl,
          lastVerified: Date.now()
        };
      }
      const key = this.toKey(multiaddr2);
      let metadata = this.addresses.get(key);
      if (metadata == null) {
        metadata = {
          verified: !isNetworkAddress(multiaddr2),
          expires: 0
        };
        this.addresses.set(key, metadata);
      }
      return {
        multiaddr: multiaddr2,
        verified: metadata.verified,
        type: "transport",
        expires: metadata.expires,
        lastVerified: metadata.lastVerified
      };
    }
    has(ma) {
      const key = this.toKey(ma);
      return this.addresses.has(key);
    }
    remove(ma) {
      var _a2;
      const key = this.toKey(ma);
      const startingConfidence = ((_a2 = this.addresses.get(key)) == null ? void 0 : _a2.verified) ?? false;
      this.log("removing observed address %a", ma);
      this.addresses.delete(key);
      return startingConfidence;
    }
    confirm(ma, ttl) {
      const key = this.toKey(ma);
      const metadata = this.addresses.get(key) ?? {
        verified: false,
        expires: 0,
        lastVerified: 0
      };
      const startingConfidence = metadata.verified;
      metadata.verified = true;
      metadata.expires = Date.now() + ttl;
      metadata.lastVerified = Date.now();
      this.addresses.set(key, metadata);
      return startingConfidence;
    }
    unconfirm(ma, ttl) {
      const key = this.toKey(ma);
      const metadata = this.addresses.get(key) ?? {
        verified: false,
        expires: 0
      };
      const startingConfidence = metadata.verified;
      metadata.verified = false;
      metadata.expires = Date.now() + ttl;
      this.addresses.set(key, metadata);
      return startingConfidence;
    }
    toKey(ma) {
      if (isNetworkAddress(ma)) {
        const options = ma.toOptions();
        return `${options.host}-${options.port}-${options.transport}`;
      }
      return ma.toString();
    }
  };

  // node_modules/libp2p/dist/src/address-manager/index.js
  var ONE_MINUTE = 6e4;
  var defaultValues3 = {
    maxObservedAddresses: 10,
    addressVerificationTTL: ONE_MINUTE * 10,
    addressVerificationRetry: ONE_MINUTE * 5
  };
  var defaultAddressFilter = (addrs) => addrs;
  function stripPeerId(ma, peerId2) {
    const observedPeerIdStr = ma.getPeerId();
    if (observedPeerIdStr != null) {
      const observedPeerId = peerIdFromString(observedPeerIdStr);
      if (observedPeerId.equals(peerId2)) {
        ma = ma.decapsulate(multiaddr(`/p2p/${peerId2.toString()}`));
      }
    }
    return ma;
  }
  var AddressManager = class {
    log;
    components;
    // this is an array to allow for duplicates, e.g. multiples of `/ip4/0.0.0.0/tcp/0`
    listen;
    announce;
    appendAnnounce;
    announceFilter;
    observed;
    dnsMappings;
    ipMappings;
    transportAddresses;
    observedAddressFilter;
    addressVerificationTTL;
    addressVerificationRetry;
    /**
     * Responsible for managing the peer addresses.
     * Peers can specify their listen and announce addresses.
     * The listen addresses will be used by the libp2p transports to listen for new connections,
     * while the announce addresses will be used for the peer addresses' to other peers in the network.
     */
    constructor(components, init = {}) {
      const { listen = [], announce = [], appendAnnounce = [] } = init;
      this.components = components;
      this.log = components.logger.forComponent("libp2p:address-manager");
      this.listen = listen.map((ma) => ma.toString());
      this.announce = new Set(announce.map((ma) => ma.toString()));
      this.appendAnnounce = new Set(appendAnnounce.map((ma) => ma.toString()));
      this.observed = new ObservedAddresses(components, init);
      this.dnsMappings = new DNSMappings(components, init);
      this.ipMappings = new IPMappings(components, init);
      this.transportAddresses = new TransportAddresses(components, init);
      this.announceFilter = init.announceFilter ?? defaultAddressFilter;
      this.observedAddressFilter = createScalableCuckooFilter(1024);
      this.addressVerificationTTL = init.addressVerificationTTL ?? defaultValues3.addressVerificationTTL;
      this.addressVerificationRetry = init.addressVerificationRetry ?? defaultValues3.addressVerificationRetry;
      this._updatePeerStoreAddresses = debounce2(this._updatePeerStoreAddresses.bind(this), 1e3);
      components.events.addEventListener("transport:listening", () => {
        this._updatePeerStoreAddresses();
      });
      components.events.addEventListener("transport:close", () => {
        this._updatePeerStoreAddresses();
      });
    }
    [Symbol.toStringTag] = "@libp2p/address-manager";
    _updatePeerStoreAddresses() {
      const addrs = this.getAddresses().map((ma) => {
        if (ma.getPeerId() === this.components.peerId.toString()) {
          return ma.decapsulate(`/p2p/${this.components.peerId.toString()}`);
        }
        return ma;
      });
      this.components.peerStore.patch(this.components.peerId, {
        multiaddrs: addrs
      }).catch((err) => {
        this.log.error("error updating addresses", err);
      });
    }
    /**
     * Get peer listen multiaddrs
     */
    getListenAddrs() {
      return Array.from(this.listen).map((a) => multiaddr(a));
    }
    /**
     * Get peer announcing multiaddrs
     */
    getAnnounceAddrs() {
      return Array.from(this.announce).map((a) => multiaddr(a));
    }
    /**
     * Get peer announcing multiaddrs
     */
    getAppendAnnounceAddrs() {
      return Array.from(this.appendAnnounce).map((a) => multiaddr(a));
    }
    /**
     * Get observed multiaddrs
     */
    getObservedAddrs() {
      return this.observed.getAll().map((addr) => addr.multiaddr);
    }
    /**
     * Add peer observed addresses
     */
    addObservedAddr(addr) {
      const tuples = addr.stringTuples();
      const socketAddress = `${tuples[0][1]}:${tuples[1][1]}`;
      if (this.observedAddressFilter.has(socketAddress)) {
        return;
      }
      this.observedAddressFilter.add(socketAddress);
      addr = stripPeerId(addr, this.components.peerId);
      if (this.ipMappings.has(addr)) {
        return;
      }
      if (this.dnsMappings.has(addr)) {
        return;
      }
      this.observed.add(addr);
    }
    confirmObservedAddr(addr, options) {
      addr = stripPeerId(addr, this.components.peerId);
      let startingConfidence = true;
      if ((options == null ? void 0 : options.type) === "transport" || this.transportAddresses.has(addr)) {
        const transportStartingConfidence = this.transportAddresses.confirm(addr, (options == null ? void 0 : options.ttl) ?? this.addressVerificationTTL);
        if (!transportStartingConfidence && startingConfidence) {
          startingConfidence = false;
        }
      }
      if ((options == null ? void 0 : options.type) === "dns-mapping" || this.dnsMappings.has(addr)) {
        const dnsMappingStartingConfidence = this.dnsMappings.confirm(addr, (options == null ? void 0 : options.ttl) ?? this.addressVerificationTTL);
        if (!dnsMappingStartingConfidence && startingConfidence) {
          startingConfidence = false;
        }
      }
      if ((options == null ? void 0 : options.type) === "ip-mapping" || this.ipMappings.has(addr)) {
        const ipMappingStartingConfidence = this.ipMappings.confirm(addr, (options == null ? void 0 : options.ttl) ?? this.addressVerificationTTL);
        if (!ipMappingStartingConfidence && startingConfidence) {
          startingConfidence = false;
        }
      }
      if ((options == null ? void 0 : options.type) === "observed" || this.observed.has(addr)) {
        if (this.maybeUpgradeToIPMapping(addr)) {
          this.ipMappings.confirm(addr, (options == null ? void 0 : options.ttl) ?? this.addressVerificationTTL);
          startingConfidence = false;
        } else {
          const observedStartingConfidence = this.observed.confirm(addr, (options == null ? void 0 : options.ttl) ?? this.addressVerificationTTL);
          if (!observedStartingConfidence && startingConfidence) {
            startingConfidence = false;
          }
        }
      }
      if (!startingConfidence) {
        this._updatePeerStoreAddresses();
      }
    }
    removeObservedAddr(addr, options) {
      addr = stripPeerId(addr, this.components.peerId);
      let startingConfidence = false;
      if (this.observed.has(addr)) {
        const observedStartingConfidence = this.observed.remove(addr);
        if (!observedStartingConfidence && startingConfidence) {
          startingConfidence = false;
        }
      }
      if (this.transportAddresses.has(addr)) {
        const transportStartingConfidence = this.transportAddresses.unconfirm(addr, (options == null ? void 0 : options.ttl) ?? this.addressVerificationRetry);
        if (!transportStartingConfidence && startingConfidence) {
          startingConfidence = false;
        }
      }
      if (this.dnsMappings.has(addr)) {
        const dnsMappingStartingConfidence = this.dnsMappings.unconfirm(addr, (options == null ? void 0 : options.ttl) ?? this.addressVerificationRetry);
        if (!dnsMappingStartingConfidence && startingConfidence) {
          startingConfidence = false;
        }
      }
      if (this.ipMappings.has(addr)) {
        const ipMappingStartingConfidence = this.ipMappings.unconfirm(addr, (options == null ? void 0 : options.ttl) ?? this.addressVerificationRetry);
        if (!ipMappingStartingConfidence && startingConfidence) {
          startingConfidence = false;
        }
      }
      if (startingConfidence) {
        this._updatePeerStoreAddresses();
      }
    }
    getAddresses() {
      const addresses = /* @__PURE__ */ new Set();
      const multiaddrs = this.getAddressesWithMetadata().filter((addr) => {
        if (!addr.verified) {
          return false;
        }
        const maStr = addr.multiaddr.toString();
        if (addresses.has(maStr)) {
          return false;
        }
        addresses.add(maStr);
        return true;
      }).map((address) => address.multiaddr);
      return this.announceFilter(multiaddrs.map((str) => {
        var _a2;
        const ma = multiaddr(str);
        if (((_a2 = ma.protos().pop()) == null ? void 0 : _a2.path) === true) {
          return ma;
        }
        if (ma.getPeerId() === this.components.peerId.toString()) {
          return ma;
        }
        return ma.encapsulate(`/p2p/${this.components.peerId.toString()}`);
      }));
    }
    getAddressesWithMetadata() {
      const announceMultiaddrs = this.getAnnounceAddrs();
      if (announceMultiaddrs.length > 0) {
        this.components.transportManager.getListeners().forEach((listener) => {
          listener.updateAnnounceAddrs(announceMultiaddrs);
        });
        return announceMultiaddrs.map((multiaddr2) => ({
          multiaddr: multiaddr2,
          verified: true,
          type: "announce",
          expires: Date.now() + this.addressVerificationTTL,
          lastVerified: Date.now()
        }));
      }
      let addresses = [];
      addresses = addresses.concat(this.components.transportManager.getAddrs().map((multiaddr2) => this.transportAddresses.get(multiaddr2, this.addressVerificationTTL)));
      const appendAnnounceMultiaddrs = this.getAppendAnnounceAddrs();
      if (appendAnnounceMultiaddrs.length > 0) {
        this.components.transportManager.getListeners().forEach((listener) => {
          listener.updateAnnounceAddrs(appendAnnounceMultiaddrs);
        });
        addresses = addresses.concat(appendAnnounceMultiaddrs.map((multiaddr2) => ({
          multiaddr: multiaddr2,
          verified: true,
          type: "announce",
          expires: Date.now() + this.addressVerificationTTL,
          lastVerified: Date.now()
        })));
      }
      addresses = addresses.concat(this.observed.getAll());
      addresses = addresses.concat(this.ipMappings.getAll(addresses));
      addresses = addresses.concat(this.dnsMappings.getAll(addresses));
      return addresses;
    }
    addDNSMapping(domain, addresses) {
      this.dnsMappings.add(domain, addresses);
    }
    removeDNSMapping(domain) {
      if (this.dnsMappings.remove(multiaddr(`/dns/${domain}`))) {
        this._updatePeerStoreAddresses();
      }
    }
    addPublicAddressMapping(internalIp, internalPort, externalIp, externalPort = internalPort, protocol = "tcp") {
      this.ipMappings.add(internalIp, internalPort, externalIp, externalPort, protocol);
      this.observed.removePrefixed(`/ip${isIPv4(externalIp) ? 4 : 6}/${externalIp}/${protocol}/${externalPort}`);
    }
    removePublicAddressMapping(internalIp, internalPort, externalIp, externalPort = internalPort, protocol = "tcp") {
      if (this.ipMappings.remove(multiaddr(`/ip${isIPv4(externalIp) ? 4 : 6}/${externalIp}/${protocol}/${externalPort}`))) {
        this._updatePeerStoreAddresses();
      }
    }
    /**
     * Where an external service (router, gateway, etc) is forwarding traffic to
     * us, attempt to add an IP mapping for the external address - this will
     * include the observed mapping in the address list where we also have a DNS
     * mapping for the external IP.
     *
     * Returns true if we added a new mapping
     */
    maybeUpgradeToIPMapping(ma) {
      if (this.ipMappings.has(ma)) {
        return false;
      }
      const maOptions = ma.toOptions();
      if (maOptions.family === 6 || maOptions.host === "127.0.0.1" || isPrivateIp(maOptions.host) === true) {
        return false;
      }
      const listeners = this.components.transportManager.getListeners();
      const transportMatchers = [
        (ma2) => WebSockets.exactMatch(ma2) || WebSocketsSecure.exactMatch(ma2),
        (ma2) => TCP.exactMatch(ma2),
        (ma2) => QUICV1.exactMatch(ma2)
      ];
      for (const matcher of transportMatchers) {
        if (!matcher(ma)) {
          continue;
        }
        const transportListeners = listeners.filter((listener) => {
          return listener.getAddrs().filter((ma2) => {
            return ma2.toOptions().family === 4 && matcher(ma2);
          }).length > 0;
        });
        if (transportListeners.length !== 1) {
          continue;
        }
        const linkLocalAddr = transportListeners[0].getAddrs().filter((ma2) => {
          return ma2.toOptions().host !== "127.0.0.1";
        }).pop();
        if (linkLocalAddr == null) {
          continue;
        }
        const linkLocalOptions = linkLocalAddr.toOptions();
        this.observed.remove(ma);
        this.ipMappings.add(linkLocalOptions.host, linkLocalOptions.port, maOptions.host, maOptions.port, maOptions.transport);
        return true;
      }
      return false;
    }
  };

  // node_modules/libp2p/dist/src/components.js
  var import_browser_shims216 = __toESM(require_browser_shims(), 1);

  // node_modules/libp2p/dist/src/errors.js
  var import_browser_shims215 = __toESM(require_browser_shims(), 1);
  var messages;
  (function(messages2) {
    messages2["NOT_STARTED_YET"] = "The libp2p node is not started yet";
    messages2["NOT_FOUND"] = "Not found";
  })(messages || (messages = {}));
  var MissingServiceError = class extends Error {
    constructor(message2 = "Missing service") {
      super(message2);
      this.name = "MissingServiceError";
    }
  };
  var UnmetServiceDependenciesError = class extends Error {
    constructor(message2 = "Unmet service dependencies") {
      super(message2);
      this.name = "UnmetServiceDependenciesError";
    }
  };
  var NoContentRoutersError = class extends Error {
    constructor(message2 = "No content routers available") {
      super(message2);
      this.name = "NoContentRoutersError";
    }
  };
  var NoPeerRoutersError = class extends Error {
    constructor(message2 = "No peer routers available") {
      super(message2);
      this.name = "NoPeerRoutersError";
    }
  };
  var QueriedForSelfError = class extends Error {
    constructor(message2 = "Should not try to find self") {
      super(message2);
      this.name = "QueriedForSelfError";
    }
  };
  var UnhandledProtocolError = class extends Error {
    constructor(message2 = "Unhandled protocol error") {
      super(message2);
      this.name = "UnhandledProtocolError";
    }
  };
  var DuplicateProtocolHandlerError = class extends Error {
    constructor(message2 = "Duplicate protocol handler error") {
      super(message2);
      this.name = "DuplicateProtocolHandlerError";
    }
  };
  var DialDeniedError = class extends Error {
    constructor(message2 = "Dial denied error") {
      super(message2);
      this.name = "DialDeniedError";
    }
  };
  var UnsupportedListenAddressError = class extends Error {
    constructor(message2 = "No transport was configured to listen on this address") {
      super(message2);
      this.name = "UnsupportedListenAddressError";
    }
  };
  var UnsupportedListenAddressesError = class extends Error {
    constructor(message2 = "Configured listen addresses could not be listened on") {
      super(message2);
      this.name = "UnsupportedListenAddressesError";
    }
  };
  var NoValidAddressesError = class extends Error {
    constructor(message2 = "No valid addresses") {
      super(message2);
      this.name = "NoValidAddressesError";
    }
  };
  var ConnectionInterceptedError = class extends Error {
    constructor(message2 = "Connection intercepted") {
      super(message2);
      this.name = "ConnectionInterceptedError";
    }
  };
  var ConnectionDeniedError = class extends Error {
    constructor(message2 = "Connection denied") {
      super(message2);
      this.name = "ConnectionDeniedError";
    }
  };
  var MuxerUnavailableError = class extends Error {
    constructor(message2 = "Stream is not multiplexed") {
      super(message2);
      this.name = "MuxerUnavailableError";
    }
  };
  var EncryptionFailedError = class extends Error {
    constructor(message2 = "Encryption failed") {
      super(message2);
      this.name = "EncryptionFailedError";
    }
  };
  var TransportUnavailableError = class extends Error {
    constructor(message2 = "Transport unavailable") {
      super(message2);
      this.name = "TransportUnavailableError";
    }
  };

  // node_modules/libp2p/dist/src/components.js
  var DefaultComponents = class {
    components = {};
    _started = false;
    constructor(init = {}) {
      this.components = {};
      for (const [key, value] of Object.entries(init)) {
        this.components[key] = value;
      }
      if (this.components.logger == null) {
        this.components.logger = defaultLogger();
      }
    }
    isStarted() {
      return this._started;
    }
    async _invokeStartableMethod(methodName) {
      await Promise.all(Object.values(this.components).filter((obj) => isStartable(obj)).map(async (startable) => {
        var _a2;
        await ((_a2 = startable[methodName]) == null ? void 0 : _a2.call(startable));
      }));
    }
    async beforeStart() {
      await this._invokeStartableMethod("beforeStart");
    }
    async start() {
      await this._invokeStartableMethod("start");
      this._started = true;
    }
    async afterStart() {
      await this._invokeStartableMethod("afterStart");
    }
    async beforeStop() {
      await this._invokeStartableMethod("beforeStop");
    }
    async stop() {
      await this._invokeStartableMethod("stop");
      this._started = false;
    }
    async afterStop() {
      await this._invokeStartableMethod("afterStop");
    }
  };
  var OPTIONAL_SERVICES = [
    "metrics",
    "connectionProtector",
    "dns"
  ];
  var NON_SERVICE_PROPERTIES = [
    "components",
    "isStarted",
    "beforeStart",
    "start",
    "afterStart",
    "beforeStop",
    "stop",
    "afterStop",
    "then",
    "_invokeStartableMethod"
  ];
  function defaultComponents(init = {}) {
    const components = new DefaultComponents(init);
    const proxy = new Proxy(components, {
      get(target, prop, receiver) {
        if (typeof prop === "string" && !NON_SERVICE_PROPERTIES.includes(prop)) {
          const service = components.components[prop];
          if (service == null && !OPTIONAL_SERVICES.includes(prop)) {
            throw new MissingServiceError(`${prop} not set`);
          }
          return service;
        }
        return Reflect.get(target, prop, receiver);
      },
      set(target, prop, value) {
        if (typeof prop === "string") {
          components.components[prop] = value;
        } else {
          Reflect.set(target, prop, value);
        }
        return true;
      }
    });
    return proxy;
  }
  function checkServiceDependencies(components) {
    const serviceCapabilities2 = {};
    for (const service of Object.values(components.components)) {
      for (const capability of getServiceCapabilities(service)) {
        serviceCapabilities2[capability] = true;
      }
    }
    for (const service of Object.values(components.components)) {
      for (const capability of getServiceDependencies(service)) {
        if (serviceCapabilities2[capability] !== true) {
          throw new UnmetServiceDependenciesError(`Service "${getServiceName(service)}" required capability "${capability}" but it was not provided by any component, you may need to add additional configuration when creating your node.`);
        }
      }
    }
  }
  function getServiceCapabilities(service) {
    if (Array.isArray(service == null ? void 0 : service[serviceCapabilities])) {
      return service[serviceCapabilities];
    }
    return [];
  }
  function getServiceDependencies(service) {
    if (Array.isArray(service == null ? void 0 : service[serviceDependencies])) {
      return service[serviceDependencies];
    }
    return [];
  }
  function getServiceName(service) {
    return (service == null ? void 0 : service[Symbol.toStringTag]) ?? (service == null ? void 0 : service.toString()) ?? "unknown";
  }

  // node_modules/libp2p/dist/src/config/connection-gater.browser.js
  var import_browser_shims217 = __toESM(require_browser_shims(), 1);
  var CODEC_IP45 = 4;
  var CODEC_IP65 = 41;
  function connectionGater(gater = {}) {
    return {
      denyDialPeer: async () => false,
      denyDialMultiaddr: async (multiaddr2) => {
        if (WebSockets.matches(multiaddr2)) {
          return false;
        }
        const tuples = multiaddr2.stringTuples();
        if (tuples[0][0] === CODEC_IP45 || tuples[0][0] === CODEC_IP65) {
          return Boolean(isPrivateIp(`${tuples[0][1]}`));
        }
        return false;
      },
      denyInboundConnection: async () => false,
      denyOutboundConnection: async () => false,
      denyInboundEncryptedConnection: async () => false,
      denyOutboundEncryptedConnection: async () => false,
      denyInboundUpgradedConnection: async () => false,
      denyOutboundUpgradedConnection: async () => false,
      filterMultiaddrForPeer: async () => true,
      ...gater
    };
  }

  // node_modules/libp2p/dist/src/connection-manager/index.js
  var import_browser_shims240 = __toESM(require_browser_shims(), 1);

  // node_modules/@libp2p/utils/dist/src/rate-limiter.js
  var import_browser_shims220 = __toESM(require_browser_shims(), 1);

  // node_modules/delay/index.js
  var import_browser_shims218 = __toESM(require_browser_shims(), 1);
  var createAbortError = () => {
    const error = new Error("Delay aborted");
    error.name = "AbortError";
    return error;
  };
  var clearMethods = /* @__PURE__ */ new WeakMap();
  function createDelay({ clearTimeout: defaultClear, setTimeout: defaultSet } = {}) {
    return (milliseconds, { value, signal } = {}) => {
      if (signal == null ? void 0 : signal.aborted) {
        return Promise.reject(createAbortError());
      }
      let timeoutId;
      let settle;
      let rejectFunction;
      const clear = defaultClear ?? clearTimeout;
      const signalListener = () => {
        clear(timeoutId);
        rejectFunction(createAbortError());
      };
      const cleanup = () => {
        if (signal) {
          signal.removeEventListener("abort", signalListener);
        }
      };
      const delayPromise = new Promise((resolve, reject) => {
        settle = () => {
          cleanup();
          resolve(value);
        };
        rejectFunction = reject;
        timeoutId = (defaultSet ?? setTimeout)(settle, milliseconds);
      });
      if (signal) {
        signal.addEventListener("abort", signalListener, { once: true });
      }
      clearMethods.set(delayPromise, () => {
        clear(timeoutId);
        timeoutId = null;
        settle();
      });
      return delayPromise;
    };
  }
  var delay = createDelay();
  var delay_default = delay;

  // node_modules/@libp2p/utils/dist/src/errors.js
  var import_browser_shims219 = __toESM(require_browser_shims(), 1);
  var RateLimitError = class extends Error {
    remainingPoints;
    msBeforeNext;
    consumedPoints;
    isFirstInDuration;
    constructor(message2 = "Rate limit exceeded", props) {
      super(message2);
      this.name = "RateLimitError";
      this.remainingPoints = props.remainingPoints;
      this.msBeforeNext = props.msBeforeNext;
      this.consumedPoints = props.consumedPoints;
      this.isFirstInDuration = props.isFirstInDuration;
    }
  };
  var QueueFullError2 = class extends Error {
    static name = "QueueFullError";
    constructor(message2 = "The queue was full") {
      super(message2);
      this.name = "QueueFullError";
    }
  };

  // node_modules/@libp2p/utils/dist/src/rate-limiter.js
  var RateLimiter = class {
    memoryStorage;
    points;
    duration;
    blockDuration;
    execEvenly;
    execEvenlyMinDelayMs;
    keyPrefix;
    constructor(opts = {}) {
      this.points = opts.points ?? 4;
      this.duration = opts.duration ?? 1;
      this.blockDuration = opts.blockDuration ?? 0;
      this.execEvenly = opts.execEvenly ?? false;
      this.execEvenlyMinDelayMs = opts.execEvenlyMinDelayMs ?? this.duration * 1e3 / this.points;
      this.keyPrefix = opts.keyPrefix ?? "rlflx";
      this.memoryStorage = new MemoryStorage();
    }
    async consume(key, pointsToConsume = 1, options = {}) {
      const rlKey = this.getKey(key);
      const secDuration = this._getKeySecDuration(options);
      let res = this.memoryStorage.incrby(rlKey, pointsToConsume, secDuration);
      res.remainingPoints = Math.max(this.points - res.consumedPoints, 0);
      if (res.consumedPoints > this.points) {
        if (this.blockDuration > 0 && res.consumedPoints <= this.points + pointsToConsume) {
          res = this.memoryStorage.set(rlKey, res.consumedPoints, this.blockDuration);
        }
        throw new RateLimitError("Rate limit exceeded", res);
      } else if (this.execEvenly && res.msBeforeNext > 0 && !res.isFirstInDuration) {
        let delayMs = Math.ceil(res.msBeforeNext / (res.remainingPoints + 2));
        if (delayMs < this.execEvenlyMinDelayMs) {
          delayMs = res.consumedPoints * this.execEvenlyMinDelayMs;
        }
        await delay_default(delayMs);
      }
      return res;
    }
    penalty(key, points = 1, options = {}) {
      const rlKey = this.getKey(key);
      const secDuration = this._getKeySecDuration(options);
      const res = this.memoryStorage.incrby(rlKey, points, secDuration);
      res.remainingPoints = Math.max(this.points - res.consumedPoints, 0);
      return res;
    }
    reward(key, points = 1, options = {}) {
      const rlKey = this.getKey(key);
      const secDuration = this._getKeySecDuration(options);
      const res = this.memoryStorage.incrby(rlKey, -points, secDuration);
      res.remainingPoints = Math.max(this.points - res.consumedPoints, 0);
      return res;
    }
    /**
     * Block any key for secDuration seconds
     *
     * @param key
     * @param secDuration
     */
    block(key, secDuration) {
      const msDuration = secDuration * 1e3;
      const initPoints = this.points + 1;
      this.memoryStorage.set(this.getKey(key), initPoints, secDuration);
      return {
        remainingPoints: 0,
        msBeforeNext: msDuration === 0 ? -1 : msDuration,
        consumedPoints: initPoints,
        isFirstInDuration: false
      };
    }
    set(key, points, secDuration = 0) {
      const msDuration = (secDuration >= 0 ? secDuration : this.duration) * 1e3;
      this.memoryStorage.set(this.getKey(key), points, secDuration);
      return {
        remainingPoints: 0,
        msBeforeNext: msDuration === 0 ? -1 : msDuration,
        consumedPoints: points,
        isFirstInDuration: false
      };
    }
    get(key) {
      const res = this.memoryStorage.get(this.getKey(key));
      if (res != null) {
        res.remainingPoints = Math.max(this.points - res.consumedPoints, 0);
      }
      return res;
    }
    delete(key) {
      this.memoryStorage.delete(this.getKey(key));
    }
    _getKeySecDuration(options) {
      if ((options == null ? void 0 : options.customDuration) != null && options.customDuration >= 0) {
        return options.customDuration;
      }
      return this.duration;
    }
    getKey(key) {
      return this.keyPrefix.length > 0 ? `${this.keyPrefix}:${key}` : key;
    }
    parseKey(rlKey) {
      return rlKey.substring(this.keyPrefix.length);
    }
  };
  var MemoryStorage = class {
    storage;
    constructor() {
      this.storage = /* @__PURE__ */ new Map();
    }
    incrby(key, value, durationSec) {
      const existing = this.storage.get(key);
      if (existing != null) {
        const msBeforeExpires = existing.expiresAt != null ? existing.expiresAt.getTime() - (/* @__PURE__ */ new Date()).getTime() : -1;
        if (existing.expiresAt == null || msBeforeExpires > 0) {
          existing.value += value;
          return {
            remainingPoints: 0,
            msBeforeNext: msBeforeExpires,
            consumedPoints: existing.value,
            isFirstInDuration: false
          };
        }
        return this.set(key, value, durationSec);
      }
      return this.set(key, value, durationSec);
    }
    set(key, value, durationSec) {
      const durationMs = durationSec * 1e3;
      const existing = this.storage.get(key);
      if (existing != null) {
        clearTimeout(existing.timeoutId);
      }
      const record = {
        value,
        expiresAt: durationMs > 0 ? new Date(Date.now() + durationMs) : void 0
      };
      this.storage.set(key, record);
      if (durationMs > 0) {
        record.timeoutId = setTimeout(() => {
          this.storage.delete(key);
        }, durationMs);
        if (record.timeoutId.unref != null) {
          record.timeoutId.unref();
        }
      }
      return {
        remainingPoints: 0,
        msBeforeNext: durationMs === 0 ? -1 : durationMs,
        consumedPoints: record.value,
        isFirstInDuration: true
      };
    }
    get(key) {
      const existing = this.storage.get(key);
      if (existing != null) {
        const msBeforeExpires = existing.expiresAt != null ? existing.expiresAt.getTime() - (/* @__PURE__ */ new Date()).getTime() : -1;
        return {
          remainingPoints: 0,
          msBeforeNext: msBeforeExpires,
          consumedPoints: existing.value,
          isFirstInDuration: false
        };
      }
    }
    delete(key) {
      const record = this.storage.get(key);
      if (record != null) {
        if (record.timeoutId != null) {
          clearTimeout(record.timeoutId);
        }
        this.storage.delete(key);
        return true;
      }
      return false;
    }
  };

  // node_modules/libp2p/dist/src/get-peer.js
  var import_browser_shims221 = __toESM(require_browser_shims(), 1);
  function getPeerAddress(peer) {
    if (isPeerId(peer)) {
      return { peerId: peer, multiaddrs: [] };
    }
    let multiaddrs = Array.isArray(peer) ? peer : [peer];
    let peerId2;
    if (multiaddrs.length > 0) {
      const peerIdStr = multiaddrs[0].getPeerId();
      peerId2 = peerIdStr == null ? void 0 : peerIdFromString(peerIdStr);
      multiaddrs.forEach((ma) => {
        if (!isMultiaddr(ma)) {
          throw new InvalidMultiaddrError("Invalid multiaddr");
        }
        const maPeerIdStr = ma.getPeerId();
        if (maPeerIdStr == null) {
          if (peerId2 != null) {
            throw new InvalidParametersError("Multiaddrs must all have the same peer id or have no peer id");
          }
        } else {
          const maPeerId = peerIdFromString(maPeerIdStr);
          if ((peerId2 == null ? void 0 : peerId2.equals(maPeerId)) !== true) {
            throw new InvalidParametersError("Multiaddrs must all have the same peer id or have no peer id");
          }
        }
      });
    }
    multiaddrs = multiaddrs.filter((ma) => {
      return !PEER_ID.exactMatch(ma);
    });
    return {
      peerId: peerId2,
      multiaddrs
    };
  }

  // node_modules/libp2p/dist/src/connection-manager/connection-pruner.js
  var import_browser_shims226 = __toESM(require_browser_shims(), 1);

  // node_modules/@libp2p/utils/dist/src/close.js
  var import_browser_shims222 = __toESM(require_browser_shims(), 1);
  var DEFAULT_CLOSABLE_PROTOCOLS = [
    // identify
    "/ipfs/id/1.0.0",
    // identify-push
    "/ipfs/id/push/1.0.0",
    // autonat
    "/libp2p/autonat/1.0.0",
    // dcutr
    "/libp2p/dcutr"
  ];
  async function safelyCloseConnectionIfUnused(connection, options) {
    var _a2;
    const streamProtocols = ((_a2 = connection == null ? void 0 : connection.streams) == null ? void 0 : _a2.map((stream) => stream.protocol)) ?? [];
    const closableProtocols = (options == null ? void 0 : options.closableProtocols) ?? DEFAULT_CLOSABLE_PROTOCOLS;
    if (streamProtocols.filter((proto) => proto != null && !closableProtocols.includes(proto)).length > 0) {
      return;
    }
    try {
      await (connection == null ? void 0 : connection.close(options));
    } catch (err) {
      connection == null ? void 0 : connection.abort(err);
    }
  }

  // node_modules/libp2p/dist/src/connection-manager/constants.browser.js
  var import_browser_shims224 = __toESM(require_browser_shims(), 1);

  // node_modules/libp2p/dist/src/connection-manager/constants.defaults.js
  var import_browser_shims223 = __toESM(require_browser_shims(), 1);
  var DIAL_TIMEOUT = 1e4;
  var INBOUND_UPGRADE_TIMEOUT = 1e4;
  var PROTOCOL_NEGOTIATION_TIMEOUT = 1e4;
  var MAX_PEER_ADDRS_TO_DIAL = 25;
  var INBOUND_CONNECTION_THRESHOLD = 5;
  var MAX_INCOMING_PENDING_CONNECTIONS = 10;
  var MAX_PARALLEL_RECONNECTS = 5;
  var LAST_DIAL_FAILURE_KEY = "last-dial-failure";
  var LAST_DIAL_SUCCESS_KEY = "last-dial-success";
  var MAX_DIAL_QUEUE_LENGTH = 500;

  // node_modules/libp2p/dist/src/connection-manager/constants.browser.js
  var MAX_CONNECTIONS = 100;
  var MAX_PARALLEL_DIALS = 50;

  // node_modules/libp2p/dist/src/connection-manager/utils.js
  var import_browser_shims225 = __toESM(require_browser_shims(), 1);
  async function resolveMultiaddrs(ma, options) {
    let resolvable = false;
    for (const key of resolvers.keys()) {
      resolvable = ma.protoNames().includes(key);
      if (resolvable) {
        break;
      }
    }
    if (!resolvable) {
      return [ma];
    }
    const output = await ma.resolve(options);
    options.log("resolved %s to", ma, output.map((ma2) => ma2.toString()));
    return output;
  }
  function multiaddrToIpNet(ma) {
    try {
      let parsedMa;
      if (typeof ma === "string") {
        parsedMa = multiaddr(ma);
      } else {
        parsedMa = ma;
      }
      if (!parsedMa.protoNames().includes("ipcidr")) {
        const isIPv62 = parsedMa.protoNames().includes("ip6");
        const cidr = isIPv62 ? "/ipcidr/128" : "/ipcidr/32";
        parsedMa = parsedMa.encapsulate(cidr);
      }
      return convertToIpNet(parsedMa);
    } catch (error) {
      throw new Error(`Can't convert to IpNet, Invalid multiaddr format: ${ma}`);
    }
  }

  // node_modules/libp2p/dist/src/connection-manager/connection-pruner.js
  var defaultOptions3 = {
    maxConnections: MAX_CONNECTIONS,
    allow: []
  };
  var ConnectionPruner = class {
    maxConnections;
    connectionManager;
    peerStore;
    allow;
    events;
    log;
    constructor(components, init = {}) {
      this.maxConnections = init.maxConnections ?? defaultOptions3.maxConnections;
      this.allow = (init.allow ?? []).map((ma) => multiaddrToIpNet(ma));
      this.connectionManager = components.connectionManager;
      this.peerStore = components.peerStore;
      this.events = components.events;
      this.log = components.logger.forComponent("libp2p:connection-manager:connection-pruner");
      this.maybePruneConnections = this.maybePruneConnections.bind(this);
    }
    start() {
      this.events.addEventListener("connection:open", this.maybePruneConnections);
    }
    stop() {
      this.events.removeEventListener("connection:open", this.maybePruneConnections);
    }
    maybePruneConnections() {
      this._maybePruneConnections().catch((err) => {
        this.log.error("error while pruning connections %e", err);
      });
    }
    /**
     * If we have more connections than our maximum, select some excess connections
     * to prune based on peer value
     */
    async _maybePruneConnections() {
      const connections = this.connectionManager.getConnections();
      const numConnections = connections.length;
      this.log("checking max connections limit %d/%d", numConnections, this.maxConnections);
      if (numConnections <= this.maxConnections) {
        return;
      }
      const peerValues = new PeerMap();
      for (const connection of connections) {
        const remotePeer = connection.remotePeer;
        if (peerValues.has(remotePeer)) {
          continue;
        }
        peerValues.set(remotePeer, 0);
        try {
          const peer = await this.peerStore.get(remotePeer);
          peerValues.set(remotePeer, [...peer.tags.values()].reduce((acc, curr) => {
            return acc + curr.value;
          }, 0));
        } catch (err) {
          if (err.name !== "NotFoundError") {
            this.log.error("error loading peer tags", err);
          }
        }
      }
      const sortedConnections = this.sortConnections(connections, peerValues);
      const toPrune = Math.max(numConnections - this.maxConnections, 0);
      const toClose = [];
      for (const connection of sortedConnections) {
        this.log("too many connections open - closing a connection to %p", connection.remotePeer);
        const connectionInAllowList = this.allow.some((ipNet) => {
          return ipNet.contains(connection.remoteAddr.nodeAddress().address);
        });
        if (!connectionInAllowList) {
          toClose.push(connection);
        }
        if (toClose.length === toPrune) {
          break;
        }
      }
      await Promise.all(toClose.map(async (connection) => {
        await safelyCloseConnectionIfUnused(connection, {
          signal: AbortSignal.timeout(1e3)
        });
      }));
      this.events.safeDispatchEvent("connection:prune", { detail: toClose });
    }
    sortConnections(connections, peerValues) {
      return connections.sort((a, b) => {
        const connectionALifespan = a.timeline.open;
        const connectionBLifespan = b.timeline.open;
        if (connectionALifespan < connectionBLifespan) {
          return 1;
        }
        if (connectionALifespan > connectionBLifespan) {
          return -1;
        }
        return 0;
      }).sort((a, b) => {
        if (a.direction === "outbound" && b.direction === "inbound") {
          return 1;
        }
        if (a.direction === "inbound" && b.direction === "outbound") {
          return -1;
        }
        return 0;
      }).sort((a, b) => {
        if (a.streams.length > b.streams.length) {
          return 1;
        }
        if (a.streams.length < b.streams.length) {
          return -1;
        }
        return 0;
      }).sort((a, b) => {
        const peerAValue = peerValues.get(a.remotePeer) ?? 0;
        const peerBValue = peerValues.get(b.remotePeer) ?? 0;
        if (peerAValue > peerBValue) {
          return 1;
        }
        if (peerAValue < peerBValue) {
          return -1;
        }
        return 0;
      });
    }
  };

  // node_modules/libp2p/dist/src/connection-manager/dial-queue.js
  var import_browser_shims235 = __toESM(require_browser_shims(), 1);

  // node_modules/@libp2p/utils/dist/src/priority-queue.js
  var import_browser_shims230 = __toESM(require_browser_shims(), 1);

  // node_modules/@libp2p/utils/dist/src/queue/index.js
  var import_browser_shims229 = __toESM(require_browser_shims(), 1);

  // node_modules/@libp2p/utils/dist/src/queue/job.js
  var import_browser_shims228 = __toESM(require_browser_shims(), 1);

  // node_modules/@libp2p/utils/dist/src/queue/recipient.js
  var import_browser_shims227 = __toESM(require_browser_shims(), 1);
  var JobRecipient2 = class {
    deferred;
    signal;
    constructor(signal) {
      var _a2;
      this.signal = signal;
      this.deferred = pDefer();
      this.onAbort = this.onAbort.bind(this);
      (_a2 = this.signal) == null ? void 0 : _a2.addEventListener("abort", this.onAbort);
    }
    onAbort() {
      var _a2;
      this.deferred.reject(((_a2 = this.signal) == null ? void 0 : _a2.reason) ?? new AbortError());
    }
    cleanup() {
      var _a2;
      (_a2 = this.signal) == null ? void 0 : _a2.removeEventListener("abort", this.onAbort);
    }
  };

  // node_modules/@libp2p/utils/dist/src/queue/job.js
  function randomId2() {
    return `${parseInt(String(Math.random() * 1e9), 10).toString()}${Date.now()}`;
  }
  var Job2 = class {
    id;
    fn;
    options;
    recipients;
    status;
    timeline;
    controller;
    constructor(fn, options) {
      this.id = randomId2();
      this.status = "queued";
      this.fn = fn;
      this.options = options;
      this.recipients = [];
      this.timeline = {
        created: Date.now()
      };
      this.controller = new AbortController();
      setMaxListeners(Infinity, this.controller.signal);
      this.onAbort = this.onAbort.bind(this);
    }
    abort(err) {
      this.controller.abort(err);
    }
    onAbort() {
      const allAborted = this.recipients.reduce((acc, curr) => {
        var _a2;
        return acc && ((_a2 = curr.signal) == null ? void 0 : _a2.aborted) === true;
      }, true);
      if (allAborted) {
        this.controller.abort(new AbortError());
        this.cleanup();
      }
    }
    async join(options = {}) {
      var _a2;
      const recipient = new JobRecipient2(options.signal);
      this.recipients.push(recipient);
      (_a2 = options.signal) == null ? void 0 : _a2.addEventListener("abort", this.onAbort);
      return recipient.deferred.promise;
    }
    async run() {
      this.status = "running";
      this.timeline.started = Date.now();
      try {
        this.controller.signal.throwIfAborted();
        const result = await raceSignal(this.fn({
          ...this.options ?? {},
          signal: this.controller.signal
        }), this.controller.signal);
        this.recipients.forEach((recipient) => {
          recipient.deferred.resolve(result);
        });
        this.status = "complete";
      } catch (err) {
        this.recipients.forEach((recipient) => {
          recipient.deferred.reject(err);
        });
        this.status = "errored";
      } finally {
        this.timeline.finished = Date.now();
        this.cleanup();
      }
    }
    cleanup() {
      this.recipients.forEach((recipient) => {
        var _a2;
        recipient.cleanup();
        (_a2 = recipient.signal) == null ? void 0 : _a2.removeEventListener("abort", this.onAbort);
      });
    }
  };

  // node_modules/@libp2p/utils/dist/src/queue/index.js
  var Queue2 = class extends TypedEventEmitter {
    concurrency;
    maxSize;
    queue;
    pending;
    sort;
    constructor(init = {}) {
      var _a2;
      super();
      this.concurrency = init.concurrency ?? Number.POSITIVE_INFINITY;
      this.maxSize = init.maxSize ?? Number.POSITIVE_INFINITY;
      this.pending = 0;
      if (init.metricName != null) {
        (_a2 = init.metrics) == null ? void 0 : _a2.registerMetricGroup(init.metricName, {
          calculate: () => {
            return {
              size: this.queue.length,
              running: this.pending,
              queued: this.queue.length - this.pending
            };
          }
        });
      }
      this.sort = init.sort;
      this.queue = [];
      this.emitEmpty = debounce2(this.emitEmpty.bind(this), 1);
      this.emitIdle = debounce2(this.emitIdle.bind(this), 1);
    }
    emitEmpty() {
      if (this.size !== 0) {
        return;
      }
      this.safeDispatchEvent("empty");
    }
    emitIdle() {
      if (this.running !== 0) {
        return;
      }
      this.safeDispatchEvent("idle");
    }
    tryToStartAnother() {
      if (this.size === 0) {
        this.emitEmpty();
        if (this.running === 0) {
          this.emitIdle();
        }
        return false;
      }
      if (this.pending < this.concurrency) {
        let job;
        for (const j of this.queue) {
          if (j.status === "queued") {
            job = j;
            break;
          }
        }
        if (job == null) {
          return false;
        }
        this.safeDispatchEvent("active");
        this.pending++;
        void job.run().finally(() => {
          for (let i = 0; i < this.queue.length; i++) {
            if (this.queue[i] === job) {
              this.queue.splice(i, 1);
              break;
            }
          }
          this.pending--;
          this.tryToStartAnother();
          this.safeDispatchEvent("next");
        });
        return true;
      }
      return false;
    }
    enqueue(job) {
      this.queue.push(job);
      if (this.sort != null) {
        this.queue.sort(this.sort);
      }
    }
    /**
     * Adds a sync or async task to the queue. Always returns a promise.
     */
    async add(fn, options) {
      var _a2;
      (_a2 = options == null ? void 0 : options.signal) == null ? void 0 : _a2.throwIfAborted();
      if (this.size === this.maxSize) {
        throw new QueueFullError2();
      }
      const job = new Job2(fn, options);
      this.enqueue(job);
      this.safeDispatchEvent("add");
      this.tryToStartAnother();
      return job.join(options).then((result) => {
        this.safeDispatchEvent("completed", { detail: result });
        this.safeDispatchEvent("success", { detail: { job, result } });
        return result;
      }).catch((err) => {
        if (job.status === "queued") {
          for (let i = 0; i < this.queue.length; i++) {
            if (this.queue[i] === job) {
              this.queue.splice(i, 1);
              break;
            }
          }
        }
        this.safeDispatchEvent("error", { detail: err });
        this.safeDispatchEvent("failure", { detail: { job, error: err } });
        throw err;
      });
    }
    /**
     * Clear the queue
     */
    clear() {
      this.queue.splice(0, this.queue.length);
    }
    /**
     * Abort all jobs in the queue and clear it
     */
    abort() {
      this.queue.forEach((job) => {
        job.abort(new AbortError());
      });
      this.clear();
    }
    /**
     * Can be called multiple times. Useful if you for example add additional items at a later time.
     *
     * @returns A promise that settles when the queue becomes empty.
     */
    async onEmpty(options) {
      if (this.size === 0) {
        return;
      }
      await raceEvent(this, "empty", options == null ? void 0 : options.signal);
    }
    /**
     * @returns A promise that settles when the queue size is less than the given
     * limit: `queue.size < limit`.
     *
     * If you want to avoid having the queue grow beyond a certain size you can
     * `await queue.onSizeLessThan()` before adding a new item.
     *
     * Note that this only limits the number of items waiting to start. There
     * could still be up to `concurrency` jobs already running that this call does
     * not include in its calculation.
     */
    async onSizeLessThan(limit, options) {
      if (this.size < limit) {
        return;
      }
      await raceEvent(this, "next", options == null ? void 0 : options.signal, {
        filter: () => this.size < limit
      });
    }
    /**
     * The difference with `.onEmpty` is that `.onIdle` guarantees that all work
     * from the queue has finished. `.onEmpty` merely signals that the queue is
     * empty, but it could mean that some promises haven't completed yet.
     *
     * @returns A promise that settles when the queue becomes empty, and all
     * promises have completed; `queue.size === 0 && queue.pending === 0`.
     */
    async onIdle(options) {
      if (this.pending === 0 && this.size === 0) {
        return;
      }
      await raceEvent(this, "idle", options == null ? void 0 : options.signal);
    }
    /**
     * Size of the queue including running items
     */
    get size() {
      return this.queue.length;
    }
    /**
     * The number of queued items waiting to run.
     */
    get queued() {
      return this.queue.length - this.pending;
    }
    /**
     * The number of items currently running.
     */
    get running() {
      return this.pending;
    }
    /**
     * Returns an async generator that makes it easy to iterate over the results
     * of jobs added to the queue.
     *
     * The generator will end when the queue becomes idle, that is there are no
     * jobs running and no jobs that have yet to run.
     *
     * If you need to keep the queue open indefinitely, consider using it-pushable
     * instead.
     */
    async *toGenerator(options) {
      var _a2, _b2, _c;
      (_a2 = options == null ? void 0 : options.signal) == null ? void 0 : _a2.throwIfAborted();
      const stream = pushable({
        objectMode: true
      });
      const cleanup = (err) => {
        if (err != null) {
          this.abort();
        } else {
          this.clear();
        }
        stream.end(err);
      };
      const onQueueJobComplete = (evt) => {
        if (evt.detail != null) {
          stream.push(evt.detail);
        }
      };
      const onQueueError = (evt) => {
        cleanup(evt.detail);
      };
      const onQueueIdle = () => {
        cleanup();
      };
      const onSignalAbort = () => {
        cleanup(new AbortError("Queue aborted"));
      };
      this.addEventListener("completed", onQueueJobComplete);
      this.addEventListener("error", onQueueError);
      this.addEventListener("idle", onQueueIdle);
      (_b2 = options == null ? void 0 : options.signal) == null ? void 0 : _b2.addEventListener("abort", onSignalAbort);
      try {
        yield* stream;
      } finally {
        this.removeEventListener("completed", onQueueJobComplete);
        this.removeEventListener("error", onQueueError);
        this.removeEventListener("idle", onQueueIdle);
        (_c = options == null ? void 0 : options.signal) == null ? void 0 : _c.removeEventListener("abort", onSignalAbort);
        cleanup();
      }
    }
  };

  // node_modules/@libp2p/utils/dist/src/priority-queue.js
  var PriorityQueue2 = class extends Queue2 {
    constructor(init = {}) {
      super({
        ...init,
        sort: (a, b) => {
          if (a.options.priority > b.options.priority) {
            return -1;
          }
          if (a.options.priority < b.options.priority) {
            return 1;
          }
          return 0;
        }
      });
    }
  };

  // node_modules/any-signal/dist/src/index.js
  var import_browser_shims231 = __toESM(require_browser_shims(), 1);
  function anySignal(signals) {
    const controller = new globalThis.AbortController();
    function onAbort() {
      controller.abort();
      for (const signal2 of signals) {
        if ((signal2 == null ? void 0 : signal2.removeEventListener) != null) {
          signal2.removeEventListener("abort", onAbort);
        }
      }
    }
    for (const signal2 of signals) {
      if ((signal2 == null ? void 0 : signal2.aborted) === true) {
        onAbort();
        break;
      }
      if ((signal2 == null ? void 0 : signal2.addEventListener) != null) {
        signal2.addEventListener("abort", onAbort);
      }
    }
    function clear() {
      for (const signal2 of signals) {
        if ((signal2 == null ? void 0 : signal2.removeEventListener) != null) {
          signal2.removeEventListener("abort", onAbort);
        }
      }
    }
    const signal = controller.signal;
    signal.clear = clear;
    return signal;
  }

  // node_modules/libp2p/dist/src/connection-manager/address-sorter.js
  var import_browser_shims234 = __toESM(require_browser_shims(), 1);

  // node_modules/@libp2p/utils/dist/src/multiaddr/is-loopback.js
  var import_browser_shims233 = __toESM(require_browser_shims(), 1);

  // node_modules/is-loopback-addr/dist/src/index.js
  var import_browser_shims232 = __toESM(require_browser_shims(), 1);
  function isLoopbackAddr(ip) {
    return /^127\.([0-9]{1,3})\.([0-9]{1,3})\.([0-9]{1,3})$/i.test(ip) || /^::1$/.test(ip);
  }

  // node_modules/@libp2p/utils/dist/src/multiaddr/is-loopback.js
  function isLoopback(ma) {
    if (!isIpBased(ma)) {
      return false;
    }
    const { address } = ma.nodeAddress();
    return isLoopbackAddr(address);
  }

  // node_modules/libp2p/dist/src/connection-manager/address-sorter.js
  function reliableTransportsFirst(a, b) {
    const isATcp = TCP.exactMatch(a.multiaddr);
    const isBTcp = TCP.exactMatch(b.multiaddr);
    if (isATcp && !isBTcp) {
      return -1;
    }
    if (!isATcp && isBTcp) {
      return 1;
    }
    const isAWebSocketSecure = WebSocketsSecure.exactMatch(a.multiaddr);
    const isBWebSocketSecure = WebSocketsSecure.exactMatch(b.multiaddr);
    if (isAWebSocketSecure && !isBWebSocketSecure) {
      return -1;
    }
    if (!isAWebSocketSecure && isBWebSocketSecure) {
      return 1;
    }
    const isAWebSocket = WebSockets.exactMatch(a.multiaddr);
    const isBWebSocket = WebSockets.exactMatch(b.multiaddr);
    if (isAWebSocket && !isBWebSocket) {
      return -1;
    }
    if (!isAWebSocket && isBWebSocket) {
      return 1;
    }
    const isAWebRTC = WebRTC.exactMatch(a.multiaddr);
    const isBWebRTC = WebRTC.exactMatch(b.multiaddr);
    if (isAWebRTC && !isBWebRTC) {
      return -1;
    }
    if (!isAWebRTC && isBWebRTC) {
      return 1;
    }
    const isAWebRTCDirect = WebRTCDirect.exactMatch(a.multiaddr);
    const isBWebRTCDirect = WebRTCDirect.exactMatch(b.multiaddr);
    if (isAWebRTCDirect && !isBWebRTCDirect) {
      return -1;
    }
    if (!isAWebRTCDirect && isBWebRTCDirect) {
      return 1;
    }
    const isAWebTransport = WebTransport.exactMatch(a.multiaddr);
    const isBWebTransport = WebTransport.exactMatch(b.multiaddr);
    if (isAWebTransport && !isBWebTransport) {
      return -1;
    }
    if (!isAWebTransport && isBWebTransport) {
      return 1;
    }
    return 0;
  }
  function loopbackAddressLast(a, b) {
    const isALoopback = isLoopback(a.multiaddr);
    const isBLoopback = isLoopback(b.multiaddr);
    if (isALoopback && !isBLoopback) {
      return 1;
    } else if (!isALoopback && isBLoopback) {
      return -1;
    }
    return 0;
  }
  function publicAddressesFirst(a, b) {
    const isAPrivate = isPrivate(a.multiaddr);
    const isBPrivate = isPrivate(b.multiaddr);
    if (isAPrivate && !isBPrivate) {
      return 1;
    } else if (!isAPrivate && isBPrivate) {
      return -1;
    }
    return 0;
  }
  function certifiedAddressesFirst(a, b) {
    if (a.isCertified && !b.isCertified) {
      return -1;
    } else if (!a.isCertified && b.isCertified) {
      return 1;
    }
    return 0;
  }
  function circuitRelayAddressesLast(a, b) {
    const isACircuit = Circuit.exactMatch(a.multiaddr);
    const isBCircuit = Circuit.exactMatch(b.multiaddr);
    if (isACircuit && !isBCircuit) {
      return 1;
    } else if (!isACircuit && isBCircuit) {
      return -1;
    }
    return 0;
  }
  function defaultAddressSorter(addresses) {
    return addresses.sort(reliableTransportsFirst).sort(certifiedAddressesFirst).sort(circuitRelayAddressesLast).sort(publicAddressesFirst).sort(loopbackAddressLast);
  }

  // node_modules/libp2p/dist/src/connection-manager/dial-queue.js
  var defaultOptions4 = {
    maxParallelDials: MAX_PARALLEL_DIALS,
    maxDialQueueLength: MAX_DIAL_QUEUE_LENGTH,
    maxPeerAddrsToDial: MAX_PEER_ADDRS_TO_DIAL,
    dialTimeout: DIAL_TIMEOUT,
    resolvers: {
      dnsaddr: dnsaddrResolver
    }
  };
  var DialQueue = class {
    queue;
    components;
    addressSorter;
    maxPeerAddrsToDial;
    maxDialQueueLength;
    dialTimeout;
    shutDownController;
    connections;
    log;
    constructor(components, init = {}) {
      this.addressSorter = init.addressSorter;
      this.maxPeerAddrsToDial = init.maxPeerAddrsToDial ?? defaultOptions4.maxPeerAddrsToDial;
      this.maxDialQueueLength = init.maxDialQueueLength ?? defaultOptions4.maxDialQueueLength;
      this.dialTimeout = init.dialTimeout ?? defaultOptions4.dialTimeout;
      this.connections = init.connections ?? new PeerMap();
      this.log = components.logger.forComponent("libp2p:connection-manager:dial-queue");
      this.components = components;
      this.shutDownController = new AbortController();
      setMaxListeners(Infinity, this.shutDownController.signal);
      for (const [key, value] of Object.entries(init.resolvers ?? {})) {
        resolvers.set(key, value);
      }
      this.queue = new PriorityQueue2({
        concurrency: init.maxParallelDials ?? defaultOptions4.maxParallelDials,
        metricName: "libp2p_dial_queue",
        metrics: components.metrics
      });
      this.queue.addEventListener("error", (event) => {
        var _a2;
        if (((_a2 = event.detail) == null ? void 0 : _a2.name) !== AbortError.name) {
          this.log.error("error in dial queue - %e", event.detail);
        }
      });
    }
    start() {
      this.shutDownController = new AbortController();
      setMaxListeners(Infinity, this.shutDownController.signal);
    }
    /**
     * Clears any pending dials
     */
    stop() {
      this.shutDownController.abort();
      this.queue.abort();
    }
    /**
     * Connects to a given peer, multiaddr or list of multiaddrs.
     *
     * If a peer is passed, all known multiaddrs will be tried. If a multiaddr or
     * multiaddrs are passed only those will be dialled.
     *
     * Where a list of multiaddrs is passed, if any contain a peer id then all
     * multiaddrs in the list must contain the same peer id.
     *
     * The dial to the first address that is successfully able to upgrade a
     * connection will be used, all other dials will be aborted when that happens.
     */
    async dial(peerIdOrMultiaddr, options = {}) {
      var _a2, _b2, _c;
      const { peerId: peerId2, multiaddrs } = getPeerAddress(peerIdOrMultiaddr);
      const existingConnection = Array.from(this.connections.values()).flat().find((conn) => {
        if (options.force === true) {
          return false;
        }
        if (conn.remotePeer.equals(peerId2)) {
          return true;
        }
        return multiaddrs.find((addr) => {
          return addr.equals(conn.remoteAddr);
        });
      });
      if ((existingConnection == null ? void 0 : existingConnection.status) === "open") {
        this.log("already connected to %a", existingConnection.remoteAddr);
        (_a2 = options.onProgress) == null ? void 0 : _a2.call(options, new CustomProgressEvent("dial-queue:already-connected"));
        return existingConnection;
      }
      const existingDial = this.queue.queue.find((job) => {
        if ((peerId2 == null ? void 0 : peerId2.equals(job.options.peerId)) === true) {
          return true;
        }
        const addresses = job.options.multiaddrs;
        if (addresses == null) {
          return false;
        }
        for (const multiaddr2 of multiaddrs) {
          if (addresses.has(multiaddr2.toString())) {
            return true;
          }
        }
        return false;
      });
      if (existingDial != null) {
        this.log("joining existing dial target for %p", peerId2);
        for (const multiaddr2 of multiaddrs) {
          existingDial.options.multiaddrs.add(multiaddr2.toString());
        }
        (_b2 = options.onProgress) == null ? void 0 : _b2.call(options, new CustomProgressEvent("dial-queue:already-in-dial-queue"));
        return existingDial.join(options);
      }
      if (this.queue.size >= this.maxDialQueueLength) {
        throw new DialError("Dial queue is full");
      }
      this.log("creating dial target for %p", peerId2, multiaddrs.map((ma) => ma.toString()));
      (_c = options.onProgress) == null ? void 0 : _c.call(options, new CustomProgressEvent("dial-queue:add-to-dial-queue"));
      return this.queue.add(async (options2) => {
        var _a3;
        (_a3 = options2.onProgress) == null ? void 0 : _a3.call(options2, new CustomProgressEvent("dial-queue:start-dial"));
        const signal = anySignal([
          this.shutDownController.signal,
          options2.signal
        ]);
        setMaxListeners(Infinity, signal);
        try {
          return await this.dialPeer(options2, signal);
        } finally {
          signal.clear();
        }
      }, {
        peerId: peerId2,
        priority: options.priority ?? DEFAULT_DIAL_PRIORITY,
        multiaddrs: new Set(multiaddrs.map((ma) => ma.toString())),
        signal: options.signal ?? AbortSignal.timeout(this.dialTimeout),
        onProgress: options.onProgress
      });
    }
    async dialPeer(options, signal) {
      var _a2;
      const peerId2 = options.peerId;
      const multiaddrs = options.multiaddrs;
      const failedMultiaddrs = /* @__PURE__ */ new Set();
      let forcePeerLookup = options.multiaddrs.size === 0;
      let dialed = 0;
      let dialIteration = 0;
      const errors = [];
      this.log("starting dial to %p", peerId2);
      while (forcePeerLookup || multiaddrs.size > 0) {
        dialIteration++;
        forcePeerLookup = false;
        const addrsToDial = [];
        const addrs = new Set(options.multiaddrs);
        multiaddrs.clear();
        this.log("calculating addrs to dial %p from %s", peerId2, [...addrs]);
        const calculatedAddrs = await this.calculateMultiaddrs(peerId2, addrs, {
          ...options,
          signal
        });
        for (const addr of calculatedAddrs) {
          if (failedMultiaddrs.has(addr.multiaddr.toString())) {
            this.log.trace("skipping previously failed multiaddr %a while dialing %p", addr.multiaddr, peerId2);
            continue;
          }
          addrsToDial.push(addr);
        }
        this.log("%s dial to %p with %s", dialIteration === 1 ? "starting" : "continuing", peerId2, addrsToDial.map((ma) => ma.multiaddr.toString()));
        (_a2 = options == null ? void 0 : options.onProgress) == null ? void 0 : _a2.call(options, new CustomProgressEvent("dial-queue:calculated-addresses", addrsToDial));
        for (const address of addrsToDial) {
          if (dialed === this.maxPeerAddrsToDial) {
            this.log("dialed maxPeerAddrsToDial (%d) addresses for %p, not trying any others", dialed, options.peerId);
            throw new DialError("Peer had more than maxPeerAddrsToDial");
          }
          dialed++;
          try {
            const conn = await this.components.transportManager.dial(address.multiaddr, {
              ...options,
              signal
            });
            this.log("dial to %a succeeded", address.multiaddr);
            try {
              await this.components.peerStore.merge(conn.remotePeer, {
                multiaddrs: [
                  conn.remoteAddr
                ],
                metadata: {
                  [LAST_DIAL_SUCCESS_KEY]: fromString2(Date.now().toString())
                }
              });
            } catch (err) {
              this.log.error("could not update last dial failure key for %p", peerId2, err);
            }
            return conn;
          } catch (err) {
            this.log.error("dial failed to %a", address.multiaddr, err);
            failedMultiaddrs.add(address.multiaddr.toString());
            if (peerId2 != null) {
              try {
                await this.components.peerStore.merge(peerId2, {
                  metadata: {
                    [LAST_DIAL_FAILURE_KEY]: fromString2(Date.now().toString())
                  }
                });
              } catch (err2) {
                this.log.error("could not update last dial failure key for %p", peerId2, err2);
              }
            }
            if (signal.aborted) {
              throw new TimeoutError(err.message);
            }
            errors.push(err);
          }
        }
      }
      if (errors.length === 1) {
        throw errors[0];
      }
      throw new AggregateError(errors, "All multiaddr dials failed");
    }
    // eslint-disable-next-line complexity
    async calculateMultiaddrs(peerId2, multiaddrs = /* @__PURE__ */ new Set(), options = {}) {
      var _a2, _b2;
      const addrs = [...multiaddrs].map((ma) => ({
        multiaddr: multiaddr(ma),
        isCertified: false
      }));
      if (peerId2 != null) {
        if (this.components.peerId.equals(peerId2)) {
          throw new DialError("Tried to dial self");
        }
        if (await ((_b2 = (_a2 = this.components.connectionGater).denyDialPeer) == null ? void 0 : _b2.call(_a2, peerId2)) === true) {
          throw new DialDeniedError("The dial request is blocked by gater.allowDialPeer");
        }
        if (addrs.length === 0) {
          this.log("loading multiaddrs for %p", peerId2);
          try {
            const peer = await this.components.peerStore.get(peerId2);
            addrs.push(...peer.addresses);
            this.log("loaded multiaddrs for %p", peerId2, addrs.map(({ multiaddr: multiaddr2 }) => multiaddr2.toString()));
          } catch (err) {
            if (err.name !== "NotFoundError") {
              throw err;
            }
          }
        }
        if (addrs.length === 0) {
          this.log("looking up multiaddrs for %p in the peer routing", peerId2);
          try {
            const peerInfo = await this.components.peerRouting.findPeer(peerId2, options);
            this.log("found multiaddrs for %p in the peer routing", peerId2, addrs.map(({ multiaddr: multiaddr2 }) => multiaddr2.toString()));
            addrs.push(...peerInfo.multiaddrs.map((multiaddr2) => ({
              multiaddr: multiaddr2,
              isCertified: false
            })));
          } catch (err) {
            if (err.name === "NoPeerRoutersError") {
              this.log("no peer routers configured", peerId2);
            } else {
              this.log.error("looking up multiaddrs for %p in the peer routing failed - %e", peerId2, err);
            }
          }
        }
      }
      let resolvedAddresses = (await Promise.all(addrs.map(async (addr) => {
        const result = await resolveMultiaddrs(addr.multiaddr, {
          dns: this.components.dns,
          ...options,
          log: this.log
        });
        if (result.length === 1 && result[0].equals(addr.multiaddr)) {
          return addr;
        }
        return result.map((multiaddr2) => ({
          multiaddr: multiaddr2,
          isCertified: false
        }));
      }))).flat();
      if (peerId2 != null) {
        const peerIdMultiaddr = `/p2p/${peerId2.toString()}`;
        resolvedAddresses = resolvedAddresses.map((addr) => {
          const lastProto = addr.multiaddr.protos().pop();
          if ((lastProto == null ? void 0 : lastProto.path) === true) {
            return addr;
          }
          if (addr.multiaddr.getPeerId() == null) {
            return {
              multiaddr: addr.multiaddr.encapsulate(peerIdMultiaddr),
              isCertified: addr.isCertified
            };
          }
          return addr;
        });
      }
      const filteredAddrs = resolvedAddresses.filter((addr) => {
        if (this.components.transportManager.dialTransportForMultiaddr(addr.multiaddr) == null) {
          return false;
        }
        const addrPeerId = addr.multiaddr.getPeerId();
        if (peerId2 != null && addrPeerId != null) {
          return peerId2.equals(addrPeerId);
        }
        return true;
      });
      const dedupedAddrs = /* @__PURE__ */ new Map();
      for (const addr of filteredAddrs) {
        const maStr = addr.multiaddr.toString();
        const existing = dedupedAddrs.get(maStr);
        if (existing != null) {
          existing.isCertified = existing.isCertified || addr.isCertified || false;
          continue;
        }
        dedupedAddrs.set(maStr, addr);
      }
      const dedupedMultiaddrs = [...dedupedAddrs.values()];
      if (dedupedMultiaddrs.length === 0) {
        throw new NoValidAddressesError("The dial request has no valid addresses");
      }
      const gatedAddrs = [];
      for (const addr of dedupedMultiaddrs) {
        if (this.components.connectionGater.denyDialMultiaddr != null && await this.components.connectionGater.denyDialMultiaddr(addr.multiaddr)) {
          continue;
        }
        gatedAddrs.push(addr);
      }
      const sortedGatedAddrs = this.addressSorter == null ? defaultAddressSorter(gatedAddrs) : gatedAddrs.sort(this.addressSorter);
      if (sortedGatedAddrs.length === 0) {
        throw new DialDeniedError("The connection gater denied all addresses in the dial request");
      }
      this.log.trace("addresses for %p before filtering", peerId2 ?? "unknown peer", resolvedAddresses.map(({ multiaddr: multiaddr2 }) => multiaddr2.toString()));
      this.log.trace("addresses for %p after filtering", peerId2 ?? "unknown peer", sortedGatedAddrs.map(({ multiaddr: multiaddr2 }) => multiaddr2.toString()));
      return sortedGatedAddrs;
    }
    async isDialable(multiaddr2, options = {}) {
      if (!Array.isArray(multiaddr2)) {
        multiaddr2 = [multiaddr2];
      }
      try {
        const addresses = await this.calculateMultiaddrs(void 0, new Set(multiaddr2.map((ma) => ma.toString())), options);
        if (options.runOnLimitedConnection === false) {
          return addresses.find((addr) => {
            return !Circuit.matches(addr.multiaddr);
          }) != null;
        }
        return true;
      } catch (err) {
        this.log.trace("error calculating if multiaddr(s) were dialable", err);
      }
      return false;
    }
  };

  // node_modules/libp2p/dist/src/connection-manager/reconnect-queue.js
  var import_browser_shims239 = __toESM(require_browser_shims(), 1);

  // node_modules/@libp2p/utils/dist/src/peer-queue.js
  var import_browser_shims236 = __toESM(require_browser_shims(), 1);
  var PeerQueue = class extends Queue2 {
    has(peerId2) {
      return this.find(peerId2) != null;
    }
    find(peerId2) {
      return this.queue.find((job) => {
        return peerId2.equals(job.options.peerId);
      });
    }
  };

  // node_modules/p-retry/index.js
  var import_browser_shims238 = __toESM(require_browser_shims(), 1);
  var import_retry = __toESM(require_retry2(), 1);

  // node_modules/is-network-error/index.js
  var import_browser_shims237 = __toESM(require_browser_shims(), 1);
  var objectToString = Object.prototype.toString;
  var isError2 = (value) => objectToString.call(value) === "[object Error]";
  var errorMessages = /* @__PURE__ */ new Set([
    "network error",
    // Chrome
    "Failed to fetch",
    // Chrome
    "NetworkError when attempting to fetch resource.",
    // Firefox
    "The Internet connection appears to be offline.",
    // Safari 16
    "Load failed",
    // Safari 17+
    "Network request failed",
    // `cross-fetch`
    "fetch failed",
    // Undici (Node.js)
    "terminated"
    // Undici (Node.js)
  ]);
  function isNetworkError(error) {
    const isValid = error && isError2(error) && error.name === "TypeError" && typeof error.message === "string";
    if (!isValid) {
      return false;
    }
    if (error.message === "Load failed") {
      return error.stack === void 0;
    }
    return errorMessages.has(error.message);
  }

  // node_modules/p-retry/index.js
  var AbortError7 = class extends Error {
    constructor(message2) {
      super();
      if (message2 instanceof Error) {
        this.originalError = message2;
        ({ message: message2 } = message2);
      } else {
        this.originalError = new Error(message2);
        this.originalError.stack = this.stack;
      }
      this.name = "AbortError";
      this.message = message2;
    }
  };
  var decorateErrorWithCounts = (error, attemptNumber, options) => {
    const retriesLeft = options.retries - (attemptNumber - 1);
    error.attemptNumber = attemptNumber;
    error.retriesLeft = retriesLeft;
    return error;
  };
  async function pRetry(input, options) {
    return new Promise((resolve, reject) => {
      options = { ...options };
      options.onFailedAttempt ??= () => {
      };
      options.shouldRetry ??= () => true;
      options.retries ??= 10;
      const operation = import_retry.default.operation(options);
      const abortHandler = () => {
        var _a2;
        operation.stop();
        reject((_a2 = options.signal) == null ? void 0 : _a2.reason);
      };
      if (options.signal && !options.signal.aborted) {
        options.signal.addEventListener("abort", abortHandler, { once: true });
      }
      const cleanUp = () => {
        var _a2;
        (_a2 = options.signal) == null ? void 0 : _a2.removeEventListener("abort", abortHandler);
        operation.stop();
      };
      operation.attempt(async (attemptNumber) => {
        try {
          const result = await input(attemptNumber);
          cleanUp();
          resolve(result);
        } catch (error) {
          try {
            if (!(error instanceof Error)) {
              throw new TypeError(`Non-error was thrown: "${error}". You should only throw errors.`);
            }
            if (error instanceof AbortError7) {
              throw error.originalError;
            }
            if (error instanceof TypeError && !isNetworkError(error)) {
              throw error;
            }
            decorateErrorWithCounts(error, attemptNumber, options);
            if (!await options.shouldRetry(error)) {
              operation.stop();
              reject(error);
            }
            await options.onFailedAttempt(error);
            if (!operation.retry(error)) {
              throw operation.mainError();
            }
          } catch (finalError) {
            decorateErrorWithCounts(finalError, attemptNumber, options);
            cleanUp();
            reject(finalError);
          }
        }
      });
    });
  }

  // node_modules/libp2p/dist/src/connection-manager/reconnect-queue.js
  var ReconnectQueue = class {
    log;
    queue;
    started;
    peerStore;
    retries;
    retryInterval;
    backoffFactor;
    connectionManager;
    events;
    constructor(components, init = {}) {
      this.log = components.logger.forComponent("libp2p:reconnect-queue");
      this.peerStore = components.peerStore;
      this.connectionManager = components.connectionManager;
      this.queue = new PeerQueue({
        concurrency: init.maxParallelReconnects ?? MAX_PARALLEL_RECONNECTS,
        metricName: "libp2p_reconnect_queue",
        metrics: components.metrics
      });
      this.started = false;
      this.retries = init.retries ?? 5;
      this.backoffFactor = init.backoffFactor;
      this.retryInterval = init.retryInterval;
      this.events = components.events;
      components.events.addEventListener("peer:disconnect", (evt) => {
        this.maybeReconnect(evt.detail).catch((err) => {
          this.log.error("failed to maybe reconnect to %p - %e", evt.detail, err);
        });
      });
    }
    async maybeReconnect(peerId2) {
      if (!this.started) {
        return;
      }
      const peer = await this.peerStore.get(peerId2);
      if (!hasKeepAliveTag(peer)) {
        return;
      }
      if (this.queue.has(peerId2)) {
        return;
      }
      this.queue.add(async (options) => {
        await pRetry(async (attempt) => {
          if (!this.started) {
            return;
          }
          try {
            await this.connectionManager.openConnection(peerId2, {
              signal: options == null ? void 0 : options.signal
            });
          } catch (err) {
            this.log("reconnecting to %p attempt %d of %d failed - %e", peerId2, attempt, this.retries, err);
            throw err;
          }
        }, {
          signal: options == null ? void 0 : options.signal,
          retries: this.retries,
          factor: this.backoffFactor,
          minTimeout: this.retryInterval
        });
      }, {
        peerId: peerId2
      }).catch(async (err) => {
        this.log.error("failed to reconnect to %p - %e", peerId2, err);
        const tags = {};
        [...peer.tags.keys()].forEach((key) => {
          if (key.startsWith(KEEP_ALIVE)) {
            tags[key] = void 0;
          }
        });
        await this.peerStore.merge(peerId2, {
          tags
        });
        this.events.safeDispatchEvent("peer:reconnect-failure", {
          detail: peerId2
        });
      }).catch(async (err) => {
        this.log.error("failed to remove keep-alive tag from %p - %e", peerId2, err);
      });
    }
    start() {
      this.started = true;
    }
    async afterStart() {
      void Promise.resolve().then(async () => {
        const keepAlivePeers = await this.peerStore.all({
          filters: [
            (peer) => hasKeepAliveTag(peer)
          ]
        });
        await Promise.all(keepAlivePeers.map(async (peer) => {
          await this.connectionManager.openConnection(peer.id).catch((err) => {
            this.log.error(err);
          });
        }));
      }).catch((err) => {
        this.log.error(err);
      });
    }
    stop() {
      this.started = false;
      this.queue.abort();
    }
  };
  function hasKeepAliveTag(peer) {
    for (const tag of peer.tags.keys()) {
      if (tag.startsWith(KEEP_ALIVE)) {
        return true;
      }
    }
    return false;
  }

  // node_modules/libp2p/dist/src/connection-manager/index.js
  var DEFAULT_DIAL_PRIORITY = 50;
  var defaultOptions5 = {
    maxConnections: MAX_CONNECTIONS,
    inboundConnectionThreshold: INBOUND_CONNECTION_THRESHOLD,
    maxIncomingPendingConnections: MAX_INCOMING_PENDING_CONNECTIONS
  };
  var DefaultConnectionManager = class {
    started;
    connections;
    allow;
    deny;
    maxIncomingPendingConnections;
    incomingPendingConnections;
    outboundPendingConnections;
    maxConnections;
    dialQueue;
    reconnectQueue;
    connectionPruner;
    inboundConnectionRateLimiter;
    peerStore;
    metrics;
    events;
    log;
    peerId;
    constructor(components, init = {}) {
      var _a2;
      this.maxConnections = init.maxConnections ?? defaultOptions5.maxConnections;
      if (this.maxConnections < 1) {
        throw new InvalidParametersError("Connection Manager maxConnections must be greater than 0");
      }
      this.connections = new PeerMap();
      this.started = false;
      this.peerId = components.peerId;
      this.peerStore = components.peerStore;
      this.metrics = components.metrics;
      this.events = components.events;
      this.log = components.logger.forComponent("libp2p:connection-manager");
      this.onConnect = this.onConnect.bind(this);
      this.onDisconnect = this.onDisconnect.bind(this);
      this.allow = (init.allow ?? []).map((str) => multiaddrToIpNet(str));
      this.deny = (init.deny ?? []).map((str) => multiaddrToIpNet(str));
      this.incomingPendingConnections = 0;
      this.maxIncomingPendingConnections = init.maxIncomingPendingConnections ?? defaultOptions5.maxIncomingPendingConnections;
      this.outboundPendingConnections = 0;
      this.inboundConnectionRateLimiter = new RateLimiter({
        points: init.inboundConnectionThreshold ?? defaultOptions5.inboundConnectionThreshold,
        duration: 1
      });
      this.connectionPruner = new ConnectionPruner({
        connectionManager: this,
        peerStore: components.peerStore,
        events: components.events,
        logger: components.logger
      }, {
        maxConnections: this.maxConnections,
        allow: (_a2 = init.allow) == null ? void 0 : _a2.map((a) => multiaddr(a))
      });
      this.dialQueue = new DialQueue(components, {
        addressSorter: init.addressSorter,
        maxParallelDials: init.maxParallelDials ?? MAX_PARALLEL_DIALS,
        maxDialQueueLength: init.maxDialQueueLength ?? MAX_DIAL_QUEUE_LENGTH,
        maxPeerAddrsToDial: init.maxPeerAddrsToDial ?? MAX_PEER_ADDRS_TO_DIAL,
        dialTimeout: init.dialTimeout ?? DIAL_TIMEOUT,
        resolvers: init.resolvers ?? {
          dnsaddr: dnsaddrResolver
        },
        connections: this.connections
      });
      this.reconnectQueue = new ReconnectQueue({
        events: components.events,
        peerStore: components.peerStore,
        logger: components.logger,
        connectionManager: this
      }, {
        retries: init.reconnectRetries,
        retryInterval: init.reconnectRetryInterval,
        backoffFactor: init.reconnectBackoffFactor,
        maxParallelReconnects: init.maxParallelReconnects
      });
    }
    [Symbol.toStringTag] = "@libp2p/connection-manager";
    /**
     * Starts the Connection Manager. If Metrics are not enabled on libp2p
     * only event loop and connection limits will be monitored.
     */
    async start() {
      var _a2, _b2, _c;
      (_a2 = this.metrics) == null ? void 0 : _a2.registerMetricGroup("libp2p_connection_manager_connections", {
        calculate: () => {
          const metric = {
            inbound: 0,
            "inbound pending": this.incomingPendingConnections,
            outbound: 0,
            "outbound pending": this.outboundPendingConnections
          };
          for (const conns of this.connections.values()) {
            for (const conn of conns) {
              metric[conn.direction]++;
            }
          }
          return metric;
        }
      });
      (_b2 = this.metrics) == null ? void 0 : _b2.registerMetricGroup("libp2p_protocol_streams_total", {
        label: "protocol",
        calculate: () => {
          const metric = {};
          for (const conns of this.connections.values()) {
            for (const conn of conns) {
              for (const stream of conn.streams) {
                const key = `${stream.direction} ${stream.protocol ?? "unnegotiated"}`;
                metric[key] = (metric[key] ?? 0) + 1;
              }
            }
          }
          return metric;
        }
      });
      (_c = this.metrics) == null ? void 0 : _c.registerMetricGroup("libp2p_connection_manager_protocol_streams_per_connection_90th_percentile", {
        label: "protocol",
        calculate: () => {
          const allStreams = {};
          for (const conns of this.connections.values()) {
            for (const conn of conns) {
              const streams = {};
              for (const stream of conn.streams) {
                const key = `${stream.direction} ${stream.protocol ?? "unnegotiated"}`;
                streams[key] = (streams[key] ?? 0) + 1;
              }
              for (const [protocol, count] of Object.entries(streams)) {
                allStreams[protocol] = allStreams[protocol] ?? [];
                allStreams[protocol].push(count);
              }
            }
          }
          const metric = {};
          for (let [protocol, counts] of Object.entries(allStreams)) {
            counts = counts.sort((a, b) => a - b);
            const index = Math.floor(counts.length * 0.9);
            metric[protocol] = counts[index];
          }
          return metric;
        }
      });
      this.events.addEventListener("connection:open", this.onConnect);
      this.events.addEventListener("connection:close", this.onDisconnect);
      await start(this.dialQueue, this.reconnectQueue, this.connectionPruner);
      this.started = true;
      this.log("started");
    }
    /**
     * Stops the Connection Manager
     */
    async stop() {
      this.events.removeEventListener("connection:open", this.onConnect);
      this.events.removeEventListener("connection:close", this.onDisconnect);
      await stop(this.reconnectQueue, this.dialQueue, this.connectionPruner);
      const tasks = [];
      for (const connectionList of this.connections.values()) {
        for (const connection of connectionList) {
          tasks.push((async () => {
            try {
              await connection.close();
            } catch (err) {
              this.log.error(err);
            }
          })());
        }
      }
      this.log("closing %d connections", tasks.length);
      await Promise.all(tasks);
      this.connections.clear();
      this.log("stopped");
    }
    getMaxConnections() {
      return this.maxConnections;
    }
    onConnect(evt) {
      void this._onConnect(evt).catch((err) => {
        this.log.error(err);
      });
    }
    /**
     * Tracks the incoming connection and check the connection limit
     */
    async _onConnect(evt) {
      const { detail: connection } = evt;
      if (!this.started) {
        await connection.close();
        return;
      }
      if (connection.status !== "open") {
        return;
      }
      const peerId2 = connection.remotePeer;
      const isNewPeer = !this.connections.has(peerId2);
      const storedConns = this.connections.get(peerId2) ?? [];
      storedConns.push(connection);
      this.connections.set(peerId2, storedConns);
      if (peerId2.publicKey != null && peerId2.type === "RSA") {
        await this.peerStore.patch(peerId2, {
          publicKey: peerId2.publicKey
        });
      }
      if (isNewPeer) {
        this.events.safeDispatchEvent("peer:connect", { detail: connection.remotePeer });
      }
    }
    /**
     * Removes the connection from tracking
     */
    onDisconnect(evt) {
      const { detail: connection } = evt;
      const peerId2 = connection.remotePeer;
      const peerConns = this.connections.get(peerId2) ?? [];
      const filteredPeerConns = peerConns.filter((conn) => conn.id !== connection.id);
      this.connections.set(peerId2, filteredPeerConns);
      if (filteredPeerConns.length === 0) {
        this.log("onDisconnect remove all connections for peer %p", peerId2);
        this.connections.delete(peerId2);
        this.events.safeDispatchEvent("peer:disconnect", { detail: connection.remotePeer });
      }
    }
    getConnections(peerId2) {
      if (peerId2 != null) {
        return this.connections.get(peerId2) ?? [];
      }
      let conns = [];
      for (const c of this.connections.values()) {
        conns = conns.concat(c);
      }
      return conns;
    }
    getConnectionsMap() {
      return this.connections;
    }
    async openConnection(peerIdOrMultiaddr, options = {}) {
      var _a2, _b2;
      if (!this.started) {
        throw new NotStartedError("Not started");
      }
      this.outboundPendingConnections++;
      try {
        (_a2 = options.signal) == null ? void 0 : _a2.throwIfAborted();
        const { peerId: peerId2 } = getPeerAddress(peerIdOrMultiaddr);
        if (this.peerId.equals(peerId2)) {
          throw new InvalidPeerIdError("Can not dial self");
        }
        if (peerId2 != null && options.force !== true) {
          this.log("dial %p", peerId2);
          const existingConnection = this.getConnections(peerId2).find((conn) => conn.limits == null);
          if (existingConnection != null) {
            this.log("had an existing non-limited connection to %p", peerId2);
            (_b2 = options.onProgress) == null ? void 0 : _b2.call(options, new CustomProgressEvent("dial-queue:already-connected"));
            return existingConnection;
          }
        }
        const connection = await this.dialQueue.dial(peerIdOrMultiaddr, {
          ...options,
          priority: options.priority ?? DEFAULT_DIAL_PRIORITY
        });
        if (connection.status !== "open") {
          throw new ConnectionClosedError("Remote closed connection during opening");
        }
        let peerConnections = this.connections.get(connection.remotePeer);
        if (peerConnections == null) {
          peerConnections = [];
          this.connections.set(connection.remotePeer, peerConnections);
        }
        let trackedConnection = false;
        for (const conn of peerConnections) {
          if (conn.id === connection.id) {
            trackedConnection = true;
          }
          if (options.force !== true && conn.id !== connection.id && conn.remoteAddr.equals(connection.remoteAddr)) {
            connection.abort(new InvalidMultiaddrError("Duplicate multiaddr connection"));
            return conn;
          }
        }
        if (!trackedConnection) {
          peerConnections.push(connection);
        }
        return connection;
      } finally {
        this.outboundPendingConnections--;
      }
    }
    async closeConnections(peerId2, options = {}) {
      const connections = this.connections.get(peerId2) ?? [];
      await Promise.all(connections.map(async (connection) => {
        try {
          await connection.close(options);
        } catch (err) {
          connection.abort(err);
        }
      }));
    }
    async acceptIncomingConnection(maConn) {
      const denyConnection = this.deny.some((ma) => {
        return ma.contains(maConn.remoteAddr.nodeAddress().address);
      });
      if (denyConnection) {
        this.log("connection from %a refused - connection remote address was in deny list", maConn.remoteAddr);
        return false;
      }
      const allowConnection = this.allow.some((ipNet) => {
        return ipNet.contains(maConn.remoteAddr.nodeAddress().address);
      });
      if (allowConnection) {
        this.incomingPendingConnections++;
        return true;
      }
      if (this.incomingPendingConnections === this.maxIncomingPendingConnections) {
        this.log("connection from %a refused - incomingPendingConnections exceeded by host", maConn.remoteAddr);
        return false;
      }
      if (maConn.remoteAddr.isThinWaistAddress()) {
        const host = maConn.remoteAddr.nodeAddress().address;
        try {
          await this.inboundConnectionRateLimiter.consume(host, 1);
        } catch {
          this.log("connection from %a refused - inboundConnectionThreshold exceeded by host %s", maConn.remoteAddr, host);
          return false;
        }
      }
      if (this.getConnections().length < this.maxConnections) {
        this.incomingPendingConnections++;
        return true;
      }
      this.log("connection from %a refused - maxConnections exceeded", maConn.remoteAddr);
      return false;
    }
    afterUpgradeInbound() {
      this.incomingPendingConnections--;
    }
    getDialQueue() {
      const statusMap = {
        queued: "queued",
        running: "active",
        errored: "error",
        complete: "success"
      };
      return this.dialQueue.queue.queue.map((job) => {
        return {
          id: job.id,
          status: statusMap[job.status],
          peerId: job.options.peerId,
          multiaddrs: [...job.options.multiaddrs].map((ma) => multiaddr(ma))
        };
      });
    }
    async isDialable(multiaddr2, options = {}) {
      return this.dialQueue.isDialable(multiaddr2, options);
    }
  };

  // node_modules/libp2p/dist/src/connection-monitor.js
  var import_browser_shims246 = __toESM(require_browser_shims(), 1);

  // node_modules/@libp2p/utils/dist/src/adaptive-timeout.js
  var import_browser_shims242 = __toESM(require_browser_shims(), 1);

  // node_modules/@libp2p/utils/dist/src/moving-average.js
  var import_browser_shims241 = __toESM(require_browser_shims(), 1);
  var MovingAverage = class {
    movingAverage;
    variance;
    deviation;
    forecast;
    timeSpan;
    previousTime;
    constructor(timeSpan) {
      this.timeSpan = timeSpan;
      this.movingAverage = 0;
      this.variance = 0;
      this.deviation = 0;
      this.forecast = 0;
    }
    alpha(t, pt) {
      return 1 - Math.exp(-(t - pt) / this.timeSpan);
    }
    push(value, time = Date.now()) {
      if (this.previousTime != null) {
        const a = this.alpha(time, this.previousTime);
        const diff = value - this.movingAverage;
        const incr = a * diff;
        this.movingAverage = a * value + (1 - a) * this.movingAverage;
        this.variance = (1 - a) * (this.variance + diff * incr);
        this.deviation = Math.sqrt(this.variance);
        this.forecast = this.movingAverage + a * diff;
      } else {
        this.movingAverage = value;
      }
      this.previousTime = time;
    }
  };

  // node_modules/@libp2p/utils/dist/src/adaptive-timeout.js
  var DEFAULT_TIMEOUT_MULTIPLIER = 1.2;
  var DEFAULT_FAILURE_MULTIPLIER = 2;
  var DEFAULT_MIN_TIMEOUT = 5e3;
  var DEFAULT_MAX_TIMEOUT = 6e4;
  var DEFAULT_INTERVAL = 5e3;
  var AdaptiveTimeout = class {
    success;
    failure;
    next;
    metric;
    timeoutMultiplier;
    failureMultiplier;
    minTimeout;
    maxTimeout;
    constructor(init = {}) {
      var _a2;
      const interval = init.interval ?? DEFAULT_INTERVAL;
      this.success = new MovingAverage(interval);
      this.failure = new MovingAverage(interval);
      this.next = new MovingAverage(interval);
      this.failureMultiplier = init.failureMultiplier ?? DEFAULT_FAILURE_MULTIPLIER;
      this.timeoutMultiplier = init.timeoutMultiplier ?? DEFAULT_TIMEOUT_MULTIPLIER;
      this.minTimeout = init.minTimeout ?? DEFAULT_MIN_TIMEOUT;
      this.maxTimeout = init.maxTimeout ?? DEFAULT_MAX_TIMEOUT;
      if (init.metricName != null) {
        this.metric = (_a2 = init.metrics) == null ? void 0 : _a2.registerMetricGroup(init.metricName);
      }
    }
    getTimeoutSignal(options = {}) {
      let timeout = Math.round(this.next.movingAverage * (options.timeoutFactor ?? this.timeoutMultiplier));
      if (timeout < this.minTimeout) {
        timeout = this.minTimeout;
      }
      if (timeout > this.maxTimeout) {
        timeout = this.maxTimeout;
      }
      const sendTimeout = AbortSignal.timeout(timeout);
      const timeoutSignal = anySignal([options.signal, sendTimeout]);
      setMaxListeners(Infinity, timeoutSignal, sendTimeout);
      timeoutSignal.start = Date.now();
      timeoutSignal.timeout = timeout;
      return timeoutSignal;
    }
    cleanUp(signal) {
      var _a2, _b2;
      const time = Date.now() - signal.start;
      if (signal.aborted) {
        this.failure.push(time);
        this.next.push(time * this.failureMultiplier);
        (_a2 = this.metric) == null ? void 0 : _a2.update({
          failureMovingAverage: this.failure.movingAverage,
          failureDeviation: this.failure.deviation,
          failureForecast: this.failure.forecast,
          failureVariance: this.failure.variance,
          failure: time
        });
      } else {
        this.success.push(time);
        this.next.push(time);
        (_b2 = this.metric) == null ? void 0 : _b2.update({
          successMovingAverage: this.success.movingAverage,
          successDeviation: this.success.deviation,
          successForecast: this.success.forecast,
          successVariance: this.success.variance,
          success: time
        });
      }
    }
  };

  // node_modules/it-byte-stream/dist/src/index.js
  var import_browser_shims245 = __toESM(require_browser_shims(), 1);

  // node_modules/it-queueless-pushable/dist/src/index.js
  var import_browser_shims243 = __toESM(require_browser_shims(), 1);
  var QueuelessPushable = class {
    readNext;
    haveNext;
    ended;
    nextResult;
    error;
    constructor() {
      this.ended = false;
      this.readNext = pDefer();
      this.haveNext = pDefer();
    }
    [Symbol.asyncIterator]() {
      return this;
    }
    async next() {
      if (this.nextResult == null) {
        await this.haveNext.promise;
      }
      if (this.nextResult == null) {
        throw new Error("HaveNext promise resolved but nextResult was undefined");
      }
      const nextResult = this.nextResult;
      this.nextResult = void 0;
      this.readNext.resolve();
      this.readNext = pDefer();
      return nextResult;
    }
    async throw(err) {
      this.ended = true;
      this.error = err;
      if (err != null) {
        this.haveNext.promise.catch(() => {
        });
        this.haveNext.reject(err);
      }
      const result = {
        done: true,
        value: void 0
      };
      return result;
    }
    async return() {
      const result = {
        done: true,
        value: void 0
      };
      this.ended = true;
      this.nextResult = result;
      this.haveNext.resolve();
      return result;
    }
    async push(value, options) {
      await this._push(value, options);
    }
    async end(err, options) {
      if (err != null) {
        await this.throw(err);
      } else {
        await this._push(void 0, options);
      }
    }
    async _push(value, options) {
      if (value != null && this.ended) {
        throw this.error ?? new Error("Cannot push value onto an ended pushable");
      }
      while (this.nextResult != null) {
        await this.readNext.promise;
      }
      if (value != null) {
        this.nextResult = { done: false, value };
      } else {
        this.ended = true;
        this.nextResult = { done: true, value: void 0 };
      }
      this.haveNext.resolve();
      this.haveNext = pDefer();
      await raceSignal(this.readNext.promise, options == null ? void 0 : options.signal, options);
    }
  };
  function queuelessPushable() {
    return new QueuelessPushable();
  }

  // node_modules/it-byte-stream/dist/src/errors.js
  var import_browser_shims244 = __toESM(require_browser_shims(), 1);
  var UnexpectedEOFError = class extends Error {
    name = "UnexpectedEOFError";
    code = "ERR_UNEXPECTED_EOF";
  };

  // node_modules/it-byte-stream/dist/src/index.js
  function byteStream(duplex, opts) {
    const write3 = queuelessPushable();
    duplex.sink(write3).catch(async (err) => {
      await write3.end(err);
    });
    duplex.sink = async (source2) => {
      for await (const buf of source2) {
        await write3.push(buf);
      }
      await write3.end();
    };
    let source = duplex.source;
    if (duplex.source[Symbol.iterator] != null) {
      source = duplex.source[Symbol.iterator]();
    } else if (duplex.source[Symbol.asyncIterator] != null) {
      source = duplex.source[Symbol.asyncIterator]();
    }
    const readBuffer = new Uint8ArrayList();
    const W = {
      read: async (options) => {
        var _a2;
        (_a2 = options == null ? void 0 : options.signal) == null ? void 0 : _a2.throwIfAborted();
        if ((options == null ? void 0 : options.bytes) == null) {
          const { done, value } = await raceSignal(source.next(), options == null ? void 0 : options.signal);
          if (done === true) {
            return null;
          }
          return value;
        }
        while (readBuffer.byteLength < options.bytes) {
          const { value, done } = await raceSignal(source.next(), options == null ? void 0 : options.signal);
          if (done === true) {
            throw new UnexpectedEOFError("unexpected end of input");
          }
          readBuffer.append(value);
        }
        const buf = readBuffer.sublist(0, options.bytes);
        readBuffer.consume(options.bytes);
        return buf;
      },
      write: async (data, options) => {
        var _a2;
        (_a2 = options == null ? void 0 : options.signal) == null ? void 0 : _a2.throwIfAborted();
        if (data instanceof Uint8Array) {
          await write3.push(data, options);
        } else {
          await write3.push(data.subarray(), options);
        }
      },
      unwrap: () => {
        if (readBuffer.byteLength > 0) {
          const originalStream = duplex.source;
          duplex.source = async function* () {
            if ((opts == null ? void 0 : opts.yieldBytes) === false) {
              yield readBuffer;
            } else {
              yield* readBuffer;
            }
            yield* originalStream;
          }();
        }
        return duplex;
      }
    };
    return W;
  }

  // node_modules/libp2p/dist/src/connection-monitor.js
  var DEFAULT_PING_INTERVAL_MS = 1e4;
  var PROTOCOL_VERSION = "1.0.0";
  var PROTOCOL_NAME = "ping";
  var PROTOCOL_PREFIX = "ipfs";
  var PING_LENGTH = 32;
  var DEFAULT_ABORT_CONNECTION_ON_PING_FAILURE = true;
  var ConnectionMonitor = class {
    protocol;
    components;
    log;
    heartbeatInterval;
    pingIntervalMs;
    abortController;
    timeout;
    abortConnectionOnPingFailure;
    constructor(components, init = {}) {
      this.components = components;
      this.protocol = `/${init.protocolPrefix ?? PROTOCOL_PREFIX}/${PROTOCOL_NAME}/${PROTOCOL_VERSION}`;
      this.log = components.logger.forComponent("libp2p:connection-monitor");
      this.pingIntervalMs = init.pingInterval ?? DEFAULT_PING_INTERVAL_MS;
      this.abortConnectionOnPingFailure = init.abortConnectionOnPingFailure ?? DEFAULT_ABORT_CONNECTION_ON_PING_FAILURE;
      this.timeout = new AdaptiveTimeout({
        ...init.pingTimeout ?? {},
        metrics: components.metrics,
        metricName: "libp2p_connection_monitor_ping_time_milliseconds"
      });
    }
    [Symbol.toStringTag] = "@libp2p/connection-monitor";
    [serviceCapabilities] = [
      "@libp2p/connection-monitor"
    ];
    start() {
      this.abortController = new AbortController();
      setMaxListeners(Infinity, this.abortController.signal);
      this.heartbeatInterval = setInterval(() => {
        this.components.connectionManager.getConnections().forEach((conn) => {
          Promise.resolve().then(async () => {
            var _a2;
            let start2 = Date.now();
            try {
              const signal = this.timeout.getTimeoutSignal({
                signal: (_a2 = this.abortController) == null ? void 0 : _a2.signal
              });
              const stream = await conn.newStream(this.protocol, {
                signal,
                runOnLimitedConnection: true
              });
              const bs = byteStream(stream);
              start2 = Date.now();
              await Promise.all([
                bs.write(randomBytes2(PING_LENGTH), {
                  signal
                }),
                bs.read({
                  bytes: PING_LENGTH,
                  signal
                })
              ]);
              conn.rtt = Date.now() - start2;
              await bs.unwrap().close({
                signal
              });
            } catch (err) {
              if (err.name !== "UnsupportedProtocolError") {
                throw err;
              }
              conn.rtt = (Date.now() - start2) / 2;
            }
          }).catch((err) => {
            this.log.error("error during heartbeat", err);
            if (this.abortConnectionOnPingFailure) {
              this.log.error("aborting connection due to ping failure");
              conn.abort(err);
            } else {
              this.log("connection ping failed, but not aborting due to abortConnectionOnPingFailure flag");
            }
          });
        });
      }, this.pingIntervalMs);
    }
    stop() {
      var _a2;
      (_a2 = this.abortController) == null ? void 0 : _a2.abort();
      if (this.heartbeatInterval != null) {
        clearInterval(this.heartbeatInterval);
      }
    }
  };

  // node_modules/libp2p/dist/src/content-routing.js
  var import_browser_shims248 = __toESM(require_browser_shims(), 1);

  // node_modules/it-merge/dist/src/index.js
  var import_browser_shims247 = __toESM(require_browser_shims(), 1);
  function isAsyncIterable6(thing) {
    return thing[Symbol.asyncIterator] != null;
  }
  async function addAllToPushable(sources, output, signal) {
    try {
      await Promise.all(sources.map(async (source) => {
        for await (const item of source) {
          await output.push(item, {
            signal
          });
          signal.throwIfAborted();
        }
      }));
      await output.end(void 0, {
        signal
      });
    } catch (err) {
      await output.end(err, {
        signal
      }).catch(() => {
      });
    }
  }
  async function* mergeSources(sources) {
    const controller = new AbortController();
    const output = queuelessPushable();
    addAllToPushable(sources, output, controller.signal).catch(() => {
    });
    try {
      yield* output;
    } finally {
      controller.abort();
    }
  }
  function* mergeSyncSources(syncSources) {
    for (const source of syncSources) {
      yield* source;
    }
  }
  function merge2(...sources) {
    const syncSources = [];
    for (const source of sources) {
      if (!isAsyncIterable6(source)) {
        syncSources.push(source);
      }
    }
    if (syncSources.length === sources.length) {
      return mergeSyncSources(syncSources);
    }
    return mergeSources(sources);
  }
  var src_default8 = merge2;

  // node_modules/libp2p/dist/src/content-routing.js
  var CompoundContentRouting = class {
    routers;
    started;
    components;
    constructor(components, init) {
      var _a2, _b2, _c, _d, _e;
      this.routers = init.routers ?? [];
      this.started = false;
      this.components = components;
      this.findProviders = ((_a2 = components.metrics) == null ? void 0 : _a2.traceFunction("libp2p.contentRouting.findProviders", this.findProviders.bind(this), {
        optionsIndex: 1,
        getAttributesFromArgs: ([cid], attrs) => {
          return {
            ...attrs,
            cid: cid.toString()
          };
        },
        getAttributesFromYieldedValue: (value, attrs) => {
          return {
            ...attrs,
            providers: [...Array.isArray(attrs.providers) ? attrs.providers : [], value.id.toString()]
          };
        }
      })) ?? this.findProviders;
      this.provide = ((_b2 = components.metrics) == null ? void 0 : _b2.traceFunction("libp2p.contentRouting.provide", this.provide.bind(this), {
        optionsIndex: 1,
        getAttributesFromArgs: ([cid], attrs) => {
          return {
            ...attrs,
            cid: cid.toString()
          };
        }
      })) ?? this.provide;
      this.cancelReprovide = ((_c = components.metrics) == null ? void 0 : _c.traceFunction("libp2p.contentRouting.cancelReprovide", this.cancelReprovide.bind(this), {
        optionsIndex: 1,
        getAttributesFromArgs: ([cid], attrs) => {
          return {
            ...attrs,
            cid: cid.toString()
          };
        }
      })) ?? this.cancelReprovide;
      this.put = ((_d = components.metrics) == null ? void 0 : _d.traceFunction("libp2p.contentRouting.put", this.put.bind(this), {
        optionsIndex: 2,
        getAttributesFromArgs: ([key]) => {
          return {
            key: toString2(key, "base36")
          };
        }
      })) ?? this.put;
      this.get = ((_e = components.metrics) == null ? void 0 : _e.traceFunction("libp2p.contentRouting.get", this.get.bind(this), {
        optionsIndex: 1,
        getAttributesFromArgs: ([key]) => {
          return {
            key: toString2(key, "base36")
          };
        }
      })) ?? this.get;
    }
    [Symbol.toStringTag] = "@libp2p/content-routing";
    isStarted() {
      return this.started;
    }
    async start() {
      this.started = true;
    }
    async stop() {
      this.started = false;
    }
    /**
     * Iterates over all content routers in parallel to find providers of the given key
     */
    async *findProviders(key, options = {}) {
      if (this.routers.length === 0) {
        throw new NoContentRoutersError("No content routers available");
      }
      const self = this;
      const seen = new PeerSet();
      for await (const peer of src_default8(...self.routers.filter((router) => router.findProviders instanceof Function).map((router) => router.findProviders(key, options)))) {
        if (peer == null) {
          continue;
        }
        if (peer.multiaddrs.length > 0) {
          await this.components.peerStore.merge(peer.id, {
            multiaddrs: peer.multiaddrs
          }, options);
        }
        if (seen.has(peer.id)) {
          continue;
        }
        seen.add(peer.id);
        yield peer;
      }
    }
    /**
     * Iterates over all content routers in parallel to notify it is
     * a provider of the given key
     */
    async provide(key, options = {}) {
      if (this.routers.length === 0) {
        throw new NoContentRoutersError("No content routers available");
      }
      await Promise.all(this.routers.filter((router) => router.provide instanceof Function).map(async (router) => {
        await router.provide(key, options);
      }));
    }
    async cancelReprovide(key, options = {}) {
      if (this.routers.length === 0) {
        throw new NoContentRoutersError("No content routers available");
      }
      await Promise.all(this.routers.filter((router) => router.cancelReprovide instanceof Function).map(async (router) => {
        await router.cancelReprovide(key, options);
      }));
    }
    /**
     * Store the given key/value pair in the available content routings
     */
    async put(key, value, options) {
      if (!this.isStarted()) {
        throw new NotStartedError();
      }
      await Promise.all(this.routers.filter((router) => router.put instanceof Function).map(async (router) => {
        await router.put(key, value, options);
      }));
    }
    /**
     * Get the value to the given key.
     * Times out after 1 minute by default.
     */
    async get(key, options) {
      if (!this.isStarted()) {
        throw new NotStartedError();
      }
      return Promise.any(this.routers.filter((router) => router.get instanceof Function).map(async (router) => {
        return router.get(key, options);
      }));
    }
  };

  // node_modules/libp2p/dist/src/peer-routing.js
  var import_browser_shims250 = __toESM(require_browser_shims(), 1);

  // node_modules/it-parallel/dist/src/index.js
  var import_browser_shims249 = __toESM(require_browser_shims(), 1);
  var CustomEvent2 = globalThis.CustomEvent ?? Event;
  async function* parallel(source, options = {}) {
    let concurrency = options.concurrency ?? Infinity;
    if (concurrency < 1) {
      concurrency = Infinity;
    }
    const ordered = options.ordered ?? false;
    const emitter = new EventTarget();
    const ops = [];
    let slotAvailable = pDefer();
    let resultAvailable = pDefer();
    let sourceFinished = false;
    let sourceErr;
    let opErred = false;
    emitter.addEventListener("task-complete", () => {
      resultAvailable.resolve();
    });
    void Promise.resolve().then(async () => {
      try {
        for await (const task of source) {
          if (ops.length === concurrency) {
            slotAvailable = pDefer();
            await slotAvailable.promise;
          }
          if (opErred) {
            break;
          }
          const op = {
            done: false
          };
          ops.push(op);
          task().then((result) => {
            op.done = true;
            op.ok = true;
            op.value = result;
            emitter.dispatchEvent(new CustomEvent2("task-complete"));
          }, (err) => {
            op.done = true;
            op.err = err;
            emitter.dispatchEvent(new CustomEvent2("task-complete"));
          });
        }
        sourceFinished = true;
        emitter.dispatchEvent(new CustomEvent2("task-complete"));
      } catch (err) {
        sourceErr = err;
        emitter.dispatchEvent(new CustomEvent2("task-complete"));
      }
    });
    function valuesAvailable() {
      var _a2;
      if (ordered) {
        return (_a2 = ops[0]) == null ? void 0 : _a2.done;
      }
      return Boolean(ops.find((op) => op.done));
    }
    function* yieldOrderedValues() {
      while (ops.length > 0 && ops[0].done) {
        const op = ops[0];
        ops.shift();
        if (op.ok) {
          yield op.value;
        } else {
          opErred = true;
          slotAvailable.resolve();
          throw op.err;
        }
        slotAvailable.resolve();
      }
    }
    function* yieldUnOrderedValues() {
      while (valuesAvailable()) {
        for (let i = 0; i < ops.length; i++) {
          if (ops[i].done) {
            const op = ops[i];
            ops.splice(i, 1);
            i--;
            if (op.ok) {
              yield op.value;
            } else {
              opErred = true;
              slotAvailable.resolve();
              throw op.err;
            }
            slotAvailable.resolve();
          }
        }
      }
    }
    while (true) {
      if (!valuesAvailable()) {
        resultAvailable = pDefer();
        await resultAvailable.promise;
      }
      if (sourceErr != null) {
        throw sourceErr;
      }
      if (ordered) {
        yield* yieldOrderedValues();
      } else {
        yield* yieldUnOrderedValues();
      }
      if (sourceErr != null) {
        throw sourceErr;
      }
      if (sourceFinished && ops.length === 0) {
        break;
      }
    }
  }

  // node_modules/libp2p/dist/src/peer-routing.js
  var DefaultPeerRouting = class {
    log;
    peerId;
    peerStore;
    routers;
    constructor(components, init = {}) {
      var _a2, _b2;
      this.log = components.logger.forComponent("libp2p:peer-routing");
      this.peerId = components.peerId;
      this.peerStore = components.peerStore;
      this.routers = init.routers ?? [];
      this.findPeer = ((_a2 = components.metrics) == null ? void 0 : _a2.traceFunction("libp2p.peerRouting.findPeer", this.findPeer.bind(this), {
        optionsIndex: 1,
        getAttributesFromArgs: ([peer], attrs) => {
          return {
            ...attrs,
            peer: peer.toString()
          };
        }
      })) ?? this.findPeer;
      this.getClosestPeers = ((_b2 = components.metrics) == null ? void 0 : _b2.traceFunction("libp2p.peerRouting.getClosestPeers", this.getClosestPeers.bind(this), {
        optionsIndex: 1,
        getAttributesFromArgs: ([key], attrs) => {
          return {
            ...attrs,
            key: toString2(key, "base36")
          };
        },
        getAttributesFromYieldedValue: (value, attrs) => {
          return {
            ...attrs,
            peers: [...Array.isArray(attrs.peers) ? attrs.peers : [], value.id.toString()]
          };
        }
      })) ?? this.getClosestPeers;
    }
    [Symbol.toStringTag] = "@libp2p/peer-routing";
    /**
     * Iterates over all peer routers in parallel to find the given peer
     */
    async findPeer(id, options) {
      if (this.routers.length === 0) {
        throw new NoPeerRoutersError("No peer routers available");
      }
      if (id.toString() === this.peerId.toString()) {
        throw new QueriedForSelfError("Should not try to find self");
      }
      const self = this;
      const source = src_default8(...this.routers.filter((router) => router.findPeer instanceof Function).map((router) => async function* () {
        try {
          yield await router.findPeer(id, options);
        } catch (err) {
          self.log.error(err);
        }
      }()));
      for await (const peer of source) {
        if (peer == null) {
          continue;
        }
        if (peer.multiaddrs.length > 0) {
          await this.peerStore.merge(peer.id, {
            multiaddrs: peer.multiaddrs
          }, options);
        }
        return peer;
      }
      throw new NotFoundError();
    }
    /**
     * Attempt to find the closest peers on the network to the given key
     */
    async *getClosestPeers(key, options = {}) {
      if (this.routers.length === 0) {
        throw new NoPeerRoutersError("No peer routers available");
      }
      const self = this;
      const seen = createScalableCuckooFilter(1024);
      for await (const peer of parallel(async function* () {
        const source = src_default8(...self.routers.filter((router) => router.getClosestPeers instanceof Function).map((router) => router.getClosestPeers(key, options)));
        for await (let peer2 of source) {
          yield async () => {
            if (peer2.multiaddrs.length === 0) {
              try {
                peer2 = await self.findPeer(peer2.id, {
                  ...options,
                  useCache: false
                });
              } catch (err) {
                self.log.error("could not find peer multiaddrs", err);
                return;
              }
            }
            return peer2;
          };
        }
      }())) {
        if (peer == null) {
          continue;
        }
        if (peer.multiaddrs.length > 0) {
          await this.peerStore.merge(peer.id, {
            multiaddrs: peer.multiaddrs
          }, options);
        }
        if (seen.has(peer.id.toMultihash().bytes)) {
          continue;
        }
        seen.add(peer.id.toMultihash().bytes);
        yield peer;
      }
    }
  };

  // node_modules/libp2p/dist/src/random-walk.js
  var import_browser_shims251 = __toESM(require_browser_shims(), 1);
  var RandomWalk = class extends TypedEventEmitter {
    peerRouting;
    log;
    walking;
    walkers;
    shutdownController;
    walkController;
    needNext;
    constructor(components) {
      super();
      this.log = components.logger.forComponent("libp2p:random-walk");
      this.peerRouting = components.peerRouting;
      this.walkers = 0;
      this.walking = false;
      this.shutdownController = new AbortController();
      setMaxListeners(Infinity, this.shutdownController.signal);
    }
    [Symbol.toStringTag] = "@libp2p/random-walk";
    start() {
      this.shutdownController = new AbortController();
      setMaxListeners(Infinity, this.shutdownController.signal);
    }
    stop() {
      this.shutdownController.abort();
    }
    async *walk(options) {
      var _a2, _b2;
      if (!this.walking) {
        this.startWalk();
      }
      this.walkers++;
      const signal = anySignal([this.shutdownController.signal, options == null ? void 0 : options.signal]);
      setMaxListeners(Infinity, signal);
      try {
        while (true) {
          (_a2 = this.needNext) == null ? void 0 : _a2.resolve();
          this.needNext = pDefer();
          const event = await raceEvent(this, "walk:peer", signal, {
            errorEvent: "walk:error"
          });
          yield event.detail;
        }
      } finally {
        signal.clear();
        this.walkers--;
        if (this.walkers === 0) {
          (_b2 = this.walkController) == null ? void 0 : _b2.abort();
          this.walkController = void 0;
        }
      }
    }
    startWalk() {
      this.walking = true;
      this.walkController = new AbortController();
      setMaxListeners(Infinity, this.walkController.signal);
      const signal = anySignal([this.walkController.signal, this.shutdownController.signal]);
      setMaxListeners(Infinity, signal);
      const start2 = Date.now();
      let found = 0;
      Promise.resolve().then(async () => {
        this.log("start walk");
        while (this.walkers > 0) {
          try {
            const data = randomBytes2(32);
            let s2 = Date.now();
            for await (const peer of this.peerRouting.getClosestPeers(data, { signal })) {
              if (signal.aborted) {
                this.log("aborting walk");
              }
              signal.throwIfAborted();
              this.log("found peer %p after %dms for %d walkers", peer.id, Date.now() - s2, this.walkers);
              found++;
              this.safeDispatchEvent("walk:peer", {
                detail: peer
              });
              if (this.walkers === 1 && this.needNext != null) {
                this.log("wait for need next");
                await raceSignal(this.needNext.promise, signal);
              }
              s2 = Date.now();
            }
            this.log("walk iteration for %b and %d walkers finished, found %d peers", data, this.walkers, found);
          } catch (err) {
            this.log.error("random walk errored", err);
            this.safeDispatchEvent("walk:error", {
              detail: err
            });
          }
        }
        this.log("no walkers left, ended walk");
      }).catch((err) => {
        this.log.error("random walk errored", err);
      }).finally(() => {
        this.log("finished walk, found %d peers after %dms", found, Date.now() - start2);
        this.walking = false;
      });
    }
  };

  // node_modules/libp2p/dist/src/registrar.js
  var import_browser_shims252 = __toESM(require_browser_shims(), 1);
  var DEFAULT_MAX_INBOUND_STREAMS = 32;
  var DEFAULT_MAX_OUTBOUND_STREAMS = 64;
  var Registrar = class {
    log;
    topologies;
    handlers;
    components;
    constructor(components) {
      var _a2;
      this.components = components;
      this.log = components.logger.forComponent("libp2p:registrar");
      this.topologies = /* @__PURE__ */ new Map();
      (_a2 = components.metrics) == null ? void 0 : _a2.registerMetricGroup("libp2p_registrar_topologies", {
        calculate: () => {
          const output = {};
          for (const [key, value] of this.topologies) {
            output[key] = value.size;
          }
          return output;
        }
      });
      this.handlers = trackedMap({
        name: "libp2p_registrar_protocol_handlers",
        metrics: components.metrics
      });
      this._onDisconnect = this._onDisconnect.bind(this);
      this._onPeerUpdate = this._onPeerUpdate.bind(this);
      this._onPeerIdentify = this._onPeerIdentify.bind(this);
      this.components.events.addEventListener("peer:disconnect", this._onDisconnect);
      this.components.events.addEventListener("peer:update", this._onPeerUpdate);
      this.components.events.addEventListener("peer:identify", this._onPeerIdentify);
    }
    [Symbol.toStringTag] = "@libp2p/registrar";
    getProtocols() {
      return Array.from(/* @__PURE__ */ new Set([
        ...this.handlers.keys()
      ])).sort();
    }
    getHandler(protocol) {
      const handler = this.handlers.get(protocol);
      if (handler == null) {
        throw new UnhandledProtocolError(`No handler registered for protocol ${protocol}`);
      }
      return handler;
    }
    getTopologies(protocol) {
      const topologies = this.topologies.get(protocol);
      if (topologies == null) {
        return [];
      }
      return [
        ...topologies.values()
      ];
    }
    /**
     * Registers the `handler` for each protocol
     */
    async handle(protocol, handler, opts) {
      if (this.handlers.has(protocol) && (opts == null ? void 0 : opts.force) !== true) {
        throw new DuplicateProtocolHandlerError(`Handler already registered for protocol ${protocol}`);
      }
      const options = mergeOptions.bind({ ignoreUndefined: true })({
        maxInboundStreams: DEFAULT_MAX_INBOUND_STREAMS,
        maxOutboundStreams: DEFAULT_MAX_OUTBOUND_STREAMS
      }, opts);
      this.handlers.set(protocol, {
        handler,
        options
      });
      await this.components.peerStore.merge(this.components.peerId, {
        protocols: [protocol]
      }, opts);
    }
    /**
     * Removes the handler for each protocol. The protocol
     * will no longer be supported on streams.
     */
    async unhandle(protocols, options) {
      const protocolList = Array.isArray(protocols) ? protocols : [protocols];
      protocolList.forEach((protocol) => {
        this.handlers.delete(protocol);
      });
      await this.components.peerStore.patch(this.components.peerId, {
        protocols: this.getProtocols()
      }, options);
    }
    /**
     * Register handlers for a set of multicodecs given
     */
    async register(protocol, topology) {
      if (topology == null) {
        throw new InvalidParametersError("invalid topology");
      }
      const id = `${(Math.random() * 1e9).toString(36)}${Date.now()}`;
      let topologies = this.topologies.get(protocol);
      if (topologies == null) {
        topologies = /* @__PURE__ */ new Map();
        this.topologies.set(protocol, topologies);
      }
      topologies.set(id, topology);
      return id;
    }
    /**
     * Unregister topology
     */
    unregister(id) {
      for (const [protocol, topologies] of this.topologies.entries()) {
        if (topologies.has(id)) {
          topologies.delete(id);
          if (topologies.size === 0) {
            this.topologies.delete(protocol);
          }
        }
      }
    }
    /**
     * Remove a disconnected peer from the record
     */
    _onDisconnect(evt) {
      const remotePeer = evt.detail;
      const options = {
        signal: AbortSignal.timeout(5e3)
      };
      void this.components.peerStore.get(remotePeer, options).then((peer) => {
        var _a2, _b2, _c;
        for (const protocol of peer.protocols) {
          const topologies = this.topologies.get(protocol);
          if (topologies == null) {
            continue;
          }
          for (const topology of topologies.values()) {
            if (((_a2 = topology.filter) == null ? void 0 : _a2.has(remotePeer)) === false) {
              continue;
            }
            (_b2 = topology.filter) == null ? void 0 : _b2.remove(remotePeer);
            (_c = topology.onDisconnect) == null ? void 0 : _c.call(topology, remotePeer);
          }
        }
      }).catch((err) => {
        if (err.name === "NotFoundError") {
          return;
        }
        this.log.error("could not inform topologies of disconnecting peer %p", remotePeer, err);
      });
    }
    /**
     * When a peer is updated, if they have removed supported protocols notify any
     * topologies interested in the removed protocols.
     */
    _onPeerUpdate(evt) {
      var _a2, _b2, _c;
      const { peer, previous } = evt.detail;
      const removed = ((previous == null ? void 0 : previous.protocols) ?? []).filter((protocol) => !peer.protocols.includes(protocol));
      for (const protocol of removed) {
        const topologies = this.topologies.get(protocol);
        if (topologies == null) {
          continue;
        }
        for (const topology of topologies.values()) {
          if (((_a2 = topology.filter) == null ? void 0 : _a2.has(peer.id)) === false) {
            continue;
          }
          (_b2 = topology.filter) == null ? void 0 : _b2.remove(peer.id);
          (_c = topology.onDisconnect) == null ? void 0 : _c.call(topology, peer.id);
        }
      }
    }
    /**
     * After identify has completed and we have received the list of supported
     * protocols, notify any topologies interested in those protocols.
     */
    _onPeerIdentify(evt) {
      var _a2, _b2, _c;
      const protocols = evt.detail.protocols;
      const connection = evt.detail.connection;
      const peerId2 = evt.detail.peerId;
      for (const protocol of protocols) {
        const topologies = this.topologies.get(protocol);
        if (topologies == null) {
          continue;
        }
        for (const topology of topologies.values()) {
          if (connection.limits != null && topology.notifyOnLimitedConnection !== true) {
            continue;
          }
          if (((_a2 = topology.filter) == null ? void 0 : _a2.has(peerId2)) === true) {
            continue;
          }
          (_b2 = topology.filter) == null ? void 0 : _b2.add(peerId2);
          (_c = topology.onConnect) == null ? void 0 : _c.call(topology, peerId2, connection);
        }
      }
    }
  };

  // node_modules/libp2p/dist/src/transport-manager.js
  var import_browser_shims253 = __toESM(require_browser_shims(), 1);
  var DefaultTransportManager = class {
    log;
    components;
    transports;
    listeners;
    faultTolerance;
    started;
    constructor(components, init = {}) {
      this.log = components.logger.forComponent("libp2p:transports");
      this.components = components;
      this.started = false;
      this.transports = trackedMap({
        name: "libp2p_transport_manager_transports",
        metrics: this.components.metrics
      });
      this.listeners = trackedMap({
        name: "libp2p_transport_manager_listeners",
        metrics: this.components.metrics
      });
      this.faultTolerance = init.faultTolerance ?? FaultTolerance.FATAL_ALL;
    }
    [Symbol.toStringTag] = "@libp2p/transport-manager";
    /**
     * Adds a `Transport` to the manager
     */
    add(transport) {
      const tag = transport[Symbol.toStringTag];
      if (tag == null) {
        throw new InvalidParametersError("Transport must have a valid tag");
      }
      if (this.transports.has(tag)) {
        throw new InvalidParametersError(`There is already a transport with the tag ${tag}`);
      }
      this.log("adding transport %s", tag);
      this.transports.set(tag, transport);
      if (!this.listeners.has(tag)) {
        this.listeners.set(tag, []);
      }
    }
    isStarted() {
      return this.started;
    }
    start() {
      this.started = true;
    }
    async afterStart() {
      const addrs = this.components.addressManager.getListenAddrs();
      await this.listen(addrs);
    }
    /**
     * Stops all listeners
     */
    async stop() {
      const tasks = [];
      for (const [key, listeners] of this.listeners) {
        this.log("closing listeners for %s", key);
        while (listeners.length > 0) {
          const listener = listeners.pop();
          if (listener == null) {
            continue;
          }
          tasks.push(listener.close());
        }
      }
      await Promise.all(tasks);
      this.log("all listeners closed");
      for (const key of this.listeners.keys()) {
        this.listeners.set(key, []);
      }
      this.started = false;
    }
    /**
     * Dials the given Multiaddr over it's supported transport
     */
    async dial(ma, options) {
      var _a2;
      const transport = this.dialTransportForMultiaddr(ma);
      if (transport == null) {
        throw new TransportUnavailableError(`No transport available for address ${String(ma)}`);
      }
      (_a2 = options == null ? void 0 : options.onProgress) == null ? void 0 : _a2.call(options, new CustomProgressEvent("transport-manager:selected-transport", transport[Symbol.toStringTag]));
      return transport.dial(ma, {
        ...options,
        upgrader: this.components.upgrader
      });
    }
    /**
     * Returns all Multiaddr's the listeners are using
     */
    getAddrs() {
      let addrs = [];
      for (const listeners of this.listeners.values()) {
        for (const listener of listeners) {
          addrs = [...addrs, ...listener.getAddrs()];
        }
      }
      return addrs;
    }
    /**
     * Returns all the transports instances
     */
    getTransports() {
      return Array.of(...this.transports.values());
    }
    /**
     * Returns all the listener instances
     */
    getListeners() {
      return Array.of(...this.listeners.values()).flat();
    }
    /**
     * Finds a transport that matches the given Multiaddr
     */
    dialTransportForMultiaddr(ma) {
      for (const transport of this.transports.values()) {
        const addrs = transport.dialFilter([ma]);
        if (addrs.length > 0) {
          return transport;
        }
      }
    }
    /**
     * Finds a transport that matches the given Multiaddr
     */
    listenTransportForMultiaddr(ma) {
      for (const transport of this.transports.values()) {
        const addrs = transport.listenFilter([ma]);
        if (addrs.length > 0) {
          return transport;
        }
      }
    }
    /**
     * Starts listeners for each listen Multiaddr
     */
    async listen(addrs) {
      if (!this.isStarted()) {
        throw new NotStartedError("Not started");
      }
      if (addrs == null || addrs.length === 0) {
        this.log("no addresses were provided for listening, this node is dial only");
        return;
      }
      const listenStats = {
        errors: /* @__PURE__ */ new Map(),
        ipv4: {
          success: 0,
          attempts: 0
        },
        ipv6: {
          success: 0,
          attempts: 0
        }
      };
      addrs.forEach((ma) => {
        listenStats.errors.set(ma.toString(), new UnsupportedListenAddressError());
      });
      const tasks = [];
      for (const [key, transport] of this.transports.entries()) {
        const supportedAddrs = transport.listenFilter(addrs);
        for (const addr of supportedAddrs) {
          this.log("creating listener for %s on %a", key, addr);
          const listener = transport.createListener({
            upgrader: this.components.upgrader
          });
          let listeners = this.listeners.get(key) ?? [];
          if (listeners == null) {
            listeners = [];
            this.listeners.set(key, listeners);
          }
          listeners.push(listener);
          listener.addEventListener("listening", () => {
            this.components.events.safeDispatchEvent("transport:listening", {
              detail: listener
            });
          });
          listener.addEventListener("close", () => {
            const index = listeners.findIndex((l) => l === listener);
            listeners.splice(index, 1);
            this.components.events.safeDispatchEvent("transport:close", {
              detail: listener
            });
          });
          if (IP4.matches(addr)) {
            listenStats.ipv4.attempts++;
          } else if (IP6.matches(addr)) {
            listenStats.ipv6.attempts++;
          }
          tasks.push(listener.listen(addr).then(() => {
            listenStats.errors.delete(addr.toString());
            if (IP4.matches(addr)) {
              listenStats.ipv4.success++;
            }
            if (IP6.matches(addr)) {
              listenStats.ipv6.success++;
            }
          }, (err) => {
            this.log.error("transport %s could not listen on address %a - %e", key, addr, err);
            listenStats.errors.set(addr.toString(), err);
            throw err;
          }));
        }
      }
      const results = await Promise.allSettled(tasks);
      if (results.length > 0 && results.every((res) => res.status === "fulfilled")) {
        return;
      }
      if (this.ipv6Unsupported(listenStats)) {
        this.log("all IPv4 addresses succeed but all IPv6 failed");
        return;
      }
      if (this.faultTolerance === FaultTolerance.NO_FATAL) {
        this.log("failed to listen on any address but fault tolerance allows this");
        return;
      }
      throw new UnsupportedListenAddressesError(`Some configured addresses failed to be listened on, you may need to remove one or more listen addresses from your configuration or set \`transportManager.faultTolerance\` to NO_FATAL:
${[...listenStats.errors.entries()].map(([addr, err]) => {
        return `
  ${addr}: ${`${err.stack ?? err}`.split("\n").join("\n  ")}
`;
      }).join("")}`);
    }
    ipv6Unsupported(listenStats) {
      if (listenStats.ipv4.attempts === 0 || listenStats.ipv6.attempts === 0) {
        return false;
      }
      const allIpv4Succeeded = listenStats.ipv4.attempts === listenStats.ipv4.success;
      const allIpv6Failed = listenStats.ipv6.success === 0;
      return allIpv4Succeeded && allIpv6Failed;
    }
    /**
     * Removes the given transport from the manager.
     * If a transport has any running listeners, they will be closed.
     */
    async remove(key) {
      const listeners = this.listeners.get(key) ?? [];
      this.log.trace("removing transport %s", key);
      const tasks = [];
      this.log.trace("closing listeners for %s", key);
      while (listeners.length > 0) {
        const listener = listeners.pop();
        if (listener == null) {
          continue;
        }
        tasks.push(listener.close());
      }
      await Promise.all(tasks);
      this.transports.delete(key);
      this.listeners.delete(key);
    }
    /**
     * Removes all transports from the manager.
     * If any listeners are running, they will be closed.
     *
     * @async
     */
    async removeAll() {
      const tasks = [];
      for (const key of this.transports.keys()) {
        tasks.push(this.remove(key));
      }
      await Promise.all(tasks);
    }
  };

  // node_modules/libp2p/dist/src/upgrader.js
  var import_browser_shims268 = __toESM(require_browser_shims(), 1);

  // node_modules/@libp2p/multistream-select/dist/src/index.js
  var import_browser_shims266 = __toESM(require_browser_shims(), 1);

  // node_modules/@libp2p/multistream-select/dist/src/constants.js
  var import_browser_shims254 = __toESM(require_browser_shims(), 1);
  var PROTOCOL_ID = "/multistream/1.0.0";
  var MAX_PROTOCOL_LENGTH = 1024;

  // node_modules/@libp2p/multistream-select/dist/src/select.js
  var import_browser_shims258 = __toESM(require_browser_shims(), 1);

  // node_modules/it-length-prefixed-stream/dist/src/index.js
  var import_browser_shims256 = __toESM(require_browser_shims(), 1);

  // node_modules/it-length-prefixed-stream/dist/src/errors.js
  var import_browser_shims255 = __toESM(require_browser_shims(), 1);
  var InvalidMessageLengthError = class extends Error {
    name = "InvalidMessageLengthError";
    code = "ERR_INVALID_MSG_LENGTH";
  };
  var InvalidDataLengthError = class extends Error {
    name = "InvalidDataLengthError";
    code = "ERR_MSG_DATA_TOO_LONG";
  };
  var InvalidDataLengthLengthError = class extends Error {
    name = "InvalidDataLengthLengthError";
    code = "ERR_MSG_LENGTH_TOO_LONG";
  };

  // node_modules/it-length-prefixed-stream/dist/src/index.js
  function lpStream(duplex, opts = {}) {
    const bytes = byteStream(duplex, opts);
    if (opts.maxDataLength != null && opts.maxLengthLength == null) {
      opts.maxLengthLength = encodingLength2(opts.maxDataLength);
    }
    const decodeLength = (opts == null ? void 0 : opts.lengthDecoder) ?? decode6;
    const encodeLength2 = (opts == null ? void 0 : opts.lengthEncoder) ?? encode5;
    const W = {
      read: async (options) => {
        let dataLength = -1;
        const lengthBuffer = new Uint8ArrayList();
        while (true) {
          lengthBuffer.append(await bytes.read({
            ...options,
            bytes: 1
          }));
          try {
            dataLength = decodeLength(lengthBuffer);
          } catch (err) {
            if (err instanceof RangeError) {
              continue;
            }
            throw err;
          }
          if (dataLength < 0) {
            throw new InvalidMessageLengthError("Invalid message length");
          }
          if ((opts == null ? void 0 : opts.maxLengthLength) != null && lengthBuffer.byteLength > opts.maxLengthLength) {
            throw new InvalidDataLengthLengthError("message length length too long");
          }
          if (dataLength > -1) {
            break;
          }
        }
        if ((opts == null ? void 0 : opts.maxDataLength) != null && dataLength > opts.maxDataLength) {
          throw new InvalidDataLengthError("message length too long");
        }
        return bytes.read({
          ...options,
          bytes: dataLength
        });
      },
      write: async (data, options) => {
        await bytes.write(new Uint8ArrayList(encodeLength2(data.byteLength), data), options);
      },
      writeV: async (data, options) => {
        const list = new Uint8ArrayList(...data.flatMap((buf) => [encodeLength2(buf.byteLength), buf]));
        await bytes.write(list, options);
      },
      unwrap: () => {
        return bytes.unwrap();
      }
    };
    return W;
  }

  // node_modules/@libp2p/multistream-select/dist/src/multistream.js
  var import_browser_shims257 = __toESM(require_browser_shims(), 1);
  var NewLine = fromString2("\n");
  async function write2(writer, buffer, options) {
    await writer.write(buffer, options);
  }
  async function writeAll(writer, buffers, options) {
    await writer.writeV(buffers, options);
  }
  async function read3(reader, options) {
    const buf = await reader.read(options);
    if (buf.byteLength === 0 || buf.get(buf.byteLength - 1) !== NewLine[0]) {
      options.log.error("Invalid mss message - missing newline", buf);
      throw new InvalidMessageError("Missing newline");
    }
    return buf.sublist(0, -1);
  }
  async function readString(reader, options) {
    const buf = await read3(reader, options);
    return toString2(buf.subarray());
  }

  // node_modules/@libp2p/multistream-select/dist/src/select.js
  async function select(stream, protocols, options) {
    protocols = Array.isArray(protocols) ? [...protocols] : [protocols];
    if (protocols.length === 1 && options.negotiateFully === false) {
      return optimisticSelect(stream, protocols[0], options);
    }
    const lp = lpStream(stream, {
      ...options,
      maxDataLength: MAX_PROTOCOL_LENGTH
    });
    const protocol = protocols.shift();
    if (protocol == null) {
      throw new Error("At least one protocol must be specified");
    }
    options.log.trace('select: write ["%s", "%s"]', PROTOCOL_ID, protocol);
    const p1 = fromString2(`${PROTOCOL_ID}
`);
    const p2 = fromString2(`${protocol}
`);
    await writeAll(lp, [p1, p2], options);
    options.log.trace("select: reading multistream-select header");
    let response = await readString(lp, options);
    options.log.trace('select: read "%s"', response);
    if (response === PROTOCOL_ID) {
      options.log.trace("select: reading protocol response");
      response = await readString(lp, options);
      options.log.trace('select: read "%s"', response);
    }
    if (response === protocol) {
      return { stream: lp.unwrap(), protocol };
    }
    for (const protocol2 of protocols) {
      options.log.trace('select: write "%s"', protocol2);
      await write2(lp, fromString2(`${protocol2}
`), options);
      options.log.trace("select: reading protocol response");
      const response2 = await readString(lp, options);
      options.log.trace('select: read "%s" for "%s"', response2, protocol2);
      if (response2 === protocol2) {
        return { stream: lp.unwrap(), protocol: protocol2 };
      }
    }
    throw new UnsupportedProtocolError("protocol selection failed");
  }
  function optimisticSelect(stream, protocol, options) {
    const originalSink = stream.sink.bind(stream);
    const originalSource = stream.source;
    let negotiated = false;
    let negotiating = false;
    const doneNegotiating = pDefer();
    let sentProtocol = false;
    let sendingProtocol = false;
    const doneSendingProtocol = pDefer();
    let readProtocol = false;
    let readingProtocol = false;
    const doneReadingProtocol = pDefer();
    const lp = lpStream({
      sink: originalSink,
      source: originalSource
    }, {
      ...options,
      maxDataLength: MAX_PROTOCOL_LENGTH
    });
    stream.sink = async (source) => {
      const { sink } = lp.unwrap();
      await sink(async function* () {
        let sentData = false;
        for await (const buf of source) {
          if (sendingProtocol) {
            await doneSendingProtocol.promise;
          }
          if (!sentProtocol) {
            sendingProtocol = true;
            options.log.trace('optimistic: write ["%s", "%s", data(%d)] in sink', PROTOCOL_ID, protocol, buf.byteLength);
            const protocolString = `${protocol}
`;
            yield new Uint8ArrayList(
              Uint8Array.from([19]),
              // length of PROTOCOL_ID plus newline
              fromString2(`${PROTOCOL_ID}
`),
              encode5(protocolString.length),
              fromString2(protocolString),
              buf
            ).subarray();
            options.log.trace('optimistic: wrote ["%s", "%s", data(%d)] in sink', PROTOCOL_ID, protocol, buf.byteLength);
            sentProtocol = true;
            sendingProtocol = false;
            doneSendingProtocol.resolve();
            negotiate().catch((err) => {
              options.log.error("could not finish optimistic protocol negotiation of %s", protocol, err);
            });
          } else {
            yield buf;
          }
          sentData = true;
        }
        if (!sentData) {
          await negotiate();
        }
      }());
    };
    async function negotiate() {
      if (negotiating) {
        options.log.trace("optimistic: already negotiating %s stream", protocol);
        await doneNegotiating.promise;
        return;
      }
      negotiating = true;
      try {
        if (!sentProtocol) {
          options.log.trace("optimistic: doing send protocol for %s stream", protocol);
          await doSendProtocol();
        }
        if (!readProtocol) {
          options.log.trace("optimistic: doing read protocol for %s stream", protocol);
          await doReadProtocol();
        }
      } finally {
        negotiating = false;
        negotiated = true;
        doneNegotiating.resolve();
      }
    }
    async function doSendProtocol() {
      if (sendingProtocol) {
        await doneSendingProtocol.promise;
        return;
      }
      sendingProtocol = true;
      try {
        options.log.trace('optimistic: write ["%s", "%s", data] in source', PROTOCOL_ID, protocol);
        await lp.writeV([
          fromString2(`${PROTOCOL_ID}
`),
          fromString2(`${protocol}
`)
        ]);
        options.log.trace('optimistic: wrote ["%s", "%s", data] in source', PROTOCOL_ID, protocol);
      } finally {
        sentProtocol = true;
        sendingProtocol = false;
        doneSendingProtocol.resolve();
      }
    }
    async function doReadProtocol() {
      if (readingProtocol) {
        await doneReadingProtocol.promise;
        return;
      }
      readingProtocol = true;
      try {
        options.log.trace("optimistic: reading multistream select header");
        let response = await readString(lp, options);
        options.log.trace('optimistic: read multistream select header "%s"', response);
        if (response === PROTOCOL_ID) {
          response = await readString(lp, options);
        }
        options.log.trace('optimistic: read protocol "%s", expecting "%s"', response, protocol);
        if (response !== protocol) {
          throw new UnsupportedProtocolError("protocol selection failed");
        }
      } finally {
        readProtocol = true;
        readingProtocol = false;
        doneReadingProtocol.resolve();
      }
    }
    stream.source = async function* () {
      await negotiate();
      options.log.trace('optimistic: reading data from "%s" stream', protocol);
      yield* lp.unwrap().source;
    }();
    if (stream.closeRead != null) {
      const originalCloseRead = stream.closeRead.bind(stream);
      stream.closeRead = async (opts) => {
        if (!negotiated) {
          await negotiate().catch((err) => {
            options.log.error("could not negotiate protocol before close read", err);
          });
        }
        await originalCloseRead(opts);
      };
    }
    if (stream.closeWrite != null) {
      const originalCloseWrite = stream.closeWrite.bind(stream);
      stream.closeWrite = async (opts) => {
        if (!negotiated) {
          await negotiate().catch((err) => {
            options.log.error("could not negotiate protocol before close write", err);
          });
        }
        await originalCloseWrite(opts);
      };
    }
    if (stream.close != null) {
      const originalClose = stream.close.bind(stream);
      stream.close = async (opts) => {
        const tasks = [];
        if (sendingProtocol) {
          tasks.push(doneSendingProtocol.promise);
        }
        if (readingProtocol) {
          tasks.push(doneReadingProtocol.promise);
        }
        if (tasks.length > 0) {
          await raceSignal(Promise.all(tasks), opts == null ? void 0 : opts.signal);
        } else {
          negotiated = true;
          negotiating = false;
          doneNegotiating.resolve();
        }
        await originalClose(opts);
      };
    }
    return {
      stream,
      protocol
    };
  }

  // node_modules/@libp2p/multistream-select/dist/src/handle.js
  var import_browser_shims265 = __toESM(require_browser_shims(), 1);

  // node_modules/@libp2p/multistream-select/node_modules/it-length-prefixed/dist/src/index.js
  var import_browser_shims264 = __toESM(require_browser_shims(), 1);

  // node_modules/@libp2p/multistream-select/node_modules/it-length-prefixed/dist/src/encode.js
  var import_browser_shims262 = __toESM(require_browser_shims(), 1);

  // node_modules/@libp2p/multistream-select/node_modules/it-length-prefixed/dist/src/constants.js
  var import_browser_shims259 = __toESM(require_browser_shims(), 1);
  var MAX_LENGTH_LENGTH = 8;
  var MAX_DATA_LENGTH = 1024 * 1024 * 4;

  // node_modules/@libp2p/multistream-select/node_modules/it-length-prefixed/dist/src/errors.js
  var import_browser_shims260 = __toESM(require_browser_shims(), 1);
  var InvalidMessageLengthError2 = class extends Error {
    name = "InvalidMessageLengthError";
    code = "ERR_INVALID_MSG_LENGTH";
  };
  var InvalidDataLengthError2 = class extends Error {
    name = "InvalidDataLengthError";
    code = "ERR_MSG_DATA_TOO_LONG";
  };
  var InvalidDataLengthLengthError2 = class extends Error {
    name = "InvalidDataLengthLengthError";
    code = "ERR_MSG_LENGTH_TOO_LONG";
  };
  var UnexpectedEOFError2 = class extends Error {
    name = "UnexpectedEOFError";
    code = "ERR_UNEXPECTED_EOF";
  };

  // node_modules/@libp2p/multistream-select/node_modules/it-length-prefixed/dist/src/utils.js
  var import_browser_shims261 = __toESM(require_browser_shims(), 1);
  function isAsyncIterable7(thing) {
    return thing[Symbol.asyncIterator] != null;
  }

  // node_modules/@libp2p/multistream-select/node_modules/it-length-prefixed/dist/src/encode.js
  function validateMaxDataLength(chunk, maxDataLength) {
    if (chunk.byteLength > maxDataLength) {
      throw new InvalidDataLengthError2("Message length too long");
    }
  }
  var defaultEncoder = (length4) => {
    const lengthLength = encodingLength2(length4);
    const lengthBuf = allocUnsafe(lengthLength);
    encode5(length4, lengthBuf);
    defaultEncoder.bytes = lengthLength;
    return lengthBuf;
  };
  defaultEncoder.bytes = 0;
  function encode6(source, options) {
    options = options ?? {};
    const encodeLength2 = options.lengthEncoder ?? defaultEncoder;
    const maxDataLength = (options == null ? void 0 : options.maxDataLength) ?? MAX_DATA_LENGTH;
    function* maybeYield(chunk) {
      validateMaxDataLength(chunk, maxDataLength);
      const length4 = encodeLength2(chunk.byteLength);
      if (length4 instanceof Uint8Array) {
        yield length4;
      } else {
        yield* length4;
      }
      if (chunk instanceof Uint8Array) {
        yield chunk;
      } else {
        yield* chunk;
      }
    }
    if (isAsyncIterable7(source)) {
      return async function* () {
        for await (const chunk of source) {
          yield* maybeYield(chunk);
        }
      }();
    }
    return function* () {
      for (const chunk of source) {
        yield* maybeYield(chunk);
      }
    }();
  }
  encode6.single = (chunk, options) => {
    options = options ?? {};
    const encodeLength2 = options.lengthEncoder ?? defaultEncoder;
    const maxDataLength = (options == null ? void 0 : options.maxDataLength) ?? MAX_DATA_LENGTH;
    validateMaxDataLength(chunk, maxDataLength);
    return new Uint8ArrayList(encodeLength2(chunk.byteLength), chunk);
  };

  // node_modules/@libp2p/multistream-select/node_modules/it-length-prefixed/dist/src/decode.js
  var import_browser_shims263 = __toESM(require_browser_shims(), 1);
  var ReadMode;
  (function(ReadMode5) {
    ReadMode5[ReadMode5["LENGTH"] = 0] = "LENGTH";
    ReadMode5[ReadMode5["DATA"] = 1] = "DATA";
  })(ReadMode || (ReadMode = {}));
  var defaultDecoder = (buf) => {
    const length4 = decode6(buf);
    defaultDecoder.bytes = encodingLength2(length4);
    return length4;
  };
  defaultDecoder.bytes = 0;
  function decode7(source, options) {
    const buffer = new Uint8ArrayList();
    let mode = ReadMode.LENGTH;
    let dataLength = -1;
    const lengthDecoder = (options == null ? void 0 : options.lengthDecoder) ?? defaultDecoder;
    const maxLengthLength = (options == null ? void 0 : options.maxLengthLength) ?? MAX_LENGTH_LENGTH;
    const maxDataLength = (options == null ? void 0 : options.maxDataLength) ?? MAX_DATA_LENGTH;
    function* maybeYield() {
      while (buffer.byteLength > 0) {
        if (mode === ReadMode.LENGTH) {
          try {
            dataLength = lengthDecoder(buffer);
            if (dataLength < 0) {
              throw new InvalidMessageLengthError2("Invalid message length");
            }
            if (dataLength > maxDataLength) {
              throw new InvalidDataLengthError2("Message length too long");
            }
            const dataLengthLength = lengthDecoder.bytes;
            buffer.consume(dataLengthLength);
            if ((options == null ? void 0 : options.onLength) != null) {
              options.onLength(dataLength);
            }
            mode = ReadMode.DATA;
          } catch (err) {
            if (err instanceof RangeError) {
              if (buffer.byteLength > maxLengthLength) {
                throw new InvalidDataLengthLengthError2("Message length length too long");
              }
              break;
            }
            throw err;
          }
        }
        if (mode === ReadMode.DATA) {
          if (buffer.byteLength < dataLength) {
            break;
          }
          const data = buffer.sublist(0, dataLength);
          buffer.consume(dataLength);
          if ((options == null ? void 0 : options.onData) != null) {
            options.onData(data);
          }
          yield data;
          mode = ReadMode.LENGTH;
        }
      }
    }
    if (isAsyncIterable7(source)) {
      return async function* () {
        for await (const buf of source) {
          buffer.append(buf);
          yield* maybeYield();
        }
        if (buffer.byteLength > 0) {
          throw new UnexpectedEOFError2("Unexpected end of input");
        }
      }();
    }
    return function* () {
      for (const buf of source) {
        buffer.append(buf);
        yield* maybeYield();
      }
      if (buffer.byteLength > 0) {
        throw new UnexpectedEOFError2("Unexpected end of input");
      }
    }();
  }
  decode7.fromReader = (reader, options) => {
    let byteLength = 1;
    const varByteSource = async function* () {
      while (true) {
        try {
          const { done, value } = await reader.next(byteLength);
          if (done === true) {
            return;
          }
          if (value != null) {
            yield value;
          }
        } catch (err) {
          if (err.code === "ERR_UNDER_READ") {
            return { done: true, value: null };
          }
          throw err;
        } finally {
          byteLength = 1;
        }
      }
    }();
    const onLength = (l) => {
      byteLength = l;
    };
    return decode7(varByteSource, {
      ...options ?? {},
      onLength
    });
  };

  // node_modules/@libp2p/multistream-select/dist/src/handle.js
  async function handle(stream, protocols, options) {
    protocols = Array.isArray(protocols) ? protocols : [protocols];
    options.log.trace("handle: available protocols %s", protocols);
    const lp = lpStream(stream, {
      ...options,
      maxDataLength: MAX_PROTOCOL_LENGTH,
      maxLengthLength: 2
      // 2 bytes is enough to length-prefix MAX_PROTOCOL_LENGTH
    });
    while (true) {
      options.log.trace("handle: reading incoming string");
      const protocol = await readString(lp, options);
      options.log.trace('handle: read "%s"', protocol);
      if (protocol === PROTOCOL_ID) {
        options.log.trace('handle: respond with "%s" for "%s"', PROTOCOL_ID, protocol);
        await write2(lp, fromString2(`${PROTOCOL_ID}
`), options);
        options.log.trace('handle: responded with "%s" for "%s"', PROTOCOL_ID, protocol);
        continue;
      }
      if (protocols.includes(protocol)) {
        options.log.trace('handle: respond with "%s" for "%s"', protocol, protocol);
        await write2(lp, fromString2(`${protocol}
`), options);
        options.log.trace('handle: responded with "%s" for "%s"', protocol, protocol);
        return { stream: lp.unwrap(), protocol };
      }
      if (protocol === "ls") {
        const protos = new Uint8ArrayList(...protocols.map((p) => encode6.single(fromString2(`${p}
`))), fromString2("\n"));
        options.log.trace('handle: respond with "%s" for %s', protocols, protocol);
        await write2(lp, protos, options);
        options.log.trace('handle: responded with "%s" for %s', protocols, protocol);
        continue;
      }
      options.log.trace('handle: respond with "na" for "%s"', protocol);
      await write2(lp, fromString2("na\n"), options);
      options.log('handle: responded with "na" for "%s"', protocol);
    }
  }

  // node_modules/libp2p/dist/src/connection/index.js
  var import_browser_shims267 = __toESM(require_browser_shims(), 1);
  var CLOSE_TIMEOUT = 500;
  var ConnectionImpl = class {
    /**
     * Connection identifier.
     */
    id;
    /**
     * Observed multiaddr of the remote peer
     */
    remoteAddr;
    /**
     * Remote peer id
     */
    remotePeer;
    direction;
    timeline;
    multiplexer;
    encryption;
    status;
    limits;
    log;
    /**
     * User provided tags
     *
     */
    tags;
    /**
     * Reference to the new stream function of the multiplexer
     */
    _newStream;
    /**
     * Reference to the close function of the raw connection
     */
    _close;
    _abort;
    /**
     * Reference to the getStreams function of the muxer
     */
    _getStreams;
    /**
     * An implementation of the js-libp2p connection.
     * Any libp2p transport should use an upgrader to return this connection.
     */
    constructor(init) {
      const { remoteAddr, remotePeer, newStream, close, abort, getStreams } = init;
      this.id = `${parseInt(String(Math.random() * 1e9)).toString(36)}${Date.now()}`;
      this.remoteAddr = remoteAddr;
      this.remotePeer = remotePeer;
      this.direction = init.direction;
      this.status = "open";
      this.timeline = init.timeline;
      this.multiplexer = init.multiplexer;
      this.encryption = init.encryption;
      this.limits = init.limits;
      this.log = init.logger.forComponent(`libp2p:connection:${this.direction}:${this.id}`);
      if (this.remoteAddr.getPeerId() == null) {
        this.remoteAddr = this.remoteAddr.encapsulate(`/p2p/${this.remotePeer}`);
      }
      this._newStream = newStream;
      this._close = close;
      this._abort = abort;
      this._getStreams = getStreams;
      this.tags = [];
    }
    [Symbol.toStringTag] = "Connection";
    [connectionSymbol] = true;
    /**
     * Get all the streams of the muxer
     */
    get streams() {
      return this._getStreams();
    }
    /**
     * Create a new stream from this connection
     */
    async newStream(protocols, options) {
      if (this.status === "closing") {
        throw new ConnectionClosingError("the connection is being closed");
      }
      if (this.status === "closed") {
        throw new ConnectionClosedError("the connection is closed");
      }
      if (!Array.isArray(protocols)) {
        protocols = [protocols];
      }
      if (this.limits != null && (options == null ? void 0 : options.runOnLimitedConnection) !== true) {
        throw new LimitedConnectionError("Cannot open protocol stream on limited connection");
      }
      const stream = await this._newStream(protocols, options);
      stream.direction = "outbound";
      return stream;
    }
    /**
     * Close the connection
     */
    async close(options = {}) {
      if (this.status === "closed" || this.status === "closing") {
        return;
      }
      this.log("closing connection to %a", this.remoteAddr);
      this.status = "closing";
      if (options.signal == null) {
        const signal = AbortSignal.timeout(CLOSE_TIMEOUT);
        setMaxListeners(Infinity, signal);
        options = {
          ...options,
          signal
        };
      }
      try {
        this.log.trace("closing underlying transport");
        await this._close(options);
        this.log.trace("updating timeline with close time");
        this.status = "closed";
        this.timeline.close = Date.now();
      } catch (err) {
        this.log.error("error encountered during graceful close of connection to %a", this.remoteAddr, err);
        this.abort(err);
      }
    }
    abort(err) {
      if (this.status === "closed") {
        return;
      }
      this.log.error("aborting connection to %a due to error", this.remoteAddr, err);
      this.status = "closing";
      this._abort(err);
      this.status = "closed";
      this.timeline.close = Date.now();
    }
  };
  function createConnection(init) {
    return new ConnectionImpl(init);
  }

  // node_modules/libp2p/dist/src/upgrader.js
  function findIncomingStreamLimit(protocol, registrar) {
    try {
      const { options } = registrar.getHandler(protocol);
      return options.maxInboundStreams;
    } catch (err) {
      if (err.name !== "UnhandledProtocolError") {
        throw err;
      }
    }
    return DEFAULT_MAX_INBOUND_STREAMS;
  }
  function findOutgoingStreamLimit(protocol, registrar, options = {}) {
    try {
      const { options: options2 } = registrar.getHandler(protocol);
      if (options2.maxOutboundStreams != null) {
        return options2.maxOutboundStreams;
      }
    } catch (err) {
      if (err.name !== "UnhandledProtocolError") {
        throw err;
      }
    }
    return options.maxOutboundStreams ?? DEFAULT_MAX_OUTBOUND_STREAMS;
  }
  function countStreams(protocol, direction, connection) {
    let streamCount = 0;
    connection.streams.forEach((stream) => {
      if (stream.direction === direction && stream.protocol === protocol) {
        streamCount++;
      }
    });
    return streamCount;
  }
  var Upgrader = class {
    components;
    connectionEncrypters;
    streamMuxers;
    inboundUpgradeTimeout;
    inboundStreamProtocolNegotiationTimeout;
    outboundStreamProtocolNegotiationTimeout;
    events;
    metrics;
    constructor(components, init) {
      var _a2, _b2, _c, _d;
      this.components = components;
      this.connectionEncrypters = trackedMap({
        name: "libp2p_upgrader_connection_encrypters",
        metrics: this.components.metrics
      });
      init.connectionEncrypters.forEach((encrypter) => {
        this.connectionEncrypters.set(encrypter.protocol, encrypter);
      });
      this.streamMuxers = trackedMap({
        name: "libp2p_upgrader_stream_multiplexers",
        metrics: this.components.metrics
      });
      init.streamMuxers.forEach((muxer) => {
        this.streamMuxers.set(muxer.protocol, muxer);
      });
      this.inboundUpgradeTimeout = init.inboundUpgradeTimeout ?? INBOUND_UPGRADE_TIMEOUT;
      this.inboundStreamProtocolNegotiationTimeout = init.inboundStreamProtocolNegotiationTimeout ?? PROTOCOL_NEGOTIATION_TIMEOUT;
      this.outboundStreamProtocolNegotiationTimeout = init.outboundStreamProtocolNegotiationTimeout ?? PROTOCOL_NEGOTIATION_TIMEOUT;
      this.events = components.events;
      this.metrics = {
        dials: (_a2 = components.metrics) == null ? void 0 : _a2.registerCounterGroup("libp2p_connection_manager_dials_total"),
        errors: (_b2 = components.metrics) == null ? void 0 : _b2.registerCounterGroup("libp2p_connection_manager_dial_errors_total"),
        inboundErrors: (_c = components.metrics) == null ? void 0 : _c.registerCounterGroup("libp2p_connection_manager_dials_inbound_errors_total"),
        outboundErrors: (_d = components.metrics) == null ? void 0 : _d.registerCounterGroup("libp2p_connection_manager_dials_outbound_errors_total")
      };
    }
    [Symbol.toStringTag] = "@libp2p/upgrader";
    async shouldBlockConnection(method, ...args) {
      const denyOperation = this.components.connectionGater[method];
      if (denyOperation == null) {
        return;
      }
      const result = await denyOperation.apply(this.components.connectionGater, args);
      if (result === true) {
        throw new ConnectionInterceptedError(`The multiaddr connection is blocked by gater.${method}`);
      }
    }
    createInboundAbortSignal(signal) {
      const output = anySignal([
        AbortSignal.timeout(this.inboundUpgradeTimeout),
        signal
      ]);
      setMaxListeners(Infinity, output);
      return output;
    }
    /**
     * Upgrades an inbound connection
     */
    async upgradeInbound(maConn, opts) {
      var _a2, _b2, _c;
      let accepted = false;
      const signal = this.createInboundAbortSignal(opts.signal);
      try {
        (_a2 = this.metrics.dials) == null ? void 0 : _a2.increment({
          inbound: true
        });
        accepted = await raceSignal(this.components.connectionManager.acceptIncomingConnection(maConn), signal);
        if (!accepted) {
          throw new ConnectionDeniedError("Connection denied");
        }
        await raceSignal(this.shouldBlockConnection("denyInboundConnection", maConn), signal);
        await this._performUpgrade(maConn, "inbound", {
          ...opts,
          signal
        });
      } catch (err) {
        (_b2 = this.metrics.errors) == null ? void 0 : _b2.increment({
          inbound: true
        });
        (_c = this.metrics.inboundErrors) == null ? void 0 : _c.increment({
          [err.name ?? "Error"]: true
        });
        throw err;
      } finally {
        signal.clear();
        if (accepted) {
          this.components.connectionManager.afterUpgradeInbound();
        }
      }
    }
    /**
     * Upgrades an outbound connection
     */
    async upgradeOutbound(maConn, opts) {
      var _a2, _b2, _c;
      try {
        (_a2 = this.metrics.dials) == null ? void 0 : _a2.increment({
          outbound: true
        });
        const idStr = maConn.remoteAddr.getPeerId();
        let remotePeerId;
        if (idStr != null) {
          remotePeerId = peerIdFromString(idStr);
          await raceSignal(this.shouldBlockConnection("denyOutboundConnection", remotePeerId, maConn), opts.signal);
        }
        let direction = "outbound";
        if (opts.initiator === false) {
          direction = "inbound";
        }
        return await this._performUpgrade(maConn, direction, opts);
      } catch (err) {
        (_b2 = this.metrics.errors) == null ? void 0 : _b2.increment({
          outbound: true
        });
        (_c = this.metrics.outboundErrors) == null ? void 0 : _c.increment({
          [err.name ?? "Error"]: true
        });
        throw err;
      }
    }
    async _performUpgrade(maConn, direction, opts) {
      var _a2, _b2, _c;
      let encryptedConn;
      let remotePeer;
      let upgradedConn;
      let muxerFactory;
      let cryptoProtocol;
      (_a2 = this.components.metrics) == null ? void 0 : _a2.trackMultiaddrConnection(maConn);
      maConn.log.trace("starting the %s connection upgrade", direction);
      let protectedConn = maConn;
      if ((opts == null ? void 0 : opts.skipProtection) !== true) {
        const protector = this.components.connectionProtector;
        if (protector != null) {
          maConn.log("protecting the %s connection", direction);
          protectedConn = await protector.protect(maConn, opts);
        }
      }
      try {
        encryptedConn = protectedConn;
        if ((opts == null ? void 0 : opts.skipEncryption) !== true) {
          (_b2 = opts == null ? void 0 : opts.onProgress) == null ? void 0 : _b2.call(opts, new CustomProgressEvent(`upgrader:encrypt-${direction}-connection`));
          ({
            conn: encryptedConn,
            remotePeer,
            protocol: cryptoProtocol,
            streamMuxer: muxerFactory
          } = await (direction === "inbound" ? this._encryptInbound(protectedConn, opts) : this._encryptOutbound(protectedConn, opts)));
          const maConn2 = {
            ...protectedConn,
            ...encryptedConn
          };
          await this.shouldBlockConnection(direction === "inbound" ? "denyInboundEncryptedConnection" : "denyOutboundEncryptedConnection", remotePeer, maConn2);
        } else {
          const idStr = maConn.remoteAddr.getPeerId();
          if (idStr == null) {
            throw new InvalidMultiaddrError(`${direction} connection that skipped encryption must have a peer id`);
          }
          const remotePeerId = peerIdFromString(idStr);
          cryptoProtocol = "native";
          remotePeer = remotePeerId;
        }
        if (remotePeer.equals(this.components.peerId)) {
          const err = new InvalidPeerIdError("Can not dial self");
          maConn.abort(err);
          throw err;
        }
        upgradedConn = encryptedConn;
        if ((opts == null ? void 0 : opts.muxerFactory) != null) {
          muxerFactory = opts.muxerFactory;
        } else if (muxerFactory == null && this.streamMuxers.size > 0) {
          (_c = opts == null ? void 0 : opts.onProgress) == null ? void 0 : _c.call(opts, new CustomProgressEvent(`upgrader:multiplex-${direction}-connection`));
          const multiplexed = await (direction === "inbound" ? this._multiplexInbound({
            ...protectedConn,
            ...encryptedConn
          }, this.streamMuxers, opts) : this._multiplexOutbound({
            ...protectedConn,
            ...encryptedConn
          }, this.streamMuxers, opts));
          muxerFactory = multiplexed.muxerFactory;
          upgradedConn = multiplexed.stream;
        }
      } catch (err) {
        maConn.log.error("failed to upgrade inbound connection %s %a - %e", direction === "inbound" ? "from" : "to", maConn.remoteAddr, err);
        throw err;
      }
      await this.shouldBlockConnection(direction === "inbound" ? "denyInboundUpgradedConnection" : "denyOutboundUpgradedConnection", remotePeer, maConn);
      maConn.log("successfully upgraded %s connection", direction);
      return this._createConnection({
        cryptoProtocol,
        direction,
        maConn,
        upgradedConn,
        muxerFactory,
        remotePeer,
        limits: opts == null ? void 0 : opts.limits
      });
    }
    /**
     * A convenience method for generating a new `Connection`
     */
    _createConnection(opts) {
      const { cryptoProtocol, direction, maConn, upgradedConn, remotePeer, muxerFactory, limits } = opts;
      let muxer;
      let newStream;
      let connection;
      if (muxerFactory != null) {
        muxer = muxerFactory.createStreamMuxer({
          direction,
          // Run anytime a remote stream is created
          onIncomingStream: (muxedStream) => {
            if (connection == null) {
              return;
            }
            const signal = AbortSignal.timeout(this.inboundStreamProtocolNegotiationTimeout);
            setMaxListeners(Infinity, signal);
            void Promise.resolve().then(async () => {
              var _a2;
              const protocols = this.components.registrar.getProtocols();
              const { stream, protocol } = await handle(muxedStream, protocols, {
                signal,
                log: muxedStream.log,
                yieldBytes: false
              });
              if (connection == null) {
                return;
              }
              connection.log("incoming stream opened on %s", protocol);
              const incomingLimit = findIncomingStreamLimit(protocol, this.components.registrar);
              const streamCount = countStreams(protocol, "inbound", connection);
              if (streamCount === incomingLimit) {
                const err = new TooManyInboundProtocolStreamsError(`Too many inbound protocol streams for protocol "${protocol}" - limit ${incomingLimit}`);
                muxedStream.abort(err);
                throw err;
              }
              muxedStream.source = stream.source;
              muxedStream.sink = stream.sink;
              muxedStream.protocol = protocol;
              if (stream.closeWrite != null) {
                muxedStream.closeWrite = stream.closeWrite;
              }
              if (stream.closeRead != null) {
                muxedStream.closeRead = stream.closeRead;
              }
              if (stream.close != null) {
                muxedStream.close = stream.close;
              }
              await this.components.peerStore.merge(remotePeer, {
                protocols: [protocol]
              }, {
                signal
              });
              (_a2 = this.components.metrics) == null ? void 0 : _a2.trackProtocolStream(muxedStream, connection);
              this._onStream({ connection, stream: muxedStream, protocol });
            }).catch(async (err) => {
              connection.log.error("error handling incoming stream id %s - %e", muxedStream.id, err);
              if (muxedStream.timeline.close == null) {
                await muxedStream.close({
                  signal
                }).catch((err2) => muxedStream.abort(err2));
              }
            });
          }
        });
        newStream = async (protocols, options = {}) => {
          var _a2;
          if (muxer == null) {
            throw new MuxerUnavailableError("Connection is not multiplexed");
          }
          connection.log.trace("starting new stream for protocols %s", protocols);
          const muxedStream = await muxer.newStream();
          connection.log.trace("started new stream %s for protocols %s", muxedStream.id, protocols);
          try {
            if (options.signal == null) {
              muxedStream.log("no abort signal was passed while trying to negotiate protocols %s falling back to default timeout", protocols);
              const signal = AbortSignal.timeout(this.outboundStreamProtocolNegotiationTimeout);
              setMaxListeners(Infinity, signal);
              options = {
                ...options,
                signal
              };
            }
            muxedStream.log.trace("selecting protocol from protocols %s", protocols);
            const { stream, protocol } = await select(muxedStream, protocols, {
              ...options,
              log: muxedStream.log,
              yieldBytes: true
            });
            muxedStream.log.trace("selected protocol %s", protocol);
            const outgoingLimit = findOutgoingStreamLimit(protocol, this.components.registrar, options);
            const streamCount = countStreams(protocol, "outbound", connection);
            if (streamCount >= outgoingLimit) {
              const err = new TooManyOutboundProtocolStreamsError(`Too many outbound protocol streams for protocol "${protocol}" - ${streamCount}/${outgoingLimit}`);
              muxedStream.abort(err);
              throw err;
            }
            await this.components.peerStore.merge(remotePeer, {
              protocols: [protocol]
            });
            muxedStream.source = stream.source;
            muxedStream.sink = stream.sink;
            muxedStream.protocol = protocol;
            if (stream.closeWrite != null) {
              muxedStream.closeWrite = stream.closeWrite;
            }
            if (stream.closeRead != null) {
              muxedStream.closeRead = stream.closeRead;
            }
            if (stream.close != null) {
              muxedStream.close = stream.close;
            }
            (_a2 = this.components.metrics) == null ? void 0 : _a2.trackProtocolStream(muxedStream, connection);
            return muxedStream;
          } catch (err) {
            connection.log.error("could not create new outbound stream on connection %s %a for protocols %s - %e", direction === "inbound" ? "from" : "to", opts.maConn.remoteAddr, protocols, err);
            if (muxedStream.timeline.close == null) {
              muxedStream.abort(err);
            }
            throw err;
          }
        };
        void Promise.all([
          muxer.sink(upgradedConn.source),
          upgradedConn.sink(muxer.source)
        ]).catch((err) => {
          connection.log.error("error piping data through muxer - %e", err);
        });
      }
      const _timeline = maConn.timeline;
      maConn.timeline = new Proxy(_timeline, {
        set: (...args) => {
          if (args[1] === "close" && args[2] != null && _timeline.close == null) {
            (async () => {
              try {
                if (connection.status === "open") {
                  await connection.close();
                }
              } catch (err) {
                connection.log.error("error closing connection after timeline close %e", err);
              } finally {
                this.events.safeDispatchEvent("connection:close", {
                  detail: connection
                });
              }
            })().catch((err) => {
              connection.log.error("error thrown while dispatching connection:close event %e", err);
            });
          }
          return Reflect.set(...args);
        }
      });
      maConn.timeline.upgraded = Date.now();
      const errConnectionNotMultiplexed = () => {
        throw new MuxerUnavailableError("Connection is not multiplexed");
      };
      connection = createConnection({
        remoteAddr: maConn.remoteAddr,
        remotePeer,
        status: "open",
        direction,
        timeline: maConn.timeline,
        multiplexer: muxer == null ? void 0 : muxer.protocol,
        encryption: cryptoProtocol,
        limits,
        logger: this.components.logger,
        newStream: newStream ?? errConnectionNotMultiplexed,
        getStreams: () => {
          return (muxer == null ? void 0 : muxer.streams) ?? [];
        },
        close: async (options) => {
          await (muxer == null ? void 0 : muxer.close(options));
          await maConn.close(options);
        },
        abort: (err) => {
          maConn.abort(err);
          muxer == null ? void 0 : muxer.abort(err);
        }
      });
      this.events.safeDispatchEvent("connection:open", {
        detail: connection
      });
      connection.__maConnTimeline = _timeline;
      return connection;
    }
    /**
     * Routes incoming streams to the correct handler
     */
    _onStream(opts) {
      const { connection, stream, protocol } = opts;
      const { handler, options } = this.components.registrar.getHandler(protocol);
      if (connection.limits != null && options.runOnLimitedConnection !== true) {
        throw new LimitedConnectionError("Cannot open protocol stream on limited connection");
      }
      handler({ connection, stream });
    }
    /**
     * Attempts to encrypt the incoming `connection` with the provided `cryptos`
     */
    async _encryptInbound(connection, options) {
      const protocols = Array.from(this.connectionEncrypters.keys());
      try {
        const { stream, protocol } = await handle(connection, protocols, {
          ...options,
          log: connection.log
        });
        const encrypter = this.connectionEncrypters.get(protocol);
        if (encrypter == null) {
          throw new EncryptionFailedError(`no crypto module found for ${protocol}`);
        }
        connection.log("encrypting inbound connection to %a using %s", connection.remoteAddr, protocol);
        return {
          ...await encrypter.secureInbound(stream, options),
          protocol
        };
      } catch (err) {
        connection.log.error("encrypting inbound connection from %a failed", connection.remoteAddr, err);
        throw new EncryptionFailedError(err.message);
      }
    }
    /**
     * Attempts to encrypt the given `connection` with the provided connection encrypters.
     * The first `ConnectionEncrypter` module to succeed will be used
     */
    async _encryptOutbound(connection, options) {
      const protocols = Array.from(this.connectionEncrypters.keys());
      try {
        connection.log.trace("selecting encrypter from %s", protocols);
        const { stream, protocol } = await select(connection, protocols, {
          ...options,
          log: connection.log,
          yieldBytes: true
        });
        const encrypter = this.connectionEncrypters.get(protocol);
        if (encrypter == null) {
          throw new EncryptionFailedError(`no crypto module found for ${protocol}`);
        }
        connection.log("encrypting outbound connection to %a using %s", connection.remoteAddr, protocol);
        return {
          ...await encrypter.secureOutbound(stream, options),
          protocol
        };
      } catch (err) {
        connection.log.error("encrypting outbound connection to %a failed", connection.remoteAddr, err);
        throw new EncryptionFailedError(err.message);
      }
    }
    /**
     * Selects one of the given muxers via multistream-select. That
     * muxer will be used for all future streams on the connection.
     */
    async _multiplexOutbound(connection, muxers, options) {
      const protocols = Array.from(muxers.keys());
      connection.log("outbound selecting muxer %s", protocols);
      try {
        connection.log.trace("selecting stream muxer from %s", protocols);
        const { stream, protocol } = await select(connection, protocols, {
          ...options,
          log: connection.log,
          yieldBytes: true
        });
        connection.log("selected %s as muxer protocol", protocol);
        const muxerFactory = muxers.get(protocol);
        return { stream, muxerFactory };
      } catch (err) {
        connection.log.error("error multiplexing outbound connection", err);
        throw new MuxerUnavailableError(String(err));
      }
    }
    /**
     * Registers support for one of the given muxers via multistream-select. The
     * selected muxer will be used for all future streams on the connection.
     */
    async _multiplexInbound(connection, muxers, options) {
      const protocols = Array.from(muxers.keys());
      connection.log("inbound handling muxers %s", protocols);
      try {
        const { stream, protocol } = await handle(connection, protocols, {
          ...options,
          log: connection.log
        });
        const muxerFactory = muxers.get(protocol);
        return { stream, muxerFactory };
      } catch (err) {
        connection.log.error("error multiplexing inbound connection", err);
        throw new MuxerUnavailableError(String(err));
      }
    }
    getConnectionEncrypters() {
      return this.connectionEncrypters;
    }
    getStreamMuxers() {
      return this.streamMuxers;
    }
  };

  // node_modules/libp2p/dist/src/user-agent.browser.js
  var import_browser_shims270 = __toESM(require_browser_shims(), 1);

  // node_modules/libp2p/dist/src/version.js
  var import_browser_shims269 = __toESM(require_browser_shims(), 1);
  var version = "2.8.9";
  var name2 = "js-libp2p";

  // node_modules/libp2p/dist/src/user-agent.browser.js
  function userAgent(name3, version2) {
    return `${name3 ?? name2}/${version2 ?? version} browser/${globalThis.navigator.userAgent}`;
  }

  // node_modules/libp2p/dist/src/libp2p.js
  var Libp2p = class extends TypedEventEmitter {
    peerId;
    peerStore;
    contentRouting;
    peerRouting;
    metrics;
    services;
    logger;
    status;
    components;
    log;
    // eslint-disable-next-line complexity
    constructor(init) {
      var _a2, _b2, _c, _d, _e, _f, _g, _h, _i, _j, _k, _l;
      super();
      this.status = "stopped";
      const events = new TypedEventEmitter();
      const originalDispatch = events.dispatchEvent.bind(events);
      events.dispatchEvent = (evt) => {
        const internalResult = originalDispatch(evt);
        const externalResult = this.dispatchEvent(new CustomEvent(evt.type, { detail: evt.detail }));
        return internalResult || externalResult;
      };
      setMaxListeners(Infinity, events);
      this.peerId = init.peerId;
      this.logger = init.logger ?? defaultLogger();
      this.log = this.logger.forComponent("libp2p");
      this.services = {};
      const nodeInfoName = ((_a2 = init.nodeInfo) == null ? void 0 : _a2.name) ?? name2;
      const nodeInfoVersion = ((_b2 = init.nodeInfo) == null ? void 0 : _b2.version) ?? version;
      const components = this.components = defaultComponents({
        peerId: init.peerId,
        privateKey: init.privateKey,
        nodeInfo: {
          name: nodeInfoName,
          version: nodeInfoVersion,
          userAgent: ((_c = init.nodeInfo) == null ? void 0 : _c.userAgent) ?? userAgent(nodeInfoName, nodeInfoVersion)
        },
        logger: this.logger,
        events,
        datastore: init.datastore ?? new MemoryDatastore(),
        connectionGater: connectionGater(init.connectionGater),
        dns: init.dns
      });
      if (init.metrics != null) {
        this.metrics = this.configureComponent("metrics", init.metrics(this.components));
      }
      this.peerStore = this.configureComponent("peerStore", persistentPeerStore(components, {
        addressFilter: this.components.connectionGater.filterMultiaddrForPeer,
        ...init.peerStore
      }));
      components.events.addEventListener("peer:update", (evt) => {
        if (evt.detail.previous == null) {
          const peerInfo = {
            id: evt.detail.peer.id,
            multiaddrs: evt.detail.peer.addresses.map((a) => a.multiaddr)
          };
          components.events.safeDispatchEvent("peer:discovery", { detail: peerInfo });
        }
      });
      if (init.connectionProtector != null) {
        this.configureComponent("connectionProtector", init.connectionProtector(components));
      }
      this.components.upgrader = new Upgrader(this.components, {
        connectionEncrypters: (init.connectionEncrypters ?? []).map((fn, index) => this.configureComponent(`connection-encryption-${index}`, fn(this.components))),
        streamMuxers: (init.streamMuxers ?? []).map((fn, index) => this.configureComponent(`stream-muxers-${index}`, fn(this.components))),
        inboundUpgradeTimeout: (_d = init.connectionManager) == null ? void 0 : _d.inboundUpgradeTimeout,
        inboundStreamProtocolNegotiationTimeout: ((_e = init.connectionManager) == null ? void 0 : _e.inboundStreamProtocolNegotiationTimeout) ?? ((_f = init.connectionManager) == null ? void 0 : _f.protocolNegotiationTimeout),
        outboundStreamProtocolNegotiationTimeout: ((_g = init.connectionManager) == null ? void 0 : _g.outboundStreamProtocolNegotiationTimeout) ?? ((_h = init.connectionManager) == null ? void 0 : _h.protocolNegotiationTimeout)
      });
      this.configureComponent("transportManager", new DefaultTransportManager(this.components, init.transportManager));
      this.configureComponent("connectionManager", new DefaultConnectionManager(this.components, init.connectionManager));
      if (((_i = init.connectionMonitor) == null ? void 0 : _i.enabled) !== false) {
        this.configureComponent("connectionMonitor", new ConnectionMonitor(this.components, init.connectionMonitor));
      }
      this.configureComponent("registrar", new Registrar(this.components));
      this.configureComponent("addressManager", new AddressManager(this.components, init.addresses));
      const peerRouters = (init.peerRouters ?? []).map((fn, index) => this.configureComponent(`peer-router-${index}`, fn(this.components)));
      this.peerRouting = this.components.peerRouting = this.configureComponent("peerRouting", new DefaultPeerRouting(this.components, {
        routers: peerRouters
      }));
      const contentRouters = (init.contentRouters ?? []).map((fn, index) => this.configureComponent(`content-router-${index}`, fn(this.components)));
      this.contentRouting = this.components.contentRouting = this.configureComponent("contentRouting", new CompoundContentRouting(this.components, {
        routers: contentRouters
      }));
      this.configureComponent("randomWalk", new RandomWalk(this.components));
      (init.peerDiscovery ?? []).forEach((fn, index) => {
        const service = this.configureComponent(`peer-discovery-${index}`, fn(this.components));
        service.addEventListener("peer", (evt) => {
          this.#onDiscoveryPeer(evt);
        });
      });
      (_j = init.transports) == null ? void 0 : _j.forEach((fn, index) => {
        this.components.transportManager.add(this.configureComponent(`transport-${index}`, fn(this.components)));
      });
      if (init.services != null) {
        for (const name3 of Object.keys(init.services)) {
          const createService = init.services[name3];
          const service = createService(this.components);
          if (service == null) {
            this.log.error("service factory %s returned null or undefined instance", name3);
            continue;
          }
          this.services[name3] = service;
          this.configureComponent(name3, service);
          if (service[contentRoutingSymbol] != null) {
            this.log("registering service %s for content routing", name3);
            contentRouters.push(service[contentRoutingSymbol]);
          }
          if (service[peerRoutingSymbol] != null) {
            this.log("registering service %s for peer routing", name3);
            peerRouters.push(service[peerRoutingSymbol]);
          }
          if (service[peerDiscoverySymbol] != null) {
            this.log("registering service %s for peer discovery", name3);
            (_l = (_k = service[peerDiscoverySymbol]).addEventListener) == null ? void 0 : _l.call(_k, "peer", (evt) => {
              this.#onDiscoveryPeer(evt);
            });
          }
        }
      }
      checkServiceDependencies(components);
    }
    configureComponent(name3, component) {
      if (component == null) {
        this.log.error("component %s was null or undefined", name3);
      }
      this.components[name3] = component;
      return component;
    }
    /**
     * Starts the libp2p node and all its subsystems
     */
    async start() {
      var _a2, _b2, _c, _d;
      if (this.status !== "stopped") {
        return;
      }
      this.status = "starting";
      this.log("libp2p is starting");
      try {
        await ((_b2 = (_a2 = this.components).beforeStart) == null ? void 0 : _b2.call(_a2));
        await this.components.start();
        await ((_d = (_c = this.components).afterStart) == null ? void 0 : _d.call(_c));
        this.status = "started";
        this.safeDispatchEvent("start", { detail: this });
        this.log("libp2p has started");
      } catch (err) {
        this.log.error("An error occurred starting libp2p", err);
        this.status = "started";
        await this.stop();
        throw err;
      }
    }
    /**
     * Stop the libp2p node by closing its listeners and open connections
     */
    async stop() {
      var _a2, _b2, _c, _d;
      if (this.status !== "started") {
        return;
      }
      this.log("libp2p is stopping");
      this.status = "stopping";
      await ((_b2 = (_a2 = this.components).beforeStop) == null ? void 0 : _b2.call(_a2));
      await this.components.stop();
      await ((_d = (_c = this.components).afterStop) == null ? void 0 : _d.call(_c));
      this.status = "stopped";
      this.safeDispatchEvent("stop", { detail: this });
      this.log("libp2p has stopped");
    }
    getConnections(peerId2) {
      return this.components.connectionManager.getConnections(peerId2);
    }
    getDialQueue() {
      return this.components.connectionManager.getDialQueue();
    }
    getPeers() {
      const peerSet2 = new PeerSet();
      for (const conn of this.components.connectionManager.getConnections()) {
        peerSet2.add(conn.remotePeer);
      }
      return Array.from(peerSet2);
    }
    async dial(peer, options = {}) {
      return this.components.connectionManager.openConnection(peer, {
        // ensure any userland dials take top priority in the queue
        priority: 75,
        ...options
      });
    }
    async dialProtocol(peer, protocols, options = {}) {
      if (protocols == null) {
        throw new InvalidParametersError("no protocols were provided to open a stream");
      }
      protocols = Array.isArray(protocols) ? protocols : [protocols];
      if (protocols.length === 0) {
        throw new InvalidParametersError("no protocols were provided to open a stream");
      }
      const connection = await this.dial(peer, options);
      return connection.newStream(protocols, options);
    }
    getMultiaddrs() {
      return this.components.addressManager.getAddresses();
    }
    getProtocols() {
      return this.components.registrar.getProtocols();
    }
    async hangUp(peer, options = {}) {
      if (isMultiaddr(peer)) {
        peer = peerIdFromString(peer.getPeerId() ?? "");
      }
      await this.components.connectionManager.closeConnections(peer, options);
    }
    async getPublicKey(peer, options = {}) {
      this.log("getPublicKey %p", peer);
      if (peer.publicKey != null) {
        return peer.publicKey;
      }
      try {
        const peerInfo = await this.peerStore.get(peer, options);
        if (peerInfo.id.publicKey != null) {
          return peerInfo.id.publicKey;
        }
      } catch (err) {
        if (err.name !== "NotFoundError") {
          throw err;
        }
      }
      const peerKey = concat([
        fromString2("/pk/"),
        peer.toMultihash().bytes
      ]);
      const bytes = await this.contentRouting.get(peerKey, options);
      const publicKey = publicKeyFromProtobuf(bytes);
      await this.peerStore.patch(peer, {
        publicKey
      }, options);
      return publicKey;
    }
    async handle(protocols, handler, options) {
      if (!Array.isArray(protocols)) {
        protocols = [protocols];
      }
      await Promise.all(protocols.map(async (protocol) => {
        await this.components.registrar.handle(protocol, handler, options);
      }));
    }
    async unhandle(protocols, options) {
      if (!Array.isArray(protocols)) {
        protocols = [protocols];
      }
      await Promise.all(protocols.map(async (protocol) => {
        await this.components.registrar.unhandle(protocol, options);
      }));
    }
    async register(protocol, topology, options) {
      return this.components.registrar.register(protocol, topology, options);
    }
    unregister(id) {
      this.components.registrar.unregister(id);
    }
    async isDialable(multiaddr2, options = {}) {
      return this.components.connectionManager.isDialable(multiaddr2, options);
    }
    /**
     * Called whenever peer discovery services emit `peer` events and adds peers
     * to the peer store.
     */
    #onDiscoveryPeer(evt) {
      const { detail: peer } = evt;
      if (peer.id.toString() === this.peerId.toString()) {
        this.log.error("peer discovery mechanism discovered self");
        return;
      }
      void this.components.peerStore.merge(peer.id, {
        multiaddrs: peer.multiaddrs
      }).catch((err) => {
        this.log.error(err);
      });
    }
  };

  // node_modules/libp2p/dist/src/index.js
  async function createLibp2p(options = {}) {
    options.privateKey ??= await generateKeyPair("Ed25519");
    const node = new Libp2p({
      ...await validateConfig(options),
      peerId: peerIdFromPrivateKey(options.privateKey)
    });
    if (options.start !== false) {
      await node.start();
    }
    return node;
  }

  // node_modules/@chainsafe/libp2p-gossipsub/dist/src/index.js
  var import_browser_shims304 = __toESM(require_browser_shims(), 1);

  // node_modules/it-length-prefixed/dist/src/index.js
  var import_browser_shims277 = __toESM(require_browser_shims(), 1);

  // node_modules/it-length-prefixed/dist/src/encode.js
  var import_browser_shims274 = __toESM(require_browser_shims(), 1);

  // node_modules/it-length-prefixed/dist/src/utils.js
  var import_browser_shims273 = __toESM(require_browser_shims(), 1);
  function isAsyncIterable8(thing) {
    return thing[Symbol.asyncIterator] != null;
  }

  // node_modules/it-length-prefixed/dist/src/encode.js
  var defaultEncoder2 = (length4) => {
    const lengthLength = encodingLength2(length4);
    const lengthBuf = allocUnsafe(lengthLength);
    encode5(length4, lengthBuf);
    defaultEncoder2.bytes = lengthLength;
    return lengthBuf;
  };
  defaultEncoder2.bytes = 0;
  function encode7(source, options) {
    options = options ?? {};
    const encodeLength2 = options.lengthEncoder ?? defaultEncoder2;
    function* maybeYield(chunk) {
      const length4 = encodeLength2(chunk.byteLength);
      if (length4 instanceof Uint8Array) {
        yield length4;
      } else {
        yield* length4;
      }
      if (chunk instanceof Uint8Array) {
        yield chunk;
      } else {
        yield* chunk;
      }
    }
    if (isAsyncIterable8(source)) {
      return async function* () {
        for await (const chunk of source) {
          yield* maybeYield(chunk);
        }
      }();
    }
    return function* () {
      for (const chunk of source) {
        yield* maybeYield(chunk);
      }
    }();
  }
  encode7.single = (chunk, options) => {
    options = options ?? {};
    const encodeLength2 = options.lengthEncoder ?? defaultEncoder2;
    return new Uint8ArrayList(encodeLength2(chunk.byteLength), chunk);
  };

  // node_modules/it-length-prefixed/dist/src/decode.js
  var import_browser_shims276 = __toESM(require_browser_shims(), 1);

  // node_modules/it-length-prefixed/dist/src/errors.js
  var import_browser_shims275 = __toESM(require_browser_shims(), 1);
  var InvalidMessageLengthError3 = class extends Error {
    name = "InvalidMessageLengthError";
    code = "ERR_INVALID_MSG_LENGTH";
  };
  var InvalidDataLengthError3 = class extends Error {
    name = "InvalidDataLengthError";
    code = "ERR_MSG_DATA_TOO_LONG";
  };
  var InvalidDataLengthLengthError3 = class extends Error {
    name = "InvalidDataLengthLengthError";
    code = "ERR_MSG_LENGTH_TOO_LONG";
  };
  var UnexpectedEOFError3 = class extends Error {
    name = "UnexpectedEOFError";
    code = "ERR_UNEXPECTED_EOF";
  };

  // node_modules/it-length-prefixed/dist/src/decode.js
  var MAX_LENGTH_LENGTH2 = 8;
  var MAX_DATA_LENGTH2 = 1024 * 1024 * 4;
  var ReadMode2;
  (function(ReadMode5) {
    ReadMode5[ReadMode5["LENGTH"] = 0] = "LENGTH";
    ReadMode5[ReadMode5["DATA"] = 1] = "DATA";
  })(ReadMode2 || (ReadMode2 = {}));
  var defaultDecoder2 = (buf) => {
    const length4 = decode6(buf);
    defaultDecoder2.bytes = encodingLength2(length4);
    return length4;
  };
  defaultDecoder2.bytes = 0;
  function decode8(source, options) {
    const buffer = new Uint8ArrayList();
    let mode = ReadMode2.LENGTH;
    let dataLength = -1;
    const lengthDecoder = (options == null ? void 0 : options.lengthDecoder) ?? defaultDecoder2;
    const maxLengthLength = (options == null ? void 0 : options.maxLengthLength) ?? MAX_LENGTH_LENGTH2;
    const maxDataLength = (options == null ? void 0 : options.maxDataLength) ?? MAX_DATA_LENGTH2;
    function* maybeYield() {
      while (buffer.byteLength > 0) {
        if (mode === ReadMode2.LENGTH) {
          try {
            dataLength = lengthDecoder(buffer);
            if (dataLength < 0) {
              throw new InvalidMessageLengthError3("Invalid message length");
            }
            if (dataLength > maxDataLength) {
              throw new InvalidDataLengthError3("Message length too long");
            }
            const dataLengthLength = lengthDecoder.bytes;
            buffer.consume(dataLengthLength);
            if ((options == null ? void 0 : options.onLength) != null) {
              options.onLength(dataLength);
            }
            mode = ReadMode2.DATA;
          } catch (err) {
            if (err instanceof RangeError) {
              if (buffer.byteLength > maxLengthLength) {
                throw new InvalidDataLengthLengthError3("Message length length too long");
              }
              break;
            }
            throw err;
          }
        }
        if (mode === ReadMode2.DATA) {
          if (buffer.byteLength < dataLength) {
            break;
          }
          const data = buffer.sublist(0, dataLength);
          buffer.consume(dataLength);
          if ((options == null ? void 0 : options.onData) != null) {
            options.onData(data);
          }
          yield data;
          mode = ReadMode2.LENGTH;
        }
      }
    }
    if (isAsyncIterable8(source)) {
      return async function* () {
        for await (const buf of source) {
          buffer.append(buf);
          yield* maybeYield();
        }
        if (buffer.byteLength > 0) {
          throw new UnexpectedEOFError3("Unexpected end of input");
        }
      }();
    }
    return function* () {
      for (const buf of source) {
        buffer.append(buf);
        yield* maybeYield();
      }
      if (buffer.byteLength > 0) {
        throw new UnexpectedEOFError3("Unexpected end of input");
      }
    }();
  }
  decode8.fromReader = (reader, options) => {
    let byteLength = 1;
    const varByteSource = async function* () {
      while (true) {
        try {
          const { done, value } = await reader.next(byteLength);
          if (done === true) {
            return;
          }
          if (value != null) {
            yield value;
          }
        } catch (err) {
          if (err.code === "ERR_UNDER_READ") {
            return { done: true, value: null };
          }
          throw err;
        } finally {
          byteLength = 1;
        }
      }
    }();
    const onLength = (l) => {
      byteLength = l;
    };
    return decode8(varByteSource, {
      ...options ?? {},
      onLength
    });
  };

  // node_modules/it-pipe/dist/src/index.js
  var import_browser_shims278 = __toESM(require_browser_shims(), 1);
  function pipe(first, ...rest) {
    if (first == null) {
      throw new Error("Empty pipeline");
    }
    if (isDuplex(first)) {
      const duplex = first;
      first = () => duplex.source;
    } else if (isIterable(first) || isAsyncIterable9(first)) {
      const source = first;
      first = () => source;
    }
    const fns = [first, ...rest];
    if (fns.length > 1) {
      if (isDuplex(fns[fns.length - 1])) {
        fns[fns.length - 1] = fns[fns.length - 1].sink;
      }
    }
    if (fns.length > 2) {
      for (let i = 1; i < fns.length - 1; i++) {
        if (isDuplex(fns[i])) {
          fns[i] = duplexPipelineFn(fns[i]);
        }
      }
    }
    return rawPipe(...fns);
  }
  var rawPipe = (...fns) => {
    let res;
    while (fns.length > 0) {
      res = fns.shift()(res);
    }
    return res;
  };
  var isAsyncIterable9 = (obj) => {
    return (obj == null ? void 0 : obj[Symbol.asyncIterator]) != null;
  };
  var isIterable = (obj) => {
    return (obj == null ? void 0 : obj[Symbol.iterator]) != null;
  };
  var isDuplex = (obj) => {
    if (obj == null) {
      return false;
    }
    return obj.sink != null && obj.source != null;
  };
  var duplexPipelineFn = (duplex) => {
    return (source) => {
      const p = duplex.sink(source);
      if ((p == null ? void 0 : p.then) != null) {
        const stream = pushable({
          objectMode: true
        });
        p.then(() => {
          stream.end();
        }, (err) => {
          stream.end(err);
        });
        let sourceWrap;
        const source2 = duplex.source;
        if (isAsyncIterable9(source2)) {
          sourceWrap = async function* () {
            yield* source2;
            stream.end();
          };
        } else if (isIterable(source2)) {
          sourceWrap = function* () {
            yield* source2;
            stream.end();
          };
        } else {
          throw new Error("Unknown duplex source type - must be Iterable or AsyncIterable");
        }
        return src_default8(stream, sourceWrap());
      }
      return duplex.source;
    };
  };

  // node_modules/@chainsafe/libp2p-gossipsub/dist/src/constants.js
  var import_browser_shims279 = __toESM(require_browser_shims(), 1);
  var second = 1e3;
  var minute = 60 * second;
  var FloodsubID = "/floodsub/1.0.0";
  var GossipsubIDv10 = "/meshsub/1.0.0";
  var GossipsubIDv11 = "/meshsub/1.1.0";
  var GossipsubIDv12 = "/meshsub/1.2.0";
  var GossipsubD = 6;
  var GossipsubDlo = 4;
  var GossipsubDhi = 12;
  var GossipsubDscore = 4;
  var GossipsubDout = 2;
  var GossipsubHistoryLength = 5;
  var GossipsubHistoryGossip = 3;
  var GossipsubDlazy = 6;
  var GossipsubGossipFactor = 0.25;
  var GossipsubGossipRetransmission = 3;
  var GossipsubHeartbeatInitialDelay = 100;
  var GossipsubHeartbeatInterval = second;
  var GossipsubFanoutTTL = minute;
  var GossipsubPrunePeers = 16;
  var GossipsubPruneBackoff = minute;
  var GossipsubUnsubscribeBackoff = 10 * second;
  var GossipsubPruneBackoffTicks = 15;
  var GossipsubConnectionTimeout = 30 * second;
  var GossipsubDirectConnectTicks = 300;
  var GossipsubDirectConnectInitialDelay = second;
  var GossipsubOpportunisticGraftTicks = 60;
  var GossipsubOpportunisticGraftPeers = 2;
  var GossipsubGraftFloodThreshold = 10 * second;
  var GossipsubMaxIHaveLength = 5e3;
  var GossipsubMaxIHaveMessages = 10;
  var GossipsubIWantFollowupTime = 3 * second;
  var GossipsubSeenTTL = 2 * minute;
  var TimeCacheDuration = 120 * 1e3;
  var ERR_TOPIC_VALIDATOR_REJECT = "ERR_TOPIC_VALIDATOR_REJECT";
  var ERR_TOPIC_VALIDATOR_IGNORE = "ERR_TOPIC_VALIDATOR_IGNORE";
  var ACCEPT_FROM_WHITELIST_THRESHOLD_SCORE = 0;
  var ACCEPT_FROM_WHITELIST_MAX_MESSAGES = 128;
  var ACCEPT_FROM_WHITELIST_DURATION_MS = 1e3;
  var DEFAULT_METRIC_MESH_MESSAGE_DELIVERIES_WINDOWS = 1e3;
  var BACKOFF_SLACK = 1;
  var GossipsubIdontwantMinDataSize = 512;
  var GossipsubIdontwantMaxMessages = 512;

  // node_modules/@chainsafe/libp2p-gossipsub/dist/src/message/decodeRpc.js
  var import_browser_shims280 = __toESM(require_browser_shims(), 1);
  var defaultDecodeRpcLimits = {
    maxSubscriptions: Infinity,
    maxMessages: Infinity,
    maxIhaveMessageIDs: Infinity,
    maxIwantMessageIDs: Infinity,
    maxIdontwantMessageIDs: Infinity,
    maxControlMessages: Infinity,
    maxPeerInfos: Infinity
  };

  // node_modules/@chainsafe/libp2p-gossipsub/dist/src/message/rpc.js
  var import_browser_shims281 = __toESM(require_browser_shims(), 1);
  var RPC;
  (function(RPC3) {
    let SubOpts;
    (function(SubOpts2) {
      let _codec2;
      SubOpts2.codec = () => {
        if (_codec2 == null) {
          _codec2 = message((obj, w2, opts = {}) => {
            if (opts.lengthDelimited !== false) {
              w2.fork();
            }
            if (obj.subscribe != null) {
              w2.uint32(8);
              w2.bool(obj.subscribe);
            }
            if (obj.topic != null) {
              w2.uint32(18);
              w2.string(obj.topic);
            }
            if (opts.lengthDelimited !== false) {
              w2.ldelim();
            }
          }, (reader, length4, opts = {}) => {
            const obj = {};
            const end = length4 == null ? reader.len : reader.pos + length4;
            while (reader.pos < end) {
              const tag = reader.uint32();
              switch (tag >>> 3) {
                case 1: {
                  obj.subscribe = reader.bool();
                  break;
                }
                case 2: {
                  obj.topic = reader.string();
                  break;
                }
                default: {
                  reader.skipType(tag & 7);
                  break;
                }
              }
            }
            return obj;
          });
        }
        return _codec2;
      };
      SubOpts2.encode = (obj) => {
        return encodeMessage(obj, SubOpts2.codec());
      };
      SubOpts2.decode = (buf, opts) => {
        return decodeMessage(buf, SubOpts2.codec(), opts);
      };
    })(SubOpts = RPC3.SubOpts || (RPC3.SubOpts = {}));
    let Message4;
    (function(Message5) {
      let _codec2;
      Message5.codec = () => {
        if (_codec2 == null) {
          _codec2 = message((obj, w2, opts = {}) => {
            if (opts.lengthDelimited !== false) {
              w2.fork();
            }
            if (obj.from != null) {
              w2.uint32(10);
              w2.bytes(obj.from);
            }
            if (obj.data != null) {
              w2.uint32(18);
              w2.bytes(obj.data);
            }
            if (obj.seqno != null) {
              w2.uint32(26);
              w2.bytes(obj.seqno);
            }
            if (obj.topic != null && obj.topic !== "") {
              w2.uint32(34);
              w2.string(obj.topic);
            }
            if (obj.signature != null) {
              w2.uint32(42);
              w2.bytes(obj.signature);
            }
            if (obj.key != null) {
              w2.uint32(50);
              w2.bytes(obj.key);
            }
            if (opts.lengthDelimited !== false) {
              w2.ldelim();
            }
          }, (reader, length4, opts = {}) => {
            const obj = {
              topic: ""
            };
            const end = length4 == null ? reader.len : reader.pos + length4;
            while (reader.pos < end) {
              const tag = reader.uint32();
              switch (tag >>> 3) {
                case 1: {
                  obj.from = reader.bytes();
                  break;
                }
                case 2: {
                  obj.data = reader.bytes();
                  break;
                }
                case 3: {
                  obj.seqno = reader.bytes();
                  break;
                }
                case 4: {
                  obj.topic = reader.string();
                  break;
                }
                case 5: {
                  obj.signature = reader.bytes();
                  break;
                }
                case 6: {
                  obj.key = reader.bytes();
                  break;
                }
                default: {
                  reader.skipType(tag & 7);
                  break;
                }
              }
            }
            return obj;
          });
        }
        return _codec2;
      };
      Message5.encode = (obj) => {
        return encodeMessage(obj, Message5.codec());
      };
      Message5.decode = (buf, opts) => {
        return decodeMessage(buf, Message5.codec(), opts);
      };
    })(Message4 = RPC3.Message || (RPC3.Message = {}));
    let ControlMessage;
    (function(ControlMessage2) {
      let _codec2;
      ControlMessage2.codec = () => {
        if (_codec2 == null) {
          _codec2 = message((obj, w2, opts = {}) => {
            if (opts.lengthDelimited !== false) {
              w2.fork();
            }
            if (obj.ihave != null) {
              for (const value of obj.ihave) {
                w2.uint32(10);
                RPC3.ControlIHave.codec().encode(value, w2);
              }
            }
            if (obj.iwant != null) {
              for (const value of obj.iwant) {
                w2.uint32(18);
                RPC3.ControlIWant.codec().encode(value, w2);
              }
            }
            if (obj.graft != null) {
              for (const value of obj.graft) {
                w2.uint32(26);
                RPC3.ControlGraft.codec().encode(value, w2);
              }
            }
            if (obj.prune != null) {
              for (const value of obj.prune) {
                w2.uint32(34);
                RPC3.ControlPrune.codec().encode(value, w2);
              }
            }
            if (obj.idontwant != null) {
              for (const value of obj.idontwant) {
                w2.uint32(42);
                RPC3.ControlIDontWant.codec().encode(value, w2);
              }
            }
            if (opts.lengthDelimited !== false) {
              w2.ldelim();
            }
          }, (reader, length4, opts = {}) => {
            var _a2, _b2, _c, _d, _e, _f, _g, _h, _i, _j;
            const obj = {
              ihave: [],
              iwant: [],
              graft: [],
              prune: [],
              idontwant: []
            };
            const end = length4 == null ? reader.len : reader.pos + length4;
            while (reader.pos < end) {
              const tag = reader.uint32();
              switch (tag >>> 3) {
                case 1: {
                  if (((_a2 = opts.limits) == null ? void 0 : _a2.ihave) != null && obj.ihave.length === opts.limits.ihave) {
                    throw new MaxLengthError('Decode error - map field "ihave" had too many elements');
                  }
                  obj.ihave.push(RPC3.ControlIHave.codec().decode(reader, reader.uint32(), {
                    limits: (_b2 = opts.limits) == null ? void 0 : _b2.ihave$
                  }));
                  break;
                }
                case 2: {
                  if (((_c = opts.limits) == null ? void 0 : _c.iwant) != null && obj.iwant.length === opts.limits.iwant) {
                    throw new MaxLengthError('Decode error - map field "iwant" had too many elements');
                  }
                  obj.iwant.push(RPC3.ControlIWant.codec().decode(reader, reader.uint32(), {
                    limits: (_d = opts.limits) == null ? void 0 : _d.iwant$
                  }));
                  break;
                }
                case 3: {
                  if (((_e = opts.limits) == null ? void 0 : _e.graft) != null && obj.graft.length === opts.limits.graft) {
                    throw new MaxLengthError('Decode error - map field "graft" had too many elements');
                  }
                  obj.graft.push(RPC3.ControlGraft.codec().decode(reader, reader.uint32(), {
                    limits: (_f = opts.limits) == null ? void 0 : _f.graft$
                  }));
                  break;
                }
                case 4: {
                  if (((_g = opts.limits) == null ? void 0 : _g.prune) != null && obj.prune.length === opts.limits.prune) {
                    throw new MaxLengthError('Decode error - map field "prune" had too many elements');
                  }
                  obj.prune.push(RPC3.ControlPrune.codec().decode(reader, reader.uint32(), {
                    limits: (_h = opts.limits) == null ? void 0 : _h.prune$
                  }));
                  break;
                }
                case 5: {
                  if (((_i = opts.limits) == null ? void 0 : _i.idontwant) != null && obj.idontwant.length === opts.limits.idontwant) {
                    throw new MaxLengthError('Decode error - map field "idontwant" had too many elements');
                  }
                  obj.idontwant.push(RPC3.ControlIDontWant.codec().decode(reader, reader.uint32(), {
                    limits: (_j = opts.limits) == null ? void 0 : _j.idontwant$
                  }));
                  break;
                }
                default: {
                  reader.skipType(tag & 7);
                  break;
                }
              }
            }
            return obj;
          });
        }
        return _codec2;
      };
      ControlMessage2.encode = (obj) => {
        return encodeMessage(obj, ControlMessage2.codec());
      };
      ControlMessage2.decode = (buf, opts) => {
        return decodeMessage(buf, ControlMessage2.codec(), opts);
      };
    })(ControlMessage = RPC3.ControlMessage || (RPC3.ControlMessage = {}));
    let ControlIHave;
    (function(ControlIHave2) {
      let _codec2;
      ControlIHave2.codec = () => {
        if (_codec2 == null) {
          _codec2 = message((obj, w2, opts = {}) => {
            if (opts.lengthDelimited !== false) {
              w2.fork();
            }
            if (obj.topicID != null) {
              w2.uint32(10);
              w2.string(obj.topicID);
            }
            if (obj.messageIDs != null) {
              for (const value of obj.messageIDs) {
                w2.uint32(18);
                w2.bytes(value);
              }
            }
            if (opts.lengthDelimited !== false) {
              w2.ldelim();
            }
          }, (reader, length4, opts = {}) => {
            var _a2;
            const obj = {
              messageIDs: []
            };
            const end = length4 == null ? reader.len : reader.pos + length4;
            while (reader.pos < end) {
              const tag = reader.uint32();
              switch (tag >>> 3) {
                case 1: {
                  obj.topicID = reader.string();
                  break;
                }
                case 2: {
                  if (((_a2 = opts.limits) == null ? void 0 : _a2.messageIDs) != null && obj.messageIDs.length === opts.limits.messageIDs) {
                    throw new MaxLengthError('Decode error - map field "messageIDs" had too many elements');
                  }
                  obj.messageIDs.push(reader.bytes());
                  break;
                }
                default: {
                  reader.skipType(tag & 7);
                  break;
                }
              }
            }
            return obj;
          });
        }
        return _codec2;
      };
      ControlIHave2.encode = (obj) => {
        return encodeMessage(obj, ControlIHave2.codec());
      };
      ControlIHave2.decode = (buf, opts) => {
        return decodeMessage(buf, ControlIHave2.codec(), opts);
      };
    })(ControlIHave = RPC3.ControlIHave || (RPC3.ControlIHave = {}));
    let ControlIWant;
    (function(ControlIWant2) {
      let _codec2;
      ControlIWant2.codec = () => {
        if (_codec2 == null) {
          _codec2 = message((obj, w2, opts = {}) => {
            if (opts.lengthDelimited !== false) {
              w2.fork();
            }
            if (obj.messageIDs != null) {
              for (const value of obj.messageIDs) {
                w2.uint32(10);
                w2.bytes(value);
              }
            }
            if (opts.lengthDelimited !== false) {
              w2.ldelim();
            }
          }, (reader, length4, opts = {}) => {
            var _a2;
            const obj = {
              messageIDs: []
            };
            const end = length4 == null ? reader.len : reader.pos + length4;
            while (reader.pos < end) {
              const tag = reader.uint32();
              switch (tag >>> 3) {
                case 1: {
                  if (((_a2 = opts.limits) == null ? void 0 : _a2.messageIDs) != null && obj.messageIDs.length === opts.limits.messageIDs) {
                    throw new MaxLengthError('Decode error - map field "messageIDs" had too many elements');
                  }
                  obj.messageIDs.push(reader.bytes());
                  break;
                }
                default: {
                  reader.skipType(tag & 7);
                  break;
                }
              }
            }
            return obj;
          });
        }
        return _codec2;
      };
      ControlIWant2.encode = (obj) => {
        return encodeMessage(obj, ControlIWant2.codec());
      };
      ControlIWant2.decode = (buf, opts) => {
        return decodeMessage(buf, ControlIWant2.codec(), opts);
      };
    })(ControlIWant = RPC3.ControlIWant || (RPC3.ControlIWant = {}));
    let ControlGraft;
    (function(ControlGraft2) {
      let _codec2;
      ControlGraft2.codec = () => {
        if (_codec2 == null) {
          _codec2 = message((obj, w2, opts = {}) => {
            if (opts.lengthDelimited !== false) {
              w2.fork();
            }
            if (obj.topicID != null) {
              w2.uint32(10);
              w2.string(obj.topicID);
            }
            if (opts.lengthDelimited !== false) {
              w2.ldelim();
            }
          }, (reader, length4, opts = {}) => {
            const obj = {};
            const end = length4 == null ? reader.len : reader.pos + length4;
            while (reader.pos < end) {
              const tag = reader.uint32();
              switch (tag >>> 3) {
                case 1: {
                  obj.topicID = reader.string();
                  break;
                }
                default: {
                  reader.skipType(tag & 7);
                  break;
                }
              }
            }
            return obj;
          });
        }
        return _codec2;
      };
      ControlGraft2.encode = (obj) => {
        return encodeMessage(obj, ControlGraft2.codec());
      };
      ControlGraft2.decode = (buf, opts) => {
        return decodeMessage(buf, ControlGraft2.codec(), opts);
      };
    })(ControlGraft = RPC3.ControlGraft || (RPC3.ControlGraft = {}));
    let ControlPrune;
    (function(ControlPrune2) {
      let _codec2;
      ControlPrune2.codec = () => {
        if (_codec2 == null) {
          _codec2 = message((obj, w2, opts = {}) => {
            if (opts.lengthDelimited !== false) {
              w2.fork();
            }
            if (obj.topicID != null) {
              w2.uint32(10);
              w2.string(obj.topicID);
            }
            if (obj.peers != null) {
              for (const value of obj.peers) {
                w2.uint32(18);
                RPC3.PeerInfo.codec().encode(value, w2);
              }
            }
            if (obj.backoff != null) {
              w2.uint32(24);
              w2.uint64Number(obj.backoff);
            }
            if (opts.lengthDelimited !== false) {
              w2.ldelim();
            }
          }, (reader, length4, opts = {}) => {
            var _a2, _b2;
            const obj = {
              peers: []
            };
            const end = length4 == null ? reader.len : reader.pos + length4;
            while (reader.pos < end) {
              const tag = reader.uint32();
              switch (tag >>> 3) {
                case 1: {
                  obj.topicID = reader.string();
                  break;
                }
                case 2: {
                  if (((_a2 = opts.limits) == null ? void 0 : _a2.peers) != null && obj.peers.length === opts.limits.peers) {
                    throw new MaxLengthError('Decode error - map field "peers" had too many elements');
                  }
                  obj.peers.push(RPC3.PeerInfo.codec().decode(reader, reader.uint32(), {
                    limits: (_b2 = opts.limits) == null ? void 0 : _b2.peers$
                  }));
                  break;
                }
                case 3: {
                  obj.backoff = reader.uint64Number();
                  break;
                }
                default: {
                  reader.skipType(tag & 7);
                  break;
                }
              }
            }
            return obj;
          });
        }
        return _codec2;
      };
      ControlPrune2.encode = (obj) => {
        return encodeMessage(obj, ControlPrune2.codec());
      };
      ControlPrune2.decode = (buf, opts) => {
        return decodeMessage(buf, ControlPrune2.codec(), opts);
      };
    })(ControlPrune = RPC3.ControlPrune || (RPC3.ControlPrune = {}));
    let PeerInfo2;
    (function(PeerInfo3) {
      let _codec2;
      PeerInfo3.codec = () => {
        if (_codec2 == null) {
          _codec2 = message((obj, w2, opts = {}) => {
            if (opts.lengthDelimited !== false) {
              w2.fork();
            }
            if (obj.peerID != null) {
              w2.uint32(10);
              w2.bytes(obj.peerID);
            }
            if (obj.signedPeerRecord != null) {
              w2.uint32(18);
              w2.bytes(obj.signedPeerRecord);
            }
            if (opts.lengthDelimited !== false) {
              w2.ldelim();
            }
          }, (reader, length4, opts = {}) => {
            const obj = {};
            const end = length4 == null ? reader.len : reader.pos + length4;
            while (reader.pos < end) {
              const tag = reader.uint32();
              switch (tag >>> 3) {
                case 1: {
                  obj.peerID = reader.bytes();
                  break;
                }
                case 2: {
                  obj.signedPeerRecord = reader.bytes();
                  break;
                }
                default: {
                  reader.skipType(tag & 7);
                  break;
                }
              }
            }
            return obj;
          });
        }
        return _codec2;
      };
      PeerInfo3.encode = (obj) => {
        return encodeMessage(obj, PeerInfo3.codec());
      };
      PeerInfo3.decode = (buf, opts) => {
        return decodeMessage(buf, PeerInfo3.codec(), opts);
      };
    })(PeerInfo2 = RPC3.PeerInfo || (RPC3.PeerInfo = {}));
    let ControlIDontWant;
    (function(ControlIDontWant2) {
      let _codec2;
      ControlIDontWant2.codec = () => {
        if (_codec2 == null) {
          _codec2 = message((obj, w2, opts = {}) => {
            if (opts.lengthDelimited !== false) {
              w2.fork();
            }
            if (obj.messageIDs != null) {
              for (const value of obj.messageIDs) {
                w2.uint32(10);
                w2.bytes(value);
              }
            }
            if (opts.lengthDelimited !== false) {
              w2.ldelim();
            }
          }, (reader, length4, opts = {}) => {
            var _a2;
            const obj = {
              messageIDs: []
            };
            const end = length4 == null ? reader.len : reader.pos + length4;
            while (reader.pos < end) {
              const tag = reader.uint32();
              switch (tag >>> 3) {
                case 1: {
                  if (((_a2 = opts.limits) == null ? void 0 : _a2.messageIDs) != null && obj.messageIDs.length === opts.limits.messageIDs) {
                    throw new MaxLengthError('Decode error - map field "messageIDs" had too many elements');
                  }
                  obj.messageIDs.push(reader.bytes());
                  break;
                }
                default: {
                  reader.skipType(tag & 7);
                  break;
                }
              }
            }
            return obj;
          });
        }
        return _codec2;
      };
      ControlIDontWant2.encode = (obj) => {
        return encodeMessage(obj, ControlIDontWant2.codec());
      };
      ControlIDontWant2.decode = (buf, opts) => {
        return decodeMessage(buf, ControlIDontWant2.codec(), opts);
      };
    })(ControlIDontWant = RPC3.ControlIDontWant || (RPC3.ControlIDontWant = {}));
    let _codec;
    RPC3.codec = () => {
      if (_codec == null) {
        _codec = message((obj, w2, opts = {}) => {
          if (opts.lengthDelimited !== false) {
            w2.fork();
          }
          if (obj.subscriptions != null) {
            for (const value of obj.subscriptions) {
              w2.uint32(10);
              RPC3.SubOpts.codec().encode(value, w2);
            }
          }
          if (obj.messages != null) {
            for (const value of obj.messages) {
              w2.uint32(18);
              RPC3.Message.codec().encode(value, w2);
            }
          }
          if (obj.control != null) {
            w2.uint32(26);
            RPC3.ControlMessage.codec().encode(obj.control, w2);
          }
          if (opts.lengthDelimited !== false) {
            w2.ldelim();
          }
        }, (reader, length4, opts = {}) => {
          var _a2, _b2, _c, _d, _e;
          const obj = {
            subscriptions: [],
            messages: []
          };
          const end = length4 == null ? reader.len : reader.pos + length4;
          while (reader.pos < end) {
            const tag = reader.uint32();
            switch (tag >>> 3) {
              case 1: {
                if (((_a2 = opts.limits) == null ? void 0 : _a2.subscriptions) != null && obj.subscriptions.length === opts.limits.subscriptions) {
                  throw new MaxLengthError('Decode error - map field "subscriptions" had too many elements');
                }
                obj.subscriptions.push(RPC3.SubOpts.codec().decode(reader, reader.uint32(), {
                  limits: (_b2 = opts.limits) == null ? void 0 : _b2.subscriptions$
                }));
                break;
              }
              case 2: {
                if (((_c = opts.limits) == null ? void 0 : _c.messages) != null && obj.messages.length === opts.limits.messages) {
                  throw new MaxLengthError('Decode error - map field "messages" had too many elements');
                }
                obj.messages.push(RPC3.Message.codec().decode(reader, reader.uint32(), {
                  limits: (_d = opts.limits) == null ? void 0 : _d.messages$
                }));
                break;
              }
              case 3: {
                obj.control = RPC3.ControlMessage.codec().decode(reader, reader.uint32(), {
                  limits: (_e = opts.limits) == null ? void 0 : _e.control
                });
                break;
              }
              default: {
                reader.skipType(tag & 7);
                break;
              }
            }
          }
          return obj;
        });
      }
      return _codec;
    };
    RPC3.encode = (obj) => {
      return encodeMessage(obj, RPC3.codec());
    };
    RPC3.decode = (buf, opts) => {
      return decodeMessage(buf, RPC3.codec(), opts);
    };
  })(RPC || (RPC = {}));

  // node_modules/@chainsafe/libp2p-gossipsub/dist/src/message-cache.js
  var import_browser_shims282 = __toESM(require_browser_shims(), 1);
  var MessageCache = class {
    gossip;
    msgs = /* @__PURE__ */ new Map();
    msgIdToStrFn;
    history = [];
    /** Track with accounting of messages in the mcache that are not yet validated */
    notValidatedCount = 0;
    /**
     * Holds history of messages in timebounded history arrays
     */
    constructor(gossip, historyCapacity, msgIdToStrFn) {
      this.gossip = gossip;
      this.msgIdToStrFn = msgIdToStrFn;
      for (let i = 0; i < historyCapacity; i++) {
        this.history[i] = [];
      }
    }
    get size() {
      return this.msgs.size;
    }
    /**
     * Adds a message to the current window and the cache
     * Returns true if the message is not known and is inserted in the cache
     */
    put(messageId, msg, validated = false) {
      const { msgIdStr } = messageId;
      if (this.msgs.has(msgIdStr)) {
        return false;
      }
      this.msgs.set(msgIdStr, {
        message: msg,
        validated,
        originatingPeers: /* @__PURE__ */ new Set(),
        iwantCounts: /* @__PURE__ */ new Map()
      });
      this.history[0].push({ ...messageId, topic: msg.topic });
      if (!validated) {
        this.notValidatedCount++;
      }
      return true;
    }
    observeDuplicate(msgId2, fromPeerIdStr) {
      const entry = this.msgs.get(msgId2);
      if (entry != null && // if the message is already validated, we don't need to store extra peers sending us
      // duplicates as the message has already been forwarded
      !entry.validated) {
        entry.originatingPeers.add(fromPeerIdStr);
      }
    }
    /**
     * Retrieves a message from the cache by its ID, if it is still present
     */
    get(msgId2) {
      var _a2;
      return (_a2 = this.msgs.get(this.msgIdToStrFn(msgId2))) == null ? void 0 : _a2.message;
    }
    /**
     * Increases the iwant count for the given message by one and returns the message together
     * with the iwant if the message exists.
     */
    getWithIWantCount(msgIdStr, p) {
      const msg = this.msgs.get(msgIdStr);
      if (msg == null) {
        return null;
      }
      const count = (msg.iwantCounts.get(p) ?? 0) + 1;
      msg.iwantCounts.set(p, count);
      return { msg: msg.message, count };
    }
    /**
     * Retrieves a list of message IDs for a set of topics
     */
    getGossipIDs(topics) {
      const msgIdsByTopic = /* @__PURE__ */ new Map();
      for (let i = 0; i < this.gossip; i++) {
        this.history[i].forEach((entry) => {
          const msg = this.msgs.get(entry.msgIdStr);
          if (((msg == null ? void 0 : msg.validated) ?? false) && topics.has(entry.topic)) {
            let msgIds = msgIdsByTopic.get(entry.topic);
            if (msgIds == null) {
              msgIds = [];
              msgIdsByTopic.set(entry.topic, msgIds);
            }
            msgIds.push(entry.msgId);
          }
        });
      }
      return msgIdsByTopic;
    }
    /**
     * Gets a message with msgId and tags it as validated.
     * This function also returns the known peers that have sent us this message. This is used to
     * prevent us sending redundant messages to peers who have already propagated it.
     */
    validate(msgId2) {
      const entry = this.msgs.get(msgId2);
      if (entry == null) {
        return null;
      }
      if (!entry.validated) {
        this.notValidatedCount--;
      }
      const { message: message2, originatingPeers } = entry;
      entry.validated = true;
      entry.originatingPeers = /* @__PURE__ */ new Set();
      return { message: message2, originatingPeers };
    }
    /**
     * Shifts the current window, discarding messages older than this.history.length of the cache
     */
    shift() {
      const lastCacheEntries = this.history[this.history.length - 1];
      lastCacheEntries.forEach((cacheEntry) => {
        const entry = this.msgs.get(cacheEntry.msgIdStr);
        if (entry != null) {
          this.msgs.delete(cacheEntry.msgIdStr);
          if (!entry.validated) {
            this.notValidatedCount--;
          }
        }
      });
      this.history.pop();
      this.history.unshift([]);
    }
    remove(msgId2) {
      const entry = this.msgs.get(msgId2);
      if (entry == null) {
        return null;
      }
      this.msgs.delete(msgId2);
      return entry;
    }
  };

  // node_modules/@chainsafe/libp2p-gossipsub/dist/src/metrics.js
  var import_browser_shims284 = __toESM(require_browser_shims(), 1);

  // node_modules/@chainsafe/libp2p-gossipsub/dist/src/types.js
  var import_browser_shims283 = __toESM(require_browser_shims(), 1);
  var SignaturePolicy;
  (function(SignaturePolicy2) {
    SignaturePolicy2["StrictSign"] = "StrictSign";
    SignaturePolicy2["StrictNoSign"] = "StrictNoSign";
  })(SignaturePolicy || (SignaturePolicy = {}));
  var PublishConfigType;
  (function(PublishConfigType2) {
    PublishConfigType2[PublishConfigType2["Signing"] = 0] = "Signing";
    PublishConfigType2[PublishConfigType2["Anonymous"] = 1] = "Anonymous";
  })(PublishConfigType || (PublishConfigType = {}));
  var RejectReason;
  (function(RejectReason2) {
    RejectReason2["Error"] = "error";
    RejectReason2["Ignore"] = "ignore";
    RejectReason2["Reject"] = "reject";
    RejectReason2["Blacklisted"] = "blacklisted";
  })(RejectReason || (RejectReason = {}));
  var ValidateError;
  (function(ValidateError2) {
    ValidateError2["InvalidSignature"] = "invalid_signature";
    ValidateError2["InvalidSeqno"] = "invalid_seqno";
    ValidateError2["InvalidPeerId"] = "invalid_peerid";
    ValidateError2["SignaturePresent"] = "signature_present";
    ValidateError2["SeqnoPresent"] = "seqno_present";
    ValidateError2["FromPresent"] = "from_present";
    ValidateError2["TransformFailed"] = "transform_failed";
  })(ValidateError || (ValidateError = {}));
  var MessageStatus;
  (function(MessageStatus2) {
    MessageStatus2["duplicate"] = "duplicate";
    MessageStatus2["invalid"] = "invalid";
    MessageStatus2["valid"] = "valid";
  })(MessageStatus || (MessageStatus = {}));
  function rejectReasonFromAcceptance(acceptance) {
    switch (acceptance) {
      case TopicValidatorResult.Ignore:
        return RejectReason.Ignore;
      case TopicValidatorResult.Reject:
        return RejectReason.Reject;
      default:
        throw new Error("Unreachable");
    }
  }

  // node_modules/@chainsafe/libp2p-gossipsub/dist/src/metrics.js
  var MessageSource;
  (function(MessageSource2) {
    MessageSource2["forward"] = "forward";
    MessageSource2["publish"] = "publish";
  })(MessageSource || (MessageSource = {}));
  var InclusionReason;
  (function(InclusionReason2) {
    InclusionReason2["Fanout"] = "fanout";
    InclusionReason2["Random"] = "random";
    InclusionReason2["Subscribed"] = "subscribed";
    InclusionReason2["Outbound"] = "outbound";
    InclusionReason2["NotEnough"] = "not_enough";
    InclusionReason2["Opportunistic"] = "opportunistic";
  })(InclusionReason || (InclusionReason = {}));
  var ChurnReason;
  (function(ChurnReason2) {
    ChurnReason2["Dc"] = "disconnected";
    ChurnReason2["BadScore"] = "bad_score";
    ChurnReason2["Prune"] = "prune";
    ChurnReason2["Excess"] = "excess";
  })(ChurnReason || (ChurnReason = {}));
  var ScorePenalty;
  (function(ScorePenalty2) {
    ScorePenalty2["GraftBackoff"] = "graft_backoff";
    ScorePenalty2["BrokenPromise"] = "broken_promise";
    ScorePenalty2["MessageDeficit"] = "message_deficit";
    ScorePenalty2["IPColocation"] = "IP_colocation";
  })(ScorePenalty || (ScorePenalty = {}));
  var IHaveIgnoreReason;
  (function(IHaveIgnoreReason2) {
    IHaveIgnoreReason2["LowScore"] = "low_score";
    IHaveIgnoreReason2["MaxIhave"] = "max_ihave";
    IHaveIgnoreReason2["MaxIasked"] = "max_iasked";
  })(IHaveIgnoreReason || (IHaveIgnoreReason = {}));
  var ScoreThreshold;
  (function(ScoreThreshold2) {
    ScoreThreshold2["graylist"] = "graylist";
    ScoreThreshold2["publish"] = "publish";
    ScoreThreshold2["gossip"] = "gossip";
    ScoreThreshold2["mesh"] = "mesh";
  })(ScoreThreshold || (ScoreThreshold = {}));
  function getMetrics(register, topicStrToLabel, opts) {
    return {
      /* Metrics for static config */
      protocolsEnabled: register.gauge({
        name: "gossipsub_protocol",
        help: "Status of enabled protocols",
        labelNames: ["protocol"]
      }),
      /* Metrics per known topic */
      /**
       * Status of our subscription to this topic. This metric allows analyzing other topic metrics
       * filtered by our current subscription status.
       * = rust-libp2p `topic_subscription_status` */
      topicSubscriptionStatus: register.gauge({
        name: "gossipsub_topic_subscription_status",
        help: "Status of our subscription to this topic",
        labelNames: ["topicStr"]
      }),
      /** Number of peers subscribed to each topic. This allows us to analyze a topic's behaviour
       * regardless of our subscription status. */
      topicPeersCount: register.gauge({
        name: "gossipsub_topic_peer_count",
        help: "Number of peers subscribed to each topic",
        labelNames: ["topicStr"]
      }),
      /* Metrics regarding mesh state */
      /**
       * Number of peers in our mesh. This metric should be updated with the count of peers for a
       * topic in the mesh regardless of inclusion and churn events.
       * = rust-libp2p `mesh_peer_counts` */
      meshPeerCounts: register.gauge({
        name: "gossipsub_mesh_peer_count",
        help: "Number of peers in our mesh",
        labelNames: ["topicStr"]
      }),
      /**
       * Number of times we include peers in a topic mesh for different reasons.
       * = rust-libp2p `mesh_peer_inclusion_events` */
      meshPeerInclusionEventsFanout: register.gauge({
        name: "gossipsub_mesh_peer_inclusion_events_fanout_total",
        help: "Number of times we include peers in a topic mesh for fanout reasons",
        labelNames: ["topic"]
      }),
      meshPeerInclusionEventsRandom: register.gauge({
        name: "gossipsub_mesh_peer_inclusion_events_random_total",
        help: "Number of times we include peers in a topic mesh for random reasons",
        labelNames: ["topic"]
      }),
      meshPeerInclusionEventsSubscribed: register.gauge({
        name: "gossipsub_mesh_peer_inclusion_events_subscribed_total",
        help: "Number of times we include peers in a topic mesh for subscribed reasons",
        labelNames: ["topic"]
      }),
      meshPeerInclusionEventsOutbound: register.gauge({
        name: "gossipsub_mesh_peer_inclusion_events_outbound_total",
        help: "Number of times we include peers in a topic mesh for outbound reasons",
        labelNames: ["topic"]
      }),
      meshPeerInclusionEventsNotEnough: register.gauge({
        name: "gossipsub_mesh_peer_inclusion_events_not_enough_total",
        help: "Number of times we include peers in a topic mesh for not_enough reasons",
        labelNames: ["topic"]
      }),
      meshPeerInclusionEventsOpportunistic: register.gauge({
        name: "gossipsub_mesh_peer_inclusion_events_opportunistic_total",
        help: "Number of times we include peers in a topic mesh for opportunistic reasons",
        labelNames: ["topic"]
      }),
      meshPeerInclusionEventsUnknown: register.gauge({
        name: "gossipsub_mesh_peer_inclusion_events_unknown_total",
        help: "Number of times we include peers in a topic mesh for unknown reasons",
        labelNames: ["topic"]
      }),
      /**
       * Number of times we remove peers in a topic mesh for different reasons.
       * = rust-libp2p `mesh_peer_churn_events` */
      meshPeerChurnEventsDisconnected: register.gauge({
        name: "gossipsub_peer_churn_events_disconnected_total",
        help: "Number of times we remove peers in a topic mesh for disconnected reasons",
        labelNames: ["topic"]
      }),
      meshPeerChurnEventsBadScore: register.gauge({
        name: "gossipsub_peer_churn_events_bad_score_total",
        help: "Number of times we remove peers in a topic mesh for bad_score reasons",
        labelNames: ["topic"]
      }),
      meshPeerChurnEventsPrune: register.gauge({
        name: "gossipsub_peer_churn_events_prune_total",
        help: "Number of times we remove peers in a topic mesh for prune reasons",
        labelNames: ["topic"]
      }),
      meshPeerChurnEventsExcess: register.gauge({
        name: "gossipsub_peer_churn_events_excess_total",
        help: "Number of times we remove peers in a topic mesh for excess reasons",
        labelNames: ["topic"]
      }),
      meshPeerChurnEventsUnknown: register.gauge({
        name: "gossipsub_peer_churn_events_unknown_total",
        help: "Number of times we remove peers in a topic mesh for unknown reasons",
        labelNames: ["topic"]
      }),
      /* General Metrics */
      /**
       * Gossipsub supports floodsub, gossipsub v1.0, v1.1, and v1.2. Peers are classified based
       * on which protocol they support. This metric keeps track of the number of peers that are
       * connected of each type. */
      peersPerProtocol: register.gauge({
        name: "gossipsub_peers_per_protocol_count",
        help: "Peers connected for each topic",
        labelNames: ["protocol"]
      }),
      /** The time it takes to complete one iteration of the heartbeat. */
      heartbeatDuration: register.histogram({
        name: "gossipsub_heartbeat_duration_seconds",
        help: "The time it takes to complete one iteration of the heartbeat",
        // Should take <10ms, over 1s it's a huge issue that needs debugging, since a heartbeat will be cancelled
        buckets: [0.01, 0.1, 1]
      }),
      /** Heartbeat run took longer than heartbeat interval so next is skipped */
      heartbeatSkipped: register.gauge({
        name: "gossipsub_heartbeat_skipped",
        help: "Heartbeat run took longer than heartbeat interval so next is skipped"
      }),
      /**
       * Message validation results for each topic.
       * Invalid == Reject?
       * = rust-libp2p `invalid_messages`, `accepted_messages`, `ignored_messages`, `rejected_messages` */
      acceptedMessagesTotal: register.gauge({
        name: "gossipsub_accepted_messages_total",
        help: "Total accepted messages for each topic",
        labelNames: ["topic"]
      }),
      ignoredMessagesTotal: register.gauge({
        name: "gossipsub_ignored_messages_total",
        help: "Total ignored messages for each topic",
        labelNames: ["topic"]
      }),
      rejectedMessagesTotal: register.gauge({
        name: "gossipsub_rejected_messages_total",
        help: "Total rejected messages for each topic",
        labelNames: ["topic"]
      }),
      unknownValidationResultsTotal: register.gauge({
        name: "gossipsub_unknown_validation_results_total",
        help: "Total unknown validation results for each topic",
        labelNames: ["topic"]
      }),
      /**
       * When the user validates a message, it tries to re propagate it to its mesh peers. If the
       * message expires from the memcache before it can be validated, we count this a cache miss
       * and it is an indicator that the memcache size should be increased.
       * = rust-libp2p `mcache_misses` */
      asyncValidationMcacheHit: register.gauge({
        name: "gossipsub_async_validation_mcache_hit_total",
        help: "Async validation result reported by the user layer",
        labelNames: ["hit"]
      }),
      asyncValidationDelayFromFirstSeenSec: register.histogram({
        name: "gossipsub_async_validation_delay_from_first_seen",
        help: "Async validation report delay from first seen in second",
        buckets: [0.01, 0.03, 0.1, 0.3, 1, 3, 10]
      }),
      asyncValidationUnknownFirstSeen: register.gauge({
        name: "gossipsub_async_validation_unknown_first_seen_count_total",
        help: "Async validation report unknown first seen value for message"
      }),
      // peer stream
      peerReadStreamError: register.gauge({
        name: "gossipsub_peer_read_stream_err_count_total",
        help: "Peer read stream error"
      }),
      // RPC outgoing. Track byte length + data structure sizes
      rpcRecvBytes: register.gauge({ name: "gossipsub_rpc_recv_bytes_total", help: "RPC recv" }),
      rpcRecvCount: register.gauge({ name: "gossipsub_rpc_recv_count_total", help: "RPC recv" }),
      rpcRecvSubscription: register.gauge({ name: "gossipsub_rpc_recv_subscription_total", help: "RPC recv" }),
      rpcRecvMessage: register.gauge({ name: "gossipsub_rpc_recv_message_total", help: "RPC recv" }),
      rpcRecvControl: register.gauge({ name: "gossipsub_rpc_recv_control_total", help: "RPC recv" }),
      rpcRecvIHave: register.gauge({ name: "gossipsub_rpc_recv_ihave_total", help: "RPC recv" }),
      rpcRecvIWant: register.gauge({ name: "gossipsub_rpc_recv_iwant_total", help: "RPC recv" }),
      rpcRecvGraft: register.gauge({ name: "gossipsub_rpc_recv_graft_total", help: "RPC recv" }),
      rpcRecvPrune: register.gauge({ name: "gossipsub_rpc_recv_prune_total", help: "RPC recv" }),
      rpcDataError: register.gauge({ name: "gossipsub_rpc_data_err_count_total", help: "RPC data error" }),
      rpcRecvError: register.gauge({ name: "gossipsub_rpc_recv_err_count_total", help: "RPC recv error" }),
      /** Total count of RPC dropped because acceptFrom() == false */
      rpcRecvNotAccepted: register.gauge({
        name: "gossipsub_rpc_rcv_not_accepted_total",
        help: "Total count of RPC dropped because acceptFrom() == false"
      }),
      // RPC incoming. Track byte length + data structure sizes
      rpcSentBytes: register.gauge({ name: "gossipsub_rpc_sent_bytes_total", help: "RPC sent" }),
      rpcSentCount: register.gauge({ name: "gossipsub_rpc_sent_count_total", help: "RPC sent" }),
      rpcSentSubscription: register.gauge({ name: "gossipsub_rpc_sent_subscription_total", help: "RPC sent" }),
      rpcSentMessage: register.gauge({ name: "gossipsub_rpc_sent_message_total", help: "RPC sent" }),
      rpcSentControl: register.gauge({ name: "gossipsub_rpc_sent_control_total", help: "RPC sent" }),
      rpcSentIHave: register.gauge({ name: "gossipsub_rpc_sent_ihave_total", help: "RPC sent" }),
      rpcSentIWant: register.gauge({ name: "gossipsub_rpc_sent_iwant_total", help: "RPC sent" }),
      rpcSentGraft: register.gauge({ name: "gossipsub_rpc_sent_graft_total", help: "RPC sent" }),
      rpcSentPrune: register.gauge({ name: "gossipsub_rpc_sent_prune_total", help: "RPC sent" }),
      rpcSentIDontWant: register.gauge({ name: "gossipsub_rpc_sent_idontwant_total", help: "RPC sent" }),
      // publish message. Track peers sent to and bytes
      /** Total count of msg published by topic */
      msgPublishCount: register.gauge({
        name: "gossipsub_msg_publish_count_total",
        help: "Total count of msg published by topic",
        labelNames: ["topic"]
      }),
      /** Total count of peers that we publish a msg to */
      msgPublishPeersByTopic: register.gauge({
        name: "gossipsub_msg_publish_peers_total",
        help: "Total count of peers that we publish a msg to",
        labelNames: ["topic"]
      }),
      /** Total count of peers (by group) that we publish a msg to */
      directPeersPublishedTotal: register.gauge({
        name: "gossipsub_direct_peers_published_total",
        help: "Total direct peers that we publish a msg to",
        labelNames: ["topic"]
      }),
      floodsubPeersPublishedTotal: register.gauge({
        name: "gossipsub_floodsub_peers_published_total",
        help: "Total floodsub peers that we publish a msg to",
        labelNames: ["topic"]
      }),
      meshPeersPublishedTotal: register.gauge({
        name: "gossipsub_mesh_peers_published_total",
        help: "Total mesh peers that we publish a msg to",
        labelNames: ["topic"]
      }),
      fanoutPeersPublishedTotal: register.gauge({
        name: "gossipsub_fanout_peers_published_total",
        help: "Total fanout peers that we publish a msg to",
        labelNames: ["topic"]
      }),
      /** Total count of msg publish data.length bytes */
      msgPublishBytes: register.gauge({
        name: "gossipsub_msg_publish_bytes_total",
        help: "Total count of msg publish data.length bytes",
        labelNames: ["topic"]
      }),
      /** Total time in seconds to publish a message */
      msgPublishTime: register.histogram({
        name: "gossipsub_msg_publish_seconds",
        help: "Total time in seconds to publish a message",
        buckets: [1e-3, 2e-3, 5e-3, 0.01, 0.1, 0.5, 1],
        labelNames: ["topic"]
      }),
      /** Total count of msg forwarded by topic */
      msgForwardCount: register.gauge({
        name: "gossipsub_msg_forward_count_total",
        help: "Total count of msg forwarded by topic",
        labelNames: ["topic"]
      }),
      /** Total count of peers that we forward a msg to */
      msgForwardPeers: register.gauge({
        name: "gossipsub_msg_forward_peers_total",
        help: "Total count of peers that we forward a msg to",
        labelNames: ["topic"]
      }),
      /** Total count of recv msgs before any validation */
      msgReceivedPreValidation: register.gauge({
        name: "gossipsub_msg_received_prevalidation_total",
        help: "Total count of recv msgs before any validation",
        labelNames: ["topic"]
      }),
      /** Total count of recv msgs error */
      msgReceivedError: register.gauge({
        name: "gossipsub_msg_received_error_total",
        help: "Total count of recv msgs error",
        labelNames: ["topic"]
      }),
      /** Tracks distribution of recv msgs by duplicate, invalid, valid */
      prevalidationInvalidTotal: register.gauge({
        name: "gossipsub_pre_validation_invalid_total",
        help: "Total count of invalid messages received",
        labelNames: ["topic"]
      }),
      prevalidationValidTotal: register.gauge({
        name: "gossipsub_pre_validation_valid_total",
        help: "Total count of valid messages received",
        labelNames: ["topic"]
      }),
      prevalidationDuplicateTotal: register.gauge({
        name: "gossipsub_pre_validation_duplicate_total",
        help: "Total count of duplicate messages received",
        labelNames: ["topic"]
      }),
      prevalidationUnknownTotal: register.gauge({
        name: "gossipsub_pre_validation_unknown_status_total",
        help: "Total count of unknown_status messages received",
        labelNames: ["topic"]
      }),
      /** Tracks specific reason of invalid */
      msgReceivedInvalid: register.gauge({
        name: "gossipsub_msg_received_invalid_total",
        help: "Tracks specific reason of invalid",
        labelNames: ["error"]
      }),
      msgReceivedInvalidByTopic: register.gauge({
        name: "gossipsub_msg_received_invalid_by_topic_total",
        help: "Tracks specific invalid message by topic",
        labelNames: ["topic"]
      }),
      /** Track duplicate message delivery time */
      duplicateMsgDeliveryDelay: register.histogram({
        name: "gossisub_duplicate_msg_delivery_delay_seconds",
        help: "Time since the 1st duplicated message validated",
        labelNames: ["topic"],
        buckets: [
          0.25 * opts.maxMeshMessageDeliveriesWindowSec,
          0.5 * opts.maxMeshMessageDeliveriesWindowSec,
          Number(opts.maxMeshMessageDeliveriesWindowSec),
          2 * opts.maxMeshMessageDeliveriesWindowSec,
          4 * opts.maxMeshMessageDeliveriesWindowSec
        ]
      }),
      /** Total count of late msg delivery total by topic */
      duplicateMsgLateDelivery: register.gauge({
        name: "gossisub_duplicate_msg_late_delivery_total",
        help: "Total count of late duplicate message delivery by topic, which triggers P3 penalty",
        labelNames: ["topic"]
      }),
      duplicateMsgIgnored: register.gauge({
        name: "gossisub_ignored_published_duplicate_msgs_total",
        help: "Total count of published duplicate message ignored by topic",
        labelNames: ["topic"]
      }),
      /* Metrics related to scoring */
      /** Total times score() is called */
      scoreFnCalls: register.gauge({
        name: "gossipsub_score_fn_calls_total",
        help: "Total times score() is called"
      }),
      /** Total times score() call actually computed computeScore(), no cache */
      scoreFnRuns: register.gauge({
        name: "gossipsub_score_fn_runs_total",
        help: "Total times score() call actually computed computeScore(), no cache"
      }),
      scoreCachedDelta: register.histogram({
        name: "gossipsub_score_cache_delta",
        help: "Delta of score between cached values that expired",
        buckets: [10, 100, 1e3]
      }),
      /** Current count of peers by score threshold */
      peersByScoreThreshold: register.gauge({
        name: "gossipsub_peers_by_score_threshold_count",
        help: "Current count of peers by score threshold",
        labelNames: ["threshold"]
      }),
      score: register.avgMinMax({
        name: "gossipsub_score",
        help: "Avg min max of gossip scores"
      }),
      /**
       * Separate score weights
       * Need to use 2-label metrics in this case to debug the score weights
       **/
      scoreWeights: register.avgMinMax({
        name: "gossipsub_score_weights",
        help: "Separate score weights",
        labelNames: ["topic", "p"]
      }),
      /** Histogram of the scores for each mesh topic. */
      // TODO: Not implemented
      scorePerMesh: register.avgMinMax({
        name: "gossipsub_score_per_mesh",
        help: "Histogram of the scores for each mesh topic",
        labelNames: ["topic"]
      }),
      /** A counter of the kind of penalties being applied to peers. */
      // TODO: Not fully implemented
      scoringPenalties: register.gauge({
        name: "gossipsub_scoring_penalties_total",
        help: "A counter of the kind of penalties being applied to peers",
        labelNames: ["penalty"]
      }),
      behaviourPenalty: register.histogram({
        name: "gossipsub_peer_stat_behaviour_penalty",
        help: "Current peer stat behaviour_penalty at each scrape",
        buckets: [
          0.25 * opts.behaviourPenaltyThreshold,
          0.5 * opts.behaviourPenaltyThreshold,
          Number(opts.behaviourPenaltyThreshold),
          2 * opts.behaviourPenaltyThreshold,
          4 * opts.behaviourPenaltyThreshold
        ]
      }),
      // TODO:
      // - iasked per peer (on heartbeat)
      // - when promise is resolved, track messages from promises
      /** Total received IHAVE messages that we ignore for some reason */
      ihaveRcvIgnored: register.gauge({
        name: "gossipsub_ihave_rcv_ignored_total",
        help: "Total received IHAVE messages that we ignore for some reason",
        labelNames: ["reason"]
      }),
      /** Total received IHAVE messages by topic */
      ihaveRcvMsgids: register.gauge({
        name: "gossipsub_ihave_rcv_msgids_total",
        help: "Total received IHAVE messages by topic",
        labelNames: ["topic"]
      }),
      /**
       * Total messages per topic we don't have. Not actual requests.
       * The number of times we have decided that an IWANT control message is required for this
       * topic. A very high metric might indicate an underperforming network.
       * = rust-libp2p `topic_iwant_msgs` */
      ihaveRcvNotSeenMsgids: register.gauge({
        name: "gossipsub_ihave_rcv_not_seen_msgids_total",
        help: "Total messages per topic we do not have, not actual requests",
        labelNames: ["topic"]
      }),
      /** Total received IWANT messages by topic */
      iwantRcvMsgids: register.gauge({
        name: "gossipsub_iwant_rcv_msgids_total",
        help: "Total received IWANT messages by topic",
        labelNames: ["topic"]
      }),
      /** Total requested messageIDs that we don't have */
      iwantRcvDonthaveMsgids: register.gauge({
        name: "gossipsub_iwant_rcv_dont_have_msgids_total",
        help: "Total requested messageIDs that we do not have"
      }),
      /** Total received IDONTWANT messages */
      idontwantRcvMsgids: register.gauge({
        name: "gossipsub_idontwant_rcv_msgids_total",
        help: "Total received IDONTWANT messages"
      }),
      /** Total received IDONTWANT messageIDs that we don't have */
      idontwantRcvDonthaveMsgids: register.gauge({
        name: "gossipsub_idontwant_rcv_dont_have_msgids_total",
        help: "Total received IDONTWANT messageIDs that we do not have in mcache"
      }),
      iwantPromiseStarted: register.gauge({
        name: "gossipsub_iwant_promise_sent_total",
        help: "Total count of started IWANT promises"
      }),
      /** Total count of resolved IWANT promises */
      iwantPromiseResolved: register.gauge({
        name: "gossipsub_iwant_promise_resolved_total",
        help: "Total count of resolved IWANT promises"
      }),
      /** Total count of resolved IWANT promises from duplicate messages */
      iwantPromiseResolvedFromDuplicate: register.gauge({
        name: "gossipsub_iwant_promise_resolved_from_duplicate_total",
        help: "Total count of resolved IWANT promises from duplicate messages"
      }),
      /** Total count of peers we have asked IWANT promises that are resolved */
      iwantPromiseResolvedPeers: register.gauge({
        name: "gossipsub_iwant_promise_resolved_peers",
        help: "Total count of peers we have asked IWANT promises that are resolved"
      }),
      iwantPromiseBroken: register.gauge({
        name: "gossipsub_iwant_promise_broken",
        help: "Total count of broken IWANT promises"
      }),
      iwantMessagePruned: register.gauge({
        name: "gossipsub_iwant_message_pruned",
        help: "Total count of pruned IWANT messages"
      }),
      /** Histogram of delivery time of resolved IWANT promises */
      iwantPromiseDeliveryTime: register.histogram({
        name: "gossipsub_iwant_promise_delivery_seconds",
        help: "Histogram of delivery time of resolved IWANT promises",
        buckets: [
          0.5 * opts.gossipPromiseExpireSec,
          Number(opts.gossipPromiseExpireSec),
          2 * opts.gossipPromiseExpireSec,
          4 * opts.gossipPromiseExpireSec
        ]
      }),
      iwantPromiseUntracked: register.gauge({
        name: "gossip_iwant_promise_untracked",
        help: "Total count of untracked IWANT promise"
      }),
      /** Backoff time */
      connectedPeersBackoffSec: register.histogram({
        name: "gossipsub_connected_peers_backoff_seconds",
        help: "Backoff time in seconds",
        // Using 1 seconds as minimum as that's close to the heartbeat duration, no need for more resolution.
        // As per spec, backoff times are 10 seconds for UnsubscribeBackoff and 60 seconds for PruneBackoff.
        // Higher values of 60 seconds should not occur, but we add 120 seconds just in case
        // https://github.com/libp2p/specs/blob/master/pubsub/gossipsub/gossipsub-v1.1.md#overview-of-new-parameters
        buckets: [1, 2, 4, 10, 20, 60, 120]
      }),
      /* Data structure sizes */
      /** Unbounded cache sizes */
      cacheSize: register.gauge({
        name: "gossipsub_cache_size",
        help: "Unbounded cache sizes",
        labelNames: ["cache"]
      }),
      /** Current mcache msg count */
      mcacheSize: register.gauge({
        name: "gossipsub_mcache_size",
        help: "Current mcache msg count"
      }),
      mcacheNotValidatedCount: register.gauge({
        name: "gossipsub_mcache_not_validated_count",
        help: "Current mcache msg count not validated"
      }),
      fastMsgIdCacheCollision: register.gauge({
        name: "gossipsub_fastmsgid_cache_collision_total",
        help: "Total count of key collisions on fastmsgid cache put"
      }),
      newConnectionCount: register.gauge({
        name: "gossipsub_new_connection_total",
        help: "Total new connection by status",
        labelNames: ["status"]
      }),
      topicStrToLabel,
      toTopic(topicStr) {
        return this.topicStrToLabel.get(topicStr) ?? topicStr;
      },
      /** We joined a topic */
      onJoin(topicStr) {
        this.topicSubscriptionStatus.set({ topicStr }, 1);
        this.meshPeerCounts.set({ topicStr }, 0);
      },
      /** We left a topic */
      onLeave(topicStr) {
        this.topicSubscriptionStatus.set({ topicStr }, 0);
        this.meshPeerCounts.set({ topicStr }, 0);
      },
      /** Register the inclusion of peers in our mesh due to some reason. */
      onAddToMesh(topicStr, reason, count) {
        const topic = this.toTopic(topicStr);
        switch (reason) {
          case InclusionReason.Fanout:
            this.meshPeerInclusionEventsFanout.inc({ topic }, count);
            break;
          case InclusionReason.Random:
            this.meshPeerInclusionEventsRandom.inc({ topic }, count);
            break;
          case InclusionReason.Subscribed:
            this.meshPeerInclusionEventsSubscribed.inc({ topic }, count);
            break;
          case InclusionReason.Outbound:
            this.meshPeerInclusionEventsOutbound.inc({ topic }, count);
            break;
          case InclusionReason.NotEnough:
            this.meshPeerInclusionEventsNotEnough.inc({ topic }, count);
            break;
          case InclusionReason.Opportunistic:
            this.meshPeerInclusionEventsOpportunistic.inc({ topic }, count);
            break;
          default:
            this.meshPeerInclusionEventsUnknown.inc({ topic }, count);
            break;
        }
      },
      /** Register the removal of peers in our mesh due to some reason */
      // - remove_peer_from_mesh()
      // - heartbeat() Churn::BadScore
      // - heartbeat() Churn::Excess
      // - on_disconnect() Churn::Ds
      onRemoveFromMesh(topicStr, reason, count) {
        const topic = this.toTopic(topicStr);
        switch (reason) {
          case ChurnReason.Dc:
            this.meshPeerChurnEventsDisconnected.inc({ topic }, count);
            break;
          case ChurnReason.BadScore:
            this.meshPeerChurnEventsBadScore.inc({ topic }, count);
            break;
          case ChurnReason.Prune:
            this.meshPeerChurnEventsPrune.inc({ topic }, count);
            break;
          case ChurnReason.Excess:
            this.meshPeerChurnEventsExcess.inc({ topic }, count);
            break;
          default:
            this.meshPeerChurnEventsUnknown.inc({ topic }, count);
            break;
        }
      },
      /**
       * Update validation result to metrics
       *
       * @param messageRecord - null means the message's mcache record was not known at the time of acceptance report
       */
      onReportValidation(messageRecord, acceptance, firstSeenTimestampMs) {
        this.asyncValidationMcacheHit.inc({ hit: messageRecord != null ? "hit" : "miss" });
        if (messageRecord != null) {
          const topic = this.toTopic(messageRecord.message.topic);
          switch (acceptance) {
            case TopicValidatorResult.Accept:
              this.acceptedMessagesTotal.inc({ topic });
              break;
            case TopicValidatorResult.Ignore:
              this.ignoredMessagesTotal.inc({ topic });
              break;
            case TopicValidatorResult.Reject:
              this.rejectedMessagesTotal.inc({ topic });
              break;
            default:
              this.unknownValidationResultsTotal.inc({ topic });
              break;
          }
        }
        if (firstSeenTimestampMs != null) {
          this.asyncValidationDelayFromFirstSeenSec.observe((Date.now() - firstSeenTimestampMs) / 1e3);
        } else {
          this.asyncValidationUnknownFirstSeen.inc();
        }
      },
      /**
       * - in handle_graft() Penalty::GraftBackoff
       * - in apply_iwant_penalties() Penalty::BrokenPromise
       * - in metric_score() P3 Penalty::MessageDeficit
       * - in metric_score() P6 Penalty::IPColocation
       */
      onScorePenalty(penalty) {
        this.scoringPenalties.inc({ penalty }, 1);
      },
      onIhaveRcv(topicStr, ihave, idonthave) {
        const topic = this.toTopic(topicStr);
        this.ihaveRcvMsgids.inc({ topic }, ihave);
        this.ihaveRcvNotSeenMsgids.inc({ topic }, idonthave);
      },
      onIwantRcv(iwantByTopic, iwantDonthave) {
        for (const [topicStr, iwant] of iwantByTopic) {
          const topic = this.toTopic(topicStr);
          this.iwantRcvMsgids.inc({ topic }, iwant);
        }
        this.iwantRcvDonthaveMsgids.inc(iwantDonthave);
      },
      onIdontwantRcv(idontwant, idontwantDonthave) {
        this.idontwantRcvMsgids.inc(idontwant);
        this.idontwantRcvDonthaveMsgids.inc(idontwantDonthave);
      },
      onForwardMsg(topicStr, tosendCount) {
        const topic = this.toTopic(topicStr);
        this.msgForwardCount.inc({ topic }, 1);
        this.msgForwardPeers.inc({ topic }, tosendCount);
      },
      onPublishMsg(topicStr, tosendGroupCount, tosendCount, dataLen, ms2) {
        const topic = this.toTopic(topicStr);
        this.msgPublishCount.inc({ topic }, 1);
        this.msgPublishBytes.inc({ topic }, tosendCount * dataLen);
        this.msgPublishPeersByTopic.inc({ topic }, tosendCount);
        this.directPeersPublishedTotal.inc({ topic }, tosendGroupCount.direct);
        this.floodsubPeersPublishedTotal.inc({ topic }, tosendGroupCount.floodsub);
        this.meshPeersPublishedTotal.inc({ topic }, tosendGroupCount.mesh);
        this.fanoutPeersPublishedTotal.inc({ topic }, tosendGroupCount.fanout);
        this.msgPublishTime.observe({ topic }, ms2 / 1e3);
      },
      onMsgRecvPreValidation(topicStr) {
        const topic = this.toTopic(topicStr);
        this.msgReceivedPreValidation.inc({ topic }, 1);
      },
      onMsgRecvError(topicStr) {
        const topic = this.toTopic(topicStr);
        this.msgReceivedError.inc({ topic }, 1);
      },
      onPrevalidationResult(topicStr, status) {
        const topic = this.toTopic(topicStr);
        switch (status) {
          case MessageStatus.duplicate:
            this.prevalidationDuplicateTotal.inc({ topic });
            break;
          case MessageStatus.invalid:
            this.prevalidationInvalidTotal.inc({ topic });
            break;
          case MessageStatus.valid:
            this.prevalidationValidTotal.inc({ topic });
            break;
          default:
            this.prevalidationUnknownTotal.inc({ topic });
            break;
        }
      },
      onMsgRecvInvalid(topicStr, reason) {
        const topic = this.toTopic(topicStr);
        const error = reason.reason === RejectReason.Error ? reason.error : reason.reason;
        this.msgReceivedInvalid.inc({ error }, 1);
        this.msgReceivedInvalidByTopic.inc({ topic }, 1);
      },
      onDuplicateMsgDelivery(topicStr, deliveryDelayMs, isLateDelivery) {
        const topic = this.toTopic(topicStr);
        this.duplicateMsgDeliveryDelay.observe({ topic }, deliveryDelayMs / 1e3);
        if (isLateDelivery) {
          this.duplicateMsgLateDelivery.inc({ topic }, 1);
        }
      },
      onPublishDuplicateMsg(topicStr) {
        const topic = this.toTopic(topicStr);
        this.duplicateMsgIgnored.inc({ topic }, 1);
      },
      onPeerReadStreamError() {
        this.peerReadStreamError.inc(1);
      },
      onRpcRecvError() {
        this.rpcRecvError.inc(1);
      },
      onRpcDataError() {
        this.rpcDataError.inc(1);
      },
      onRpcRecv(rpc, rpcBytes) {
        this.rpcRecvBytes.inc(rpcBytes);
        this.rpcRecvCount.inc(1);
        if (rpc.subscriptions != null)
          this.rpcRecvSubscription.inc(rpc.subscriptions.length);
        if (rpc.messages != null)
          this.rpcRecvMessage.inc(rpc.messages.length);
        if (rpc.control != null) {
          this.rpcRecvControl.inc(1);
          if (rpc.control.ihave != null)
            this.rpcRecvIHave.inc(rpc.control.ihave.length);
          if (rpc.control.iwant != null)
            this.rpcRecvIWant.inc(rpc.control.iwant.length);
          if (rpc.control.graft != null)
            this.rpcRecvGraft.inc(rpc.control.graft.length);
          if (rpc.control.prune != null)
            this.rpcRecvPrune.inc(rpc.control.prune.length);
        }
      },
      onRpcSent(rpc, rpcBytes) {
        var _a2, _b2, _c, _d, _e;
        this.rpcSentBytes.inc(rpcBytes);
        this.rpcSentCount.inc(1);
        if (rpc.subscriptions != null)
          this.rpcSentSubscription.inc(rpc.subscriptions.length);
        if (rpc.messages != null)
          this.rpcSentMessage.inc(rpc.messages.length);
        if (rpc.control != null) {
          const ihave = ((_a2 = rpc.control.ihave) == null ? void 0 : _a2.length) ?? 0;
          const iwant = ((_b2 = rpc.control.iwant) == null ? void 0 : _b2.length) ?? 0;
          const graft = ((_c = rpc.control.graft) == null ? void 0 : _c.length) ?? 0;
          const prune = ((_d = rpc.control.prune) == null ? void 0 : _d.length) ?? 0;
          const idontwant = ((_e = rpc.control.idontwant) == null ? void 0 : _e.length) ?? 0;
          if (ihave > 0)
            this.rpcSentIHave.inc(ihave);
          if (iwant > 0)
            this.rpcSentIWant.inc(iwant);
          if (graft > 0)
            this.rpcSentGraft.inc(graft);
          if (prune > 0)
            this.rpcSentPrune.inc(prune);
          if (idontwant > 0)
            this.rpcSentIDontWant.inc(idontwant);
          if (ihave > 0 || iwant > 0 || graft > 0 || prune > 0 || idontwant > 0)
            this.rpcSentControl.inc(1);
        }
      },
      registerScores(scores, scoreThresholds) {
        let graylist = 0;
        let publish = 0;
        let gossip = 0;
        let mesh = 0;
        for (const score of scores) {
          if (score >= scoreThresholds.graylistThreshold)
            graylist++;
          if (score >= scoreThresholds.publishThreshold)
            publish++;
          if (score >= scoreThresholds.gossipThreshold)
            gossip++;
          if (score >= 0)
            mesh++;
        }
        this.peersByScoreThreshold.set({ threshold: ScoreThreshold.graylist }, graylist);
        this.peersByScoreThreshold.set({ threshold: ScoreThreshold.publish }, publish);
        this.peersByScoreThreshold.set({ threshold: ScoreThreshold.gossip }, gossip);
        this.peersByScoreThreshold.set({ threshold: ScoreThreshold.mesh }, mesh);
        this.score.set(scores);
      },
      registerScoreWeights(sw) {
        for (const [topic, wsTopic] of sw.byTopic) {
          this.scoreWeights.set({ topic, p: "p1" }, wsTopic.p1w);
          this.scoreWeights.set({ topic, p: "p2" }, wsTopic.p2w);
          this.scoreWeights.set({ topic, p: "p3" }, wsTopic.p3w);
          this.scoreWeights.set({ topic, p: "p3b" }, wsTopic.p3bw);
          this.scoreWeights.set({ topic, p: "p4" }, wsTopic.p4w);
        }
        this.scoreWeights.set({ p: "p5" }, sw.p5w);
        this.scoreWeights.set({ p: "p6" }, sw.p6w);
        this.scoreWeights.set({ p: "p7" }, sw.p7w);
      },
      registerScorePerMesh(mesh, scoreByPeer) {
        const peersPerTopicLabel = /* @__PURE__ */ new Map();
        mesh.forEach((peers, topicStr) => {
          const topicLabel = this.topicStrToLabel.get(topicStr) ?? "unknown";
          let peersInMesh = peersPerTopicLabel.get(topicLabel);
          if (peersInMesh == null) {
            peersInMesh = /* @__PURE__ */ new Set();
            peersPerTopicLabel.set(topicLabel, peersInMesh);
          }
          peers.forEach((p) => peersInMesh == null ? void 0 : peersInMesh.add(p));
        });
        for (const [topic, peers] of peersPerTopicLabel) {
          const meshScores = [];
          peers.forEach((peer) => {
            meshScores.push(scoreByPeer.get(peer) ?? 0);
          });
          this.scorePerMesh.set({ topic }, meshScores);
        }
      }
    };
  }

  // node_modules/@chainsafe/libp2p-gossipsub/dist/src/score/peer-score-params.js
  var import_browser_shims286 = __toESM(require_browser_shims(), 1);

  // node_modules/@chainsafe/libp2p-gossipsub/dist/src/errors.js
  var import_browser_shims285 = __toESM(require_browser_shims(), 1);
  var InvalidPeerScoreParamsError = class extends Error {
    static name = "InvalidPeerScoreParamsError";
    constructor(message2 = "Invalid peer score params") {
      super(message2);
      this.name = "InvalidPeerScoreParamsError";
    }
  };

  // node_modules/@chainsafe/libp2p-gossipsub/dist/src/score/peer-score-params.js
  var defaultPeerScoreParams = {
    topics: {},
    topicScoreCap: 10,
    appSpecificScore: () => 0,
    appSpecificWeight: 10,
    IPColocationFactorWeight: -5,
    IPColocationFactorThreshold: 10,
    IPColocationFactorWhitelist: /* @__PURE__ */ new Set(),
    behaviourPenaltyWeight: -10,
    behaviourPenaltyThreshold: 0,
    behaviourPenaltyDecay: 0.2,
    decayInterval: 1e3,
    decayToZero: 0.1,
    retainScore: 3600 * 1e3
  };
  var defaultTopicScoreParams = {
    topicWeight: 0.5,
    timeInMeshWeight: 1,
    timeInMeshQuantum: 1,
    timeInMeshCap: 3600,
    firstMessageDeliveriesWeight: 1,
    firstMessageDeliveriesDecay: 0.5,
    firstMessageDeliveriesCap: 2e3,
    meshMessageDeliveriesWeight: -1,
    meshMessageDeliveriesDecay: 0.5,
    meshMessageDeliveriesCap: 100,
    meshMessageDeliveriesThreshold: 20,
    meshMessageDeliveriesWindow: 10,
    meshMessageDeliveriesActivation: 5e3,
    meshFailurePenaltyWeight: -1,
    meshFailurePenaltyDecay: 0.5,
    invalidMessageDeliveriesWeight: -1,
    invalidMessageDeliveriesDecay: 0.3
  };
  function createPeerScoreParams(p = {}) {
    return {
      ...defaultPeerScoreParams,
      ...p,
      topics: p.topics != null ? Object.entries(p.topics).reduce((topics, [topic, topicScoreParams]) => {
        topics[topic] = createTopicScoreParams(topicScoreParams);
        return topics;
      }, {}) : {}
    };
  }
  function createTopicScoreParams(p = {}) {
    return {
      ...defaultTopicScoreParams,
      ...p
    };
  }
  function validatePeerScoreParams(p) {
    for (const [topic, params] of Object.entries(p.topics)) {
      try {
        validateTopicScoreParams(params);
      } catch (e) {
        throw new InvalidPeerScoreParamsError(`invalid score parameters for topic ${topic}: ${e.message}`);
      }
    }
    if (p.topicScoreCap < 0) {
      throw new InvalidPeerScoreParamsError("invalid topic score cap; must be positive (or 0 for no cap)");
    }
    if (p.appSpecificScore === null || p.appSpecificScore === void 0) {
      throw new InvalidPeerScoreParamsError("missing application specific score function");
    }
    if (p.IPColocationFactorWeight > 0) {
      throw new InvalidPeerScoreParamsError("invalid IPColocationFactorWeight; must be negative (or 0 to disable)");
    }
    if (p.IPColocationFactorWeight !== 0 && p.IPColocationFactorThreshold < 1) {
      throw new InvalidPeerScoreParamsError("invalid IPColocationFactorThreshold; must be at least 1");
    }
    if (p.behaviourPenaltyWeight > 0) {
      throw new InvalidPeerScoreParamsError("invalid BehaviourPenaltyWeight; must be negative (or 0 to disable)");
    }
    if (p.behaviourPenaltyWeight !== 0 && (p.behaviourPenaltyDecay <= 0 || p.behaviourPenaltyDecay >= 1)) {
      throw new InvalidPeerScoreParamsError("invalid BehaviourPenaltyDecay; must be between 0 and 1");
    }
    if (p.decayInterval < 1e3) {
      throw new InvalidPeerScoreParamsError("invalid DecayInterval; must be at least 1s");
    }
    if (p.decayToZero <= 0 || p.decayToZero >= 1) {
      throw new InvalidPeerScoreParamsError("invalid DecayToZero; must be between 0 and 1");
    }
  }
  function validateTopicScoreParams(p) {
    if (p.topicWeight < 0) {
      throw new InvalidPeerScoreParamsError("invalid topic weight; must be >= 0");
    }
    if (p.timeInMeshQuantum === 0) {
      throw new InvalidPeerScoreParamsError("invalid TimeInMeshQuantum; must be non zero");
    }
    if (p.timeInMeshWeight < 0) {
      throw new InvalidPeerScoreParamsError("invalid TimeInMeshWeight; must be positive (or 0 to disable)");
    }
    if (p.timeInMeshWeight !== 0 && p.timeInMeshQuantum <= 0) {
      throw new InvalidPeerScoreParamsError("invalid TimeInMeshQuantum; must be positive");
    }
    if (p.timeInMeshWeight !== 0 && p.timeInMeshCap <= 0) {
      throw new InvalidPeerScoreParamsError("invalid TimeInMeshCap; must be positive");
    }
    if (p.firstMessageDeliveriesWeight < 0) {
      throw new InvalidPeerScoreParamsError("invallid FirstMessageDeliveriesWeight; must be positive (or 0 to disable)");
    }
    if (p.firstMessageDeliveriesWeight !== 0 && (p.firstMessageDeliveriesDecay <= 0 || p.firstMessageDeliveriesDecay >= 1)) {
      throw new InvalidPeerScoreParamsError("invalid FirstMessageDeliveriesDecay; must be between 0 and 1");
    }
    if (p.firstMessageDeliveriesWeight !== 0 && p.firstMessageDeliveriesCap <= 0) {
      throw new InvalidPeerScoreParamsError("invalid FirstMessageDeliveriesCap; must be positive");
    }
    if (p.meshMessageDeliveriesWeight > 0) {
      throw new InvalidPeerScoreParamsError("invalid MeshMessageDeliveriesWeight; must be negative (or 0 to disable)");
    }
    if (p.meshMessageDeliveriesWeight !== 0 && (p.meshMessageDeliveriesDecay <= 0 || p.meshMessageDeliveriesDecay >= 1)) {
      throw new InvalidPeerScoreParamsError("invalid MeshMessageDeliveriesDecay; must be between 0 and 1");
    }
    if (p.meshMessageDeliveriesWeight !== 0 && p.meshMessageDeliveriesCap <= 0) {
      throw new InvalidPeerScoreParamsError("invalid MeshMessageDeliveriesCap; must be positive");
    }
    if (p.meshMessageDeliveriesWeight !== 0 && p.meshMessageDeliveriesThreshold <= 0) {
      throw new InvalidPeerScoreParamsError("invalid MeshMessageDeliveriesThreshold; must be positive");
    }
    if (p.meshMessageDeliveriesWindow < 0) {
      throw new InvalidPeerScoreParamsError("invalid MeshMessageDeliveriesWindow; must be non-negative");
    }
    if (p.meshMessageDeliveriesWeight !== 0 && p.meshMessageDeliveriesActivation < 1e3) {
      throw new InvalidPeerScoreParamsError("invalid MeshMessageDeliveriesActivation; must be at least 1s");
    }
    if (p.meshFailurePenaltyWeight > 0) {
      throw new InvalidPeerScoreParamsError("invalid MeshFailurePenaltyWeight; must be negative (or 0 to disable)");
    }
    if (p.meshFailurePenaltyWeight !== 0 && (p.meshFailurePenaltyDecay <= 0 || p.meshFailurePenaltyDecay >= 1)) {
      throw new InvalidPeerScoreParamsError("invalid MeshFailurePenaltyDecay; must be between 0 and 1");
    }
    if (p.invalidMessageDeliveriesWeight > 0) {
      throw new InvalidPeerScoreParamsError("invalid InvalidMessageDeliveriesWeight; must be negative (or 0 to disable)");
    }
    if (p.invalidMessageDeliveriesDecay <= 0 || p.invalidMessageDeliveriesDecay >= 1) {
      throw new InvalidPeerScoreParamsError("invalid InvalidMessageDeliveriesDecay; must be between 0 and 1");
    }
  }

  // node_modules/@chainsafe/libp2p-gossipsub/dist/src/score/peer-score-thresholds.js
  var import_browser_shims287 = __toESM(require_browser_shims(), 1);
  var defaultPeerScoreThresholds = {
    gossipThreshold: -10,
    publishThreshold: -50,
    graylistThreshold: -80,
    acceptPXThreshold: 10,
    opportunisticGraftThreshold: 20
  };
  function createPeerScoreThresholds(p = {}) {
    return {
      ...defaultPeerScoreThresholds,
      ...p
    };
  }

  // node_modules/@chainsafe/libp2p-gossipsub/dist/src/score/peer-score.js
  var import_browser_shims291 = __toESM(require_browser_shims(), 1);

  // node_modules/@chainsafe/libp2p-gossipsub/dist/src/utils/set.js
  var import_browser_shims288 = __toESM(require_browser_shims(), 1);
  function removeItemsFromSet(superSet, ineed, cond = () => true) {
    const subset = /* @__PURE__ */ new Set();
    if (ineed <= 0)
      return subset;
    for (const id of superSet) {
      if (subset.size >= ineed)
        break;
      if (cond(id)) {
        subset.add(id);
        superSet.delete(id);
      }
    }
    return subset;
  }
  function removeFirstNItemsFromSet(superSet, ineed) {
    return removeItemsFromSet(superSet, ineed, () => true);
  }
  var MapDef = class extends Map {
    getDefault;
    constructor(getDefault) {
      super();
      this.getDefault = getDefault;
    }
    getOrDefault(key) {
      let value = super.get(key);
      if (value === void 0) {
        value = this.getDefault();
        this.set(key, value);
      }
      return value;
    }
  };

  // node_modules/@chainsafe/libp2p-gossipsub/dist/src/score/compute-score.js
  var import_browser_shims289 = __toESM(require_browser_shims(), 1);
  function computeScore(peer, pstats, params, peerIPs) {
    let score = 0;
    Object.entries(pstats.topics).forEach(([topic, tstats]) => {
      const topicParams = params.topics[topic];
      if (topicParams === void 0) {
        return;
      }
      let topicScore = 0;
      if (tstats.inMesh) {
        let p1 = tstats.meshTime / topicParams.timeInMeshQuantum;
        if (p1 > topicParams.timeInMeshCap) {
          p1 = topicParams.timeInMeshCap;
        }
        topicScore += p1 * topicParams.timeInMeshWeight;
      }
      let p2 = tstats.firstMessageDeliveries;
      if (p2 > topicParams.firstMessageDeliveriesCap) {
        p2 = topicParams.firstMessageDeliveriesCap;
      }
      topicScore += p2 * topicParams.firstMessageDeliveriesWeight;
      if (tstats.meshMessageDeliveriesActive && tstats.meshMessageDeliveries < topicParams.meshMessageDeliveriesThreshold) {
        const deficit = topicParams.meshMessageDeliveriesThreshold - tstats.meshMessageDeliveries;
        const p3 = deficit * deficit;
        topicScore += p3 * topicParams.meshMessageDeliveriesWeight;
      }
      const p3b = tstats.meshFailurePenalty;
      topicScore += p3b * topicParams.meshFailurePenaltyWeight;
      const p4 = tstats.invalidMessageDeliveries * tstats.invalidMessageDeliveries;
      topicScore += p4 * topicParams.invalidMessageDeliveriesWeight;
      score += topicScore * topicParams.topicWeight;
    });
    if (params.topicScoreCap > 0 && score > params.topicScoreCap) {
      score = params.topicScoreCap;
    }
    const p5 = params.appSpecificScore(peer);
    score += p5 * params.appSpecificWeight;
    pstats.knownIPs.forEach((ip) => {
      if (params.IPColocationFactorWhitelist.has(ip)) {
        return;
      }
      const peersInIP = peerIPs.get(ip);
      const numPeersInIP = peersInIP != null ? peersInIP.size : 0;
      if (numPeersInIP > params.IPColocationFactorThreshold) {
        const surplus = numPeersInIP - params.IPColocationFactorThreshold;
        const p6 = surplus * surplus;
        score += p6 * params.IPColocationFactorWeight;
      }
    });
    if (pstats.behaviourPenalty > params.behaviourPenaltyThreshold) {
      const excess = pstats.behaviourPenalty - params.behaviourPenaltyThreshold;
      const p7 = excess * excess;
      score += p7 * params.behaviourPenaltyWeight;
    }
    return score;
  }

  // node_modules/@chainsafe/libp2p-gossipsub/dist/src/score/message-deliveries.js
  var import_browser_shims290 = __toESM(require_browser_shims(), 1);
  var import_denque = __toESM(require_denque(), 1);
  var DeliveryRecordStatus;
  (function(DeliveryRecordStatus2) {
    DeliveryRecordStatus2[DeliveryRecordStatus2["unknown"] = 0] = "unknown";
    DeliveryRecordStatus2[DeliveryRecordStatus2["valid"] = 1] = "valid";
    DeliveryRecordStatus2[DeliveryRecordStatus2["invalid"] = 2] = "invalid";
    DeliveryRecordStatus2[DeliveryRecordStatus2["ignored"] = 3] = "ignored";
  })(DeliveryRecordStatus || (DeliveryRecordStatus = {}));
  var MessageDeliveries = class {
    records;
    queue;
    constructor() {
      this.records = /* @__PURE__ */ new Map();
      this.queue = new import_denque.default();
    }
    getRecord(msgIdStr) {
      return this.records.get(msgIdStr);
    }
    ensureRecord(msgIdStr) {
      let drec = this.records.get(msgIdStr);
      if (drec != null) {
        return drec;
      }
      drec = {
        status: DeliveryRecordStatus.unknown,
        firstSeenTsMs: Date.now(),
        validated: 0,
        peers: /* @__PURE__ */ new Set()
      };
      this.records.set(msgIdStr, drec);
      const entry = {
        msgId: msgIdStr,
        expire: Date.now() + TimeCacheDuration
      };
      this.queue.push(entry);
      return drec;
    }
    gc() {
      const now = Date.now();
      let head = this.queue.peekFront();
      while (head != null && head.expire < now) {
        this.records.delete(head.msgId);
        this.queue.shift();
        head = this.queue.peekFront();
      }
    }
    clear() {
      this.records.clear();
      this.queue.clear();
    }
  };

  // node_modules/@chainsafe/libp2p-gossipsub/dist/src/score/peer-score.js
  var PeerScore = class {
    params;
    metrics;
    /**
     * Per-peer stats for score calculation
     */
    peerStats = /* @__PURE__ */ new Map();
    /**
     * IP colocation tracking; maps IP => set of peers.
     */
    peerIPs = new MapDef(() => /* @__PURE__ */ new Set());
    /**
     * Cache score up to decayInterval if topic stats are unchanged.
     */
    scoreCache = /* @__PURE__ */ new Map();
    /**
     * Recent message delivery timing/participants
     */
    deliveryRecords = new MessageDeliveries();
    _backgroundInterval;
    scoreCacheValidityMs;
    computeScore;
    log;
    constructor(params, metrics, componentLogger, opts) {
      this.params = params;
      this.metrics = metrics;
      validatePeerScoreParams(params);
      this.scoreCacheValidityMs = opts.scoreCacheValidityMs;
      this.computeScore = opts.computeScore ?? computeScore;
      this.log = componentLogger.forComponent("libp2p:gossipsub:score");
    }
    get size() {
      return this.peerStats.size;
    }
    /**
     * Start PeerScore instance
     */
    start() {
      if (this._backgroundInterval != null) {
        this.log("Peer score already running");
        return;
      }
      this._backgroundInterval = setInterval(() => {
        this.background();
      }, this.params.decayInterval);
      this.log("started");
    }
    /**
     * Stop PeerScore instance
     */
    stop() {
      if (this._backgroundInterval == null) {
        this.log("Peer score already stopped");
        return;
      }
      clearInterval(this._backgroundInterval);
      delete this._backgroundInterval;
      this.peerIPs.clear();
      this.peerStats.clear();
      this.deliveryRecords.clear();
      this.log("stopped");
    }
    /**
     * Periodic maintenance
     */
    background() {
      this.refreshScores();
      this.deliveryRecords.gc();
    }
    dumpPeerScoreStats() {
      return Object.fromEntries(Array.from(this.peerStats.entries()).map(([peer, stats]) => [peer, stats]));
    }
    messageFirstSeenTimestampMs(msgIdStr) {
      const drec = this.deliveryRecords.getRecord(msgIdStr);
      return drec != null ? drec.firstSeenTsMs : null;
    }
    /**
     * Decays scores, and purges score records for disconnected peers once their expiry has elapsed.
     */
    refreshScores() {
      const now = Date.now();
      const decayToZero = this.params.decayToZero;
      this.peerStats.forEach((pstats, id) => {
        if (!pstats.connected) {
          if (now > pstats.expire) {
            this.removeIPsForPeer(id, pstats.knownIPs);
            this.peerStats.delete(id);
            this.scoreCache.delete(id);
          }
          return;
        }
        Object.entries(pstats.topics).forEach(([topic, tstats]) => {
          const tparams = this.params.topics[topic];
          if (tparams === void 0) {
            return;
          }
          tstats.firstMessageDeliveries *= tparams.firstMessageDeliveriesDecay;
          if (tstats.firstMessageDeliveries < decayToZero) {
            tstats.firstMessageDeliveries = 0;
          }
          tstats.meshMessageDeliveries *= tparams.meshMessageDeliveriesDecay;
          if (tstats.meshMessageDeliveries < decayToZero) {
            tstats.meshMessageDeliveries = 0;
          }
          tstats.meshFailurePenalty *= tparams.meshFailurePenaltyDecay;
          if (tstats.meshFailurePenalty < decayToZero) {
            tstats.meshFailurePenalty = 0;
          }
          tstats.invalidMessageDeliveries *= tparams.invalidMessageDeliveriesDecay;
          if (tstats.invalidMessageDeliveries < decayToZero) {
            tstats.invalidMessageDeliveries = 0;
          }
          if (tstats.inMesh) {
            tstats.meshTime = now - tstats.graftTime;
            if (tstats.meshTime > tparams.meshMessageDeliveriesActivation) {
              tstats.meshMessageDeliveriesActive = true;
            }
          }
        });
        pstats.behaviourPenalty *= this.params.behaviourPenaltyDecay;
        if (pstats.behaviourPenalty < decayToZero) {
          pstats.behaviourPenalty = 0;
        }
      });
    }
    /**
     * Return the score for a peer
     */
    score(id) {
      var _a2, _b2, _c;
      (_a2 = this.metrics) == null ? void 0 : _a2.scoreFnCalls.inc();
      const pstats = this.peerStats.get(id);
      if (pstats == null) {
        return 0;
      }
      const now = Date.now();
      const cacheEntry = this.scoreCache.get(id);
      if (cacheEntry != null && cacheEntry.cacheUntil > now) {
        return cacheEntry.score;
      }
      (_b2 = this.metrics) == null ? void 0 : _b2.scoreFnRuns.inc();
      const score = this.computeScore(id, pstats, this.params, this.peerIPs);
      const cacheUntil = now + this.scoreCacheValidityMs;
      if (cacheEntry != null) {
        (_c = this.metrics) == null ? void 0 : _c.scoreCachedDelta.observe(Math.abs(score - cacheEntry.score));
        cacheEntry.score = score;
        cacheEntry.cacheUntil = cacheUntil;
      } else {
        this.scoreCache.set(id, { score, cacheUntil });
      }
      return score;
    }
    /**
     * Apply a behavioural penalty to a peer
     */
    addPenalty(id, penalty, penaltyLabel) {
      var _a2;
      const pstats = this.peerStats.get(id);
      if (pstats != null) {
        pstats.behaviourPenalty += penalty;
        (_a2 = this.metrics) == null ? void 0 : _a2.onScorePenalty(penaltyLabel);
      }
    }
    addPeer(id) {
      const pstats = {
        connected: true,
        expire: 0,
        topics: {},
        knownIPs: /* @__PURE__ */ new Set(),
        behaviourPenalty: 0
      };
      this.peerStats.set(id, pstats);
    }
    /** Adds a new IP to a peer, if the peer is not known the update is ignored */
    addIP(id, ip) {
      const pstats = this.peerStats.get(id);
      if (pstats != null) {
        pstats.knownIPs.add(ip);
      }
      this.peerIPs.getOrDefault(ip).add(id);
    }
    /** Remove peer association with IP */
    removeIP(id, ip) {
      const pstats = this.peerStats.get(id);
      if (pstats != null) {
        pstats.knownIPs.delete(ip);
      }
      const peersWithIP = this.peerIPs.get(ip);
      if (peersWithIP != null) {
        peersWithIP.delete(id);
        if (peersWithIP.size === 0) {
          this.peerIPs.delete(ip);
        }
      }
    }
    removePeer(id) {
      const pstats = this.peerStats.get(id);
      if (pstats == null) {
        return;
      }
      if (this.score(id) > 0) {
        this.removeIPsForPeer(id, pstats.knownIPs);
        this.peerStats.delete(id);
        return;
      }
      Object.entries(pstats.topics).forEach(([topic, tstats]) => {
        tstats.firstMessageDeliveries = 0;
        const threshold = this.params.topics[topic].meshMessageDeliveriesThreshold;
        if (tstats.inMesh && tstats.meshMessageDeliveriesActive && tstats.meshMessageDeliveries < threshold) {
          const deficit = threshold - tstats.meshMessageDeliveries;
          tstats.meshFailurePenalty += deficit * deficit;
        }
        tstats.inMesh = false;
        tstats.meshMessageDeliveriesActive = false;
      });
      pstats.connected = false;
      pstats.expire = Date.now() + this.params.retainScore;
    }
    /** Handles scoring functionality as a peer GRAFTs to a topic. */
    graft(id, topic) {
      const pstats = this.peerStats.get(id);
      if (pstats != null) {
        const tstats = this.getPtopicStats(pstats, topic);
        if (tstats != null) {
          tstats.inMesh = true;
          tstats.graftTime = Date.now();
          tstats.meshTime = 0;
          tstats.meshMessageDeliveriesActive = false;
        }
      }
    }
    /** Handles scoring functionality as a peer PRUNEs from a topic. */
    prune(id, topic) {
      const pstats = this.peerStats.get(id);
      if (pstats != null) {
        const tstats = this.getPtopicStats(pstats, topic);
        if (tstats != null) {
          const threshold = this.params.topics[topic].meshMessageDeliveriesThreshold;
          if (tstats.meshMessageDeliveriesActive && tstats.meshMessageDeliveries < threshold) {
            const deficit = threshold - tstats.meshMessageDeliveries;
            tstats.meshFailurePenalty += deficit * deficit;
          }
          tstats.meshMessageDeliveriesActive = false;
          tstats.inMesh = false;
        }
      }
    }
    validateMessage(msgIdStr) {
      this.deliveryRecords.ensureRecord(msgIdStr);
    }
    deliverMessage(from3, msgIdStr, topic) {
      this.markFirstMessageDelivery(from3, topic);
      const drec = this.deliveryRecords.ensureRecord(msgIdStr);
      const now = Date.now();
      if (drec.status !== DeliveryRecordStatus.unknown) {
        this.log("unexpected delivery: message from %s was first seen %s ago and has delivery status %s", from3, now - drec.firstSeenTsMs, DeliveryRecordStatus[drec.status]);
        return;
      }
      drec.status = DeliveryRecordStatus.valid;
      drec.validated = now;
      drec.peers.forEach((p) => {
        if (p !== from3.toString()) {
          this.markDuplicateMessageDelivery(p, topic);
        }
      });
    }
    /**
     * Similar to `rejectMessage` except does not require the message id or reason for an invalid message.
     */
    rejectInvalidMessage(from3, topic) {
      this.markInvalidMessageDelivery(from3, topic);
    }
    rejectMessage(from3, msgIdStr, topic, reason) {
      switch (reason) {
        // these messages are not tracked, but the peer is penalized as they are invalid
        case RejectReason.Error:
          this.markInvalidMessageDelivery(from3, topic);
          return;
        // we ignore those messages, so do nothing.
        case RejectReason.Blacklisted:
          return;
      }
      const drec = this.deliveryRecords.ensureRecord(msgIdStr);
      if (drec.status !== DeliveryRecordStatus.unknown) {
        this.log("unexpected rejection: message from %s was first seen %s ago and has delivery status %d", from3, Date.now() - drec.firstSeenTsMs, DeliveryRecordStatus[drec.status]);
        return;
      }
      if (reason === RejectReason.Ignore) {
        drec.status = DeliveryRecordStatus.ignored;
        drec.peers.clear();
        return;
      }
      drec.status = DeliveryRecordStatus.invalid;
      this.markInvalidMessageDelivery(from3, topic);
      drec.peers.forEach((p) => {
        this.markInvalidMessageDelivery(p, topic);
      });
      drec.peers.clear();
    }
    duplicateMessage(from3, msgIdStr, topic) {
      const drec = this.deliveryRecords.ensureRecord(msgIdStr);
      if (drec.peers.has(from3)) {
        return;
      }
      switch (drec.status) {
        case DeliveryRecordStatus.unknown:
          drec.peers.add(from3);
          break;
        case DeliveryRecordStatus.valid:
          drec.peers.add(from3);
          this.markDuplicateMessageDelivery(from3, topic, drec.validated);
          break;
        case DeliveryRecordStatus.invalid:
          this.markInvalidMessageDelivery(from3, topic);
          break;
        case DeliveryRecordStatus.ignored:
          break;
      }
    }
    /**
     * Increments the "invalid message deliveries" counter for all scored topics the message is published in.
     */
    markInvalidMessageDelivery(from3, topic) {
      const pstats = this.peerStats.get(from3);
      if (pstats != null) {
        const tstats = this.getPtopicStats(pstats, topic);
        if (tstats != null) {
          tstats.invalidMessageDeliveries += 1;
        }
      }
    }
    /**
     * Increments the "first message deliveries" counter for all scored topics the message is published in,
     * as well as the "mesh message deliveries" counter, if the peer is in the mesh for the topic.
     * Messages already known (with the seenCache) are counted with markDuplicateMessageDelivery()
     */
    markFirstMessageDelivery(from3, topic) {
      const pstats = this.peerStats.get(from3);
      if (pstats != null) {
        const tstats = this.getPtopicStats(pstats, topic);
        if (tstats != null) {
          let cap = this.params.topics[topic].firstMessageDeliveriesCap;
          tstats.firstMessageDeliveries = Math.min(cap, tstats.firstMessageDeliveries + 1);
          if (tstats.inMesh) {
            cap = this.params.topics[topic].meshMessageDeliveriesCap;
            tstats.meshMessageDeliveries = Math.min(cap, tstats.meshMessageDeliveries + 1);
          }
        }
      }
    }
    /**
     * Increments the "mesh message deliveries" counter for messages we've seen before,
     * as long the message was received within the P3 window.
     */
    markDuplicateMessageDelivery(from3, topic, validatedTime) {
      var _a2;
      const pstats = this.peerStats.get(from3);
      if (pstats != null) {
        const now = validatedTime !== void 0 ? Date.now() : 0;
        const tstats = this.getPtopicStats(pstats, topic);
        if (tstats != null && tstats.inMesh) {
          const tparams = this.params.topics[topic];
          if (validatedTime !== void 0) {
            const deliveryDelayMs = now - validatedTime;
            const isLateDelivery = deliveryDelayMs > tparams.meshMessageDeliveriesWindow;
            (_a2 = this.metrics) == null ? void 0 : _a2.onDuplicateMsgDelivery(topic, deliveryDelayMs, isLateDelivery);
            if (isLateDelivery) {
              return;
            }
          }
          const cap = tparams.meshMessageDeliveriesCap;
          tstats.meshMessageDeliveries = Math.min(cap, tstats.meshMessageDeliveries + 1);
        }
      }
    }
    /**
     * Removes an IP list from the tracking list for a peer.
     */
    removeIPsForPeer(id, ipsToRemove) {
      for (const ipToRemove of ipsToRemove) {
        const peerSet2 = this.peerIPs.get(ipToRemove);
        if (peerSet2 != null) {
          peerSet2.delete(id);
          if (peerSet2.size === 0) {
            this.peerIPs.delete(ipToRemove);
          }
        }
      }
    }
    /**
     * Returns topic stats if they exist, otherwise if the supplied parameters score the
     * topic, inserts the default stats and returns a reference to those. If neither apply, returns None.
     */
    getPtopicStats(pstats, topic) {
      let topicStats = pstats.topics[topic];
      if (topicStats !== void 0) {
        return topicStats;
      }
      if (this.params.topics[topic] !== void 0) {
        topicStats = {
          inMesh: false,
          graftTime: 0,
          meshTime: 0,
          firstMessageDeliveries: 0,
          meshMessageDeliveries: 0,
          meshMessageDeliveriesActive: false,
          meshFailurePenalty: 0,
          invalidMessageDeliveries: 0
        };
        pstats.topics[topic] = topicStats;
        return topicStats;
      }
      return null;
    }
  };

  // node_modules/@chainsafe/libp2p-gossipsub/dist/src/score/scoreMetrics.js
  var import_browser_shims292 = __toESM(require_browser_shims(), 1);
  function computeScoreWeights(peer, pstats, params, peerIPs, topicStrToLabel) {
    let score = 0;
    const byTopic = /* @__PURE__ */ new Map();
    Object.entries(pstats.topics).forEach(([topic, tstats]) => {
      const topicLabel = topicStrToLabel.get(topic) ?? "unknown";
      const topicParams = params.topics[topic];
      if (topicParams === void 0) {
        return;
      }
      let topicScores = byTopic.get(topicLabel);
      if (topicScores == null) {
        topicScores = {
          p1w: 0,
          p2w: 0,
          p3w: 0,
          p3bw: 0,
          p4w: 0
        };
        byTopic.set(topicLabel, topicScores);
      }
      let p1w = 0;
      let p2w = 0;
      let p3w = 0;
      let p3bw = 0;
      let p4w = 0;
      if (tstats.inMesh) {
        const p1 = Math.max(tstats.meshTime / topicParams.timeInMeshQuantum, topicParams.timeInMeshCap);
        p1w += p1 * topicParams.timeInMeshWeight;
      }
      let p2 = tstats.firstMessageDeliveries;
      if (p2 > topicParams.firstMessageDeliveriesCap) {
        p2 = topicParams.firstMessageDeliveriesCap;
      }
      p2w += p2 * topicParams.firstMessageDeliveriesWeight;
      if (tstats.meshMessageDeliveriesActive && tstats.meshMessageDeliveries < topicParams.meshMessageDeliveriesThreshold) {
        const deficit = topicParams.meshMessageDeliveriesThreshold - tstats.meshMessageDeliveries;
        const p3 = deficit * deficit;
        p3w += p3 * topicParams.meshMessageDeliveriesWeight;
      }
      const p3b = tstats.meshFailurePenalty;
      p3bw += p3b * topicParams.meshFailurePenaltyWeight;
      const p4 = tstats.invalidMessageDeliveries * tstats.invalidMessageDeliveries;
      p4w += p4 * topicParams.invalidMessageDeliveriesWeight;
      score += (p1w + p2w + p3w + p3bw + p4w) * topicParams.topicWeight;
      topicScores.p1w += p1w;
      topicScores.p2w += p2w;
      topicScores.p3w += p3w;
      topicScores.p3bw += p3bw;
      topicScores.p4w += p4w;
    });
    if (params.topicScoreCap > 0 && score > params.topicScoreCap) {
      score = params.topicScoreCap;
      const capF = params.topicScoreCap / score;
      for (const ws of byTopic.values()) {
        ws.p1w *= capF;
        ws.p2w *= capF;
        ws.p3w *= capF;
        ws.p3bw *= capF;
        ws.p4w *= capF;
      }
    }
    let p5w = 0;
    let p6w = 0;
    let p7w = 0;
    const p5 = params.appSpecificScore(peer);
    p5w += p5 * params.appSpecificWeight;
    pstats.knownIPs.forEach((ip) => {
      if (params.IPColocationFactorWhitelist.has(ip)) {
        return;
      }
      const peersInIP = peerIPs.get(ip);
      const numPeersInIP = peersInIP != null ? peersInIP.size : 0;
      if (numPeersInIP > params.IPColocationFactorThreshold) {
        const surplus = numPeersInIP - params.IPColocationFactorThreshold;
        const p6 = surplus * surplus;
        p6w += p6 * params.IPColocationFactorWeight;
      }
    });
    const p7 = pstats.behaviourPenalty * pstats.behaviourPenalty;
    p7w += p7 * params.behaviourPenaltyWeight;
    score += p5w + p6w + p7w;
    return {
      byTopic,
      p5w,
      p6w,
      p7w,
      score
    };
  }
  function computeAllPeersScoreWeights(peerIdStrs, peerStats, params, peerIPs, topicStrToLabel) {
    const sw = {
      byTopic: /* @__PURE__ */ new Map(),
      p5w: [],
      p6w: [],
      p7w: [],
      score: []
    };
    for (const peerIdStr of peerIdStrs) {
      const pstats = peerStats.get(peerIdStr);
      if (pstats != null) {
        const swPeer = computeScoreWeights(peerIdStr, pstats, params, peerIPs, topicStrToLabel);
        for (const [topic, swPeerTopic] of swPeer.byTopic) {
          let swTopic = sw.byTopic.get(topic);
          if (swTopic == null) {
            swTopic = {
              p1w: [],
              p2w: [],
              p3w: [],
              p3bw: [],
              p4w: []
            };
            sw.byTopic.set(topic, swTopic);
          }
          swTopic.p1w.push(swPeerTopic.p1w);
          swTopic.p2w.push(swPeerTopic.p2w);
          swTopic.p3w.push(swPeerTopic.p3w);
          swTopic.p3bw.push(swPeerTopic.p3bw);
          swTopic.p4w.push(swPeerTopic.p4w);
        }
        sw.p5w.push(swPeer.p5w);
        sw.p6w.push(swPeer.p6w);
        sw.p7w.push(swPeer.p7w);
        sw.score.push(swPeer.score);
      } else {
        sw.p5w.push(0);
        sw.p6w.push(0);
        sw.p7w.push(0);
        sw.score.push(0);
      }
    }
    return sw;
  }

  // node_modules/@chainsafe/libp2p-gossipsub/dist/src/stream.js
  var import_browser_shims293 = __toESM(require_browser_shims(), 1);
  var OutboundStream = class {
    rawStream;
    pushable;
    closeController;
    maxBufferSize;
    constructor(rawStream, errCallback, opts) {
      this.rawStream = rawStream;
      this.pushable = pushable();
      this.closeController = new AbortController();
      this.maxBufferSize = opts.maxBufferSize ?? Infinity;
      this.closeController.signal.addEventListener("abort", () => {
        rawStream.close().catch((err) => {
          rawStream.abort(err);
        });
      });
      pipe(this.pushable, this.rawStream).catch(errCallback);
    }
    get protocol() {
      return this.rawStream.protocol;
    }
    push(data) {
      if (this.pushable.readableLength > this.maxBufferSize) {
        throw Error(`OutboundStream buffer full, size > ${this.maxBufferSize}`);
      }
      this.pushable.push(encode7.single(data));
    }
    /**
     * Same to push() but this is prefixed data so no need to encode length prefixed again
     */
    pushPrefixed(data) {
      if (this.pushable.readableLength > this.maxBufferSize) {
        throw Error(`OutboundStream buffer full, size > ${this.maxBufferSize}`);
      }
      this.pushable.push(data);
    }
    async close() {
      this.closeController.abort();
      await this.pushable.return();
    }
  };
  var InboundStream = class {
    source;
    rawStream;
    closeController;
    constructor(rawStream, opts = {}) {
      this.rawStream = rawStream;
      this.closeController = new AbortController();
      this.closeController.signal.addEventListener("abort", () => {
        rawStream.close().catch((err) => {
          rawStream.abort(err);
        });
      });
      this.source = pipe(this.rawStream, (source) => decode8(source, opts));
    }
    async close() {
      this.closeController.abort();
    }
  };

  // node_modules/@chainsafe/libp2p-gossipsub/dist/src/tracer.js
  var import_browser_shims294 = __toESM(require_browser_shims(), 1);
  var IWantTracer = class {
    gossipsubIWantFollowupMs;
    msgIdToStrFn;
    metrics;
    /**
     * Promises to deliver a message
     * Map per message id, per peer, promise expiration time
     */
    promises = /* @__PURE__ */ new Map();
    /**
     * First request time by msgId. Used for metrics to track expire times.
     * Necessary to know if peers are actually breaking promises or simply sending them a bit later
     */
    requestMsByMsg = /* @__PURE__ */ new Map();
    requestMsByMsgExpire;
    constructor(gossipsubIWantFollowupMs, msgIdToStrFn, metrics) {
      this.gossipsubIWantFollowupMs = gossipsubIWantFollowupMs;
      this.msgIdToStrFn = msgIdToStrFn;
      this.metrics = metrics;
      this.requestMsByMsgExpire = 10 * gossipsubIWantFollowupMs;
    }
    get size() {
      return this.promises.size;
    }
    get requestMsByMsgSize() {
      return this.requestMsByMsg.size;
    }
    /**
     * Track a promise to deliver a message from a list of msgIds we are requesting
     */
    addPromise(from3, msgIds) {
      const ix = Math.floor(Math.random() * msgIds.length);
      const msgId2 = msgIds[ix];
      const msgIdStr = this.msgIdToStrFn(msgId2);
      let expireByPeer = this.promises.get(msgIdStr);
      if (expireByPeer == null) {
        expireByPeer = /* @__PURE__ */ new Map();
        this.promises.set(msgIdStr, expireByPeer);
      }
      const now = Date.now();
      if (!expireByPeer.has(from3)) {
        expireByPeer.set(from3, now + this.gossipsubIWantFollowupMs);
        if (this.metrics != null) {
          this.metrics.iwantPromiseStarted.inc(1);
          if (!this.requestMsByMsg.has(msgIdStr)) {
            this.requestMsByMsg.set(msgIdStr, now);
          }
        }
      }
    }
    /**
     * Returns the number of broken promises for each peer who didn't follow up on an IWANT request.
     *
     * This should be called not too often relative to the expire times, since it iterates over the whole data.
     */
    getBrokenPromises() {
      var _a2;
      const now = Date.now();
      const result = /* @__PURE__ */ new Map();
      let brokenPromises = 0;
      this.promises.forEach((expireByPeer, msgId2) => {
        expireByPeer.forEach((expire, p) => {
          if (expire < now) {
            result.set(p, (result.get(p) ?? 0) + 1);
            expireByPeer.delete(p);
            brokenPromises++;
          }
        });
        if (expireByPeer.size === 0) {
          this.promises.delete(msgId2);
        }
      });
      (_a2 = this.metrics) == null ? void 0 : _a2.iwantPromiseBroken.inc(brokenPromises);
      return result;
    }
    /**
     * Someone delivered a message, stop tracking promises for it
     */
    deliverMessage(msgIdStr, isDuplicate = false) {
      this.trackMessage(msgIdStr);
      const expireByPeer = this.promises.get(msgIdStr);
      if (expireByPeer != null) {
        this.promises.delete(msgIdStr);
        if (this.metrics != null) {
          this.metrics.iwantPromiseResolved.inc(1);
          if (isDuplicate)
            this.metrics.iwantPromiseResolvedFromDuplicate.inc(1);
          this.metrics.iwantPromiseResolvedPeers.inc(expireByPeer.size);
        }
      }
    }
    /**
     * A message got rejected, so we can stop tracking promises and let the score penalty apply from invalid message delivery,
     * unless its an obviously invalid message.
     */
    rejectMessage(msgIdStr, reason) {
      this.trackMessage(msgIdStr);
      switch (reason) {
        case RejectReason.Error:
          return;
        default:
          break;
      }
      this.promises.delete(msgIdStr);
    }
    clear() {
      this.promises.clear();
    }
    prune() {
      var _a2;
      const maxMs = Date.now() - this.requestMsByMsgExpire;
      let count = 0;
      for (const [k, v] of this.requestMsByMsg.entries()) {
        if (v < maxMs) {
          this.requestMsByMsg.delete(k);
          count++;
        } else {
          break;
        }
      }
      (_a2 = this.metrics) == null ? void 0 : _a2.iwantMessagePruned.inc(count);
    }
    trackMessage(msgIdStr) {
      if (this.metrics != null) {
        const requestMs = this.requestMsByMsg.get(msgIdStr);
        if (requestMs !== void 0) {
          this.metrics.iwantPromiseDeliveryTime.observe((Date.now() - requestMs) / 1e3);
          this.requestMsByMsg.delete(msgIdStr);
        }
      }
    }
  };

  // node_modules/@chainsafe/libp2p-gossipsub/dist/src/utils/buildRawMessage.js
  var import_browser_shims295 = __toESM(require_browser_shims(), 1);
  var SignPrefix = fromString2("libp2p-pubsub:");
  async function buildRawMessage(publishConfig, topic, originalData, transformedData) {
    switch (publishConfig.type) {
      case PublishConfigType.Signing: {
        const rpcMsg = {
          from: publishConfig.author.toMultihash().bytes,
          data: transformedData,
          seqno: randomBytes2(8),
          topic,
          signature: void 0,
          // Exclude signature field for signing
          key: void 0
          // Exclude key field for signing
        };
        const bytes = concat([SignPrefix, RPC.Message.encode(rpcMsg)]);
        rpcMsg.signature = await publishConfig.privateKey.sign(bytes);
        rpcMsg.key = publishConfig.key;
        const msg = {
          type: "signed",
          from: publishConfig.author,
          data: originalData,
          sequenceNumber: BigInt(`0x${toString2(rpcMsg.seqno ?? new Uint8Array(0), "base16")}`),
          topic,
          signature: rpcMsg.signature,
          key: publicKeyFromProtobuf(rpcMsg.key)
        };
        return {
          raw: rpcMsg,
          msg
        };
      }
      case PublishConfigType.Anonymous: {
        return {
          raw: {
            from: void 0,
            data: transformedData,
            seqno: void 0,
            topic,
            signature: void 0,
            key: void 0
          },
          msg: {
            type: "unsigned",
            data: originalData,
            topic
          }
        };
      }
      default:
        throw new Error("Unreachable");
    }
  }
  async function validateToRawMessage(signaturePolicy, msg) {
    switch (signaturePolicy) {
      case StrictNoSign:
        if (msg.signature != null)
          return { valid: false, error: ValidateError.SignaturePresent };
        if (msg.seqno != null)
          return { valid: false, error: ValidateError.SeqnoPresent };
        if (msg.key != null)
          return { valid: false, error: ValidateError.FromPresent };
        return { valid: true, message: { type: "unsigned", topic: msg.topic, data: msg.data ?? new Uint8Array(0) } };
      case StrictSign: {
        if (msg.seqno == null)
          return { valid: false, error: ValidateError.InvalidSeqno };
        if (msg.seqno.length !== 8) {
          return { valid: false, error: ValidateError.InvalidSeqno };
        }
        if (msg.signature == null)
          return { valid: false, error: ValidateError.InvalidSignature };
        if (msg.from == null)
          return { valid: false, error: ValidateError.InvalidPeerId };
        let fromPeerId;
        try {
          fromPeerId = peerIdFromMultihash(decode4(msg.from));
        } catch (e) {
          return { valid: false, error: ValidateError.InvalidPeerId };
        }
        let publicKey;
        if (msg.key != null) {
          publicKey = publicKeyFromProtobuf(msg.key);
          if (fromPeerId.publicKey !== void 0 && !publicKey.equals(fromPeerId.publicKey)) {
            return { valid: false, error: ValidateError.InvalidPeerId };
          }
        } else {
          if (fromPeerId.publicKey == null) {
            return { valid: false, error: ValidateError.InvalidPeerId };
          }
          publicKey = fromPeerId.publicKey;
        }
        const rpcMsgPreSign = {
          from: msg.from,
          data: msg.data,
          seqno: msg.seqno,
          topic: msg.topic,
          signature: void 0,
          // Exclude signature field for signing
          key: void 0
          // Exclude key field for signing
        };
        const bytes = concat([SignPrefix, RPC.Message.encode(rpcMsgPreSign)]);
        if (!await publicKey.verify(bytes, msg.signature)) {
          return { valid: false, error: ValidateError.InvalidSignature };
        }
        return {
          valid: true,
          message: {
            type: "signed",
            from: fromPeerId,
            data: msg.data ?? new Uint8Array(0),
            sequenceNumber: BigInt(`0x${toString2(msg.seqno, "base16")}`),
            topic: msg.topic,
            signature: msg.signature,
            key: msg.key != null ? publicKeyFromProtobuf(msg.key) : publicKey
          }
        };
      }
      default:
        throw new Error("Unreachable");
    }
  }

  // node_modules/@chainsafe/libp2p-gossipsub/dist/src/utils/create-gossip-rpc.js
  var import_browser_shims296 = __toESM(require_browser_shims(), 1);
  function createGossipRpc(messages2 = [], control) {
    return {
      subscriptions: [],
      messages: messages2,
      control: control !== void 0 ? {
        graft: control.graft ?? [],
        prune: control.prune ?? [],
        ihave: control.ihave ?? [],
        iwant: control.iwant ?? [],
        idontwant: control.idontwant ?? []
      } : void 0
    };
  }
  function ensureControl(rpc) {
    if (rpc.control === void 0) {
      rpc.control = {
        graft: [],
        prune: [],
        ihave: [],
        iwant: [],
        idontwant: []
      };
    }
    return rpc;
  }

  // node_modules/@chainsafe/libp2p-gossipsub/dist/src/utils/shuffle.js
  var import_browser_shims297 = __toESM(require_browser_shims(), 1);
  function shuffle(arr) {
    if (arr.length <= 1) {
      return arr;
    }
    const randInt = () => {
      return Math.floor(Math.random() * Math.floor(arr.length));
    };
    for (let i = 0; i < arr.length; i++) {
      const j = randInt();
      const tmp = arr[i];
      arr[i] = arr[j];
      arr[j] = tmp;
    }
    return arr;
  }

  // node_modules/@chainsafe/libp2p-gossipsub/dist/src/utils/messageIdToString.js
  var import_browser_shims298 = __toESM(require_browser_shims(), 1);
  function messageIdToString(msgId2) {
    return toString2(msgId2, "base64");
  }

  // node_modules/@chainsafe/libp2p-gossipsub/dist/src/utils/publishConfig.js
  var import_browser_shims299 = __toESM(require_browser_shims(), 1);
  function getPublishConfigFromPeerId(signaturePolicy, peerId2, privateKey) {
    switch (signaturePolicy) {
      case StrictSign: {
        return {
          type: PublishConfigType.Signing,
          author: peerId2,
          key: publicKeyToProtobuf(privateKey.publicKey),
          privateKey
        };
      }
      case StrictNoSign:
        return {
          type: PublishConfigType.Anonymous
        };
      default:
        throw new Error(`Unknown signature policy "${signaturePolicy}"`);
    }
  }

  // node_modules/@chainsafe/libp2p-gossipsub/dist/src/utils/msgIdFn.js
  var import_browser_shims301 = __toESM(require_browser_shims(), 1);

  // node_modules/@libp2p/pubsub/dist/src/utils.js
  var import_browser_shims300 = __toESM(require_browser_shims(), 1);
  var msgId = (key, seqno) => {
    const seqnoBytes = fromString2(seqno.toString(16).padStart(16, "0"), "base16");
    const keyBytes = publicKeyToProtobuf(key);
    const msgId2 = new Uint8Array(keyBytes.byteLength + seqnoBytes.length);
    msgId2.set(keyBytes, 0);
    msgId2.set(seqnoBytes, keyBytes.byteLength);
    return msgId2;
  };

  // node_modules/@chainsafe/libp2p-gossipsub/dist/src/utils/msgIdFn.js
  function msgIdFnStrictSign(msg) {
    if (msg.type !== "signed") {
      throw new Error("expected signed message type");
    }
    if (msg.sequenceNumber == null)
      throw Error("missing seqno field");
    return msgId(msg.from.publicKey ?? msg.key, msg.sequenceNumber);
  }
  async function msgIdFnStrictNoSign(msg) {
    return sha256.encode(msg.data);
  }

  // node_modules/@chainsafe/libp2p-gossipsub/dist/src/utils/multiaddr.js
  var import_browser_shims302 = __toESM(require_browser_shims(), 1);
  var Protocol;
  (function(Protocol2) {
    Protocol2[Protocol2["ip4"] = 4] = "ip4";
    Protocol2[Protocol2["ip6"] = 41] = "ip6";
  })(Protocol || (Protocol = {}));
  function multiaddrToIPStr(multiaddr2) {
    for (const tuple of multiaddr2.tuples()) {
      switch (tuple[0]) {
        case Protocol.ip4:
        case Protocol.ip6:
          return convertToString(tuple[0], tuple[1]);
        default:
          break;
      }
    }
    return null;
  }

  // node_modules/@chainsafe/libp2p-gossipsub/dist/src/utils/time-cache.js
  var import_browser_shims303 = __toESM(require_browser_shims(), 1);
  var SimpleTimeCache = class {
    entries = /* @__PURE__ */ new Map();
    validityMs;
    constructor(opts) {
      this.validityMs = opts.validityMs;
    }
    get size() {
      return this.entries.size;
    }
    /** Returns true if there was a key collision and the entry is dropped */
    put(key, value) {
      if (this.entries.has(key)) {
        return true;
      }
      this.entries.set(key, { value, validUntilMs: Date.now() + this.validityMs });
      return false;
    }
    prune() {
      const now = Date.now();
      for (const [k, v] of this.entries.entries()) {
        if (v.validUntilMs < now) {
          this.entries.delete(k);
        } else {
          break;
        }
      }
    }
    has(key) {
      return this.entries.has(key);
    }
    get(key) {
      const value = this.entries.get(key);
      return value != null && value.validUntilMs >= Date.now() ? value.value : void 0;
    }
    clear() {
      this.entries.clear();
    }
  };

  // node_modules/@chainsafe/libp2p-gossipsub/dist/src/index.js
  var GossipStatusCode;
  (function(GossipStatusCode2) {
    GossipStatusCode2[GossipStatusCode2["started"] = 0] = "started";
    GossipStatusCode2[GossipStatusCode2["stopped"] = 1] = "stopped";
  })(GossipStatusCode || (GossipStatusCode = {}));
  var GossipSub = class extends TypedEventEmitter {
    /**
     * The signature policy to follow by default
     */
    globalSignaturePolicy;
    multicodecs = [GossipsubIDv12, GossipsubIDv11, GossipsubIDv10];
    publishConfig;
    dataTransform;
    // State
    peers = /* @__PURE__ */ new Map();
    streamsInbound = /* @__PURE__ */ new Map();
    streamsOutbound = /* @__PURE__ */ new Map();
    /** Ensures outbound streams are created sequentially */
    outboundInflightQueue = pushable({ objectMode: true });
    /** Direct peers */
    direct = /* @__PURE__ */ new Set();
    /** Floodsub peers */
    floodsubPeers = /* @__PURE__ */ new Set();
    /** Cache of seen messages */
    seenCache;
    /**
     * Map of peer id and AcceptRequestWhileListEntry
     */
    acceptFromWhitelist = /* @__PURE__ */ new Map();
    /**
     * Map of topics to which peers are subscribed to
     */
    topics = /* @__PURE__ */ new Map();
    /**
     * List of our subscriptions
     */
    subscriptions = /* @__PURE__ */ new Set();
    /**
     * Map of topic meshes
     * topic => peer id set
     */
    mesh = /* @__PURE__ */ new Map();
    /**
     * Map of topics to set of peers. These mesh peers are the ones to which we are publishing without a topic membership
     * topic => peer id set
     */
    fanout = /* @__PURE__ */ new Map();
    /**
     * Map of last publish time for fanout topics
     * topic => last publish time
     */
    fanoutLastpub = /* @__PURE__ */ new Map();
    /**
     * Map of pending messages to gossip
     * peer id => control messages
     */
    gossip = /* @__PURE__ */ new Map();
    /**
     * Map of control messages
     * peer id => control message
     */
    control = /* @__PURE__ */ new Map();
    /**
     * Number of IHAVEs received from peer in the last heartbeat
     */
    peerhave = /* @__PURE__ */ new Map();
    /** Number of messages we have asked from peer in the last heartbeat */
    iasked = /* @__PURE__ */ new Map();
    /** Prune backoff map */
    backoff = /* @__PURE__ */ new Map();
    /**
     * Connection direction cache, marks peers with outbound connections
     * peer id => direction
     */
    outbound = /* @__PURE__ */ new Map();
    msgIdFn;
    /**
     * A fast message id function used for internal message de-duplication
     */
    fastMsgIdFn;
    msgIdToStrFn;
    /** Maps fast message-id to canonical message-id */
    fastMsgIdCache;
    /**
     * Short term cache for published message ids. This is used for penalizing peers sending
     * our own messages back if the messages are anonymous or use a random author.
     */
    publishedMessageIds;
    /**
     * A message cache that contains the messages for last few heartbeat ticks
     */
    mcache;
    /** Peer score tracking */
    score;
    /**
     * Custom validator function per topic.
     * Must return or resolve quickly (< 100ms) to prevent causing penalties for late messages.
     * If you need to apply validation that may require longer times use `asyncValidation` option and callback the
     * validation result through `Gossipsub.reportValidationResult`
     */
    topicValidators = /* @__PURE__ */ new Map();
    /**
     * Make this protected so child class may want to redirect to its own log.
     */
    log;
    /**
     * Number of heartbeats since the beginning of time
     * This allows us to amortize some resource cleanup -- eg: backoff cleanup
     */
    heartbeatTicks = 0;
    /**
     * Tracks IHAVE/IWANT promises broken by peers
     */
    gossipTracer;
    /**
     * Tracks IDONTWANT messages received by peers in the current heartbeat
     */
    idontwantCounts = /* @__PURE__ */ new Map();
    /**
     * Tracks IDONTWANT messages received by peers and the heartbeat they were received in
     *
     * idontwants are stored for `mcacheLength` heartbeats before being pruned,
     * so this map is bounded by peerCount * idontwantMaxMessages * mcacheLength
     */
    idontwants = /* @__PURE__ */ new Map();
    components;
    directPeerInitial = null;
    static multicodec = GossipsubIDv12;
    // Options
    opts;
    decodeRpcLimits;
    metrics;
    status = { code: GossipStatusCode.stopped };
    maxInboundStreams;
    maxOutboundStreams;
    runOnLimitedConnection;
    allowedTopics;
    heartbeatTimer = null;
    constructor(components, options = {}) {
      super();
      const opts = {
        fallbackToFloodsub: true,
        floodPublish: true,
        batchPublish: false,
        tagMeshPeers: true,
        doPX: false,
        directPeers: [],
        D: GossipsubD,
        Dlo: GossipsubDlo,
        Dhi: GossipsubDhi,
        Dscore: GossipsubDscore,
        Dout: GossipsubDout,
        Dlazy: GossipsubDlazy,
        heartbeatInterval: GossipsubHeartbeatInterval,
        fanoutTTL: GossipsubFanoutTTL,
        mcacheLength: GossipsubHistoryLength,
        mcacheGossip: GossipsubHistoryGossip,
        seenTTL: GossipsubSeenTTL,
        gossipsubIWantFollowupMs: GossipsubIWantFollowupTime,
        prunePeers: GossipsubPrunePeers,
        pruneBackoff: GossipsubPruneBackoff,
        unsubcribeBackoff: GossipsubUnsubscribeBackoff,
        graftFloodThreshold: GossipsubGraftFloodThreshold,
        opportunisticGraftPeers: GossipsubOpportunisticGraftPeers,
        opportunisticGraftTicks: GossipsubOpportunisticGraftTicks,
        directConnectTicks: GossipsubDirectConnectTicks,
        gossipFactor: GossipsubGossipFactor,
        idontwantMinDataSize: GossipsubIdontwantMinDataSize,
        idontwantMaxMessages: GossipsubIdontwantMaxMessages,
        ...options,
        scoreParams: createPeerScoreParams(options.scoreParams),
        scoreThresholds: createPeerScoreThresholds(options.scoreThresholds)
      };
      this.components = components;
      this.decodeRpcLimits = opts.decodeRpcLimits ?? defaultDecodeRpcLimits;
      this.globalSignaturePolicy = opts.globalSignaturePolicy ?? StrictSign;
      if (opts.fallbackToFloodsub) {
        this.multicodecs.push(FloodsubID);
      }
      this.log = components.logger.forComponent(opts.debugName ?? "libp2p:gossipsub");
      this.opts = opts;
      this.direct = new Set(opts.directPeers.map((p) => p.id.toString()));
      this.seenCache = new SimpleTimeCache({ validityMs: opts.seenTTL });
      this.publishedMessageIds = new SimpleTimeCache({ validityMs: opts.seenTTL });
      if (options.msgIdFn != null) {
        this.msgIdFn = options.msgIdFn;
      } else {
        switch (this.globalSignaturePolicy) {
          case StrictSign:
            this.msgIdFn = msgIdFnStrictSign;
            break;
          case StrictNoSign:
            this.msgIdFn = msgIdFnStrictNoSign;
            break;
          default:
            throw new Error(`Invalid globalSignaturePolicy: ${this.globalSignaturePolicy}`);
        }
      }
      if (options.fastMsgIdFn != null) {
        this.fastMsgIdFn = options.fastMsgIdFn;
        this.fastMsgIdCache = new SimpleTimeCache({ validityMs: opts.seenTTL });
      }
      this.msgIdToStrFn = options.msgIdToStrFn ?? messageIdToString;
      this.mcache = options.messageCache ?? new MessageCache(opts.mcacheGossip, opts.mcacheLength, this.msgIdToStrFn);
      if (options.dataTransform != null) {
        this.dataTransform = options.dataTransform;
      }
      if (options.metricsRegister != null) {
        if (options.metricsTopicStrToLabel == null) {
          throw Error("Must set metricsTopicStrToLabel with metrics");
        }
        const maxMeshMessageDeliveriesWindowMs = Math.max(...Object.values(opts.scoreParams.topics).map((topicParam) => topicParam.meshMessageDeliveriesWindow), DEFAULT_METRIC_MESH_MESSAGE_DELIVERIES_WINDOWS);
        const metrics = getMetrics(options.metricsRegister, options.metricsTopicStrToLabel, {
          gossipPromiseExpireSec: this.opts.gossipsubIWantFollowupMs / 1e3,
          behaviourPenaltyThreshold: opts.scoreParams.behaviourPenaltyThreshold,
          maxMeshMessageDeliveriesWindowSec: maxMeshMessageDeliveriesWindowMs / 1e3
        });
        metrics.mcacheSize.addCollect(() => {
          this.onScrapeMetrics(metrics);
        });
        for (const protocol of this.multicodecs) {
          metrics.protocolsEnabled.set({ protocol }, 1);
        }
        this.metrics = metrics;
      } else {
        this.metrics = null;
      }
      this.gossipTracer = new IWantTracer(this.opts.gossipsubIWantFollowupMs, this.msgIdToStrFn, this.metrics);
      this.score = new PeerScore(this.opts.scoreParams, this.metrics, this.components.logger, {
        scoreCacheValidityMs: opts.heartbeatInterval
      });
      this.maxInboundStreams = options.maxInboundStreams;
      this.maxOutboundStreams = options.maxOutboundStreams;
      this.runOnLimitedConnection = options.runOnLimitedConnection;
      this.allowedTopics = opts.allowedTopics != null ? new Set(opts.allowedTopics) : null;
    }
    [Symbol.toStringTag] = "@chainsafe/libp2p-gossipsub";
    [serviceCapabilities] = [
      "@libp2p/pubsub"
    ];
    [serviceDependencies] = [
      "@libp2p/identify"
    ];
    getPeers() {
      return [...this.peers.values()];
    }
    isStarted() {
      return this.status.code === GossipStatusCode.started;
    }
    // LIFECYCLE METHODS
    /**
     * Mounts the gossipsub protocol onto the libp2p node and sends our
     * our subscriptions to every peer connected
     */
    async start() {
      if (this.isStarted()) {
        return;
      }
      this.log("starting");
      this.publishConfig = getPublishConfigFromPeerId(this.globalSignaturePolicy, this.components.peerId, this.components.privateKey);
      this.outboundInflightQueue = pushable({ objectMode: true });
      pipe(this.outboundInflightQueue, async (source) => {
        for await (const { peerId: peerId2, connection } of source) {
          await this.createOutboundStream(peerId2, connection);
        }
      }).catch((e) => {
        this.log.error("outbound inflight queue error", e);
      });
      await Promise.all(this.opts.directPeers.map(async (p) => {
        await this.components.peerStore.merge(p.id, {
          multiaddrs: p.addrs
        });
      }));
      const registrar = this.components.registrar;
      await Promise.all(this.multicodecs.map(async (multicodec) => registrar.handle(multicodec, this.onIncomingStream.bind(this), {
        maxInboundStreams: this.maxInboundStreams,
        maxOutboundStreams: this.maxOutboundStreams,
        runOnLimitedConnection: this.runOnLimitedConnection
      })));
      const topology = {
        onConnect: this.onPeerConnected.bind(this),
        onDisconnect: this.onPeerDisconnected.bind(this),
        notifyOnLimitedConnection: this.runOnLimitedConnection
      };
      const registrarTopologyIds = await Promise.all(this.multicodecs.map(async (multicodec) => registrar.register(multicodec, topology)));
      const heartbeatTimeout = setTimeout(this.runHeartbeat, GossipsubHeartbeatInitialDelay);
      this.status = {
        code: GossipStatusCode.started,
        registrarTopologyIds,
        heartbeatTimeout,
        hearbeatStartMs: Date.now() + GossipsubHeartbeatInitialDelay
      };
      this.score.start();
      this.directPeerInitial = setTimeout(() => {
        Promise.resolve().then(async () => {
          await Promise.all(Array.from(this.direct).map(async (id) => this.connect(id)));
        }).catch((err) => {
          this.log(err);
        });
      }, GossipsubDirectConnectInitialDelay);
      if (this.opts.tagMeshPeers) {
        this.addEventListener("gossipsub:graft", this.tagMeshPeer);
        this.addEventListener("gossipsub:prune", this.untagMeshPeer);
      }
      this.log("started");
    }
    /**
     * Unmounts the gossipsub protocol and shuts down every connection
     */
    async stop() {
      this.log("stopping");
      if (this.status.code !== GossipStatusCode.started) {
        return;
      }
      const { registrarTopologyIds } = this.status;
      this.status = { code: GossipStatusCode.stopped };
      if (this.opts.tagMeshPeers) {
        this.removeEventListener("gossipsub:graft", this.tagMeshPeer);
        this.removeEventListener("gossipsub:prune", this.untagMeshPeer);
      }
      const registrar = this.components.registrar;
      await Promise.all(this.multicodecs.map(async (multicodec) => registrar.unhandle(multicodec)));
      registrarTopologyIds.forEach((id) => {
        registrar.unregister(id);
      });
      this.outboundInflightQueue.end();
      const closePromises = [];
      for (const outboundStream of this.streamsOutbound.values()) {
        closePromises.push(outboundStream.close());
      }
      this.streamsOutbound.clear();
      for (const inboundStream of this.streamsInbound.values()) {
        closePromises.push(inboundStream.close());
      }
      this.streamsInbound.clear();
      await Promise.all(closePromises);
      this.peers.clear();
      this.subscriptions.clear();
      if (this.heartbeatTimer != null) {
        this.heartbeatTimer.cancel();
        this.heartbeatTimer = null;
      }
      this.score.stop();
      this.mesh.clear();
      this.fanout.clear();
      this.fanoutLastpub.clear();
      this.gossip.clear();
      this.control.clear();
      this.peerhave.clear();
      this.iasked.clear();
      this.backoff.clear();
      this.outbound.clear();
      this.gossipTracer.clear();
      this.seenCache.clear();
      if (this.fastMsgIdCache != null)
        this.fastMsgIdCache.clear();
      if (this.directPeerInitial != null)
        clearTimeout(this.directPeerInitial);
      this.idontwantCounts.clear();
      this.idontwants.clear();
      this.log("stopped");
    }
    /** FOR DEBUG ONLY - Dump peer stats for all peers. Data is cloned, safe to mutate */
    dumpPeerScoreStats() {
      return this.score.dumpPeerScoreStats();
    }
    /**
     * On an inbound stream opened
     */
    onIncomingStream({ stream, connection }) {
      if (!this.isStarted()) {
        return;
      }
      const peerId2 = connection.remotePeer;
      this.addPeer(peerId2, connection.direction, connection.remoteAddr);
      this.createInboundStream(peerId2, stream);
      this.outboundInflightQueue.push({ peerId: peerId2, connection });
    }
    /**
     * Registrar notifies an established connection with pubsub protocol
     */
    onPeerConnected(peerId2, connection) {
      var _a2;
      (_a2 = this.metrics) == null ? void 0 : _a2.newConnectionCount.inc({ status: connection.status });
      if (!this.isStarted() || connection.status !== "open") {
        return;
      }
      this.addPeer(peerId2, connection.direction, connection.remoteAddr);
      this.outboundInflightQueue.push({ peerId: peerId2, connection });
    }
    /**
     * Registrar notifies a closing connection with pubsub protocol
     */
    onPeerDisconnected(peerId2) {
      this.log("connection ended %p", peerId2);
      this.removePeer(peerId2);
    }
    async createOutboundStream(peerId2, connection) {
      var _a2;
      if (!this.isStarted()) {
        return;
      }
      const id = peerId2.toString();
      if (!this.peers.has(id)) {
        return;
      }
      if (this.streamsOutbound.has(id)) {
        return;
      }
      try {
        const stream = new OutboundStream(await connection.newStream(this.multicodecs, {
          runOnLimitedConnection: this.runOnLimitedConnection
        }), (e) => {
          this.log.error("outbound pipe error", e);
        }, { maxBufferSize: this.opts.maxOutboundBufferSize });
        this.log("create outbound stream %p", peerId2);
        this.streamsOutbound.set(id, stream);
        const protocol = stream.protocol;
        if (protocol === FloodsubID) {
          this.floodsubPeers.add(id);
        }
        (_a2 = this.metrics) == null ? void 0 : _a2.peersPerProtocol.inc({ protocol }, 1);
        if (this.subscriptions.size > 0) {
          this.log("send subscriptions to", id);
          this.sendSubscriptions(id, Array.from(this.subscriptions), true);
        }
      } catch (e) {
        this.log.error("createOutboundStream error", e);
      }
    }
    createInboundStream(peerId2, stream) {
      if (!this.isStarted()) {
        return;
      }
      const id = peerId2.toString();
      if (!this.peers.has(id)) {
        return;
      }
      const priorInboundStream = this.streamsInbound.get(id);
      if (priorInboundStream !== void 0) {
        this.log("replacing existing inbound steam %s", id);
        priorInboundStream.close().catch((err) => {
          this.log.error(err);
        });
      }
      this.log("create inbound stream %s", id);
      const inboundStream = new InboundStream(stream, { maxDataLength: this.opts.maxInboundDataLength });
      this.streamsInbound.set(id, inboundStream);
      this.pipePeerReadStream(peerId2, inboundStream.source).catch((err) => {
        this.log(err);
      });
    }
    /**
     * Add a peer to the router
     */
    addPeer(peerId2, direction, addr) {
      const id = peerId2.toString();
      if (!this.peers.has(id)) {
        this.log("new peer %p", peerId2);
        this.peers.set(id, peerId2);
        this.score.addPeer(id);
        const currentIP = multiaddrToIPStr(addr);
        if (currentIP !== null) {
          this.score.addIP(id, currentIP);
        } else {
          this.log("Added peer has no IP in current address %s %s", id, addr.toString());
        }
        if (!this.outbound.has(id)) {
          this.outbound.set(id, direction === "outbound");
        }
      }
    }
    /**
     * Removes a peer from the router
     */
    removePeer(peerId2) {
      var _a2, _b2;
      const id = peerId2.toString();
      if (!this.peers.has(id)) {
        return;
      }
      this.log("delete peer %p", peerId2);
      this.peers.delete(id);
      const outboundStream = this.streamsOutbound.get(id);
      const inboundStream = this.streamsInbound.get(id);
      if (outboundStream != null) {
        (_a2 = this.metrics) == null ? void 0 : _a2.peersPerProtocol.inc({ protocol: outboundStream.protocol }, -1);
      }
      outboundStream == null ? void 0 : outboundStream.close().catch((err) => {
        this.log.error(err);
      });
      inboundStream == null ? void 0 : inboundStream.close().catch((err) => {
        this.log.error(err);
      });
      this.streamsOutbound.delete(id);
      this.streamsInbound.delete(id);
      for (const peers of this.topics.values()) {
        peers.delete(id);
      }
      for (const [topicStr, peers] of this.mesh) {
        if (peers.delete(id)) {
          (_b2 = this.metrics) == null ? void 0 : _b2.onRemoveFromMesh(topicStr, ChurnReason.Dc, 1);
        }
      }
      for (const peers of this.fanout.values()) {
        peers.delete(id);
      }
      this.floodsubPeers.delete(id);
      this.gossip.delete(id);
      this.control.delete(id);
      this.outbound.delete(id);
      this.idontwantCounts.delete(id);
      this.idontwants.delete(id);
      this.score.removePeer(id);
      this.acceptFromWhitelist.delete(id);
    }
    // API METHODS
    get started() {
      return this.status.code === GossipStatusCode.started;
    }
    /**
     * Get a the peer-ids in a topic mesh
     */
    getMeshPeers(topic) {
      const peersInTopic = this.mesh.get(topic);
      return peersInTopic != null ? Array.from(peersInTopic) : [];
    }
    /**
     * Get a list of the peer-ids that are subscribed to one topic.
     */
    getSubscribers(topic) {
      const peersInTopic = this.topics.get(topic);
      return (peersInTopic != null ? Array.from(peersInTopic) : []).map((str) => this.peers.get(str) ?? peerIdFromString(str));
    }
    /**
     * Get the list of topics which the peer is subscribed to.
     */
    getTopics() {
      return Array.from(this.subscriptions);
    }
    // TODO: Reviewing Pubsub API
    // MESSAGE METHODS
    /**
     * Responsible for processing each RPC message received by other peers.
     */
    async pipePeerReadStream(peerId2, stream) {
      var _a2;
      try {
        await pipe(stream, async (source) => {
          var _a3, _b2, _c;
          for await (const data of source) {
            try {
              const rpcBytes = data.subarray();
              const rpc = RPC.decode(rpcBytes, {
                limits: {
                  subscriptions: this.decodeRpcLimits.maxSubscriptions,
                  messages: this.decodeRpcLimits.maxMessages,
                  control$: {
                    ihave: this.decodeRpcLimits.maxIhaveMessageIDs,
                    iwant: this.decodeRpcLimits.maxIwantMessageIDs,
                    graft: this.decodeRpcLimits.maxControlMessages,
                    prune: this.decodeRpcLimits.maxControlMessages,
                    prune$: {
                      peers: this.decodeRpcLimits.maxPeerInfos
                    },
                    idontwant: this.decodeRpcLimits.maxControlMessages,
                    idontwant$: {
                      messageIDs: this.decodeRpcLimits.maxIdontwantMessageIDs
                    }
                  }
                }
              });
              (_a3 = this.metrics) == null ? void 0 : _a3.onRpcRecv(rpc, rpcBytes.length);
              if (this.opts.awaitRpcHandler) {
                try {
                  await this.handleReceivedRpc(peerId2, rpc);
                } catch (err) {
                  (_b2 = this.metrics) == null ? void 0 : _b2.onRpcRecvError();
                  this.log(err);
                }
              } else {
                this.handleReceivedRpc(peerId2, rpc).catch((err) => {
                  var _a4;
                  (_a4 = this.metrics) == null ? void 0 : _a4.onRpcRecvError();
                  this.log(err);
                });
              }
            } catch (e) {
              (_c = this.metrics) == null ? void 0 : _c.onRpcDataError();
              this.log(e);
            }
          }
        });
      } catch (err) {
        (_a2 = this.metrics) == null ? void 0 : _a2.onPeerReadStreamError();
        this.handlePeerReadStreamError(err, peerId2);
      }
    }
    /**
     * Handle error when read stream pipe throws, less of the functional use but more
     * to for testing purposes to spy on the error handling
     * */
    handlePeerReadStreamError(err, peerId2) {
      this.log.error(err);
      this.onPeerDisconnected(peerId2);
    }
    /**
     * Handles an rpc request from a peer
     */
    async handleReceivedRpc(from3, rpc) {
      var _a2;
      if (!this.acceptFrom(from3.toString())) {
        this.log("received message from unacceptable peer %p", from3);
        (_a2 = this.metrics) == null ? void 0 : _a2.rpcRecvNotAccepted.inc();
        return;
      }
      const subscriptions = rpc.subscriptions != null ? rpc.subscriptions.length : 0;
      const messages2 = rpc.messages != null ? rpc.messages.length : 0;
      let ihave = 0;
      let iwant = 0;
      let graft = 0;
      let prune = 0;
      if (rpc.control != null) {
        if (rpc.control.ihave != null)
          ihave = rpc.control.ihave.length;
        if (rpc.control.iwant != null)
          iwant = rpc.control.iwant.length;
        if (rpc.control.graft != null)
          graft = rpc.control.graft.length;
        if (rpc.control.prune != null)
          prune = rpc.control.prune.length;
      }
      this.log(`rpc.from ${from3.toString()} subscriptions ${subscriptions} messages ${messages2} ihave ${ihave} iwant ${iwant} graft ${graft} prune ${prune}`);
      if (rpc.subscriptions != null && rpc.subscriptions.length > 0) {
        const subscriptions2 = [];
        rpc.subscriptions.forEach((subOpt) => {
          const topic = subOpt.topic;
          const subscribe = subOpt.subscribe === true;
          if (topic != null) {
            if (this.allowedTopics != null && !this.allowedTopics.has(topic)) {
              return;
            }
            this.handleReceivedSubscription(from3, topic, subscribe);
            subscriptions2.push({ topic, subscribe });
          }
        });
        this.safeDispatchEvent("subscription-change", {
          detail: { peerId: from3, subscriptions: subscriptions2 }
        });
      }
      for (const message2 of rpc.messages) {
        if (this.allowedTopics != null && !this.allowedTopics.has(message2.topic)) {
          continue;
        }
        const handleReceivedMessagePromise = this.handleReceivedMessage(from3, message2).catch((err) => {
          var _a3;
          (_a3 = this.metrics) == null ? void 0 : _a3.onMsgRecvError(message2.topic);
          this.log(err);
        });
        if (this.opts.awaitRpcMessageHandler) {
          await handleReceivedMessagePromise;
        }
      }
      if (rpc.control != null) {
        await this.handleControlMessage(from3.toString(), rpc.control);
      }
    }
    /**
     * Handles a subscription change from a peer
     */
    handleReceivedSubscription(from3, topic, subscribe) {
      this.log("subscription update from %p topic %s", from3, topic);
      let topicSet = this.topics.get(topic);
      if (topicSet == null) {
        topicSet = /* @__PURE__ */ new Set();
        this.topics.set(topic, topicSet);
      }
      if (subscribe) {
        topicSet.add(from3.toString());
      } else {
        topicSet.delete(from3.toString());
      }
    }
    /**
     * Handles a newly received message from an RPC.
     * May forward to all peers in the mesh.
     */
    async handleReceivedMessage(from3, rpcMsg) {
      var _a2, _b2, _c;
      (_a2 = this.metrics) == null ? void 0 : _a2.onMsgRecvPreValidation(rpcMsg.topic);
      const validationResult = await this.validateReceivedMessage(from3, rpcMsg);
      (_b2 = this.metrics) == null ? void 0 : _b2.onPrevalidationResult(rpcMsg.topic, validationResult.code);
      const validationCode = validationResult.code;
      switch (validationCode) {
        case MessageStatus.duplicate:
          this.score.duplicateMessage(from3.toString(), validationResult.msgIdStr, rpcMsg.topic);
          this.gossipTracer.deliverMessage(validationResult.msgIdStr, true);
          this.mcache.observeDuplicate(validationResult.msgIdStr, from3.toString());
          return;
        case MessageStatus.invalid:
          if (validationResult.msgIdStr != null) {
            const msgIdStr = validationResult.msgIdStr;
            this.score.rejectMessage(from3.toString(), msgIdStr, rpcMsg.topic, validationResult.reason);
            this.gossipTracer.rejectMessage(msgIdStr, validationResult.reason);
          } else {
            this.score.rejectInvalidMessage(from3.toString(), rpcMsg.topic);
          }
          (_c = this.metrics) == null ? void 0 : _c.onMsgRecvInvalid(rpcMsg.topic, validationResult);
          return;
        case MessageStatus.valid:
          this.score.validateMessage(validationResult.messageId.msgIdStr);
          this.gossipTracer.deliverMessage(validationResult.messageId.msgIdStr);
          this.mcache.put(validationResult.messageId, rpcMsg, !this.opts.asyncValidation);
          if (this.subscriptions.has(rpcMsg.topic)) {
            const isFromSelf = this.components.peerId.equals(from3);
            if (!isFromSelf || this.opts.emitSelf) {
              super.dispatchEvent(new CustomEvent("gossipsub:message", {
                detail: {
                  propagationSource: from3,
                  msgId: validationResult.messageId.msgIdStr,
                  msg: validationResult.msg
                }
              }));
              super.dispatchEvent(new CustomEvent("message", { detail: validationResult.msg }));
            }
          }
          if (!this.opts.asyncValidation) {
            this.forwardMessage(validationResult.messageId.msgIdStr, rpcMsg, from3.toString());
          }
          break;
        default:
          throw new Error(`Invalid validation result: ${validationCode}`);
      }
    }
    /**
     * Handles a newly received message from an RPC.
     * May forward to all peers in the mesh.
     */
    async validateReceivedMessage(propagationSource, rpcMsg) {
      var _a2, _b2, _c, _d;
      const fastMsgIdStr = (_a2 = this.fastMsgIdFn) == null ? void 0 : _a2.call(this, rpcMsg);
      const msgIdCached = fastMsgIdStr !== void 0 ? (_b2 = this.fastMsgIdCache) == null ? void 0 : _b2.get(fastMsgIdStr) : void 0;
      if (msgIdCached != null) {
        return { code: MessageStatus.duplicate, msgIdStr: msgIdCached };
      }
      const validationResult = await validateToRawMessage(this.globalSignaturePolicy, rpcMsg);
      if (!validationResult.valid) {
        return { code: MessageStatus.invalid, reason: RejectReason.Error, error: validationResult.error };
      }
      const msg = validationResult.message;
      try {
        if (this.dataTransform != null) {
          msg.data = this.dataTransform.inboundTransform(rpcMsg.topic, msg.data);
        }
      } catch (e) {
        this.log("Invalid message, transform failed", e);
        return { code: MessageStatus.invalid, reason: RejectReason.Error, error: ValidateError.TransformFailed };
      }
      const msgId2 = await this.msgIdFn(msg);
      const msgIdStr = this.msgIdToStrFn(msgId2);
      const messageId = { msgId: msgId2, msgIdStr };
      if (fastMsgIdStr !== void 0 && this.fastMsgIdCache != null) {
        const collision = this.fastMsgIdCache.put(fastMsgIdStr, msgIdStr);
        if (collision) {
          (_c = this.metrics) == null ? void 0 : _c.fastMsgIdCacheCollision.inc();
        }
      }
      if (this.seenCache.has(msgIdStr)) {
        return { code: MessageStatus.duplicate, msgIdStr };
      } else {
        this.seenCache.put(msgIdStr);
      }
      if ((((_d = rpcMsg.data) == null ? void 0 : _d.length) ?? 0) >= this.opts.idontwantMinDataSize) {
        this.sendIDontWants(msgId2, rpcMsg.topic, propagationSource.toString());
      }
      const topicValidator = this.topicValidators.get(rpcMsg.topic);
      if (topicValidator != null) {
        let acceptance;
        try {
          acceptance = await topicValidator(propagationSource, msg);
        } catch (e) {
          const errCode = e.code;
          if (errCode === ERR_TOPIC_VALIDATOR_IGNORE)
            acceptance = TopicValidatorResult.Ignore;
          if (errCode === ERR_TOPIC_VALIDATOR_REJECT)
            acceptance = TopicValidatorResult.Reject;
          else
            acceptance = TopicValidatorResult.Ignore;
        }
        if (acceptance !== TopicValidatorResult.Accept) {
          return { code: MessageStatus.invalid, reason: rejectReasonFromAcceptance(acceptance), msgIdStr };
        }
      }
      return { code: MessageStatus.valid, messageId, msg };
    }
    /**
     * Return score of a peer.
     */
    getScore(peerId2) {
      return this.score.score(peerId2);
    }
    /**
     * Send an rpc object to a peer with subscriptions
     */
    sendSubscriptions(toPeer, topics, subscribe) {
      this.sendRpc(toPeer, {
        subscriptions: topics.map((topic) => ({ topic, subscribe })),
        messages: []
      });
    }
    /**
     * Handles an rpc control message from a peer
     */
    async handleControlMessage(id, controlMsg) {
      var _a2, _b2, _c, _d, _e, _f, _g;
      if (controlMsg === void 0) {
        return;
      }
      const iwant = ((_a2 = controlMsg.ihave) == null ? void 0 : _a2.length) > 0 ? this.handleIHave(id, controlMsg.ihave) : [];
      const ihave = ((_b2 = controlMsg.iwant) == null ? void 0 : _b2.length) > 0 ? this.handleIWant(id, controlMsg.iwant) : [];
      const prune = ((_c = controlMsg.graft) == null ? void 0 : _c.length) > 0 ? await this.handleGraft(id, controlMsg.graft) : [];
      ((_d = controlMsg.prune) == null ? void 0 : _d.length) > 0 && await this.handlePrune(id, controlMsg.prune);
      ((_e = controlMsg.idontwant) == null ? void 0 : _e.length) > 0 && this.handleIdontwant(id, controlMsg.idontwant);
      if (iwant.length === 0 && ihave.length === 0 && prune.length === 0) {
        return;
      }
      const sent = this.sendRpc(id, createGossipRpc(ihave, { iwant, prune }));
      const iwantMessageIds = (_f = iwant[0]) == null ? void 0 : _f.messageIDs;
      if (iwantMessageIds != null) {
        if (sent) {
          this.gossipTracer.addPromise(id, iwantMessageIds);
        } else {
          (_g = this.metrics) == null ? void 0 : _g.iwantPromiseUntracked.inc(1);
        }
      }
    }
    /**
     * Whether to accept a message from a peer
     */
    acceptFrom(id) {
      if (this.direct.has(id)) {
        return true;
      }
      const now = Date.now();
      const entry = this.acceptFromWhitelist.get(id);
      if (entry != null && entry.messagesAccepted < ACCEPT_FROM_WHITELIST_MAX_MESSAGES && entry.acceptUntil >= now) {
        entry.messagesAccepted += 1;
        return true;
      }
      const score = this.score.score(id);
      if (score >= ACCEPT_FROM_WHITELIST_THRESHOLD_SCORE) {
        this.acceptFromWhitelist.set(id, {
          messagesAccepted: 0,
          acceptUntil: now + ACCEPT_FROM_WHITELIST_DURATION_MS
        });
      } else {
        this.acceptFromWhitelist.delete(id);
      }
      return score >= this.opts.scoreThresholds.graylistThreshold;
    }
    /**
     * Handles IHAVE messages
     */
    handleIHave(id, ihave) {
      var _a2, _b2, _c;
      if (ihave.length === 0) {
        return [];
      }
      const score = this.score.score(id);
      if (score < this.opts.scoreThresholds.gossipThreshold) {
        this.log("IHAVE: ignoring peer %s with score below threshold [ score = %d ]", id, score);
        (_a2 = this.metrics) == null ? void 0 : _a2.ihaveRcvIgnored.inc({ reason: IHaveIgnoreReason.LowScore });
        return [];
      }
      const peerhave = (this.peerhave.get(id) ?? 0) + 1;
      this.peerhave.set(id, peerhave);
      if (peerhave > GossipsubMaxIHaveMessages) {
        this.log("IHAVE: peer %s has advertised too many times (%d) within this heartbeat interval; ignoring", id, peerhave);
        (_b2 = this.metrics) == null ? void 0 : _b2.ihaveRcvIgnored.inc({ reason: IHaveIgnoreReason.MaxIhave });
        return [];
      }
      const iasked = this.iasked.get(id) ?? 0;
      if (iasked >= GossipsubMaxIHaveLength) {
        this.log("IHAVE: peer %s has already advertised too many messages (%d); ignoring", id, iasked);
        (_c = this.metrics) == null ? void 0 : _c.ihaveRcvIgnored.inc({ reason: IHaveIgnoreReason.MaxIasked });
        return [];
      }
      const iwant = /* @__PURE__ */ new Map();
      ihave.forEach(({ topicID, messageIDs }) => {
        var _a3;
        if (topicID == null || messageIDs == null || !this.mesh.has(topicID)) {
          return;
        }
        let idonthave = 0;
        messageIDs.forEach((msgId2) => {
          const msgIdStr = this.msgIdToStrFn(msgId2);
          if (!this.seenCache.has(msgIdStr)) {
            iwant.set(msgIdStr, msgId2);
            idonthave++;
          }
        });
        (_a3 = this.metrics) == null ? void 0 : _a3.onIhaveRcv(topicID, messageIDs.length, idonthave);
      });
      if (iwant.size === 0) {
        return [];
      }
      let iask = iwant.size;
      if (iask + iasked > GossipsubMaxIHaveLength) {
        iask = GossipsubMaxIHaveLength - iasked;
      }
      this.log("IHAVE: Asking for %d out of %d messages from %s", iask, iwant.size, id);
      let iwantList = Array.from(iwant.values());
      shuffle(iwantList);
      iwantList = iwantList.slice(0, iask);
      this.iasked.set(id, iasked + iask);
      return [
        {
          messageIDs: iwantList
        }
      ];
    }
    /**
     * Handles IWANT messages
     * Returns messages to send back to peer
     */
    handleIWant(id, iwant) {
      var _a2;
      if (iwant.length === 0) {
        return [];
      }
      const score = this.score.score(id);
      if (score < this.opts.scoreThresholds.gossipThreshold) {
        this.log("IWANT: ignoring peer %s with score below threshold [score = %d]", id, score);
        return [];
      }
      const ihave = /* @__PURE__ */ new Map();
      const iwantByTopic = /* @__PURE__ */ new Map();
      let iwantDonthave = 0;
      iwant.forEach(({ messageIDs }) => {
        messageIDs == null ? void 0 : messageIDs.forEach((msgId2) => {
          const msgIdStr = this.msgIdToStrFn(msgId2);
          const entry = this.mcache.getWithIWantCount(msgIdStr, id);
          if (entry == null) {
            iwantDonthave++;
            return;
          }
          iwantByTopic.set(entry.msg.topic, 1 + (iwantByTopic.get(entry.msg.topic) ?? 0));
          if (entry.count > GossipsubGossipRetransmission) {
            this.log("IWANT: Peer %s has asked for message %s too many times: ignoring request", id, msgId2);
            return;
          }
          ihave.set(msgIdStr, entry.msg);
        });
      });
      (_a2 = this.metrics) == null ? void 0 : _a2.onIwantRcv(iwantByTopic, iwantDonthave);
      if (ihave.size === 0) {
        this.log("IWANT: Could not provide any wanted messages to %s", id);
        return [];
      }
      this.log("IWANT: Sending %d messages to %s", ihave.size, id);
      return Array.from(ihave.values());
    }
    /**
     * Handles Graft messages
     */
    async handleGraft(id, graft) {
      const prune = [];
      const score = this.score.score(id);
      const now = Date.now();
      let doPX = this.opts.doPX;
      graft.forEach(({ topicID }) => {
        var _a2, _b2;
        if (topicID == null) {
          return;
        }
        const peersInMesh = this.mesh.get(topicID);
        if (peersInMesh == null) {
          doPX = false;
          return;
        }
        if (peersInMesh.has(id)) {
          return;
        }
        const backoffExpiry = (_a2 = this.backoff.get(topicID)) == null ? void 0 : _a2.get(id);
        if (this.direct.has(id)) {
          this.log("GRAFT: ignoring request from direct peer %s", id);
          prune.push(topicID);
          doPX = false;
        } else if (typeof backoffExpiry === "number" && now < backoffExpiry) {
          this.log("GRAFT: ignoring backed off peer %s", id);
          this.score.addPenalty(id, 1, ScorePenalty.GraftBackoff);
          doPX = false;
          const floodCutoff = backoffExpiry + this.opts.graftFloodThreshold - this.opts.pruneBackoff;
          if (now < floodCutoff) {
            this.score.addPenalty(id, 1, ScorePenalty.GraftBackoff);
          }
          this.addBackoff(id, topicID);
          prune.push(topicID);
        } else if (score < 0) {
          this.log("GRAFT: ignoring peer %s with negative score: score=%d, topic=%s", id, score, topicID);
          prune.push(topicID);
          doPX = false;
          this.addBackoff(id, topicID);
        } else if (peersInMesh.size >= this.opts.Dhi && !(this.outbound.get(id) ?? false)) {
          prune.push(topicID);
          this.addBackoff(id, topicID);
        } else {
          this.log("GRAFT: Add mesh link from %s in %s", id, topicID);
          this.score.graft(id, topicID);
          peersInMesh.add(id);
          (_b2 = this.metrics) == null ? void 0 : _b2.onAddToMesh(topicID, InclusionReason.Subscribed, 1);
        }
        this.safeDispatchEvent("gossipsub:graft", { detail: { peerId: id, topic: topicID, direction: "inbound" } });
      });
      if (prune.length === 0) {
        return [];
      }
      const onUnsubscribe = false;
      return Promise.all(prune.map(async (topic) => this.makePrune(id, topic, doPX, onUnsubscribe)));
    }
    /**
     * Handles Prune messages
     */
    async handlePrune(id, prune) {
      var _a2;
      const score = this.score.score(id);
      for (const { topicID, backoff, peers } of prune) {
        if (topicID == null) {
          continue;
        }
        const peersInMesh = this.mesh.get(topicID);
        if (peersInMesh == null) {
          return;
        }
        this.log("PRUNE: Remove mesh link to %s in %s", id, topicID);
        this.score.prune(id, topicID);
        if (peersInMesh.has(id)) {
          peersInMesh.delete(id);
          (_a2 = this.metrics) == null ? void 0 : _a2.onRemoveFromMesh(topicID, ChurnReason.Prune, 1);
        }
        if (typeof backoff === "number" && backoff > 0) {
          this.doAddBackoff(id, topicID, backoff * 1e3);
        } else {
          this.addBackoff(id, topicID);
        }
        if (peers != null && peers.length > 0) {
          if (score < this.opts.scoreThresholds.acceptPXThreshold) {
            this.log("PRUNE: ignoring PX from peer %s with insufficient score [score = %d, topic = %s]", id, score, topicID);
          } else {
            await this.pxConnect(peers);
          }
        }
        this.safeDispatchEvent("gossipsub:prune", { detail: { peerId: id, topic: topicID, direction: "inbound" } });
      }
    }
    handleIdontwant(id, idontwant) {
      var _a2;
      let idontwantCount = this.idontwantCounts.get(id) ?? 0;
      if (idontwantCount >= this.opts.idontwantMaxMessages) {
        return;
      }
      const startIdontwantCount = idontwantCount;
      let idontwants = this.idontwants.get(id);
      if (idontwants == null) {
        idontwants = /* @__PURE__ */ new Map();
        this.idontwants.set(id, idontwants);
      }
      let idonthave = 0;
      out: for (const { messageIDs } of idontwant) {
        for (const msgId2 of messageIDs) {
          if (idontwantCount >= this.opts.idontwantMaxMessages) {
            break out;
          }
          idontwantCount++;
          const msgIdStr = this.msgIdToStrFn(msgId2);
          idontwants.set(msgIdStr, this.heartbeatTicks);
          if (!this.mcache.msgs.has(msgIdStr))
            idonthave++;
        }
      }
      this.idontwantCounts.set(id, idontwantCount);
      const total = idontwantCount - startIdontwantCount;
      (_a2 = this.metrics) == null ? void 0 : _a2.onIdontwantRcv(total, idonthave);
    }
    /**
     * Add standard backoff log for a peer in a topic
     */
    addBackoff(id, topic) {
      this.doAddBackoff(id, topic, this.opts.pruneBackoff);
    }
    /**
     * Add backoff expiry interval for a peer in a topic
     *
     * @param id
     * @param topic
     * @param intervalMs - backoff duration in milliseconds
     */
    doAddBackoff(id, topic, intervalMs) {
      let backoff = this.backoff.get(topic);
      if (backoff == null) {
        backoff = /* @__PURE__ */ new Map();
        this.backoff.set(topic, backoff);
      }
      const expire = Date.now() + intervalMs;
      const existingExpire = backoff.get(id) ?? 0;
      if (existingExpire < expire) {
        backoff.set(id, expire);
      }
    }
    /**
     * Apply penalties from broken IHAVE/IWANT promises
     */
    applyIwantPenalties() {
      this.gossipTracer.getBrokenPromises().forEach((count, p) => {
        this.log("peer %s didn't follow up in %d IWANT requests; adding penalty", p, count);
        this.score.addPenalty(p, count, ScorePenalty.BrokenPromise);
      });
    }
    /**
     * Clear expired backoff expiries
     */
    clearBackoff() {
      if (this.heartbeatTicks % GossipsubPruneBackoffTicks !== 0) {
        return;
      }
      const now = Date.now();
      this.backoff.forEach((backoff, topic) => {
        backoff.forEach((expire, id) => {
          if (expire + BACKOFF_SLACK * this.opts.heartbeatInterval < now) {
            backoff.delete(id);
          }
        });
        if (backoff.size === 0) {
          this.backoff.delete(topic);
        }
      });
    }
    /**
     * Maybe reconnect to direct peers
     */
    async directConnect() {
      const toconnect = [];
      this.direct.forEach((id) => {
        if (!this.streamsOutbound.has(id)) {
          toconnect.push(id);
        }
      });
      await Promise.all(toconnect.map(async (id) => this.connect(id)));
    }
    /**
     * Maybe attempt connection given signed peer records
     */
    async pxConnect(peers) {
      if (peers.length > this.opts.prunePeers) {
        shuffle(peers);
        peers = peers.slice(0, this.opts.prunePeers);
      }
      const toconnect = [];
      await Promise.all(peers.map(async (pi) => {
        if (pi.peerID == null) {
          return;
        }
        const peer = peerIdFromMultihash(decode4(pi.peerID));
        const p = peer.toString();
        if (this.peers.has(p)) {
          return;
        }
        if (pi.signedPeerRecord == null) {
          toconnect.push(p);
          return;
        }
        try {
          if (!await this.components.peerStore.consumePeerRecord(pi.signedPeerRecord, peer)) {
            this.log("bogus peer record obtained through px: could not add peer record to address book");
            return;
          }
          toconnect.push(p);
        } catch (e) {
          this.log("bogus peer record obtained through px: invalid signature or not a peer record");
        }
      }));
      if (toconnect.length === 0) {
        return;
      }
      await Promise.all(toconnect.map(async (id) => this.connect(id)));
    }
    /**
     * Connect to a peer using the gossipsub protocol
     */
    async connect(id) {
      var _a2;
      this.log("Initiating connection with %s", id);
      const peerId2 = peerIdFromString(id);
      const connection = await this.components.connectionManager.openConnection(peerId2);
      for (const multicodec of this.multicodecs) {
        for (const topology of this.components.registrar.getTopologies(multicodec)) {
          (_a2 = topology.onConnect) == null ? void 0 : _a2.call(topology, peerId2, connection);
        }
      }
    }
    /**
     * Subscribes to a topic
     */
    subscribe(topic) {
      if (this.status.code !== GossipStatusCode.started) {
        throw new Error("Pubsub has not started");
      }
      if (!this.subscriptions.has(topic)) {
        this.subscriptions.add(topic);
        for (const peerId2 of this.peers.keys()) {
          this.sendSubscriptions(peerId2, [topic], true);
        }
      }
      this.join(topic);
    }
    /**
     * Unsubscribe to a topic
     */
    unsubscribe(topic) {
      if (this.status.code !== GossipStatusCode.started) {
        throw new Error("Pubsub is not started");
      }
      const wasSubscribed = this.subscriptions.delete(topic);
      this.log("unsubscribe from %s - am subscribed %s", topic, wasSubscribed);
      if (wasSubscribed) {
        for (const peerId2 of this.peers.keys()) {
          this.sendSubscriptions(peerId2, [topic], false);
        }
      }
      this.leave(topic);
    }
    /**
     * Join topic
     */
    join(topic) {
      var _a2, _b2, _c;
      if (this.status.code !== GossipStatusCode.started) {
        throw new Error("Gossipsub has not started");
      }
      if (this.mesh.has(topic)) {
        return;
      }
      this.log("JOIN %s", topic);
      (_a2 = this.metrics) == null ? void 0 : _a2.onJoin(topic);
      const toAdd = /* @__PURE__ */ new Set();
      const backoff = this.backoff.get(topic);
      const fanoutPeers = this.fanout.get(topic);
      if (fanoutPeers != null) {
        this.fanout.delete(topic);
        this.fanoutLastpub.delete(topic);
        fanoutPeers.forEach((id) => {
          if (!this.direct.has(id) && this.score.score(id) >= 0 && (backoff == null ? void 0 : backoff.has(id)) !== true) {
            toAdd.add(id);
          }
        });
        (_b2 = this.metrics) == null ? void 0 : _b2.onAddToMesh(topic, InclusionReason.Fanout, toAdd.size);
      }
      if (toAdd.size < this.opts.D) {
        const fanoutCount = toAdd.size;
        const newPeers = this.getRandomGossipPeers(topic, this.opts.D, (id) => (
          // filter direct peers and peers with negative score
          !toAdd.has(id) && !this.direct.has(id) && this.score.score(id) >= 0 && (backoff == null ? void 0 : backoff.has(id)) !== true
        ));
        newPeers.forEach((peer) => {
          toAdd.add(peer);
        });
        (_c = this.metrics) == null ? void 0 : _c.onAddToMesh(topic, InclusionReason.Random, toAdd.size - fanoutCount);
      }
      this.mesh.set(topic, toAdd);
      toAdd.forEach((id) => {
        this.log("JOIN: Add mesh link to %s in %s", id, topic);
        this.sendGraft(id, topic);
      });
    }
    /**
     * Leave topic
     */
    leave(topic) {
      var _a2;
      if (this.status.code !== GossipStatusCode.started) {
        throw new Error("Gossipsub has not started");
      }
      this.log("LEAVE %s", topic);
      (_a2 = this.metrics) == null ? void 0 : _a2.onLeave(topic);
      const meshPeers = this.mesh.get(topic);
      if (meshPeers != null) {
        Promise.all(Array.from(meshPeers).map(async (id) => {
          this.log("LEAVE: Remove mesh link to %s in %s", id, topic);
          await this.sendPrune(id, topic);
        })).catch((err) => {
          this.log("Error sending prunes to mesh peers", err);
        });
        this.mesh.delete(topic);
      }
    }
    selectPeersToForward(topic, propagationSource, excludePeers) {
      const tosend = /* @__PURE__ */ new Set();
      const peersInTopic = this.topics.get(topic);
      if (peersInTopic != null) {
        this.direct.forEach((peer) => {
          if (peersInTopic.has(peer) && propagationSource !== peer && !((excludePeers == null ? void 0 : excludePeers.has(peer)) ?? false)) {
            tosend.add(peer);
          }
        });
        this.floodsubPeers.forEach((peer) => {
          if (peersInTopic.has(peer) && propagationSource !== peer && !((excludePeers == null ? void 0 : excludePeers.has(peer)) ?? false) && this.score.score(peer) >= this.opts.scoreThresholds.publishThreshold) {
            tosend.add(peer);
          }
        });
      }
      const meshPeers = this.mesh.get(topic);
      if (meshPeers != null && meshPeers.size > 0) {
        meshPeers.forEach((peer) => {
          if (propagationSource !== peer && !((excludePeers == null ? void 0 : excludePeers.has(peer)) ?? false)) {
            tosend.add(peer);
          }
        });
      }
      return tosend;
    }
    selectPeersToPublish(topic) {
      const tosend = /* @__PURE__ */ new Set();
      const tosendCount = {
        direct: 0,
        floodsub: 0,
        mesh: 0,
        fanout: 0
      };
      const peersInTopic = this.topics.get(topic);
      if (peersInTopic != null) {
        if (this.opts.floodPublish) {
          peersInTopic.forEach((id) => {
            if (this.direct.has(id)) {
              tosend.add(id);
              tosendCount.direct++;
            } else if (this.score.score(id) >= this.opts.scoreThresholds.publishThreshold) {
              tosend.add(id);
              tosendCount.floodsub++;
            }
          });
        } else {
          this.direct.forEach((id) => {
            if (peersInTopic.has(id)) {
              tosend.add(id);
              tosendCount.direct++;
            }
          });
          this.floodsubPeers.forEach((id) => {
            if (peersInTopic.has(id) && this.score.score(id) >= this.opts.scoreThresholds.publishThreshold) {
              tosend.add(id);
              tosendCount.floodsub++;
            }
          });
          const meshPeers = this.mesh.get(topic);
          if (meshPeers != null && meshPeers.size > 0) {
            meshPeers.forEach((peer) => {
              tosend.add(peer);
              tosendCount.mesh++;
            });
            if (meshPeers.size < this.opts.D) {
              const topicPeers = this.getRandomGossipPeers(topic, this.opts.D - meshPeers.size, (id) => {
                return !meshPeers.has(id) && !this.direct.has(id) && !this.floodsubPeers.has(id) && this.score.score(id) >= this.opts.scoreThresholds.publishThreshold;
              });
              topicPeers.forEach((peer) => {
                tosend.add(peer);
                tosendCount.mesh++;
              });
            }
          } else {
            const fanoutPeers = this.fanout.get(topic);
            if (fanoutPeers != null && fanoutPeers.size > 0) {
              fanoutPeers.forEach((peer) => {
                tosend.add(peer);
                tosendCount.fanout++;
              });
            } else {
              const newFanoutPeers = this.getRandomGossipPeers(topic, this.opts.D, (id) => {
                return this.score.score(id) >= this.opts.scoreThresholds.publishThreshold;
              });
              if (newFanoutPeers.size > 0) {
                this.fanout.set(topic, newFanoutPeers);
                newFanoutPeers.forEach((peer) => {
                  tosend.add(peer);
                  tosendCount.fanout++;
                });
              }
            }
            this.fanoutLastpub.set(topic, Date.now());
          }
        }
      }
      return { tosend, tosendCount };
    }
    /**
     * Forwards a message from our peers.
     *
     * For messages published by us (the app layer), this class uses `publish`
     */
    forwardMessage(msgIdStr, rawMsg, propagationSource, excludePeers) {
      var _a2;
      if (propagationSource != null) {
        this.score.deliverMessage(propagationSource, msgIdStr, rawMsg.topic);
      }
      const tosend = this.selectPeersToForward(rawMsg.topic, propagationSource, excludePeers);
      tosend.forEach((id) => {
        this.sendRpc(id, createGossipRpc([rawMsg]));
      });
      (_a2 = this.metrics) == null ? void 0 : _a2.onForwardMsg(rawMsg.topic, tosend.size);
    }
    /**
     * App layer publishes a message to peers, return number of peers this message is published to
     * Note: `async` due to crypto only if `StrictSign`, otherwise it's a sync fn.
     *
     * For messages not from us, this class uses `forwardMessage`.
     */
    async publish(topic, data, opts) {
      var _a2, _b2;
      const startMs = Date.now();
      const transformedData = this.dataTransform != null ? this.dataTransform.outboundTransform(topic, data) : data;
      if (this.publishConfig == null) {
        throw Error("PublishError.Uninitialized");
      }
      const { raw: rawMsg, msg } = await buildRawMessage(this.publishConfig, topic, data, transformedData);
      const msgId2 = await this.msgIdFn(msg);
      const msgIdStr = this.msgIdToStrFn(msgId2);
      const ignoreDuplicatePublishError = (opts == null ? void 0 : opts.ignoreDuplicatePublishError) ?? this.opts.ignoreDuplicatePublishError;
      if (this.seenCache.has(msgIdStr)) {
        if (ignoreDuplicatePublishError) {
          (_a2 = this.metrics) == null ? void 0 : _a2.onPublishDuplicateMsg(topic);
          return { recipients: [] };
        }
        throw Error("PublishError.Duplicate");
      }
      const { tosend, tosendCount } = this.selectPeersToPublish(topic);
      const willSendToSelf = this.opts.emitSelf && this.subscriptions.has(topic);
      const allowPublishToZeroTopicPeers = (opts == null ? void 0 : opts.allowPublishToZeroTopicPeers) ?? this.opts.allowPublishToZeroTopicPeers;
      if (tosend.size === 0 && !allowPublishToZeroTopicPeers && !willSendToSelf) {
        throw Error("PublishError.NoPeersSubscribedToTopic");
      }
      this.seenCache.put(msgIdStr);
      this.mcache.put({ msgId: msgId2, msgIdStr }, rawMsg, true);
      this.publishedMessageIds.put(msgIdStr);
      const batchPublish = (opts == null ? void 0 : opts.batchPublish) ?? this.opts.batchPublish;
      const rpc = createGossipRpc([rawMsg]);
      if (batchPublish) {
        this.sendRpcInBatch(tosend, rpc);
      } else {
        for (const id of tosend) {
          const sent = this.sendRpc(id, rpc);
          if (!sent) {
            tosend.delete(id);
          }
        }
      }
      const durationMs = Date.now() - startMs;
      (_b2 = this.metrics) == null ? void 0 : _b2.onPublishMsg(topic, tosendCount, tosend.size, rawMsg.data != null ? rawMsg.data.length : 0, durationMs);
      if (willSendToSelf) {
        tosend.add(this.components.peerId.toString());
        super.dispatchEvent(new CustomEvent("gossipsub:message", {
          detail: {
            propagationSource: this.components.peerId,
            msgId: msgIdStr,
            msg
          }
        }));
        super.dispatchEvent(new CustomEvent("message", { detail: msg }));
      }
      return {
        recipients: Array.from(tosend.values()).map((str) => this.peers.get(str) ?? peerIdFromString(str))
      };
    }
    /**
     * Send the same data in batch to tosend list without considering cached control messages
     * This is not only faster but also avoid allocating memory for each peer
     * see https://github.com/ChainSafe/js-libp2p-gossipsub/issues/344
     */
    sendRpcInBatch(tosend, rpc) {
      var _a2;
      const rpcBytes = RPC.encode(rpc);
      const prefixedData = encode7.single(rpcBytes);
      for (const id of tosend) {
        const outboundStream = this.streamsOutbound.get(id);
        if (outboundStream == null) {
          this.log(`Cannot send RPC to ${id} as there is no open stream to it available`);
          tosend.delete(id);
          continue;
        }
        try {
          outboundStream.pushPrefixed(prefixedData);
        } catch (e) {
          tosend.delete(id);
          this.log.error(`Cannot send rpc to ${id}`, e);
        }
        (_a2 = this.metrics) == null ? void 0 : _a2.onRpcSent(rpc, rpcBytes.length);
      }
    }
    /**
     * This function should be called when `asyncValidation` is `true` after
     * the message got validated by the caller. Messages are stored in the `mcache` and
     * validation is expected to be fast enough that the messages should still exist in the cache.
     * There are three possible validation outcomes and the outcome is given in acceptance.
     *
     * If acceptance = `MessageAcceptance.Accept` the message will get propagated to the
     * network. The `propagation_source` parameter indicates who the message was received by and
     * will not be forwarded back to that peer.
     *
     * If acceptance = `MessageAcceptance.Reject` the message will be deleted from the memcache
     * and the P penalty will be applied to the `propagationSource`.
     *
     * If acceptance = `MessageAcceptance.Ignore` the message will be deleted from the memcache
     * but no P penalty will be applied.
     *
     * This function will return true if the message was found in the cache and false if was not
     * in the cache anymore.
     *
     * This should only be called once per message.
     */
    reportMessageValidationResult(msgId2, propagationSource, acceptance) {
      var _a2;
      let cacheEntry;
      if (acceptance === TopicValidatorResult.Accept) {
        cacheEntry = this.mcache.validate(msgId2);
        if (cacheEntry != null) {
          const { message: rawMsg, originatingPeers } = cacheEntry;
          this.score.deliverMessage(propagationSource, msgId2, rawMsg.topic);
          this.forwardMessage(msgId2, cacheEntry.message, propagationSource, originatingPeers);
        }
      } else {
        cacheEntry = this.mcache.remove(msgId2);
        if (cacheEntry != null) {
          const rejectReason = rejectReasonFromAcceptance(acceptance);
          const { message: rawMsg, originatingPeers } = cacheEntry;
          this.score.rejectMessage(propagationSource, msgId2, rawMsg.topic, rejectReason);
          for (const peer of originatingPeers) {
            this.score.rejectMessage(peer, msgId2, rawMsg.topic, rejectReason);
          }
        }
      }
      const firstSeenTimestampMs = this.score.messageFirstSeenTimestampMs(msgId2);
      (_a2 = this.metrics) == null ? void 0 : _a2.onReportValidation(cacheEntry, acceptance, firstSeenTimestampMs);
    }
    /**
     * Sends a GRAFT message to a peer
     */
    sendGraft(id, topic) {
      const graft = [
        {
          topicID: topic
        }
      ];
      const out = createGossipRpc([], { graft });
      this.sendRpc(id, out);
    }
    /**
     * Sends a PRUNE message to a peer
     */
    async sendPrune(id, topic) {
      const onUnsubscribe = true;
      const prune = [await this.makePrune(id, topic, this.opts.doPX, onUnsubscribe)];
      const out = createGossipRpc([], { prune });
      this.sendRpc(id, out);
    }
    sendIDontWants(msgId2, topic, source) {
      var _a2;
      const ids = this.mesh.get(topic);
      if (ids == null) {
        return;
      }
      const tosend = new Set(ids);
      tosend.delete(source);
      for (const id of tosend) {
        if (((_a2 = this.streamsOutbound.get(id)) == null ? void 0 : _a2.protocol) !== GossipsubIDv12) {
          tosend.delete(id);
        }
      }
      const idontwantRpc = createGossipRpc([], { idontwant: [{ messageIDs: [msgId2] }] });
      this.sendRpcInBatch(tosend, idontwantRpc);
    }
    /**
     * Send an rpc object to a peer
     */
    sendRpc(id, rpc) {
      var _a2, _b2, _c, _d, _e;
      const outboundStream = this.streamsOutbound.get(id);
      if (outboundStream == null) {
        this.log(`Cannot send RPC to ${id} as there is no open stream to it available`);
        return false;
      }
      const ctrl = this.control.get(id);
      if (ctrl != null) {
        this.piggybackControl(id, rpc, ctrl);
        this.control.delete(id);
      }
      const ihave = this.gossip.get(id);
      if (ihave != null) {
        this.piggybackGossip(id, rpc, ihave);
        this.gossip.delete(id);
      }
      const rpcBytes = RPC.encode(rpc);
      try {
        outboundStream.push(rpcBytes);
      } catch (e) {
        this.log.error(`Cannot send rpc to ${id}`, e);
        if (ctrl != null) {
          this.control.set(id, ctrl);
        }
        if (ihave != null) {
          this.gossip.set(id, ihave);
        }
        return false;
      }
      (_a2 = this.metrics) == null ? void 0 : _a2.onRpcSent(rpc, rpcBytes.length);
      if (((_b2 = rpc.control) == null ? void 0 : _b2.graft) != null) {
        for (const topic of (_c = rpc.control) == null ? void 0 : _c.graft) {
          if (topic.topicID != null) {
            this.safeDispatchEvent("gossipsub:graft", { detail: { peerId: id, topic: topic.topicID, direction: "outbound" } });
          }
        }
      }
      if (((_d = rpc.control) == null ? void 0 : _d.prune) != null) {
        for (const topic of (_e = rpc.control) == null ? void 0 : _e.prune) {
          if (topic.topicID != null) {
            this.safeDispatchEvent("gossipsub:prune", { detail: { peerId: id, topic: topic.topicID, direction: "outbound" } });
          }
        }
      }
      return true;
    }
    /** Mutates `outRpc` adding graft and prune control messages */
    piggybackControl(id, outRpc, ctrl) {
      var _a2, _b2;
      const rpc = ensureControl(outRpc);
      for (const graft of ctrl.graft) {
        if (graft.topicID != null && (((_a2 = this.mesh.get(graft.topicID)) == null ? void 0 : _a2.has(id)) ?? false)) {
          rpc.control.graft.push(graft);
        }
      }
      for (const prune of ctrl.prune) {
        if (prune.topicID != null && !(((_b2 = this.mesh.get(prune.topicID)) == null ? void 0 : _b2.has(id)) ?? false)) {
          rpc.control.prune.push(prune);
        }
      }
    }
    /** Mutates `outRpc` adding ihave control messages */
    piggybackGossip(id, outRpc, ihave) {
      const rpc = ensureControl(outRpc);
      rpc.control.ihave = ihave;
    }
    /**
     * Send graft and prune messages
     *
     * @param tograft - peer id => topic[]
     * @param toprune - peer id => topic[]
     */
    async sendGraftPrune(tograft, toprune, noPX) {
      const doPX = this.opts.doPX;
      const onUnsubscribe = false;
      for (const [id, topics] of tograft) {
        const graft = topics.map((topicID) => ({ topicID }));
        let prune = [];
        const pruning = toprune.get(id);
        if (pruning != null) {
          prune = await Promise.all(pruning.map(async (topicID) => this.makePrune(id, topicID, doPX && !(noPX.get(id) ?? false), onUnsubscribe)));
          toprune.delete(id);
        }
        this.sendRpc(id, createGossipRpc([], { graft, prune }));
      }
      for (const [id, topics] of toprune) {
        const prune = await Promise.all(topics.map(async (topicID) => this.makePrune(id, topicID, doPX && !(noPX.get(id) ?? false), onUnsubscribe)));
        this.sendRpc(id, createGossipRpc([], { prune }));
      }
    }
    /**
     * Emits gossip - Send IHAVE messages to a random set of gossip peers
     */
    emitGossip(peersToGossipByTopic) {
      const gossipIDsByTopic = this.mcache.getGossipIDs(new Set(peersToGossipByTopic.keys()));
      for (const [topic, peersToGossip] of peersToGossipByTopic) {
        this.doEmitGossip(topic, peersToGossip, gossipIDsByTopic.get(topic) ?? []);
      }
    }
    /**
     * Send gossip messages to GossipFactor peers above threshold with a minimum of D_lazy
     * Peers are randomly selected from the heartbeat which exclude mesh + fanout peers
     * We also exclude direct peers, as there is no reason to emit gossip to them
     *
     * @param topic
     * @param candidateToGossip - peers to gossip
     * @param messageIDs - message ids to gossip
     */
    doEmitGossip(topic, candidateToGossip, messageIDs) {
      if (messageIDs.length === 0) {
        return;
      }
      shuffle(messageIDs);
      if (messageIDs.length > GossipsubMaxIHaveLength) {
        this.log("too many messages for gossip; will truncate IHAVE list (%d messages)", messageIDs.length);
      }
      if (candidateToGossip.size === 0)
        return;
      let target = this.opts.Dlazy;
      const gossipFactor = this.opts.gossipFactor;
      const factor = gossipFactor * candidateToGossip.size;
      let peersToGossip = candidateToGossip;
      if (factor > target) {
        target = factor;
      }
      if (target > peersToGossip.size) {
        target = peersToGossip.size;
      } else {
        peersToGossip = shuffle(Array.from(peersToGossip)).slice(0, target);
      }
      peersToGossip.forEach((id) => {
        let peerMessageIDs = messageIDs;
        if (messageIDs.length > GossipsubMaxIHaveLength) {
          peerMessageIDs = shuffle(peerMessageIDs.slice()).slice(0, GossipsubMaxIHaveLength);
        }
        this.pushGossip(id, {
          topicID: topic,
          messageIDs: peerMessageIDs
        });
      });
    }
    /**
     * Flush gossip and control messages
     */
    flush() {
      for (const [peer, ihave] of this.gossip.entries()) {
        this.gossip.delete(peer);
        this.sendRpc(peer, createGossipRpc([], { ihave }));
      }
      for (const [peer, control] of this.control.entries()) {
        this.control.delete(peer);
        const out = createGossipRpc([], { graft: control.graft, prune: control.prune });
        this.sendRpc(peer, out);
      }
    }
    /**
     * Adds new IHAVE messages to pending gossip
     */
    pushGossip(id, controlIHaveMsgs) {
      this.log("Add gossip to %s", id);
      const gossip = this.gossip.get(id) ?? [];
      this.gossip.set(id, gossip.concat(controlIHaveMsgs));
    }
    /**
     * Make a PRUNE control message for a peer in a topic
     */
    async makePrune(id, topic, doPX, onUnsubscribe) {
      var _a2;
      this.score.prune(id, topic);
      if (((_a2 = this.streamsOutbound.get(id)) == null ? void 0 : _a2.protocol) === GossipsubIDv10) {
        return {
          topicID: topic,
          peers: []
        };
      }
      const backoffMs = onUnsubscribe ? this.opts.unsubcribeBackoff : this.opts.pruneBackoff;
      const backoff = backoffMs / 1e3;
      this.doAddBackoff(id, topic, backoffMs);
      if (!doPX) {
        return {
          topicID: topic,
          peers: [],
          backoff
        };
      }
      const peers = this.getRandomGossipPeers(topic, this.opts.prunePeers, (xid) => {
        return xid !== id && this.score.score(xid) >= 0;
      });
      const px = await Promise.all(Array.from(peers).map(async (peerId2) => {
        const id2 = this.peers.get(peerId2) ?? peerIdFromString(peerId2);
        let peerInfo;
        try {
          peerInfo = await this.components.peerStore.get(id2);
        } catch (err) {
          if (err.name !== "NotFoundError") {
            throw err;
          }
        }
        return {
          peerID: id2.toMultihash().bytes,
          signedPeerRecord: peerInfo == null ? void 0 : peerInfo.peerRecordEnvelope
        };
      }));
      return {
        topicID: topic,
        peers: px,
        backoff
      };
    }
    runHeartbeat = () => {
      var _a2;
      const timer = (_a2 = this.metrics) == null ? void 0 : _a2.heartbeatDuration.startTimer();
      this.heartbeat().catch((err) => {
        this.log("Error running heartbeat", err);
      }).finally(() => {
        var _a3;
        if (timer != null) {
          timer();
        }
        if (this.status.code === GossipStatusCode.started) {
          clearTimeout(this.status.heartbeatTimeout);
          let msToNextHeartbeat = this.opts.heartbeatInterval - (Date.now() - this.status.hearbeatStartMs) % this.opts.heartbeatInterval;
          if (msToNextHeartbeat < this.opts.heartbeatInterval * 0.25) {
            msToNextHeartbeat += this.opts.heartbeatInterval;
            (_a3 = this.metrics) == null ? void 0 : _a3.heartbeatSkipped.inc();
          }
          this.status.heartbeatTimeout = setTimeout(this.runHeartbeat, msToNextHeartbeat);
        }
      });
    };
    /**
     * Maintains the mesh and fanout maps in gossipsub.
     */
    async heartbeat() {
      var _a2, _b2;
      const { D, Dlo, Dhi, Dscore, Dout, fanoutTTL } = this.opts;
      this.heartbeatTicks++;
      const scores = /* @__PURE__ */ new Map();
      const getScore = (id) => {
        let s2 = scores.get(id);
        if (s2 === void 0) {
          s2 = this.score.score(id);
          scores.set(id, s2);
        }
        return s2;
      };
      const tograft = /* @__PURE__ */ new Map();
      const toprune = /* @__PURE__ */ new Map();
      const noPX = /* @__PURE__ */ new Map();
      this.clearBackoff();
      this.peerhave.clear();
      (_a2 = this.metrics) == null ? void 0 : _a2.cacheSize.set({ cache: "iasked" }, this.iasked.size);
      this.iasked.clear();
      this.applyIwantPenalties();
      this.idontwantCounts.clear();
      for (const idontwants of this.idontwants.values()) {
        for (const [msgId2, heartbeatTick] of idontwants) {
          if (this.heartbeatTicks - heartbeatTick >= this.opts.mcacheLength) {
            idontwants.delete(msgId2);
          }
        }
      }
      if (this.heartbeatTicks % this.opts.directConnectTicks === 0) {
        await this.directConnect();
      }
      (_b2 = this.fastMsgIdCache) == null ? void 0 : _b2.prune();
      this.seenCache.prune();
      this.gossipTracer.prune();
      this.publishedMessageIds.prune();
      const peersToGossipByTopic = /* @__PURE__ */ new Map();
      this.mesh.forEach((peers, topic) => {
        const peersInTopic = this.topics.get(topic);
        const candidateMeshPeers = /* @__PURE__ */ new Set();
        const peersToGossip = /* @__PURE__ */ new Set();
        peersToGossipByTopic.set(topic, peersToGossip);
        if (peersInTopic != null) {
          const shuffledPeers = shuffle(Array.from(peersInTopic));
          const backoff = this.backoff.get(topic);
          for (const id of shuffledPeers) {
            const peerStreams = this.streamsOutbound.get(id);
            if (peerStreams != null && this.multicodecs.includes(peerStreams.protocol) && !peers.has(id) && !this.direct.has(id)) {
              const score = getScore(id);
              if ((backoff == null ? void 0 : backoff.has(id)) !== true && score >= 0)
                candidateMeshPeers.add(id);
              if (score >= this.opts.scoreThresholds.gossipThreshold)
                peersToGossip.add(id);
            }
          }
        }
        const prunePeer = (id, reason) => {
          var _a3;
          this.log("HEARTBEAT: Remove mesh link to %s in %s", id, topic);
          this.addBackoff(id, topic);
          peers.delete(id);
          if (getScore(id) >= this.opts.scoreThresholds.gossipThreshold)
            peersToGossip.add(id);
          (_a3 = this.metrics) == null ? void 0 : _a3.onRemoveFromMesh(topic, reason, 1);
          const topics = toprune.get(id);
          if (topics == null) {
            toprune.set(id, [topic]);
          } else {
            topics.push(topic);
          }
        };
        const graftPeer = (id, reason) => {
          var _a3;
          this.log("HEARTBEAT: Add mesh link to %s in %s", id, topic);
          this.score.graft(id, topic);
          peers.add(id);
          peersToGossip.delete(id);
          (_a3 = this.metrics) == null ? void 0 : _a3.onAddToMesh(topic, reason, 1);
          const topics = tograft.get(id);
          if (topics == null) {
            tograft.set(id, [topic]);
          } else {
            topics.push(topic);
          }
        };
        peers.forEach((id) => {
          const score = getScore(id);
          if (score < 0) {
            this.log("HEARTBEAT: Prune peer %s with negative score: score=%d, topic=%s", id, score, topic);
            prunePeer(id, ChurnReason.BadScore);
            noPX.set(id, true);
          }
        });
        if (peers.size < Dlo) {
          const ineed = D - peers.size;
          const newMeshPeers = removeFirstNItemsFromSet(candidateMeshPeers, ineed);
          newMeshPeers.forEach((p) => {
            graftPeer(p, InclusionReason.NotEnough);
          });
        }
        if (peers.size > Dhi) {
          let peersArray = Array.from(peers);
          peersArray.sort((a, b) => getScore(b) - getScore(a));
          peersArray = peersArray.slice(0, Dscore).concat(shuffle(peersArray.slice(Dscore)));
          let outbound = 0;
          peersArray.slice(0, D).forEach((p) => {
            if (this.outbound.get(p) ?? false) {
              outbound++;
            }
          });
          if (outbound < Dout) {
            const rotate = (i) => {
              const p = peersArray[i];
              for (let j = i; j > 0; j--) {
                peersArray[j] = peersArray[j - 1];
              }
              peersArray[0] = p;
            };
            if (outbound > 0) {
              let ihave = outbound;
              for (let i = 1; i < D && ihave > 0; i++) {
                if (this.outbound.get(peersArray[i]) ?? false) {
                  rotate(i);
                  ihave--;
                }
              }
            }
            let ineed = D - outbound;
            for (let i = D; i < peersArray.length && ineed > 0; i++) {
              if (this.outbound.get(peersArray[i]) ?? false) {
                rotate(i);
                ineed--;
              }
            }
          }
          peersArray.slice(D).forEach((p) => {
            prunePeer(p, ChurnReason.Excess);
          });
        }
        if (peers.size >= Dlo) {
          let outbound = 0;
          peers.forEach((p) => {
            if (this.outbound.get(p) ?? false) {
              outbound++;
            }
          });
          if (outbound < Dout) {
            const ineed = Dout - outbound;
            const newMeshPeers = removeItemsFromSet(candidateMeshPeers, ineed, (id) => this.outbound.get(id) === true);
            newMeshPeers.forEach((p) => {
              graftPeer(p, InclusionReason.Outbound);
            });
          }
        }
        if (this.heartbeatTicks % this.opts.opportunisticGraftTicks === 0 && peers.size > 1) {
          const peersList = Array.from(peers).sort((a, b) => getScore(a) - getScore(b));
          const medianIndex = Math.floor(peers.size / 2);
          const medianScore = getScore(peersList[medianIndex]);
          if (medianScore < this.opts.scoreThresholds.opportunisticGraftThreshold) {
            const ineed = this.opts.opportunisticGraftPeers;
            const newMeshPeers = removeItemsFromSet(candidateMeshPeers, ineed, (id) => getScore(id) > medianScore);
            for (const id of newMeshPeers) {
              this.log("HEARTBEAT: Opportunistically graft peer %s on topic %s", id, topic);
              graftPeer(id, InclusionReason.Opportunistic);
            }
          }
        }
      });
      const now = Date.now();
      this.fanoutLastpub.forEach((lastpb, topic) => {
        if (lastpb + fanoutTTL < now) {
          this.fanout.delete(topic);
          this.fanoutLastpub.delete(topic);
        }
      });
      this.fanout.forEach((fanoutPeers, topic) => {
        const topicPeers = this.topics.get(topic);
        fanoutPeers.forEach((id) => {
          if (!((topicPeers == null ? void 0 : topicPeers.has(id)) ?? false) || getScore(id) < this.opts.scoreThresholds.publishThreshold) {
            fanoutPeers.delete(id);
          }
        });
        const peersInTopic = this.topics.get(topic);
        const candidateFanoutPeers = [];
        const peersToGossip = /* @__PURE__ */ new Set();
        peersToGossipByTopic.set(topic, peersToGossip);
        if (peersInTopic != null) {
          const shuffledPeers = shuffle(Array.from(peersInTopic));
          for (const id of shuffledPeers) {
            const peerStreams = this.streamsOutbound.get(id);
            if (peerStreams != null && this.multicodecs.includes(peerStreams.protocol) && !fanoutPeers.has(id) && !this.direct.has(id)) {
              const score = getScore(id);
              if (score >= this.opts.scoreThresholds.publishThreshold)
                candidateFanoutPeers.push(id);
              if (score >= this.opts.scoreThresholds.gossipThreshold)
                peersToGossip.add(id);
            }
          }
        }
        if (fanoutPeers.size < D) {
          const ineed = D - fanoutPeers.size;
          candidateFanoutPeers.slice(0, ineed).forEach((id) => {
            fanoutPeers.add(id);
            peersToGossip == null ? void 0 : peersToGossip.delete(id);
          });
        }
      });
      this.emitGossip(peersToGossipByTopic);
      await this.sendGraftPrune(tograft, toprune, noPX);
      this.flush();
      this.mcache.shift();
      this.dispatchEvent(new CustomEvent("gossipsub:heartbeat"));
    }
    /**
     * Given a topic, returns up to count peers subscribed to that topic
     * that pass an optional filter function
     *
     * @param topic
     * @param count
     * @param filter - a function to filter acceptable peers
     */
    getRandomGossipPeers(topic, count, filter2 = () => true) {
      const peersInTopic = this.topics.get(topic);
      if (peersInTopic == null) {
        return /* @__PURE__ */ new Set();
      }
      let peers = [];
      peersInTopic.forEach((id) => {
        const peerStreams = this.streamsOutbound.get(id);
        if (peerStreams == null) {
          return;
        }
        if (this.multicodecs.includes(peerStreams.protocol) && filter2(id)) {
          peers.push(id);
        }
      });
      peers = shuffle(peers);
      if (count > 0 && peers.length > count) {
        peers = peers.slice(0, count);
      }
      return new Set(peers);
    }
    onScrapeMetrics(metrics) {
      var _a2, _b2;
      metrics.mcacheSize.set(this.mcache.size);
      metrics.mcacheNotValidatedCount.set(this.mcache.notValidatedCount);
      metrics.cacheSize.set({ cache: "direct" }, this.direct.size);
      metrics.cacheSize.set({ cache: "seenCache" }, this.seenCache.size);
      metrics.cacheSize.set({ cache: "fastMsgIdCache" }, ((_a2 = this.fastMsgIdCache) == null ? void 0 : _a2.size) ?? 0);
      metrics.cacheSize.set({ cache: "publishedMessageIds" }, this.publishedMessageIds.size);
      metrics.cacheSize.set({ cache: "mcache" }, this.mcache.size);
      metrics.cacheSize.set({ cache: "score" }, this.score.size);
      metrics.cacheSize.set({ cache: "gossipTracer.promises" }, this.gossipTracer.size);
      metrics.cacheSize.set({ cache: "gossipTracer.requests" }, this.gossipTracer.requestMsByMsgSize);
      metrics.cacheSize.set({ cache: "topics" }, this.topics.size);
      metrics.cacheSize.set({ cache: "subscriptions" }, this.subscriptions.size);
      metrics.cacheSize.set({ cache: "mesh" }, this.mesh.size);
      metrics.cacheSize.set({ cache: "fanout" }, this.fanout.size);
      metrics.cacheSize.set({ cache: "peers" }, this.peers.size);
      metrics.cacheSize.set({ cache: "streamsOutbound" }, this.streamsOutbound.size);
      metrics.cacheSize.set({ cache: "streamsInbound" }, this.streamsInbound.size);
      metrics.cacheSize.set({ cache: "acceptFromWhitelist" }, this.acceptFromWhitelist.size);
      metrics.cacheSize.set({ cache: "gossip" }, this.gossip.size);
      metrics.cacheSize.set({ cache: "control" }, this.control.size);
      metrics.cacheSize.set({ cache: "peerhave" }, this.peerhave.size);
      metrics.cacheSize.set({ cache: "outbound" }, this.outbound.size);
      let backoffSize = 0;
      const now = Date.now();
      metrics.connectedPeersBackoffSec.reset();
      for (const backoff of this.backoff.values()) {
        backoffSize += backoff.size;
        for (const [peer, expiredMs] of backoff.entries()) {
          if (this.peers.has(peer)) {
            metrics.connectedPeersBackoffSec.observe(Math.max(0, expiredMs - now) / 1e3);
          }
        }
      }
      metrics.cacheSize.set({ cache: "backoff" }, backoffSize);
      let idontwantsCount = 0;
      for (const idontwant of this.idontwants.values()) {
        idontwantsCount += idontwant.size;
      }
      metrics.cacheSize.set({ cache: "idontwants" }, idontwantsCount);
      for (const [topicStr, peers] of this.topics) {
        metrics.topicPeersCount.set({ topicStr }, peers.size);
      }
      for (const [topicStr, peers] of this.mesh) {
        metrics.meshPeerCounts.set({ topicStr }, peers.size);
      }
      const scores = [];
      const scoreByPeer = /* @__PURE__ */ new Map();
      metrics.behaviourPenalty.reset();
      for (const peerIdStr of this.peers.keys()) {
        const score = this.score.score(peerIdStr);
        scores.push(score);
        scoreByPeer.set(peerIdStr, score);
        metrics.behaviourPenalty.observe(((_b2 = this.score.peerStats.get(peerIdStr)) == null ? void 0 : _b2.behaviourPenalty) ?? 0);
      }
      metrics.registerScores(scores, this.opts.scoreThresholds);
      metrics.registerScorePerMesh(this.mesh, scoreByPeer);
      const sw = computeAllPeersScoreWeights(this.peers.keys(), this.score.peerStats, this.score.params, this.score.peerIPs, metrics.topicStrToLabel);
      metrics.registerScoreWeights(sw);
    }
    tagMeshPeer = (evt) => {
      const { peerId: peerId2, topic } = evt.detail;
      this.components.peerStore.merge(this.peers.get(peerId2) ?? peerIdFromString(peerId2), {
        tags: {
          [topic]: {
            value: 100
          }
        }
      }).catch((err) => {
        this.log.error("Error tagging peer %s with topic %s", peerId2, topic, err);
      });
    };
    untagMeshPeer = (evt) => {
      const { peerId: peerId2, topic } = evt.detail;
      this.components.peerStore.merge(this.peers.get(peerId2) ?? peerIdFromString(peerId2), {
        tags: {
          [topic]: void 0
        }
      }).catch((err) => {
        this.log.error("Error untagging peer %s with topic %s", peerId2, topic, err);
      });
    };
  };
  function gossipsub(init = {}) {
    return (components) => new GossipSub(components, init);
  }

  // node_modules/@chainsafe/libp2p-noise/dist/src/index.js
  var import_browser_shims336 = __toESM(require_browser_shims(), 1);

  // node_modules/@chainsafe/libp2p-noise/dist/src/noise.js
  var import_browser_shims335 = __toESM(require_browser_shims(), 1);

  // node_modules/@chainsafe/libp2p-noise/node_modules/it-length-prefixed/dist/src/index.js
  var import_browser_shims310 = __toESM(require_browser_shims(), 1);

  // node_modules/@chainsafe/libp2p-noise/node_modules/it-length-prefixed/dist/src/encode.js
  var import_browser_shims308 = __toESM(require_browser_shims(), 1);

  // node_modules/@chainsafe/libp2p-noise/node_modules/it-length-prefixed/dist/src/constants.js
  var import_browser_shims305 = __toESM(require_browser_shims(), 1);
  var MAX_LENGTH_LENGTH3 = 8;
  var MAX_DATA_LENGTH3 = 1024 * 1024 * 4;

  // node_modules/@chainsafe/libp2p-noise/node_modules/it-length-prefixed/dist/src/errors.js
  var import_browser_shims306 = __toESM(require_browser_shims(), 1);
  var InvalidMessageLengthError4 = class extends Error {
    name = "InvalidMessageLengthError";
    code = "ERR_INVALID_MSG_LENGTH";
  };
  var InvalidDataLengthError4 = class extends Error {
    name = "InvalidDataLengthError";
    code = "ERR_MSG_DATA_TOO_LONG";
  };
  var InvalidDataLengthLengthError4 = class extends Error {
    name = "InvalidDataLengthLengthError";
    code = "ERR_MSG_LENGTH_TOO_LONG";
  };
  var UnexpectedEOFError4 = class extends Error {
    name = "UnexpectedEOFError";
    code = "ERR_UNEXPECTED_EOF";
  };

  // node_modules/@chainsafe/libp2p-noise/node_modules/it-length-prefixed/dist/src/utils.js
  var import_browser_shims307 = __toESM(require_browser_shims(), 1);
  function isAsyncIterable10(thing) {
    return thing[Symbol.asyncIterator] != null;
  }

  // node_modules/@chainsafe/libp2p-noise/node_modules/it-length-prefixed/dist/src/encode.js
  function validateMaxDataLength2(chunk, maxDataLength) {
    if (chunk.byteLength > maxDataLength) {
      throw new InvalidDataLengthError4("Message length too long");
    }
  }
  var defaultEncoder3 = (length4) => {
    const lengthLength = encodingLength2(length4);
    const lengthBuf = allocUnsafe(lengthLength);
    encode5(length4, lengthBuf);
    defaultEncoder3.bytes = lengthLength;
    return lengthBuf;
  };
  defaultEncoder3.bytes = 0;
  function encode8(source, options) {
    options = options ?? {};
    const encodeLength2 = options.lengthEncoder ?? defaultEncoder3;
    const maxDataLength = (options == null ? void 0 : options.maxDataLength) ?? MAX_DATA_LENGTH3;
    function* maybeYield(chunk) {
      validateMaxDataLength2(chunk, maxDataLength);
      const length4 = encodeLength2(chunk.byteLength);
      if (length4 instanceof Uint8Array) {
        yield length4;
      } else {
        yield* length4;
      }
      if (chunk instanceof Uint8Array) {
        yield chunk;
      } else {
        yield* chunk;
      }
    }
    if (isAsyncIterable10(source)) {
      return async function* () {
        for await (const chunk of source) {
          yield* maybeYield(chunk);
        }
      }();
    }
    return function* () {
      for (const chunk of source) {
        yield* maybeYield(chunk);
      }
    }();
  }
  encode8.single = (chunk, options) => {
    options = options ?? {};
    const encodeLength2 = options.lengthEncoder ?? defaultEncoder3;
    const maxDataLength = (options == null ? void 0 : options.maxDataLength) ?? MAX_DATA_LENGTH3;
    validateMaxDataLength2(chunk, maxDataLength);
    return new Uint8ArrayList(encodeLength2(chunk.byteLength), chunk);
  };

  // node_modules/@chainsafe/libp2p-noise/node_modules/it-length-prefixed/dist/src/decode.js
  var import_browser_shims309 = __toESM(require_browser_shims(), 1);
  var ReadMode3;
  (function(ReadMode5) {
    ReadMode5[ReadMode5["LENGTH"] = 0] = "LENGTH";
    ReadMode5[ReadMode5["DATA"] = 1] = "DATA";
  })(ReadMode3 || (ReadMode3 = {}));
  var defaultDecoder3 = (buf) => {
    const length4 = decode6(buf);
    defaultDecoder3.bytes = encodingLength2(length4);
    return length4;
  };
  defaultDecoder3.bytes = 0;
  function decode9(source, options) {
    const buffer = new Uint8ArrayList();
    let mode = ReadMode3.LENGTH;
    let dataLength = -1;
    const lengthDecoder = (options == null ? void 0 : options.lengthDecoder) ?? defaultDecoder3;
    const maxLengthLength = (options == null ? void 0 : options.maxLengthLength) ?? MAX_LENGTH_LENGTH3;
    const maxDataLength = (options == null ? void 0 : options.maxDataLength) ?? MAX_DATA_LENGTH3;
    function* maybeYield() {
      while (buffer.byteLength > 0) {
        if (mode === ReadMode3.LENGTH) {
          try {
            dataLength = lengthDecoder(buffer);
            if (dataLength < 0) {
              throw new InvalidMessageLengthError4("Invalid message length");
            }
            if (dataLength > maxDataLength) {
              throw new InvalidDataLengthError4("Message length too long");
            }
            const dataLengthLength = lengthDecoder.bytes;
            buffer.consume(dataLengthLength);
            if ((options == null ? void 0 : options.onLength) != null) {
              options.onLength(dataLength);
            }
            mode = ReadMode3.DATA;
          } catch (err) {
            if (err instanceof RangeError) {
              if (buffer.byteLength > maxLengthLength) {
                throw new InvalidDataLengthLengthError4("Message length length too long");
              }
              break;
            }
            throw err;
          }
        }
        if (mode === ReadMode3.DATA) {
          if (buffer.byteLength < dataLength) {
            break;
          }
          const data = buffer.sublist(0, dataLength);
          buffer.consume(dataLength);
          if ((options == null ? void 0 : options.onData) != null) {
            options.onData(data);
          }
          yield data;
          mode = ReadMode3.LENGTH;
        }
      }
    }
    if (isAsyncIterable10(source)) {
      return async function* () {
        for await (const buf of source) {
          buffer.append(buf);
          yield* maybeYield();
        }
        if (buffer.byteLength > 0) {
          throw new UnexpectedEOFError4("Unexpected end of input");
        }
      }();
    }
    return function* () {
      for (const buf of source) {
        buffer.append(buf);
        yield* maybeYield();
      }
      if (buffer.byteLength > 0) {
        throw new UnexpectedEOFError4("Unexpected end of input");
      }
    }();
  }
  decode9.fromReader = (reader, options) => {
    let byteLength = 1;
    const varByteSource = async function* () {
      while (true) {
        try {
          const { done, value } = await reader.next(byteLength);
          if (done === true) {
            return;
          }
          if (value != null) {
            yield value;
          }
        } catch (err) {
          if (err.code === "ERR_UNDER_READ") {
            return { done: true, value: null };
          }
          throw err;
        } finally {
          byteLength = 1;
        }
      }
    }();
    const onLength = (l) => {
      byteLength = l;
    };
    return decode9(varByteSource, {
      ...options ?? {},
      onLength
    });
  };

  // node_modules/it-pair/dist/src/duplex.js
  var import_browser_shims312 = __toESM(require_browser_shims(), 1);

  // node_modules/it-pair/dist/src/index.js
  var import_browser_shims311 = __toESM(require_browser_shims(), 1);
  function pair() {
    const deferred = pDefer();
    let piped = false;
    return {
      sink: async (source) => {
        if (piped) {
          throw new Error("already piped");
        }
        piped = true;
        deferred.resolve(source);
      },
      source: async function* () {
        const source = await deferred.promise;
        yield* source;
      }()
    };
  }

  // node_modules/it-pair/dist/src/duplex.js
  function duplexPair() {
    const a = pair();
    const b = pair();
    return [
      {
        source: a.source,
        sink: b.sink
      },
      {
        source: b.source,
        sink: a.sink
      }
    ];
  }

  // node_modules/@chainsafe/libp2p-noise/dist/src/constants.js
  var import_browser_shims313 = __toESM(require_browser_shims(), 1);
  var NOISE_MSG_MAX_LENGTH_BYTES = 65535;
  var NOISE_MSG_MAX_LENGTH_BYTES_WITHOUT_TAG = NOISE_MSG_MAX_LENGTH_BYTES - 16;
  var _a, _b;
  var DUMP_SESSION_KEYS = Boolean((_b = (_a = globalThis.process) == null ? void 0 : _a.env) == null ? void 0 : _b.DUMP_SESSION_KEYS);

  // node_modules/@chainsafe/libp2p-noise/dist/src/crypto/index.browser.js
  var import_browser_shims320 = __toESM(require_browser_shims(), 1);

  // node_modules/@chainsafe/libp2p-noise/dist/src/crypto/js.js
  var import_browser_shims319 = __toESM(require_browser_shims(), 1);

  // node_modules/@noble/ciphers/esm/chacha.js
  var import_browser_shims317 = __toESM(require_browser_shims(), 1);

  // node_modules/@noble/ciphers/esm/_arx.js
  var import_browser_shims315 = __toESM(require_browser_shims(), 1);

  // node_modules/@noble/ciphers/esm/utils.js
  var import_browser_shims314 = __toESM(require_browser_shims(), 1);
  function isBytes3(a) {
    return a instanceof Uint8Array || ArrayBuffer.isView(a) && a.constructor.name === "Uint8Array";
  }
  function abool2(b) {
    if (typeof b !== "boolean")
      throw new Error(`boolean expected, not ${b}`);
  }
  function anumber2(n) {
    if (!Number.isSafeInteger(n) || n < 0)
      throw new Error("positive integer expected, got " + n);
  }
  function abytes3(b, ...lengths) {
    if (!isBytes3(b))
      throw new Error("Uint8Array expected");
    if (lengths.length > 0 && !lengths.includes(b.length))
      throw new Error("Uint8Array expected of length " + lengths + ", got length=" + b.length);
  }
  function aexists2(instance, checkFinished = true) {
    if (instance.destroyed)
      throw new Error("Hash instance has been destroyed");
    if (checkFinished && instance.finished)
      throw new Error("Hash#digest() has already been called");
  }
  function aoutput2(out, instance) {
    abytes3(out);
    const min = instance.outputLen;
    if (out.length < min) {
      throw new Error("digestInto() expects output buffer of length at least " + min);
    }
  }
  function u32(arr) {
    return new Uint32Array(arr.buffer, arr.byteOffset, Math.floor(arr.byteLength / 4));
  }
  function clean2(...arrays) {
    for (let i = 0; i < arrays.length; i++) {
      arrays[i].fill(0);
    }
  }
  function createView2(arr) {
    return new DataView(arr.buffer, arr.byteOffset, arr.byteLength);
  }
  var isLE = /* @__PURE__ */ (() => new Uint8Array(new Uint32Array([287454020]).buffer)[0] === 68)();
  function utf8ToBytes2(str) {
    if (typeof str !== "string")
      throw new Error("string expected");
    return new Uint8Array(new TextEncoder().encode(str));
  }
  function toBytes3(data) {
    if (typeof data === "string")
      data = utf8ToBytes2(data);
    else if (isBytes3(data))
      data = copyBytes(data);
    else
      throw new Error("Uint8Array expected, got " + typeof data);
    return data;
  }
  function checkOpts(defaults, opts) {
    if (opts == null || typeof opts !== "object")
      throw new Error("options must be defined");
    const merged = Object.assign(defaults, opts);
    return merged;
  }
  function equalBytes(a, b) {
    if (a.length !== b.length)
      return false;
    let diff = 0;
    for (let i = 0; i < a.length; i++)
      diff |= a[i] ^ b[i];
    return diff === 0;
  }
  var wrapCipher = /* @__NO_SIDE_EFFECTS__ */ (params, constructor) => {
    function wrappedCipher(key, ...args) {
      abytes3(key);
      if (!isLE)
        throw new Error("Non little-endian hardware is not yet supported");
      if (params.nonceLength !== void 0) {
        const nonce = args[0];
        if (!nonce)
          throw new Error("nonce / iv required");
        if (params.varSizeNonce)
          abytes3(nonce);
        else
          abytes3(nonce, params.nonceLength);
      }
      const tagl = params.tagLength;
      if (tagl && args[1] !== void 0) {
        abytes3(args[1]);
      }
      const cipher = constructor(key, ...args);
      const checkOutput = (fnLength, output) => {
        if (output !== void 0) {
          if (fnLength !== 2)
            throw new Error("cipher output not supported");
          abytes3(output);
        }
      };
      let called = false;
      const wrCipher = {
        encrypt(data, output) {
          if (called)
            throw new Error("cannot encrypt() twice with same key + nonce");
          called = true;
          abytes3(data);
          checkOutput(cipher.encrypt.length, output);
          return cipher.encrypt(data, output);
        },
        decrypt(data, output) {
          abytes3(data);
          if (tagl && data.length < tagl)
            throw new Error("invalid ciphertext length: smaller than tagLength=" + tagl);
          checkOutput(cipher.decrypt.length, output);
          return cipher.decrypt(data, output);
        }
      };
      return wrCipher;
    }
    Object.assign(wrappedCipher, params);
    return wrappedCipher;
  };
  function getOutput(expectedLength, out, onlyAligned = true) {
    if (out === void 0)
      return new Uint8Array(expectedLength);
    if (out.length !== expectedLength)
      throw new Error("invalid output length, expected " + expectedLength + ", got: " + out.length);
    if (onlyAligned && !isAligned32(out))
      throw new Error("invalid output, must be aligned");
    return out;
  }
  function setBigUint642(view, byteOffset, value, isLE2) {
    if (typeof view.setBigUint64 === "function")
      return view.setBigUint64(byteOffset, value, isLE2);
    const _32n2 = BigInt(32);
    const _u32_max = BigInt(4294967295);
    const wh = Number(value >> _32n2 & _u32_max);
    const wl = Number(value & _u32_max);
    const h2 = isLE2 ? 4 : 0;
    const l = isLE2 ? 0 : 4;
    view.setUint32(byteOffset + h2, wh, isLE2);
    view.setUint32(byteOffset + l, wl, isLE2);
  }
  function u64Lengths(dataLength, aadLength, isLE2) {
    abool2(isLE2);
    const num = new Uint8Array(16);
    const view = createView2(num);
    setBigUint642(view, 0, BigInt(aadLength), isLE2);
    setBigUint642(view, 8, BigInt(dataLength), isLE2);
    return num;
  }
  function isAligned32(bytes) {
    return bytes.byteOffset % 4 === 0;
  }
  function copyBytes(bytes) {
    return Uint8Array.from(bytes);
  }

  // node_modules/@noble/ciphers/esm/_arx.js
  var _utf8ToBytes = (str) => Uint8Array.from(str.split("").map((c) => c.charCodeAt(0)));
  var sigma16 = _utf8ToBytes("expand 16-byte k");
  var sigma32 = _utf8ToBytes("expand 32-byte k");
  var sigma16_32 = u32(sigma16);
  var sigma32_32 = u32(sigma32);
  function rotl(a, b) {
    return a << b | a >>> 32 - b;
  }
  function isAligned322(b) {
    return b.byteOffset % 4 === 0;
  }
  var BLOCK_LEN = 64;
  var BLOCK_LEN32 = 16;
  var MAX_COUNTER = 2 ** 32 - 1;
  var U32_EMPTY = new Uint32Array();
  function runCipher(core, sigma, key, nonce, data, output, counter, rounds) {
    const len = data.length;
    const block = new Uint8Array(BLOCK_LEN);
    const b32 = u32(block);
    const isAligned = isAligned322(data) && isAligned322(output);
    const d32 = isAligned ? u32(data) : U32_EMPTY;
    const o32 = isAligned ? u32(output) : U32_EMPTY;
    for (let pos = 0; pos < len; counter++) {
      core(sigma, key, nonce, b32, counter, rounds);
      if (counter >= MAX_COUNTER)
        throw new Error("arx: counter overflow");
      const take2 = Math.min(BLOCK_LEN, len - pos);
      if (isAligned && take2 === BLOCK_LEN) {
        const pos32 = pos / 4;
        if (pos % 4 !== 0)
          throw new Error("arx: invalid block position");
        for (let j = 0, posj; j < BLOCK_LEN32; j++) {
          posj = pos32 + j;
          o32[posj] = d32[posj] ^ b32[j];
        }
        pos += BLOCK_LEN;
        continue;
      }
      for (let j = 0, posj; j < take2; j++) {
        posj = pos + j;
        output[posj] = data[posj] ^ block[j];
      }
      pos += take2;
    }
  }
  function createCipher(core, opts) {
    const { allowShortKeys, extendNonceFn, counterLength, counterRight, rounds } = checkOpts({ allowShortKeys: false, counterLength: 8, counterRight: false, rounds: 20 }, opts);
    if (typeof core !== "function")
      throw new Error("core must be a function");
    anumber2(counterLength);
    anumber2(rounds);
    abool2(counterRight);
    abool2(allowShortKeys);
    return (key, nonce, data, output, counter = 0) => {
      abytes3(key);
      abytes3(nonce);
      abytes3(data);
      const len = data.length;
      if (output === void 0)
        output = new Uint8Array(len);
      abytes3(output);
      anumber2(counter);
      if (counter < 0 || counter >= MAX_COUNTER)
        throw new Error("arx: counter overflow");
      if (output.length < len)
        throw new Error(`arx: output (${output.length}) is shorter than data (${len})`);
      const toClean = [];
      let l = key.length;
      let k;
      let sigma;
      if (l === 32) {
        toClean.push(k = copyBytes(key));
        sigma = sigma32_32;
      } else if (l === 16 && allowShortKeys) {
        k = new Uint8Array(32);
        k.set(key);
        k.set(key, 16);
        sigma = sigma16_32;
        toClean.push(k);
      } else {
        throw new Error(`arx: invalid 32-byte key, got length=${l}`);
      }
      if (!isAligned322(nonce))
        toClean.push(nonce = copyBytes(nonce));
      const k32 = u32(k);
      if (extendNonceFn) {
        if (nonce.length !== 24)
          throw new Error(`arx: extended nonce must be 24 bytes`);
        extendNonceFn(sigma, k32, u32(nonce.subarray(0, 16)), k32);
        nonce = nonce.subarray(16);
      }
      const nonceNcLen = 16 - counterLength;
      if (nonceNcLen !== nonce.length)
        throw new Error(`arx: nonce must be ${nonceNcLen} or 16 bytes`);
      if (nonceNcLen !== 12) {
        const nc = new Uint8Array(12);
        nc.set(nonce, counterRight ? 0 : 12 - nonce.length);
        nonce = nc;
        toClean.push(nonce);
      }
      const n32 = u32(nonce);
      runCipher(core, sigma, k32, n32, data, output, counter, rounds);
      clean2(...toClean);
      return output;
    };
  }

  // node_modules/@noble/ciphers/esm/_poly1305.js
  var import_browser_shims316 = __toESM(require_browser_shims(), 1);
  var u8to16 = (a, i) => a[i++] & 255 | (a[i++] & 255) << 8;
  var Poly1305 = class {
    constructor(key) {
      this.blockLen = 16;
      this.outputLen = 16;
      this.buffer = new Uint8Array(16);
      this.r = new Uint16Array(10);
      this.h = new Uint16Array(10);
      this.pad = new Uint16Array(8);
      this.pos = 0;
      this.finished = false;
      key = toBytes3(key);
      abytes3(key, 32);
      const t0 = u8to16(key, 0);
      const t1 = u8to16(key, 2);
      const t2 = u8to16(key, 4);
      const t3 = u8to16(key, 6);
      const t4 = u8to16(key, 8);
      const t5 = u8to16(key, 10);
      const t6 = u8to16(key, 12);
      const t7 = u8to16(key, 14);
      this.r[0] = t0 & 8191;
      this.r[1] = (t0 >>> 13 | t1 << 3) & 8191;
      this.r[2] = (t1 >>> 10 | t2 << 6) & 7939;
      this.r[3] = (t2 >>> 7 | t3 << 9) & 8191;
      this.r[4] = (t3 >>> 4 | t4 << 12) & 255;
      this.r[5] = t4 >>> 1 & 8190;
      this.r[6] = (t4 >>> 14 | t5 << 2) & 8191;
      this.r[7] = (t5 >>> 11 | t6 << 5) & 8065;
      this.r[8] = (t6 >>> 8 | t7 << 8) & 8191;
      this.r[9] = t7 >>> 5 & 127;
      for (let i = 0; i < 8; i++)
        this.pad[i] = u8to16(key, 16 + 2 * i);
    }
    process(data, offset, isLast = false) {
      const hibit = isLast ? 0 : 1 << 11;
      const { h: h2, r } = this;
      const r0 = r[0];
      const r1 = r[1];
      const r2 = r[2];
      const r3 = r[3];
      const r4 = r[4];
      const r5 = r[5];
      const r6 = r[6];
      const r7 = r[7];
      const r8 = r[8];
      const r9 = r[9];
      const t0 = u8to16(data, offset + 0);
      const t1 = u8to16(data, offset + 2);
      const t2 = u8to16(data, offset + 4);
      const t3 = u8to16(data, offset + 6);
      const t4 = u8to16(data, offset + 8);
      const t5 = u8to16(data, offset + 10);
      const t6 = u8to16(data, offset + 12);
      const t7 = u8to16(data, offset + 14);
      let h0 = h2[0] + (t0 & 8191);
      let h1 = h2[1] + ((t0 >>> 13 | t1 << 3) & 8191);
      let h22 = h2[2] + ((t1 >>> 10 | t2 << 6) & 8191);
      let h3 = h2[3] + ((t2 >>> 7 | t3 << 9) & 8191);
      let h4 = h2[4] + ((t3 >>> 4 | t4 << 12) & 8191);
      let h5 = h2[5] + (t4 >>> 1 & 8191);
      let h6 = h2[6] + ((t4 >>> 14 | t5 << 2) & 8191);
      let h7 = h2[7] + ((t5 >>> 11 | t6 << 5) & 8191);
      let h8 = h2[8] + ((t6 >>> 8 | t7 << 8) & 8191);
      let h9 = h2[9] + (t7 >>> 5 | hibit);
      let c = 0;
      let d0 = c + h0 * r0 + h1 * (5 * r9) + h22 * (5 * r8) + h3 * (5 * r7) + h4 * (5 * r6);
      c = d0 >>> 13;
      d0 &= 8191;
      d0 += h5 * (5 * r5) + h6 * (5 * r4) + h7 * (5 * r3) + h8 * (5 * r2) + h9 * (5 * r1);
      c += d0 >>> 13;
      d0 &= 8191;
      let d1 = c + h0 * r1 + h1 * r0 + h22 * (5 * r9) + h3 * (5 * r8) + h4 * (5 * r7);
      c = d1 >>> 13;
      d1 &= 8191;
      d1 += h5 * (5 * r6) + h6 * (5 * r5) + h7 * (5 * r4) + h8 * (5 * r3) + h9 * (5 * r2);
      c += d1 >>> 13;
      d1 &= 8191;
      let d2 = c + h0 * r2 + h1 * r1 + h22 * r0 + h3 * (5 * r9) + h4 * (5 * r8);
      c = d2 >>> 13;
      d2 &= 8191;
      d2 += h5 * (5 * r7) + h6 * (5 * r6) + h7 * (5 * r5) + h8 * (5 * r4) + h9 * (5 * r3);
      c += d2 >>> 13;
      d2 &= 8191;
      let d3 = c + h0 * r3 + h1 * r2 + h22 * r1 + h3 * r0 + h4 * (5 * r9);
      c = d3 >>> 13;
      d3 &= 8191;
      d3 += h5 * (5 * r8) + h6 * (5 * r7) + h7 * (5 * r6) + h8 * (5 * r5) + h9 * (5 * r4);
      c += d3 >>> 13;
      d3 &= 8191;
      let d4 = c + h0 * r4 + h1 * r3 + h22 * r2 + h3 * r1 + h4 * r0;
      c = d4 >>> 13;
      d4 &= 8191;
      d4 += h5 * (5 * r9) + h6 * (5 * r8) + h7 * (5 * r7) + h8 * (5 * r6) + h9 * (5 * r5);
      c += d4 >>> 13;
      d4 &= 8191;
      let d5 = c + h0 * r5 + h1 * r4 + h22 * r3 + h3 * r2 + h4 * r1;
      c = d5 >>> 13;
      d5 &= 8191;
      d5 += h5 * r0 + h6 * (5 * r9) + h7 * (5 * r8) + h8 * (5 * r7) + h9 * (5 * r6);
      c += d5 >>> 13;
      d5 &= 8191;
      let d6 = c + h0 * r6 + h1 * r5 + h22 * r4 + h3 * r3 + h4 * r2;
      c = d6 >>> 13;
      d6 &= 8191;
      d6 += h5 * r1 + h6 * r0 + h7 * (5 * r9) + h8 * (5 * r8) + h9 * (5 * r7);
      c += d6 >>> 13;
      d6 &= 8191;
      let d7 = c + h0 * r7 + h1 * r6 + h22 * r5 + h3 * r4 + h4 * r3;
      c = d7 >>> 13;
      d7 &= 8191;
      d7 += h5 * r2 + h6 * r1 + h7 * r0 + h8 * (5 * r9) + h9 * (5 * r8);
      c += d7 >>> 13;
      d7 &= 8191;
      let d8 = c + h0 * r8 + h1 * r7 + h22 * r6 + h3 * r5 + h4 * r4;
      c = d8 >>> 13;
      d8 &= 8191;
      d8 += h5 * r3 + h6 * r2 + h7 * r1 + h8 * r0 + h9 * (5 * r9);
      c += d8 >>> 13;
      d8 &= 8191;
      let d9 = c + h0 * r9 + h1 * r8 + h22 * r7 + h3 * r6 + h4 * r5;
      c = d9 >>> 13;
      d9 &= 8191;
      d9 += h5 * r4 + h6 * r3 + h7 * r2 + h8 * r1 + h9 * r0;
      c += d9 >>> 13;
      d9 &= 8191;
      c = (c << 2) + c | 0;
      c = c + d0 | 0;
      d0 = c & 8191;
      c = c >>> 13;
      d1 += c;
      h2[0] = d0;
      h2[1] = d1;
      h2[2] = d2;
      h2[3] = d3;
      h2[4] = d4;
      h2[5] = d5;
      h2[6] = d6;
      h2[7] = d7;
      h2[8] = d8;
      h2[9] = d9;
    }
    finalize() {
      const { h: h2, pad } = this;
      const g = new Uint16Array(10);
      let c = h2[1] >>> 13;
      h2[1] &= 8191;
      for (let i = 2; i < 10; i++) {
        h2[i] += c;
        c = h2[i] >>> 13;
        h2[i] &= 8191;
      }
      h2[0] += c * 5;
      c = h2[0] >>> 13;
      h2[0] &= 8191;
      h2[1] += c;
      c = h2[1] >>> 13;
      h2[1] &= 8191;
      h2[2] += c;
      g[0] = h2[0] + 5;
      c = g[0] >>> 13;
      g[0] &= 8191;
      for (let i = 1; i < 10; i++) {
        g[i] = h2[i] + c;
        c = g[i] >>> 13;
        g[i] &= 8191;
      }
      g[9] -= 1 << 13;
      let mask = (c ^ 1) - 1;
      for (let i = 0; i < 10; i++)
        g[i] &= mask;
      mask = ~mask;
      for (let i = 0; i < 10; i++)
        h2[i] = h2[i] & mask | g[i];
      h2[0] = (h2[0] | h2[1] << 13) & 65535;
      h2[1] = (h2[1] >>> 3 | h2[2] << 10) & 65535;
      h2[2] = (h2[2] >>> 6 | h2[3] << 7) & 65535;
      h2[3] = (h2[3] >>> 9 | h2[4] << 4) & 65535;
      h2[4] = (h2[4] >>> 12 | h2[5] << 1 | h2[6] << 14) & 65535;
      h2[5] = (h2[6] >>> 2 | h2[7] << 11) & 65535;
      h2[6] = (h2[7] >>> 5 | h2[8] << 8) & 65535;
      h2[7] = (h2[8] >>> 8 | h2[9] << 5) & 65535;
      let f = h2[0] + pad[0];
      h2[0] = f & 65535;
      for (let i = 1; i < 8; i++) {
        f = (h2[i] + pad[i] | 0) + (f >>> 16) | 0;
        h2[i] = f & 65535;
      }
      clean2(g);
    }
    update(data) {
      aexists2(this);
      data = toBytes3(data);
      abytes3(data);
      const { buffer, blockLen } = this;
      const len = data.length;
      for (let pos = 0; pos < len; ) {
        const take2 = Math.min(blockLen - this.pos, len - pos);
        if (take2 === blockLen) {
          for (; blockLen <= len - pos; pos += blockLen)
            this.process(data, pos);
          continue;
        }
        buffer.set(data.subarray(pos, pos + take2), this.pos);
        this.pos += take2;
        pos += take2;
        if (this.pos === blockLen) {
          this.process(buffer, 0, false);
          this.pos = 0;
        }
      }
      return this;
    }
    destroy() {
      clean2(this.h, this.r, this.buffer, this.pad);
    }
    digestInto(out) {
      aexists2(this);
      aoutput2(out, this);
      this.finished = true;
      const { buffer, h: h2 } = this;
      let { pos } = this;
      if (pos) {
        buffer[pos++] = 1;
        for (; pos < 16; pos++)
          buffer[pos] = 0;
        this.process(buffer, 0, true);
      }
      this.finalize();
      let opos = 0;
      for (let i = 0; i < 8; i++) {
        out[opos++] = h2[i] >>> 0;
        out[opos++] = h2[i] >>> 8;
      }
      return out;
    }
    digest() {
      const { buffer, outputLen } = this;
      this.digestInto(buffer);
      const res = buffer.slice(0, outputLen);
      this.destroy();
      return res;
    }
  };
  function wrapConstructorWithKey(hashCons) {
    const hashC = (msg, key) => hashCons(key).update(toBytes3(msg)).digest();
    const tmp = hashCons(new Uint8Array(32));
    hashC.outputLen = tmp.outputLen;
    hashC.blockLen = tmp.blockLen;
    hashC.create = (key) => hashCons(key);
    return hashC;
  }
  var poly1305 = wrapConstructorWithKey((key) => new Poly1305(key));

  // node_modules/@noble/ciphers/esm/chacha.js
  function chachaCore(s2, k, n, out, cnt, rounds = 20) {
    let y00 = s2[0], y01 = s2[1], y02 = s2[2], y03 = s2[3], y04 = k[0], y05 = k[1], y06 = k[2], y07 = k[3], y08 = k[4], y09 = k[5], y10 = k[6], y11 = k[7], y12 = cnt, y13 = n[0], y14 = n[1], y15 = n[2];
    let x00 = y00, x01 = y01, x02 = y02, x03 = y03, x04 = y04, x05 = y05, x06 = y06, x07 = y07, x08 = y08, x09 = y09, x10 = y10, x11 = y11, x12 = y12, x13 = y13, x14 = y14, x15 = y15;
    for (let r = 0; r < rounds; r += 2) {
      x00 = x00 + x04 | 0;
      x12 = rotl(x12 ^ x00, 16);
      x08 = x08 + x12 | 0;
      x04 = rotl(x04 ^ x08, 12);
      x00 = x00 + x04 | 0;
      x12 = rotl(x12 ^ x00, 8);
      x08 = x08 + x12 | 0;
      x04 = rotl(x04 ^ x08, 7);
      x01 = x01 + x05 | 0;
      x13 = rotl(x13 ^ x01, 16);
      x09 = x09 + x13 | 0;
      x05 = rotl(x05 ^ x09, 12);
      x01 = x01 + x05 | 0;
      x13 = rotl(x13 ^ x01, 8);
      x09 = x09 + x13 | 0;
      x05 = rotl(x05 ^ x09, 7);
      x02 = x02 + x06 | 0;
      x14 = rotl(x14 ^ x02, 16);
      x10 = x10 + x14 | 0;
      x06 = rotl(x06 ^ x10, 12);
      x02 = x02 + x06 | 0;
      x14 = rotl(x14 ^ x02, 8);
      x10 = x10 + x14 | 0;
      x06 = rotl(x06 ^ x10, 7);
      x03 = x03 + x07 | 0;
      x15 = rotl(x15 ^ x03, 16);
      x11 = x11 + x15 | 0;
      x07 = rotl(x07 ^ x11, 12);
      x03 = x03 + x07 | 0;
      x15 = rotl(x15 ^ x03, 8);
      x11 = x11 + x15 | 0;
      x07 = rotl(x07 ^ x11, 7);
      x00 = x00 + x05 | 0;
      x15 = rotl(x15 ^ x00, 16);
      x10 = x10 + x15 | 0;
      x05 = rotl(x05 ^ x10, 12);
      x00 = x00 + x05 | 0;
      x15 = rotl(x15 ^ x00, 8);
      x10 = x10 + x15 | 0;
      x05 = rotl(x05 ^ x10, 7);
      x01 = x01 + x06 | 0;
      x12 = rotl(x12 ^ x01, 16);
      x11 = x11 + x12 | 0;
      x06 = rotl(x06 ^ x11, 12);
      x01 = x01 + x06 | 0;
      x12 = rotl(x12 ^ x01, 8);
      x11 = x11 + x12 | 0;
      x06 = rotl(x06 ^ x11, 7);
      x02 = x02 + x07 | 0;
      x13 = rotl(x13 ^ x02, 16);
      x08 = x08 + x13 | 0;
      x07 = rotl(x07 ^ x08, 12);
      x02 = x02 + x07 | 0;
      x13 = rotl(x13 ^ x02, 8);
      x08 = x08 + x13 | 0;
      x07 = rotl(x07 ^ x08, 7);
      x03 = x03 + x04 | 0;
      x14 = rotl(x14 ^ x03, 16);
      x09 = x09 + x14 | 0;
      x04 = rotl(x04 ^ x09, 12);
      x03 = x03 + x04 | 0;
      x14 = rotl(x14 ^ x03, 8);
      x09 = x09 + x14 | 0;
      x04 = rotl(x04 ^ x09, 7);
    }
    let oi = 0;
    out[oi++] = y00 + x00 | 0;
    out[oi++] = y01 + x01 | 0;
    out[oi++] = y02 + x02 | 0;
    out[oi++] = y03 + x03 | 0;
    out[oi++] = y04 + x04 | 0;
    out[oi++] = y05 + x05 | 0;
    out[oi++] = y06 + x06 | 0;
    out[oi++] = y07 + x07 | 0;
    out[oi++] = y08 + x08 | 0;
    out[oi++] = y09 + x09 | 0;
    out[oi++] = y10 + x10 | 0;
    out[oi++] = y11 + x11 | 0;
    out[oi++] = y12 + x12 | 0;
    out[oi++] = y13 + x13 | 0;
    out[oi++] = y14 + x14 | 0;
    out[oi++] = y15 + x15 | 0;
  }
  function hchacha(s2, k, i, o32) {
    let x00 = s2[0], x01 = s2[1], x02 = s2[2], x03 = s2[3], x04 = k[0], x05 = k[1], x06 = k[2], x07 = k[3], x08 = k[4], x09 = k[5], x10 = k[6], x11 = k[7], x12 = i[0], x13 = i[1], x14 = i[2], x15 = i[3];
    for (let r = 0; r < 20; r += 2) {
      x00 = x00 + x04 | 0;
      x12 = rotl(x12 ^ x00, 16);
      x08 = x08 + x12 | 0;
      x04 = rotl(x04 ^ x08, 12);
      x00 = x00 + x04 | 0;
      x12 = rotl(x12 ^ x00, 8);
      x08 = x08 + x12 | 0;
      x04 = rotl(x04 ^ x08, 7);
      x01 = x01 + x05 | 0;
      x13 = rotl(x13 ^ x01, 16);
      x09 = x09 + x13 | 0;
      x05 = rotl(x05 ^ x09, 12);
      x01 = x01 + x05 | 0;
      x13 = rotl(x13 ^ x01, 8);
      x09 = x09 + x13 | 0;
      x05 = rotl(x05 ^ x09, 7);
      x02 = x02 + x06 | 0;
      x14 = rotl(x14 ^ x02, 16);
      x10 = x10 + x14 | 0;
      x06 = rotl(x06 ^ x10, 12);
      x02 = x02 + x06 | 0;
      x14 = rotl(x14 ^ x02, 8);
      x10 = x10 + x14 | 0;
      x06 = rotl(x06 ^ x10, 7);
      x03 = x03 + x07 | 0;
      x15 = rotl(x15 ^ x03, 16);
      x11 = x11 + x15 | 0;
      x07 = rotl(x07 ^ x11, 12);
      x03 = x03 + x07 | 0;
      x15 = rotl(x15 ^ x03, 8);
      x11 = x11 + x15 | 0;
      x07 = rotl(x07 ^ x11, 7);
      x00 = x00 + x05 | 0;
      x15 = rotl(x15 ^ x00, 16);
      x10 = x10 + x15 | 0;
      x05 = rotl(x05 ^ x10, 12);
      x00 = x00 + x05 | 0;
      x15 = rotl(x15 ^ x00, 8);
      x10 = x10 + x15 | 0;
      x05 = rotl(x05 ^ x10, 7);
      x01 = x01 + x06 | 0;
      x12 = rotl(x12 ^ x01, 16);
      x11 = x11 + x12 | 0;
      x06 = rotl(x06 ^ x11, 12);
      x01 = x01 + x06 | 0;
      x12 = rotl(x12 ^ x01, 8);
      x11 = x11 + x12 | 0;
      x06 = rotl(x06 ^ x11, 7);
      x02 = x02 + x07 | 0;
      x13 = rotl(x13 ^ x02, 16);
      x08 = x08 + x13 | 0;
      x07 = rotl(x07 ^ x08, 12);
      x02 = x02 + x07 | 0;
      x13 = rotl(x13 ^ x02, 8);
      x08 = x08 + x13 | 0;
      x07 = rotl(x07 ^ x08, 7);
      x03 = x03 + x04 | 0;
      x14 = rotl(x14 ^ x03, 16);
      x09 = x09 + x14 | 0;
      x04 = rotl(x04 ^ x09, 12);
      x03 = x03 + x04 | 0;
      x14 = rotl(x14 ^ x03, 8);
      x09 = x09 + x14 | 0;
      x04 = rotl(x04 ^ x09, 7);
    }
    let oi = 0;
    o32[oi++] = x00;
    o32[oi++] = x01;
    o32[oi++] = x02;
    o32[oi++] = x03;
    o32[oi++] = x12;
    o32[oi++] = x13;
    o32[oi++] = x14;
    o32[oi++] = x15;
  }
  var chacha20 = /* @__PURE__ */ createCipher(chachaCore, {
    counterRight: false,
    counterLength: 4,
    allowShortKeys: false
  });
  var xchacha20 = /* @__PURE__ */ createCipher(chachaCore, {
    counterRight: false,
    counterLength: 8,
    extendNonceFn: hchacha,
    allowShortKeys: false
  });
  var ZEROS16 = /* @__PURE__ */ new Uint8Array(16);
  var updatePadded = (h2, msg) => {
    h2.update(msg);
    const left = msg.length % 16;
    if (left)
      h2.update(ZEROS16.subarray(left));
  };
  var ZEROS32 = /* @__PURE__ */ new Uint8Array(32);
  function computeTag(fn, key, nonce, data, AAD) {
    const authKey = fn(key, nonce, ZEROS32);
    const h2 = poly1305.create(authKey);
    if (AAD)
      updatePadded(h2, AAD);
    updatePadded(h2, data);
    const num = u64Lengths(data.length, AAD ? AAD.length : 0, true);
    h2.update(num);
    const res = h2.digest();
    clean2(authKey, num);
    return res;
  }
  var _poly1305_aead = (xorStream) => (key, nonce, AAD) => {
    const tagLength = 16;
    return {
      encrypt(plaintext, output) {
        const plength = plaintext.length;
        output = getOutput(plength + tagLength, output, false);
        output.set(plaintext);
        const oPlain = output.subarray(0, -tagLength);
        xorStream(key, nonce, oPlain, oPlain, 1);
        const tag = computeTag(xorStream, key, nonce, oPlain, AAD);
        output.set(tag, plength);
        clean2(tag);
        return output;
      },
      decrypt(ciphertext, output) {
        output = getOutput(ciphertext.length - tagLength, output, false);
        const data = ciphertext.subarray(0, -tagLength);
        const passedTag = ciphertext.subarray(-tagLength);
        const tag = computeTag(xorStream, key, nonce, data, AAD);
        if (!equalBytes(passedTag, tag))
          throw new Error("invalid tag");
        output.set(ciphertext.subarray(0, -tagLength));
        xorStream(key, nonce, output, output, 1);
        clean2(tag);
        return output;
      }
    };
  };
  var chacha20poly1305 = /* @__PURE__ */ wrapCipher({ blockSize: 64, nonceLength: 12, tagLength: 16 }, _poly1305_aead(chacha20));
  var xchacha20poly1305 = /* @__PURE__ */ wrapCipher({ blockSize: 64, nonceLength: 24, tagLength: 16 }, _poly1305_aead(xchacha20));

  // node_modules/@noble/hashes/esm/hkdf.js
  var import_browser_shims318 = __toESM(require_browser_shims(), 1);
  function extract(hash, ikm, salt) {
    ahash(hash);
    if (salt === void 0)
      salt = new Uint8Array(hash.outputLen);
    return hmac(hash, toBytes(salt), toBytes(ikm));
  }
  var HKDF_COUNTER = /* @__PURE__ */ Uint8Array.from([0]);
  var EMPTY_BUFFER = /* @__PURE__ */ Uint8Array.of();
  function expand(hash, prk, info, length4 = 32) {
    ahash(hash);
    anumber(length4);
    const olen = hash.outputLen;
    if (length4 > 255 * olen)
      throw new Error("Length should be <= 255*HashLen");
    const blocks = Math.ceil(length4 / olen);
    if (info === void 0)
      info = EMPTY_BUFFER;
    const okm = new Uint8Array(blocks * olen);
    const HMAC2 = hmac.create(hash, prk);
    const HMACTmp = HMAC2._cloneInto();
    const T = new Uint8Array(HMAC2.outputLen);
    for (let counter = 0; counter < blocks; counter++) {
      HKDF_COUNTER[0] = counter + 1;
      HMACTmp.update(counter === 0 ? EMPTY_BUFFER : T).update(info).update(HKDF_COUNTER).digestInto(T);
      okm.set(T, olen * counter);
      HMAC2._cloneInto(HMACTmp);
    }
    HMAC2.destroy();
    HMACTmp.destroy();
    clean(T, HKDF_COUNTER);
    return okm.slice(0, length4);
  }

  // node_modules/@chainsafe/libp2p-noise/dist/src/crypto/js.js
  var pureJsCrypto = {
    hashSHA256(data) {
      return sha2563(data.subarray());
    },
    getHKDF(ck, ikm) {
      const prk = extract(sha2563, ikm, ck);
      const okmU8Array = expand(sha2563, prk, void 0, 96);
      const okm = okmU8Array;
      const k1 = okm.subarray(0, 32);
      const k2 = okm.subarray(32, 64);
      const k3 = okm.subarray(64, 96);
      return [k1, k2, k3];
    },
    generateX25519KeyPair() {
      const secretKey = x25519.utils.randomPrivateKey();
      const publicKey = x25519.getPublicKey(secretKey);
      return {
        publicKey,
        privateKey: secretKey
      };
    },
    generateX25519KeyPairFromSeed(seed) {
      const publicKey = x25519.getPublicKey(seed);
      return {
        publicKey,
        privateKey: seed
      };
    },
    generateX25519SharedKey(privateKey, publicKey) {
      return x25519.getSharedSecret(privateKey.subarray(), publicKey.subarray());
    },
    chaCha20Poly1305Encrypt(plaintext, nonce, ad, k) {
      return chacha20poly1305(k, nonce, ad).encrypt(plaintext.subarray());
    },
    chaCha20Poly1305Decrypt(ciphertext, nonce, ad, k, dst) {
      return chacha20poly1305(k, nonce, ad).decrypt(ciphertext.subarray(), dst);
    }
  };

  // node_modules/@chainsafe/libp2p-noise/dist/src/crypto/index.browser.js
  var defaultCrypto = pureJsCrypto;

  // node_modules/@chainsafe/libp2p-noise/dist/src/crypto.js
  var import_browser_shims321 = __toESM(require_browser_shims(), 1);
  function wrapCrypto(crypto3) {
    return {
      generateKeypair: crypto3.generateX25519KeyPair,
      dh: (keypair, publicKey) => crypto3.generateX25519SharedKey(keypair.privateKey, publicKey).subarray(0, 32),
      encrypt: crypto3.chaCha20Poly1305Encrypt,
      decrypt: crypto3.chaCha20Poly1305Decrypt,
      hash: crypto3.hashSHA256,
      hkdf: crypto3.getHKDF
    };
  }

  // node_modules/@chainsafe/libp2p-noise/dist/src/encoder.js
  var import_browser_shims322 = __toESM(require_browser_shims(), 1);
  var uint16BEEncode = (value) => {
    const target = allocUnsafe(2);
    target[0] = value >> 8;
    target[1] = value;
    return target;
  };
  uint16BEEncode.bytes = 2;
  var uint16BEDecode = (data) => {
    if (data.length < 2)
      throw RangeError("Could not decode int16BE");
    if (data instanceof Uint8Array) {
      let value = 0;
      value += data[0] << 8;
      value += data[1];
      return value;
    }
    return data.getUint16(0);
  };
  uint16BEDecode.bytes = 2;

  // node_modules/@chainsafe/libp2p-noise/dist/src/metrics.js
  var import_browser_shims323 = __toESM(require_browser_shims(), 1);
  function registerMetrics(metrics) {
    return {
      xxHandshakeSuccesses: metrics.registerCounter("libp2p_noise_xxhandshake_successes_total", {
        help: "Total count of noise xxHandshakes successes_"
      }),
      xxHandshakeErrors: metrics.registerCounter("libp2p_noise_xxhandshake_error_total", {
        help: "Total count of noise xxHandshakes errors"
      }),
      encryptedPackets: metrics.registerCounter("libp2p_noise_encrypted_packets_total", {
        help: "Total count of noise encrypted packets successfully"
      }),
      decryptedPackets: metrics.registerCounter("libp2p_noise_decrypted_packets_total", {
        help: "Total count of noise decrypted packets"
      }),
      decryptErrors: metrics.registerCounter("libp2p_noise_decrypt_errors_total", {
        help: "Total count of noise decrypt errors"
      })
    };
  }

  // node_modules/@chainsafe/libp2p-noise/dist/src/performHandshake.js
  var import_browser_shims333 = __toESM(require_browser_shims(), 1);

  // node_modules/@chainsafe/libp2p-noise/dist/src/logger.js
  var import_browser_shims324 = __toESM(require_browser_shims(), 1);
  function logLocalStaticKeys(s2, keyLogger) {
    if (!keyLogger.enabled || !DUMP_SESSION_KEYS) {
      return;
    }
    if (s2) {
      keyLogger(`LOCAL_STATIC_PUBLIC_KEY ${toString2(s2.publicKey, "hex")}`);
      keyLogger(`LOCAL_STATIC_PRIVATE_KEY ${toString2(s2.privateKey, "hex")}`);
    } else {
      keyLogger("Missing local static keys.");
    }
  }
  function logLocalEphemeralKeys(e, keyLogger) {
    if (!keyLogger.enabled || !DUMP_SESSION_KEYS) {
      return;
    }
    if (e) {
      keyLogger(`LOCAL_PUBLIC_EPHEMERAL_KEY ${toString2(e.publicKey, "hex")}`);
      keyLogger(`LOCAL_PRIVATE_EPHEMERAL_KEY ${toString2(e.privateKey, "hex")}`);
    } else {
      keyLogger("Missing local ephemeral keys.");
    }
  }
  function logRemoteStaticKey(rs, keyLogger) {
    if (!keyLogger.enabled || !DUMP_SESSION_KEYS) {
      return;
    }
    if (rs) {
      keyLogger(`REMOTE_STATIC_PUBLIC_KEY ${toString2(rs.subarray(), "hex")}`);
    } else {
      keyLogger("Missing remote static public key.");
    }
  }
  function logRemoteEphemeralKey(re, keyLogger) {
    if (!keyLogger.enabled || !DUMP_SESSION_KEYS) {
      return;
    }
    if (re) {
      keyLogger(`REMOTE_EPHEMERAL_PUBLIC_KEY ${toString2(re.subarray(), "hex")}`);
    } else {
      keyLogger("Missing remote ephemeral keys.");
    }
  }
  function logCipherState(cs1, cs2, keyLogger) {
    if (!keyLogger.enabled || !DUMP_SESSION_KEYS) {
      return;
    }
    keyLogger(`CIPHER_STATE_1 ${cs1.n.getUint64()} ${cs1.k && toString2(cs1.k, "hex")}`);
    keyLogger(`CIPHER_STATE_2 ${cs2.n.getUint64()} ${cs2.k && toString2(cs2.k, "hex")}`);
  }

  // node_modules/@chainsafe/libp2p-noise/dist/src/protocol.js
  var import_browser_shims330 = __toESM(require_browser_shims(), 1);

  // node_modules/uint8arrays/dist/src/index.js
  var import_browser_shims327 = __toESM(require_browser_shims(), 1);

  // node_modules/uint8arrays/dist/src/xor.js
  var import_browser_shims325 = __toESM(require_browser_shims(), 1);
  function xor(a, b) {
    if (a.length !== b.length) {
      throw new Error("Inputs should have the same length");
    }
    const result = allocUnsafe(a.length);
    for (let i = 0; i < a.length; i++) {
      result[i] = a[i] ^ b[i];
    }
    return asUint8Array(result);
  }

  // node_modules/uint8arrays/dist/src/compare.js
  var import_browser_shims326 = __toESM(require_browser_shims(), 1);

  // node_modules/@chainsafe/libp2p-noise/dist/src/errors.js
  var import_browser_shims328 = __toESM(require_browser_shims(), 1);
  var InvalidCryptoExchangeError2 = class _InvalidCryptoExchangeError extends Error {
    code;
    constructor(message2 = "Invalid crypto exchange") {
      super(message2);
      this.code = _InvalidCryptoExchangeError.code;
    }
    static code = "ERR_INVALID_CRYPTO_EXCHANGE";
  };

  // node_modules/@chainsafe/libp2p-noise/dist/src/nonce.js
  var import_browser_shims329 = __toESM(require_browser_shims(), 1);
  var MIN_NONCE = 0;
  var MAX_NONCE = 4294967295;
  var ERR_MAX_NONCE = "Cipherstate has reached maximum n, a new handshake must be performed";
  var Nonce = class {
    n;
    bytes;
    view;
    constructor(n = MIN_NONCE) {
      this.n = n;
      this.bytes = alloc(12);
      this.view = new DataView(this.bytes.buffer, this.bytes.byteOffset, this.bytes.byteLength);
      this.view.setUint32(4, n, true);
    }
    increment() {
      this.n++;
      this.view.setUint32(4, this.n, true);
    }
    getBytes() {
      return this.bytes;
    }
    getUint64() {
      return this.n;
    }
    assertValue() {
      if (this.n > MAX_NONCE) {
        throw new Error(ERR_MAX_NONCE);
      }
    }
  };

  // node_modules/@chainsafe/libp2p-noise/dist/src/protocol.js
  var ZEROLEN = alloc(0);
  var CipherState = class {
    k;
    n;
    crypto;
    constructor(crypto3, k = void 0, n = 0) {
      this.crypto = crypto3;
      this.k = k;
      this.n = new Nonce(n);
    }
    hasKey() {
      return Boolean(this.k);
    }
    encryptWithAd(ad, plaintext) {
      if (!this.hasKey()) {
        return plaintext;
      }
      this.n.assertValue();
      const e = this.crypto.encrypt(plaintext, this.n.getBytes(), ad, this.k);
      this.n.increment();
      return e;
    }
    decryptWithAd(ad, ciphertext, dst) {
      if (!this.hasKey()) {
        return ciphertext;
      }
      this.n.assertValue();
      const plaintext = this.crypto.decrypt(ciphertext, this.n.getBytes(), ad, this.k, dst);
      this.n.increment();
      return plaintext;
    }
  };
  var SymmetricState = class {
    cs;
    ck;
    h;
    crypto;
    constructor(crypto3, protocolName) {
      this.crypto = crypto3;
      const protocolNameBytes = fromString2(protocolName, "utf-8");
      this.h = hashProtocolName(crypto3, protocolNameBytes);
      this.ck = this.h;
      this.cs = new CipherState(crypto3);
    }
    mixKey(ikm) {
      const [ck, tempK] = this.crypto.hkdf(this.ck, ikm);
      this.ck = ck;
      this.cs = new CipherState(this.crypto, tempK);
    }
    mixHash(data) {
      this.h = this.crypto.hash(new Uint8ArrayList(this.h, data));
    }
    encryptAndHash(plaintext) {
      const ciphertext = this.cs.encryptWithAd(this.h, plaintext);
      this.mixHash(ciphertext);
      return ciphertext;
    }
    decryptAndHash(ciphertext) {
      const plaintext = this.cs.decryptWithAd(this.h, ciphertext);
      this.mixHash(ciphertext);
      return plaintext;
    }
    split() {
      const [tempK1, tempK2] = this.crypto.hkdf(this.ck, ZEROLEN);
      return [new CipherState(this.crypto, tempK1), new CipherState(this.crypto, tempK2)];
    }
  };
  var AbstractHandshakeState = class {
    ss;
    s;
    e;
    rs;
    re;
    initiator;
    crypto;
    constructor(init) {
      const { crypto: crypto3, protocolName, prologue, initiator, s: s2, e, rs, re } = init;
      this.crypto = crypto3;
      this.ss = new SymmetricState(crypto3, protocolName);
      this.ss.mixHash(prologue);
      this.initiator = initiator;
      this.s = s2;
      this.e = e;
      this.rs = rs;
      this.re = re;
    }
    writeE() {
      if (this.e) {
        throw new Error("ephemeral keypair is already set");
      }
      const e = this.crypto.generateKeypair();
      this.ss.mixHash(e.publicKey);
      this.e = e;
      return e.publicKey;
    }
    writeS() {
      if (!this.s) {
        throw new Error("static keypair is not set");
      }
      return this.ss.encryptAndHash(this.s.publicKey);
    }
    writeEE() {
      if (!this.e) {
        throw new Error("ephemeral keypair is not set");
      }
      if (!this.re) {
        throw new Error("remote ephemeral public key is not set");
      }
      this.ss.mixKey(this.crypto.dh(this.e, this.re));
    }
    writeES() {
      if (this.initiator) {
        if (!this.e) {
          throw new Error("ephemeral keypair is not set");
        }
        if (!this.rs) {
          throw new Error("remote static public key is not set");
        }
        this.ss.mixKey(this.crypto.dh(this.e, this.rs));
      } else {
        if (!this.s) {
          throw new Error("static keypair is not set");
        }
        if (!this.re) {
          throw new Error("remote ephemeral public key is not set");
        }
        this.ss.mixKey(this.crypto.dh(this.s, this.re));
      }
    }
    writeSE() {
      if (this.initiator) {
        if (!this.s) {
          throw new Error("static keypair is not set");
        }
        if (!this.re) {
          throw new Error("remote ephemeral public key is not set");
        }
        this.ss.mixKey(this.crypto.dh(this.s, this.re));
      } else {
        if (!this.e) {
          throw new Error("ephemeral keypair is not set");
        }
        if (!this.rs) {
          throw new Error("remote static public key is not set");
        }
        this.ss.mixKey(this.crypto.dh(this.e, this.rs));
      }
    }
    readE(message2, offset = 0) {
      if (this.re) {
        throw new Error("remote ephemeral public key is already set");
      }
      if (message2.byteLength < offset + 32) {
        throw new Error("message is not long enough");
      }
      this.re = message2.sublist(offset, offset + 32);
      this.ss.mixHash(this.re);
    }
    readS(message2, offset = 0) {
      if (this.rs) {
        throw new Error("remote static public key is already set");
      }
      const cipherLength = 32 + (this.ss.cs.hasKey() ? 16 : 0);
      if (message2.byteLength < offset + cipherLength) {
        throw new Error("message is not long enough");
      }
      const temp = message2.sublist(offset, offset + cipherLength);
      this.rs = this.ss.decryptAndHash(temp);
      return cipherLength;
    }
    readEE() {
      this.writeEE();
    }
    readES() {
      this.writeES();
    }
    readSE() {
      this.writeSE();
    }
  };
  var XXHandshakeState = class extends AbstractHandshakeState {
    // e
    writeMessageA(payload) {
      return new Uint8ArrayList(this.writeE(), this.ss.encryptAndHash(payload));
    }
    // e, ee, s, es
    writeMessageB(payload) {
      const e = this.writeE();
      this.writeEE();
      const encS = this.writeS();
      this.writeES();
      return new Uint8ArrayList(e, encS, this.ss.encryptAndHash(payload));
    }
    // s, se
    writeMessageC(payload) {
      const encS = this.writeS();
      this.writeSE();
      return new Uint8ArrayList(encS, this.ss.encryptAndHash(payload));
    }
    // e
    readMessageA(message2) {
      try {
        this.readE(message2);
        return this.ss.decryptAndHash(message2.sublist(32));
      } catch (e) {
        throw new InvalidCryptoExchangeError2(`handshake stage 0 validation fail: ${e.message}`);
      }
    }
    // e, ee, s, es
    readMessageB(message2) {
      try {
        this.readE(message2);
        this.readEE();
        const consumed = this.readS(message2, 32);
        this.readES();
        return this.ss.decryptAndHash(message2.sublist(32 + consumed));
      } catch (e) {
        throw new InvalidCryptoExchangeError2(`handshake stage 1 validation fail: ${e.message}`);
      }
    }
    // s, se
    readMessageC(message2) {
      try {
        const consumed = this.readS(message2);
        this.readSE();
        return this.ss.decryptAndHash(message2.sublist(consumed));
      } catch (e) {
        throw new InvalidCryptoExchangeError2(`handshake stage 2 validation fail: ${e.message}`);
      }
    }
  };
  function hashProtocolName(crypto3, protocolName) {
    if (protocolName.length <= 32) {
      const h2 = alloc(32);
      h2.set(protocolName);
      return h2;
    } else {
      return crypto3.hash(protocolName);
    }
  }

  // node_modules/@chainsafe/libp2p-noise/dist/src/utils.js
  var import_browser_shims332 = __toESM(require_browser_shims(), 1);

  // node_modules/@chainsafe/libp2p-noise/dist/src/proto/payload.js
  var import_browser_shims331 = __toESM(require_browser_shims(), 1);
  var NoiseExtensions;
  (function(NoiseExtensions2) {
    let _codec;
    NoiseExtensions2.codec = () => {
      if (_codec == null) {
        _codec = message((obj, w2, opts = {}) => {
          if (opts.lengthDelimited !== false) {
            w2.fork();
          }
          if (obj.webtransportCerthashes != null) {
            for (const value of obj.webtransportCerthashes) {
              w2.uint32(10);
              w2.bytes(value);
            }
          }
          if (obj.streamMuxers != null) {
            for (const value of obj.streamMuxers) {
              w2.uint32(18);
              w2.string(value);
            }
          }
          if (opts.lengthDelimited !== false) {
            w2.ldelim();
          }
        }, (reader, length4, opts = {}) => {
          var _a2, _b2;
          const obj = {
            webtransportCerthashes: [],
            streamMuxers: []
          };
          const end = length4 == null ? reader.len : reader.pos + length4;
          while (reader.pos < end) {
            const tag = reader.uint32();
            switch (tag >>> 3) {
              case 1: {
                if (((_a2 = opts.limits) == null ? void 0 : _a2.webtransportCerthashes) != null && obj.webtransportCerthashes.length === opts.limits.webtransportCerthashes) {
                  throw new MaxLengthError('Decode error - map field "webtransportCerthashes" had too many elements');
                }
                obj.webtransportCerthashes.push(reader.bytes());
                break;
              }
              case 2: {
                if (((_b2 = opts.limits) == null ? void 0 : _b2.streamMuxers) != null && obj.streamMuxers.length === opts.limits.streamMuxers) {
                  throw new MaxLengthError('Decode error - map field "streamMuxers" had too many elements');
                }
                obj.streamMuxers.push(reader.string());
                break;
              }
              default: {
                reader.skipType(tag & 7);
                break;
              }
            }
          }
          return obj;
        });
      }
      return _codec;
    };
    NoiseExtensions2.encode = (obj) => {
      return encodeMessage(obj, NoiseExtensions2.codec());
    };
    NoiseExtensions2.decode = (buf, opts) => {
      return decodeMessage(buf, NoiseExtensions2.codec(), opts);
    };
  })(NoiseExtensions || (NoiseExtensions = {}));
  var NoiseHandshakePayload;
  (function(NoiseHandshakePayload2) {
    let _codec;
    NoiseHandshakePayload2.codec = () => {
      if (_codec == null) {
        _codec = message((obj, w2, opts = {}) => {
          if (opts.lengthDelimited !== false) {
            w2.fork();
          }
          if (obj.identityKey != null && obj.identityKey.byteLength > 0) {
            w2.uint32(10);
            w2.bytes(obj.identityKey);
          }
          if (obj.identitySig != null && obj.identitySig.byteLength > 0) {
            w2.uint32(18);
            w2.bytes(obj.identitySig);
          }
          if (obj.extensions != null) {
            w2.uint32(34);
            NoiseExtensions.codec().encode(obj.extensions, w2);
          }
          if (opts.lengthDelimited !== false) {
            w2.ldelim();
          }
        }, (reader, length4, opts = {}) => {
          var _a2;
          const obj = {
            identityKey: alloc(0),
            identitySig: alloc(0)
          };
          const end = length4 == null ? reader.len : reader.pos + length4;
          while (reader.pos < end) {
            const tag = reader.uint32();
            switch (tag >>> 3) {
              case 1: {
                obj.identityKey = reader.bytes();
                break;
              }
              case 2: {
                obj.identitySig = reader.bytes();
                break;
              }
              case 4: {
                obj.extensions = NoiseExtensions.codec().decode(reader, reader.uint32(), {
                  limits: (_a2 = opts.limits) == null ? void 0 : _a2.extensions
                });
                break;
              }
              default: {
                reader.skipType(tag & 7);
                break;
              }
            }
          }
          return obj;
        });
      }
      return _codec;
    };
    NoiseHandshakePayload2.encode = (obj) => {
      return encodeMessage(obj, NoiseHandshakePayload2.codec());
    };
    NoiseHandshakePayload2.decode = (buf, opts) => {
      return decodeMessage(buf, NoiseHandshakePayload2.codec(), opts);
    };
  })(NoiseHandshakePayload || (NoiseHandshakePayload = {}));

  // node_modules/@chainsafe/libp2p-noise/dist/src/utils.js
  async function createHandshakePayload(privateKey, staticPublicKey, extensions) {
    const identitySig = await privateKey.sign(getSignaturePayload(staticPublicKey));
    return NoiseHandshakePayload.encode({
      identityKey: publicKeyToProtobuf(privateKey.publicKey),
      identitySig,
      extensions
    });
  }
  async function decodeHandshakePayload(payloadBytes, remoteStaticKey, remoteIdentityKey) {
    try {
      const payload = NoiseHandshakePayload.decode(payloadBytes);
      const publicKey = publicKeyFromProtobuf(payload.identityKey);
      if ((remoteIdentityKey == null ? void 0 : remoteIdentityKey.equals(publicKey)) === false) {
        throw new Error(`Payload identity key ${publicKey} does not match expected remote identity key ${remoteIdentityKey}`);
      }
      if (!remoteStaticKey) {
        throw new Error("Remote static does not exist");
      }
      const signaturePayload = getSignaturePayload(remoteStaticKey);
      if (!await publicKey.verify(signaturePayload, payload.identitySig)) {
        throw new Error("Invalid payload signature");
      }
      return payload;
    } catch (e) {
      throw new UnexpectedPeerError(e.message);
    }
  }
  function getSignaturePayload(publicKey) {
    const prefix = fromString2("noise-libp2p-static-key:");
    if (publicKey instanceof Uint8Array) {
      return concat([prefix, publicKey], prefix.length + publicKey.length);
    }
    publicKey.prepend(prefix);
    return publicKey;
  }

  // node_modules/@chainsafe/libp2p-noise/dist/src/performHandshake.js
  async function performHandshakeInitiator(init, options) {
    const { log: log2, connection, crypto: crypto3, privateKey, prologue, s: s2, remoteIdentityKey, extensions } = init;
    const payload = await createHandshakePayload(privateKey, s2.publicKey, extensions);
    const xx = new XXHandshakeState({
      crypto: crypto3,
      protocolName: "Noise_XX_25519_ChaChaPoly_SHA256",
      initiator: true,
      prologue,
      s: s2
    });
    logLocalStaticKeys(xx.s, log2);
    log2.trace("Stage 0 - Initiator starting to send first message.");
    await connection.write(xx.writeMessageA(ZEROLEN), options);
    log2.trace("Stage 0 - Initiator finished sending first message.");
    logLocalEphemeralKeys(xx.e, log2);
    log2.trace("Stage 1 - Initiator waiting to receive first message from responder...");
    const plaintext = xx.readMessageB(await connection.read(options));
    log2.trace("Stage 1 - Initiator received the message.");
    logRemoteEphemeralKey(xx.re, log2);
    logRemoteStaticKey(xx.rs, log2);
    log2.trace("Initiator going to check remote's signature...");
    const receivedPayload = await decodeHandshakePayload(plaintext, xx.rs, remoteIdentityKey);
    log2.trace("All good with the signature!");
    log2.trace("Stage 2 - Initiator sending third handshake message.");
    await connection.write(xx.writeMessageC(payload), options);
    log2.trace("Stage 2 - Initiator sent message with signed payload.");
    const [cs1, cs2] = xx.ss.split();
    logCipherState(cs1, cs2, log2);
    return {
      payload: receivedPayload,
      encrypt: (plaintext2) => cs1.encryptWithAd(ZEROLEN, plaintext2),
      decrypt: (ciphertext, dst) => cs2.decryptWithAd(ZEROLEN, ciphertext, dst)
    };
  }
  async function performHandshakeResponder(init, options) {
    const { log: log2, connection, crypto: crypto3, privateKey, prologue, s: s2, remoteIdentityKey, extensions } = init;
    const payload = await createHandshakePayload(privateKey, s2.publicKey, extensions);
    const xx = new XXHandshakeState({
      crypto: crypto3,
      protocolName: "Noise_XX_25519_ChaChaPoly_SHA256",
      initiator: false,
      prologue,
      s: s2
    });
    logLocalStaticKeys(xx.s, log2);
    log2.trace("Stage 0 - Responder waiting to receive first message.");
    xx.readMessageA(await connection.read(options));
    log2.trace("Stage 0 - Responder received first message.");
    logRemoteEphemeralKey(xx.re, log2);
    log2.trace("Stage 1 - Responder sending out first message with signed payload and static key.");
    await connection.write(xx.writeMessageB(payload), options);
    log2.trace("Stage 1 - Responder sent the second handshake message with signed payload.");
    logLocalEphemeralKeys(xx.e, log2);
    log2.trace("Stage 2 - Responder waiting for third handshake message...");
    const plaintext = xx.readMessageC(await connection.read(options));
    log2.trace("Stage 2 - Responder received the message, finished handshake.");
    const receivedPayload = await decodeHandshakePayload(plaintext, xx.rs, remoteIdentityKey);
    const [cs1, cs2] = xx.ss.split();
    logCipherState(cs1, cs2, log2);
    return {
      payload: receivedPayload,
      encrypt: (plaintext2) => cs2.encryptWithAd(ZEROLEN, plaintext2),
      decrypt: (ciphertext, dst) => cs1.decryptWithAd(ZEROLEN, ciphertext, dst)
    };
  }

  // node_modules/@chainsafe/libp2p-noise/dist/src/streaming.js
  var import_browser_shims334 = __toESM(require_browser_shims(), 1);
  var CHACHA_TAG_LENGTH = 16;
  function encryptStream(handshake, metrics) {
    return async function* (source) {
      for await (const chunk of source) {
        for (let i = 0; i < chunk.length; i += NOISE_MSG_MAX_LENGTH_BYTES_WITHOUT_TAG) {
          let end = i + NOISE_MSG_MAX_LENGTH_BYTES_WITHOUT_TAG;
          if (end > chunk.length) {
            end = chunk.length;
          }
          let data;
          if (chunk instanceof Uint8Array) {
            data = handshake.encrypt(chunk.subarray(i, end));
          } else {
            data = handshake.encrypt(chunk.sublist(i, end));
          }
          metrics == null ? void 0 : metrics.encryptedPackets.increment();
          yield new Uint8ArrayList(uint16BEEncode(data.byteLength), data);
        }
      }
    };
  }
  function decryptStream(handshake, metrics) {
    return async function* (source) {
      for await (const chunk of source) {
        for (let i = 0; i < chunk.length; i += NOISE_MSG_MAX_LENGTH_BYTES) {
          let end = i + NOISE_MSG_MAX_LENGTH_BYTES;
          if (end > chunk.length) {
            end = chunk.length;
          }
          if (end - CHACHA_TAG_LENGTH < i) {
            throw new Error("Invalid chunk");
          }
          const encrypted = chunk.sublist(i, end);
          const dst = chunk.subarray(i, end - CHACHA_TAG_LENGTH);
          try {
            const plaintext = handshake.decrypt(encrypted, dst);
            metrics == null ? void 0 : metrics.decryptedPackets.increment();
            yield plaintext;
          } catch (e) {
            metrics == null ? void 0 : metrics.decryptErrors.increment();
            throw e;
          }
        }
      }
    };
  }

  // node_modules/@chainsafe/libp2p-noise/dist/src/noise.js
  var Noise = class {
    protocol = "/noise";
    crypto;
    prologue;
    staticKey;
    extensions;
    metrics;
    components;
    constructor(components, init = {}) {
      const { staticNoiseKey, extensions, crypto: crypto3, prologueBytes } = init;
      const { metrics } = components;
      this.components = components;
      const _crypto = crypto3 ?? defaultCrypto;
      this.crypto = wrapCrypto(_crypto);
      this.extensions = {
        webtransportCerthashes: [],
        ...extensions
      };
      this.metrics = metrics ? registerMetrics(metrics) : void 0;
      if (staticNoiseKey) {
        this.staticKey = _crypto.generateX25519KeyPairFromSeed(staticNoiseKey);
      } else {
        this.staticKey = _crypto.generateX25519KeyPair();
      }
      this.prologue = prologueBytes ?? alloc(0);
    }
    [Symbol.toStringTag] = "@chainsafe/libp2p-noise";
    [serviceCapabilities] = [
      "@libp2p/connection-encryption",
      "@chainsafe/libp2p-noise"
    ];
    /**
     * Encrypt outgoing data to the remote party (handshake as initiator)
     *
     * @param connection - streaming iterable duplex that will be encrypted
     * @param options
     * @param options.remotePeer - PeerId of the remote peer. Used to validate the integrity of the remote peer
     * @param options.signal - Used to abort the operation
     */
    async secureOutbound(connection, options) {
      var _a2, _b2;
      const wrappedConnection = lpStream(connection, {
        lengthEncoder: uint16BEEncode,
        lengthDecoder: uint16BEDecode,
        maxDataLength: NOISE_MSG_MAX_LENGTH_BYTES
      });
      const handshake = await this.performHandshakeInitiator(wrappedConnection, this.components.privateKey, (_a2 = options == null ? void 0 : options.remotePeer) == null ? void 0 : _a2.publicKey, options);
      const conn = await this.createSecureConnection(wrappedConnection, handshake);
      connection.source = conn.source;
      connection.sink = conn.sink;
      const publicKey = publicKeyFromProtobuf(handshake.payload.identityKey);
      return {
        conn: connection,
        remoteExtensions: handshake.payload.extensions,
        remotePeer: peerIdFromPublicKey(publicKey),
        streamMuxer: (options == null ? void 0 : options.skipStreamMuxerNegotiation) === true ? void 0 : this.getStreamMuxer((_b2 = handshake.payload.extensions) == null ? void 0 : _b2.streamMuxers)
      };
    }
    getStreamMuxer(protocols) {
      if (protocols == null || protocols.length === 0) {
        return;
      }
      const streamMuxers = this.components.upgrader.getStreamMuxers();
      if (streamMuxers != null) {
        for (const protocol of protocols) {
          const streamMuxer = streamMuxers.get(protocol);
          if (streamMuxer != null) {
            return streamMuxer;
          }
        }
      }
      if (protocols.length) {
        throw new InvalidCryptoExchangeError("Early muxer negotiation was requested but the initiator and responder had no common muxers");
      }
    }
    /**
     * Decrypt incoming data (handshake as responder).
     *
     * @param connection - streaming iterable duplex that will be encrypted
     * @param options
     * @param options.remotePeer - PeerId of the remote peer. Used to validate the integrity of the remote peer
     * @param options.signal - Used to abort the operation
     */
    async secureInbound(connection, options) {
      var _a2, _b2;
      const wrappedConnection = lpStream(connection, {
        lengthEncoder: uint16BEEncode,
        lengthDecoder: uint16BEDecode,
        maxDataLength: NOISE_MSG_MAX_LENGTH_BYTES
      });
      const handshake = await this.performHandshakeResponder(wrappedConnection, this.components.privateKey, (_a2 = options == null ? void 0 : options.remotePeer) == null ? void 0 : _a2.publicKey, options);
      const conn = await this.createSecureConnection(wrappedConnection, handshake);
      connection.source = conn.source;
      connection.sink = conn.sink;
      const publicKey = publicKeyFromProtobuf(handshake.payload.identityKey);
      return {
        conn: connection,
        remoteExtensions: handshake.payload.extensions,
        remotePeer: peerIdFromPublicKey(publicKey),
        streamMuxer: (options == null ? void 0 : options.skipStreamMuxerNegotiation) === true ? void 0 : this.getStreamMuxer((_b2 = handshake.payload.extensions) == null ? void 0 : _b2.streamMuxers)
      };
    }
    /**
     * Perform XX handshake as initiator.
     */
    async performHandshakeInitiator(connection, privateKey, remoteIdentityKey, options) {
      var _a2, _b2;
      let result;
      const streamMuxers = (options == null ? void 0 : options.skipStreamMuxerNegotiation) === true ? [] : [...this.components.upgrader.getStreamMuxers().keys()];
      try {
        result = await performHandshakeInitiator({
          connection,
          privateKey,
          remoteIdentityKey,
          log: this.components.logger.forComponent("libp2p:noise:xxhandshake"),
          crypto: this.crypto,
          prologue: this.prologue,
          s: this.staticKey,
          extensions: {
            streamMuxers,
            webtransportCerthashes: [],
            ...this.extensions
          }
        }, options);
        (_a2 = this.metrics) == null ? void 0 : _a2.xxHandshakeSuccesses.increment();
      } catch (e) {
        (_b2 = this.metrics) == null ? void 0 : _b2.xxHandshakeErrors.increment();
        throw e;
      }
      return result;
    }
    /**
     * Perform XX handshake as responder.
     */
    async performHandshakeResponder(connection, privateKey, remoteIdentityKey, options) {
      var _a2, _b2;
      let result;
      const streamMuxers = (options == null ? void 0 : options.skipStreamMuxerNegotiation) === true ? [] : [...this.components.upgrader.getStreamMuxers().keys()];
      try {
        result = await performHandshakeResponder({
          connection,
          privateKey,
          remoteIdentityKey,
          log: this.components.logger.forComponent("libp2p:noise:xxhandshake"),
          crypto: this.crypto,
          prologue: this.prologue,
          s: this.staticKey,
          extensions: {
            streamMuxers,
            webtransportCerthashes: [],
            ...this.extensions
          }
        }, options);
        (_a2 = this.metrics) == null ? void 0 : _a2.xxHandshakeSuccesses.increment();
      } catch (e) {
        (_b2 = this.metrics) == null ? void 0 : _b2.xxHandshakeErrors.increment();
        throw e;
      }
      return result;
    }
    async createSecureConnection(connection, handshake) {
      const [secure, user] = duplexPair();
      const network = connection.unwrap();
      await pipe(
        secure,
        // write to wrapper
        encryptStream(handshake, this.metrics),
        // encrypt data + prefix with message length
        network,
        // send to the remote peer
        (source) => decode9(source, { lengthDecoder: uint16BEDecode }),
        // read message length prefix
        decryptStream(handshake, this.metrics),
        // decrypt the incoming data
        secure
        // pipe to the wrapper
      );
      return user;
    }
  };

  // node_modules/@chainsafe/libp2p-noise/dist/src/index.js
  function noise(init = {}) {
    return (components) => new Noise(components, init);
  }

  // node_modules/@chainsafe/libp2p-yamux/dist/src/index.js
  var import_browser_shims350 = __toESM(require_browser_shims(), 1);

  // node_modules/@chainsafe/libp2p-yamux/dist/src/muxer.js
  var import_browser_shims349 = __toESM(require_browser_shims(), 1);

  // node_modules/get-iterator/dist/src/index.js
  var import_browser_shims337 = __toESM(require_browser_shims(), 1);
  function getIterator(obj) {
    if (obj != null) {
      if (typeof obj[Symbol.iterator] === "function") {
        return obj[Symbol.iterator]();
      }
      if (typeof obj[Symbol.asyncIterator] === "function") {
        return obj[Symbol.asyncIterator]();
      }
      if (typeof obj.next === "function") {
        return obj;
      }
    }
    throw new Error("argument is not an iterator or iterable");
  }

  // node_modules/@chainsafe/libp2p-yamux/dist/src/config.js
  var import_browser_shims340 = __toESM(require_browser_shims(), 1);

  // node_modules/@chainsafe/libp2p-yamux/dist/src/constants.js
  var import_browser_shims339 = __toESM(require_browser_shims(), 1);

  // node_modules/@chainsafe/libp2p-yamux/dist/src/errors.js
  var import_browser_shims338 = __toESM(require_browser_shims(), 1);
  var InvalidFrameError = class extends Error {
    static name = "InvalidFrameError";
    constructor(message2 = "The frame was invalid") {
      super(message2);
      this.name = "InvalidFrameError";
    }
  };
  var UnrequestedPingError = class extends Error {
    static name = "UnrequestedPingError";
    constructor(message2 = "Unrequested ping error") {
      super(message2);
      this.name = "UnrequestedPingError";
    }
  };
  var NotMatchingPingError = class extends Error {
    static name = "NotMatchingPingError";
    constructor(message2 = "Unrequested ping error") {
      super(message2);
      this.name = "NotMatchingPingError";
    }
  };
  var InvalidStateError = class extends Error {
    static name = "InvalidStateError";
    constructor(message2 = "Invalid state") {
      super(message2);
      this.name = "InvalidStateError";
    }
  };
  var StreamAlreadyExistsError = class extends Error {
    static name = "StreamAlreadyExistsError";
    constructor(message2 = "Strean already exists") {
      super(message2);
      this.name = "StreamAlreadyExistsError";
    }
  };
  var DecodeInvalidVersionError = class extends Error {
    static name = "DecodeInvalidVersionError";
    constructor(message2 = "Decode invalid version") {
      super(message2);
      this.name = "DecodeInvalidVersionError";
    }
  };
  var BothClientsError = class extends Error {
    static name = "BothClientsError";
    constructor(message2 = "Both clients") {
      super(message2);
      this.name = "BothClientsError";
    }
  };
  var ReceiveWindowExceededError = class extends Error {
    static name = "ReceiveWindowExceededError";
    constructor(message2 = "Receive window exceeded") {
      super(message2);
      this.name = "ReceiveWindowExceededError";
    }
  };

  // node_modules/@chainsafe/libp2p-yamux/dist/src/constants.js
  var PROTOCOL_ERRORS = /* @__PURE__ */ new Set([
    InvalidFrameError.name,
    UnrequestedPingError.name,
    NotMatchingPingError.name,
    StreamAlreadyExistsError.name,
    DecodeInvalidVersionError.name,
    BothClientsError.name,
    ReceiveWindowExceededError.name
  ]);
  var INITIAL_STREAM_WINDOW = 256 * 1024;
  var MAX_STREAM_WINDOW = 16 * 1024 * 1024;

  // node_modules/@chainsafe/libp2p-yamux/dist/src/config.js
  var defaultConfig = {
    enableKeepAlive: true,
    keepAliveInterval: 3e4,
    maxInboundStreams: 1e3,
    maxOutboundStreams: 1e3,
    initialStreamWindowSize: INITIAL_STREAM_WINDOW,
    maxStreamWindowSize: MAX_STREAM_WINDOW,
    maxMessageSize: 64 * 1024
  };
  function verifyConfig(config) {
    if (config.keepAliveInterval <= 0) {
      throw new InvalidParametersError("keep-alive interval must be positive");
    }
    if (config.maxInboundStreams < 0) {
      throw new InvalidParametersError("max inbound streams must be larger or equal 0");
    }
    if (config.maxOutboundStreams < 0) {
      throw new InvalidParametersError("max outbound streams must be larger or equal 0");
    }
    if (config.initialStreamWindowSize < INITIAL_STREAM_WINDOW) {
      throw new InvalidParametersError("InitialStreamWindowSize must be larger or equal 256 kB");
    }
    if (config.maxStreamWindowSize < config.initialStreamWindowSize) {
      throw new InvalidParametersError("MaxStreamWindowSize must be larger than the InitialStreamWindowSize");
    }
    if (config.maxStreamWindowSize > 2 ** 32 - 1) {
      throw new InvalidParametersError("MaxStreamWindowSize must be less than equal MAX_UINT32");
    }
    if (config.maxMessageSize < 1024) {
      throw new InvalidParametersError("MaxMessageSize must be greater than a kilobyte");
    }
  }

  // node_modules/@chainsafe/libp2p-yamux/dist/src/decode.js
  var import_browser_shims342 = __toESM(require_browser_shims(), 1);

  // node_modules/@chainsafe/libp2p-yamux/dist/src/frame.js
  var import_browser_shims341 = __toESM(require_browser_shims(), 1);
  var FrameType;
  (function(FrameType2) {
    FrameType2[FrameType2["Data"] = 0] = "Data";
    FrameType2[FrameType2["WindowUpdate"] = 1] = "WindowUpdate";
    FrameType2[FrameType2["Ping"] = 2] = "Ping";
    FrameType2[FrameType2["GoAway"] = 3] = "GoAway";
  })(FrameType || (FrameType = {}));
  var Flag;
  (function(Flag2) {
    Flag2[Flag2["SYN"] = 1] = "SYN";
    Flag2[Flag2["ACK"] = 2] = "ACK";
    Flag2[Flag2["FIN"] = 4] = "FIN";
    Flag2[Flag2["RST"] = 8] = "RST";
  })(Flag || (Flag = {}));
  var flagCodes = Object.values(Flag).filter((x) => typeof x !== "string");
  var YAMUX_VERSION = 0;
  var GoAwayCode;
  (function(GoAwayCode2) {
    GoAwayCode2[GoAwayCode2["NormalTermination"] = 0] = "NormalTermination";
    GoAwayCode2[GoAwayCode2["ProtocolError"] = 1] = "ProtocolError";
    GoAwayCode2[GoAwayCode2["InternalError"] = 2] = "InternalError";
  })(GoAwayCode || (GoAwayCode = {}));
  var HEADER_LENGTH = 12;

  // node_modules/@chainsafe/libp2p-yamux/dist/src/decode.js
  var twoPow24 = 2 ** 24;
  function decodeHeader(data) {
    if (data[0] !== YAMUX_VERSION) {
      throw new InvalidFrameError("Invalid frame version");
    }
    return {
      type: data[1],
      flag: (data[2] << 8) + data[3],
      streamID: data[4] * twoPow24 + (data[5] << 16) + (data[6] << 8) + data[7],
      length: data[8] * twoPow24 + (data[9] << 16) + (data[10] << 8) + data[11]
    };
  }
  var Decoder2 = class {
    source;
    /** Buffer for in-progress frames */
    buffer;
    /** Used to sanity check against decoding while in an inconsistent state */
    frameInProgress;
    constructor(source) {
      this.source = returnlessSource(source);
      this.buffer = new Uint8ArrayList();
      this.frameInProgress = false;
    }
    /**
     * Emits frames from the decoder source.
     *
     * Note: If `readData` is emitted, it _must_ be called before the next iteration
     * Otherwise an error is thrown
     */
    async *emitFrames() {
      for await (const chunk of this.source) {
        this.buffer.append(chunk);
        while (true) {
          const header = this.readHeader();
          if (header === void 0) {
            break;
          }
          const { type, length: length4 } = header;
          if (type === FrameType.Data) {
            this.frameInProgress = true;
            yield {
              header,
              readData: this.readBytes.bind(this, length4)
            };
          } else {
            yield { header };
          }
        }
      }
    }
    readHeader() {
      if (this.frameInProgress) {
        throw new InvalidStateError("decoding frame already in progress");
      }
      if (this.buffer.length < HEADER_LENGTH) {
        return;
      }
      const header = decodeHeader(this.buffer.subarray(0, HEADER_LENGTH));
      this.buffer.consume(HEADER_LENGTH);
      return header;
    }
    async readBytes(length4) {
      if (this.buffer.length < length4) {
        for await (const chunk of this.source) {
          this.buffer.append(chunk);
          if (this.buffer.length >= length4) {
            break;
          }
        }
      }
      const out = this.buffer.sublist(0, length4);
      this.buffer.consume(length4);
      this.frameInProgress = false;
      return out;
    }
  };
  function returnlessSource(source) {
    if (source[Symbol.iterator] !== void 0) {
      const iterator = source[Symbol.iterator]();
      iterator.return = void 0;
      return {
        [Symbol.iterator]() {
          return iterator;
        }
      };
    } else if (source[Symbol.asyncIterator] !== void 0) {
      const iterator = source[Symbol.asyncIterator]();
      iterator.return = void 0;
      return {
        [Symbol.asyncIterator]() {
          return iterator;
        }
      };
    } else {
      throw new Error("a source must be either an iterable or an async iterable");
    }
  }

  // node_modules/@chainsafe/libp2p-yamux/dist/src/encode.js
  var import_browser_shims343 = __toESM(require_browser_shims(), 1);
  function encodeHeader(header) {
    const frame = new Uint8Array(HEADER_LENGTH);
    frame[1] = header.type;
    frame[2] = header.flag >>> 8;
    frame[3] = header.flag;
    frame[4] = header.streamID >>> 24;
    frame[5] = header.streamID >>> 16;
    frame[6] = header.streamID >>> 8;
    frame[7] = header.streamID;
    frame[8] = header.length >>> 24;
    frame[9] = header.length >>> 16;
    frame[10] = header.length >>> 8;
    frame[11] = header.length;
    return frame;
  }

  // node_modules/@chainsafe/libp2p-yamux/dist/src/stream.js
  var import_browser_shims348 = __toESM(require_browser_shims(), 1);

  // node_modules/@libp2p/utils/dist/src/abstract-stream.js
  var import_browser_shims346 = __toESM(require_browser_shims(), 1);

  // node_modules/@libp2p/utils/dist/src/close-source.js
  var import_browser_shims345 = __toESM(require_browser_shims(), 1);

  // node_modules/@libp2p/utils/dist/src/is-promise.js
  var import_browser_shims344 = __toESM(require_browser_shims(), 1);
  function isPromise2(thing) {
    if (thing == null) {
      return false;
    }
    return typeof thing.then === "function" && typeof thing.catch === "function" && typeof thing.finally === "function";
  }

  // node_modules/@libp2p/utils/dist/src/close-source.js
  function closeSource(source, log2) {
    var _a2, _b2;
    const res = (_b2 = (_a2 = getIterator(source)).return) == null ? void 0 : _b2.call(_a2);
    if (isPromise2(res)) {
      res.catch((err) => {
        log2.error("could not cause iterator to return", err);
      });
    }
  }

  // node_modules/@libp2p/utils/dist/src/abstract-stream.js
  var DEFAULT_SEND_CLOSE_WRITE_TIMEOUT = 5e3;
  function isPromise3(thing) {
    if (thing == null) {
      return false;
    }
    return typeof thing.then === "function" && typeof thing.catch === "function" && typeof thing.finally === "function";
  }
  var AbstractStream = class {
    id;
    direction;
    timeline;
    protocol;
    metadata;
    source;
    status;
    readStatus;
    writeStatus;
    log;
    sinkController;
    sinkEnd;
    closed;
    endErr;
    streamSource;
    onEnd;
    onCloseRead;
    onCloseWrite;
    onReset;
    onAbort;
    sendCloseWriteTimeout;
    sendingData;
    constructor(init) {
      this.sinkController = new AbortController();
      this.sinkEnd = pDefer();
      this.closed = pDefer();
      this.log = init.log;
      this.status = "open";
      this.readStatus = "ready";
      this.writeStatus = "ready";
      this.id = init.id;
      this.metadata = init.metadata ?? {};
      this.direction = init.direction;
      this.timeline = {
        open: Date.now()
      };
      this.sendCloseWriteTimeout = init.sendCloseWriteTimeout ?? DEFAULT_SEND_CLOSE_WRITE_TIMEOUT;
      this.onEnd = init.onEnd;
      this.onCloseRead = init.onCloseRead;
      this.onCloseWrite = init.onCloseWrite;
      this.onReset = init.onReset;
      this.onAbort = init.onAbort;
      this.source = this.streamSource = pushable({
        onEnd: (err) => {
          if (err != null) {
            this.log.trace("source ended with error", err);
          } else {
            this.log.trace("source ended");
          }
          this.onSourceEnd(err);
        }
      });
      this.sink = this.sink.bind(this);
    }
    async sink(source) {
      if (this.writeStatus !== "ready") {
        throw new StreamStateError(`writable end state is "${this.writeStatus}" not "ready"`);
      }
      try {
        this.writeStatus = "writing";
        const options = {
          signal: this.sinkController.signal
        };
        if (this.direction === "outbound") {
          const res = this.sendNewStream(options);
          if (isPromise3(res)) {
            await res;
          }
        }
        const abortListener = () => {
          closeSource(source, this.log);
        };
        try {
          this.sinkController.signal.addEventListener("abort", abortListener);
          this.log.trace("sink reading from source");
          for await (let data of source) {
            data = data instanceof Uint8Array ? new Uint8ArrayList(data) : data;
            const res = this.sendData(data, options);
            if (isPromise3(res)) {
              this.sendingData = pDefer();
              await res;
              this.sendingData.resolve();
              this.sendingData = void 0;
            }
          }
        } finally {
          this.sinkController.signal.removeEventListener("abort", abortListener);
        }
        this.log.trace('sink finished reading from source, write status is "%s"', this.writeStatus);
        if (this.writeStatus === "writing") {
          this.writeStatus = "closing";
          this.log.trace("send close write to remote");
          await this.sendCloseWrite({
            signal: AbortSignal.timeout(this.sendCloseWriteTimeout)
          });
          this.writeStatus = "closed";
        }
        this.onSinkEnd();
      } catch (err) {
        this.log.trace("sink ended with error, calling abort with error", err);
        this.abort(err);
        throw err;
      } finally {
        this.log.trace("resolve sink end");
        this.sinkEnd.resolve();
      }
    }
    onSourceEnd(err) {
      var _a2;
      if (this.timeline.closeRead != null) {
        return;
      }
      this.timeline.closeRead = Date.now();
      this.readStatus = "closed";
      if (err != null && this.endErr == null) {
        this.endErr = err;
      }
      (_a2 = this.onCloseRead) == null ? void 0 : _a2.call(this);
      if (this.timeline.closeWrite != null) {
        this.log.trace("source and sink ended");
        this.timeline.close = Date.now();
        if (this.status !== "aborted" && this.status !== "reset") {
          this.status = "closed";
        }
        if (this.onEnd != null) {
          this.onEnd(this.endErr);
        }
        this.closed.resolve();
      } else {
        this.log.trace("source ended, waiting for sink to end");
      }
    }
    onSinkEnd(err) {
      var _a2;
      if (this.timeline.closeWrite != null) {
        return;
      }
      this.timeline.closeWrite = Date.now();
      this.writeStatus = "closed";
      if (err != null && this.endErr == null) {
        this.endErr = err;
      }
      (_a2 = this.onCloseWrite) == null ? void 0 : _a2.call(this);
      if (this.timeline.closeRead != null) {
        this.log.trace("sink and source ended");
        this.timeline.close = Date.now();
        if (this.status !== "aborted" && this.status !== "reset") {
          this.status = "closed";
        }
        if (this.onEnd != null) {
          this.onEnd(this.endErr);
        }
        this.closed.resolve();
      } else {
        this.log.trace("sink ended, waiting for source to end");
      }
    }
    // Close for both Reading and Writing
    async close(options) {
      if (this.status !== "open") {
        return;
      }
      this.log.trace("closing gracefully");
      this.status = "closing";
      await raceSignal(Promise.all([
        this.closeWrite(options),
        this.closeRead(options),
        this.closed.promise
      ]), options == null ? void 0 : options.signal);
      this.status = "closed";
      this.log.trace("closed gracefully");
    }
    async closeRead(options = {}) {
      if (this.readStatus === "closing" || this.readStatus === "closed") {
        return;
      }
      this.log.trace('closing readable end of stream with starting read status "%s"', this.readStatus);
      const readStatus = this.readStatus;
      this.readStatus = "closing";
      if (this.status !== "reset" && this.status !== "aborted" && this.timeline.closeRead == null) {
        this.log.trace("send close read to remote");
        await this.sendCloseRead(options);
      }
      if (readStatus === "ready") {
        this.log.trace("ending internal source queue with %d queued bytes", this.streamSource.readableLength);
        this.streamSource.end();
      }
      this.log.trace("closed readable end of stream");
    }
    async closeWrite(options = {}) {
      if (this.writeStatus === "closing" || this.writeStatus === "closed") {
        return;
      }
      this.log.trace('closing writable end of stream with starting write status "%s"', this.writeStatus);
      if (this.writeStatus === "ready") {
        this.log.trace("sink was never sunk, sink an empty array");
        await raceSignal(this.sink([]), options.signal);
      }
      if (this.writeStatus === "writing") {
        if (this.sendingData != null) {
          await raceSignal(this.sendingData.promise, options.signal);
        }
        this.log.trace("aborting source passed to .sink");
        this.sinkController.abort();
        await raceSignal(this.sinkEnd.promise, options.signal);
      }
      this.writeStatus = "closed";
      this.log.trace("closed writable end of stream");
    }
    /**
     * Close immediately for reading and writing and send a reset message (local
     * error)
     */
    abort(err) {
      var _a2;
      if (this.status === "closed" || this.status === "aborted" || this.status === "reset") {
        return;
      }
      this.log("abort with error", err);
      this.log("try to send reset to remote");
      const res = this.sendReset();
      if (isPromise3(res)) {
        res.catch((err2) => {
          this.log.error("error sending reset message", err2);
        });
      }
      this.status = "aborted";
      this.timeline.abort = Date.now();
      this._closeSinkAndSource(err);
      (_a2 = this.onAbort) == null ? void 0 : _a2.call(this, err);
    }
    /**
     * Receive a reset message - close immediately for reading and writing (remote
     * error)
     */
    reset() {
      var _a2;
      if (this.status === "closed" || this.status === "aborted" || this.status === "reset") {
        return;
      }
      const err = new StreamResetError("stream reset");
      this.status = "reset";
      this.timeline.reset = Date.now();
      this._closeSinkAndSource(err);
      (_a2 = this.onReset) == null ? void 0 : _a2.call(this);
    }
    _closeSinkAndSource(err) {
      this._closeSink(err);
      this._closeSource(err);
    }
    _closeSink(err) {
      if (this.writeStatus === "writing") {
        this.log.trace("end sink source");
        this.sinkController.abort();
      }
      this.onSinkEnd(err);
    }
    _closeSource(err) {
      if (this.readStatus !== "closing" && this.readStatus !== "closed") {
        this.log.trace("ending source with %d bytes to be read by consumer", this.streamSource.readableLength);
        this.readStatus = "closing";
        this.streamSource.end(err);
      }
    }
    /**
     * The remote closed for writing so we should expect to receive no more
     * messages
     */
    remoteCloseWrite() {
      if (this.readStatus === "closing" || this.readStatus === "closed") {
        this.log("received remote close write but local source is already closed");
        return;
      }
      this.log.trace("remote close write");
      this._closeSource();
    }
    /**
     * The remote closed for reading so we should not send any more
     * messages
     */
    remoteCloseRead() {
      if (this.writeStatus === "closing" || this.writeStatus === "closed") {
        this.log("received remote close read but local sink is already closed");
        return;
      }
      this.log.trace("remote close read");
      this._closeSink();
    }
    /**
     * The underlying muxer has closed, no more messages can be sent or will
     * be received, close immediately to free up resources
     */
    destroy() {
      if (this.status === "closed" || this.status === "aborted" || this.status === "reset") {
        this.log("received destroy but we are already closed");
        return;
      }
      this.log.trace("stream destroyed");
      this._closeSinkAndSource();
    }
    /**
     * When an extending class reads data from it's implementation-specific source,
     * call this method to allow the stream consumer to read the data.
     */
    sourcePush(data) {
      this.streamSource.push(data);
    }
    /**
     * Returns the amount of unread data - can be used to prevent large amounts of
     * data building up when the stream consumer is too slow.
     */
    sourceReadableLength() {
      return this.streamSource.readableLength;
    }
  };

  // node_modules/it-foreach/dist/src/index.js
  var import_browser_shims347 = __toESM(require_browser_shims(), 1);
  function isAsyncIterable11(thing) {
    return thing[Symbol.asyncIterator] != null;
  }
  function isPromise4(thing) {
    return (thing == null ? void 0 : thing.then) != null;
  }
  function forEach(source, fn) {
    let index = 0;
    if (isAsyncIterable11(source)) {
      return async function* () {
        for await (const val of source) {
          const res2 = fn(val, index++);
          if (isPromise4(res2)) {
            await res2;
          }
          yield val;
        }
      }();
    }
    const peekable2 = src_default4(source);
    const { value, done } = peekable2.next();
    if (done === true) {
      return function* () {
      }();
    }
    const res = fn(value, index++);
    if (typeof (res == null ? void 0 : res.then) === "function") {
      return async function* () {
        yield value;
        for (const val of peekable2) {
          const res2 = fn(val, index++);
          if (isPromise4(res2)) {
            await res2;
          }
          yield val;
        }
      }();
    }
    const func2 = fn;
    return function* () {
      yield value;
      for (const val of peekable2) {
        func2(val, index++);
        yield val;
      }
    }();
  }
  var src_default9 = forEach;

  // node_modules/@chainsafe/libp2p-yamux/dist/src/stream.js
  var StreamState;
  (function(StreamState2) {
    StreamState2[StreamState2["Init"] = 0] = "Init";
    StreamState2[StreamState2["SYNSent"] = 1] = "SYNSent";
    StreamState2[StreamState2["SYNReceived"] = 2] = "SYNReceived";
    StreamState2[StreamState2["Established"] = 3] = "Established";
    StreamState2[StreamState2["Finished"] = 4] = "Finished";
  })(StreamState || (StreamState = {}));
  var YamuxStream = class extends AbstractStream {
    name;
    state;
    config;
    _id;
    /** The number of available bytes to send */
    sendWindowCapacity;
    /** Callback to notify that the sendWindowCapacity has been updated */
    sendWindowCapacityUpdate;
    /** The number of bytes available to receive in a full window */
    recvWindow;
    /** The number of available bytes to receive */
    recvWindowCapacity;
    /**
     * An 'epoch' is the time it takes to process and read data
     *
     * Used in conjunction with RTT to determine whether to increase the recvWindow
     */
    epochStart;
    getRTT;
    sendFrame;
    constructor(init) {
      super({
        ...init,
        onEnd: (err) => {
          var _a2;
          this.state = StreamState.Finished;
          (_a2 = init.onEnd) == null ? void 0 : _a2.call(init, err);
        }
      });
      this.config = init.config;
      this._id = parseInt(init.id, 10);
      this.name = init.name;
      this.state = init.state;
      this.sendWindowCapacity = INITIAL_STREAM_WINDOW;
      this.recvWindow = this.config.initialStreamWindowSize;
      this.recvWindowCapacity = this.recvWindow;
      this.epochStart = Date.now();
      this.getRTT = init.getRTT;
      this.sendFrame = init.sendFrame;
      this.source = src_default9(this.source, () => {
        this.sendWindowUpdate();
      });
    }
    /**
     * Send a message to the remote muxer informing them a new stream is being
     * opened.
     *
     * This is a noop for Yamux because the first window update is sent when
     * .newStream is called on the muxer which opens the stream on the remote.
     */
    async sendNewStream() {
    }
    /**
     * Send a data message to the remote muxer
     */
    async sendData(buf, options = {}) {
      var _a2, _b2;
      buf = buf.sublist();
      while (buf.byteLength !== 0) {
        if (this.sendWindowCapacity === 0) {
          (_a2 = this.log) == null ? void 0 : _a2.trace("wait for send window capacity, status %s", this.status);
          await this.waitForSendWindowCapacity(options);
          if (this.status === "closed" || this.status === "aborted" || this.status === "reset") {
            (_b2 = this.log) == null ? void 0 : _b2.trace("%s while waiting for send window capacity", this.status);
            return;
          }
        }
        const toSend = Math.min(this.sendWindowCapacity, this.config.maxMessageSize - HEADER_LENGTH, buf.length);
        const flags = this.getSendFlags();
        this.sendFrame({
          type: FrameType.Data,
          flag: flags,
          streamID: this._id,
          length: toSend
        }, buf.sublist(0, toSend));
        this.sendWindowCapacity -= toSend;
        buf.consume(toSend);
      }
    }
    /**
     * Send a reset message to the remote muxer
     */
    async sendReset() {
      this.sendFrame({
        type: FrameType.WindowUpdate,
        flag: Flag.RST,
        streamID: this._id,
        length: 0
      });
    }
    /**
     * Send a message to the remote muxer, informing them no more data messages
     * will be sent by this end of the stream
     */
    async sendCloseWrite() {
      const flags = this.getSendFlags() | Flag.FIN;
      this.sendFrame({
        type: FrameType.WindowUpdate,
        flag: flags,
        streamID: this._id,
        length: 0
      });
    }
    /**
     * Send a message to the remote muxer, informing them no more data messages
     * will be read by this end of the stream
     */
    async sendCloseRead() {
    }
    /**
     * Wait for the send window to be non-zero
     *
     * Will throw with ERR_STREAM_ABORT if the stream gets aborted
     */
    async waitForSendWindowCapacity(options = {}) {
      var _a2, _b2;
      if (this.sendWindowCapacity > 0) {
        return;
      }
      let resolve;
      let reject;
      const abort = () => {
        if (this.status === "open" || this.status === "closing") {
          reject(new AbortError("Stream aborted"));
        } else {
          resolve();
        }
      };
      (_a2 = options.signal) == null ? void 0 : _a2.addEventListener("abort", abort);
      try {
        await new Promise((_resolve, _reject) => {
          this.sendWindowCapacityUpdate = () => {
            _resolve();
          };
          reject = _reject;
          resolve = _resolve;
        });
      } finally {
        (_b2 = options.signal) == null ? void 0 : _b2.removeEventListener("abort", abort);
      }
    }
    /**
     * handleWindowUpdate is called when the stream receives a window update frame
     */
    handleWindowUpdate(header) {
      var _a2, _b2;
      (_a2 = this.log) == null ? void 0 : _a2.trace("stream received window update id=%s", this._id);
      this.processFlags(header.flag);
      const available = this.sendWindowCapacity;
      this.sendWindowCapacity += header.length;
      if (available === 0 && header.length > 0) {
        (_b2 = this.sendWindowCapacityUpdate) == null ? void 0 : _b2.call(this);
      }
    }
    /**
     * handleData is called when the stream receives a data frame
     */
    async handleData(header, readData) {
      var _a2;
      (_a2 = this.log) == null ? void 0 : _a2.trace("stream received data id=%s", this._id);
      this.processFlags(header.flag);
      if (this.recvWindowCapacity < header.length) {
        throw new ReceiveWindowExceededError("Receive window exceeded");
      }
      const data = await readData();
      this.recvWindowCapacity -= header.length;
      this.sourcePush(data);
    }
    /**
     * processFlags is used to update the state of the stream based on set flags, if any.
     */
    processFlags(flags) {
      if ((flags & Flag.ACK) === Flag.ACK) {
        if (this.state === StreamState.SYNSent) {
          this.state = StreamState.Established;
        }
      }
      if ((flags & Flag.FIN) === Flag.FIN) {
        this.remoteCloseWrite();
      }
      if ((flags & Flag.RST) === Flag.RST) {
        this.reset();
      }
    }
    /**
     * getSendFlags determines any flags that are appropriate
     * based on the current stream state.
     *
     * The state is updated as a side-effect.
     */
    getSendFlags() {
      switch (this.state) {
        case StreamState.Init:
          this.state = StreamState.SYNSent;
          return Flag.SYN;
        case StreamState.SYNReceived:
          this.state = StreamState.Established;
          return Flag.ACK;
        default:
          return 0;
      }
    }
    /**
     * potentially sends a window update enabling further writes to take place.
     */
    sendWindowUpdate() {
      const flags = this.getSendFlags();
      const now = Date.now();
      const rtt = this.getRTT();
      if (flags === 0 && rtt > -1 && now - this.epochStart < rtt * 4) {
        this.recvWindow = Math.min(this.recvWindow * 2, this.config.maxStreamWindowSize);
      }
      if (this.recvWindowCapacity >= this.recvWindow && flags === 0) {
        return;
      }
      const delta = this.recvWindow - this.recvWindowCapacity;
      this.recvWindowCapacity = this.recvWindow;
      this.epochStart = now;
      this.sendFrame({
        type: FrameType.WindowUpdate,
        flag: flags,
        streamID: this._id,
        length: delta
      });
    }
  };

  // node_modules/@chainsafe/libp2p-yamux/dist/src/muxer.js
  var YAMUX_PROTOCOL_ID = "/yamux/1.0.0";
  var CLOSE_TIMEOUT2 = 500;
  var Yamux = class {
    protocol = YAMUX_PROTOCOL_ID;
    _components;
    _init;
    constructor(components, init = {}) {
      this._components = components;
      this._init = init;
    }
    [Symbol.toStringTag] = "@chainsafe/libp2p-yamux";
    [serviceCapabilities] = [
      "@libp2p/stream-multiplexing"
    ];
    createStreamMuxer(init) {
      return new YamuxMuxer(this._components, {
        ...this._init,
        ...init
      });
    }
  };
  var YamuxMuxer = class {
    protocol = YAMUX_PROTOCOL_ID;
    source;
    sink;
    config;
    log;
    logger;
    /** Used to close the muxer from either the sink or source */
    closeController;
    /** The next stream id to be used when initiating a new stream */
    nextStreamID;
    /** Primary stream mapping, streamID => stream */
    _streams;
    /** The next ping id to be used when pinging */
    nextPingID;
    /** Tracking info for the currently active ping */
    activePing;
    /** Round trip time */
    rtt;
    /** True if client, false if server */
    client;
    localGoAway;
    remoteGoAway;
    /** Number of tracked inbound streams */
    numInboundStreams;
    /** Number of tracked outbound streams */
    numOutboundStreams;
    onIncomingStream;
    onStreamEnd;
    constructor(components, init) {
      var _a2;
      this.client = init.direction === "outbound";
      this.config = { ...defaultConfig, ...init };
      this.logger = components.logger;
      this.log = this.logger.forComponent("libp2p:yamux");
      verifyConfig(this.config);
      this.closeController = new AbortController();
      setMaxListeners(Infinity, this.closeController.signal);
      this.onIncomingStream = init.onIncomingStream;
      this.onStreamEnd = init.onStreamEnd;
      this._streams = /* @__PURE__ */ new Map();
      this.source = pushable({
        onEnd: () => {
          var _a3;
          (_a3 = this.log) == null ? void 0 : _a3.trace("muxer source ended");
          this._streams.forEach((stream) => {
            stream.destroy();
          });
        }
      });
      this.sink = async (source) => {
        var _a3, _b2, _c;
        const shutDownListener = () => {
          const iterator = getIterator(source);
          if (iterator.return != null) {
            const res = iterator.return();
            if (isPromise5(res)) {
              res.catch((err) => {
                var _a4;
                (_a4 = this.log) == null ? void 0 : _a4.call(this, "could not cause sink source to return", err);
              });
            }
          }
        };
        let reason, error;
        try {
          const decoder = new Decoder2(source);
          try {
            this.closeController.signal.addEventListener("abort", shutDownListener);
            for await (const frame of decoder.emitFrames()) {
              await this.handleFrame(frame.header, frame.readData);
            }
          } finally {
            this.closeController.signal.removeEventListener("abort", shutDownListener);
          }
          reason = GoAwayCode.NormalTermination;
        } catch (err) {
          if (PROTOCOL_ERRORS.has(err.name)) {
            (_a3 = this.log) == null ? void 0 : _a3.error("protocol error in sink", err);
            reason = GoAwayCode.ProtocolError;
          } else {
            (_b2 = this.log) == null ? void 0 : _b2.error("internal error in sink", err);
            reason = GoAwayCode.InternalError;
          }
          error = err;
        }
        (_c = this.log) == null ? void 0 : _c.trace("muxer sink ended");
        if (error != null) {
          this.abort(error, reason);
        } else {
          await this.close({ reason });
        }
      };
      this.numInboundStreams = 0;
      this.numOutboundStreams = 0;
      this.nextStreamID = this.client ? 1 : 2;
      this.nextPingID = 0;
      this.rtt = -1;
      (_a2 = this.log) == null ? void 0 : _a2.trace("muxer created");
      if (this.config.enableKeepAlive) {
        this.keepAliveLoop().catch((e) => {
          var _a3;
          return (_a3 = this.log) == null ? void 0 : _a3.error("keepalive error: %s", e);
        });
      }
      this.ping().catch((e) => {
        var _a3;
        return (_a3 = this.log) == null ? void 0 : _a3.error("ping error: %s", e);
      });
    }
    get streams() {
      return Array.from(this._streams.values());
    }
    newStream(name3) {
      var _a2;
      if (this.remoteGoAway !== void 0) {
        throw new MuxerClosedError("Muxer closed remotely");
      }
      if (this.localGoAway !== void 0) {
        throw new MuxerClosedError("Muxer closed locally");
      }
      const id = this.nextStreamID;
      this.nextStreamID += 2;
      if (this.numOutboundStreams >= this.config.maxOutboundStreams) {
        throw new TooManyOutboundProtocolStreamsError("max outbound streams exceeded");
      }
      (_a2 = this.log) == null ? void 0 : _a2.trace("new outgoing stream id=%s", id);
      const stream = this._newStream(id, name3, StreamState.Init, "outbound");
      this._streams.set(id, stream);
      this.numOutboundStreams++;
      stream.sendWindowUpdate();
      return stream;
    }
    /**
     * Initiate a ping and wait for a response
     *
     * Note: only a single ping will be initiated at a time.
     * If a ping is already in progress, a new ping will not be initiated.
     *
     * @returns the round-trip-time in milliseconds
     */
    async ping() {
      if (this.remoteGoAway !== void 0) {
        throw new MuxerClosedError("Muxer closed remotely");
      }
      if (this.localGoAway !== void 0) {
        throw new MuxerClosedError("Muxer closed locally");
      }
      if (this.activePing === void 0) {
        let _resolve = () => {
        };
        this.activePing = {
          id: this.nextPingID++,
          // this promise awaits resolution or the close controller aborting
          promise: new Promise((resolve, reject) => {
            const closed = () => {
              reject(new MuxerClosedError("Muxer closed locally"));
            };
            this.closeController.signal.addEventListener("abort", closed, { once: true });
            _resolve = () => {
              this.closeController.signal.removeEventListener("abort", closed);
              resolve();
            };
          }),
          resolve: _resolve
        };
        const start2 = Date.now();
        this.sendPing(this.activePing.id);
        try {
          await this.activePing.promise;
        } finally {
          delete this.activePing;
        }
        const end = Date.now();
        this.rtt = end - start2;
      } else {
        await this.activePing.promise;
      }
      return this.rtt;
    }
    /**
     * Get the ping round trip time
     *
     * Note: Will return 0 if no successful ping has yet been completed
     *
     * @returns the round-trip-time in milliseconds
     */
    getRTT() {
      return this.rtt;
    }
    /**
     * Close the muxer
     */
    async close(options = {}) {
      var _a2;
      if (this.closeController.signal.aborted) {
        return;
      }
      const reason = (options == null ? void 0 : options.reason) ?? GoAwayCode.NormalTermination;
      (_a2 = this.log) == null ? void 0 : _a2.trace("muxer close reason=%s", reason);
      if (options.signal == null) {
        const signal = AbortSignal.timeout(CLOSE_TIMEOUT2);
        setMaxListeners(Infinity, signal);
        options = {
          ...options,
          signal
        };
      }
      try {
        await Promise.all([...this._streams.values()].map(async (s2) => s2.close(options)));
        this.sendGoAway(reason);
        this._closeMuxer();
      } catch (err) {
        this.abort(err);
      }
    }
    abort(err, reason) {
      var _a2;
      if (this.closeController.signal.aborted) {
        return;
      }
      reason = reason ?? GoAwayCode.InternalError;
      (_a2 = this.log) == null ? void 0 : _a2.error("muxer abort reason=%s error=%s", reason, err);
      for (const stream of this._streams.values()) {
        stream.abort(err);
      }
      this.sendGoAway(reason);
      this._closeMuxer();
    }
    isClosed() {
      return this.closeController.signal.aborted;
    }
    /**
     * Called when either the local or remote shuts down the muxer
     */
    _closeMuxer() {
      this.closeController.abort();
      this.source.end();
    }
    /** Create a new stream */
    _newStream(id, name3, state, direction) {
      if (this._streams.get(id) != null) {
        throw new InvalidParametersError("Stream already exists with that id");
      }
      const stream = new YamuxStream({
        id: id.toString(),
        name: name3,
        state,
        direction,
        sendFrame: this.sendFrame.bind(this),
        onEnd: () => {
          var _a2;
          this.closeStream(id);
          (_a2 = this.onStreamEnd) == null ? void 0 : _a2.call(this, stream);
        },
        log: this.logger.forComponent(`libp2p:yamux:${direction}:${id}`),
        config: this.config,
        getRTT: this.getRTT.bind(this)
      });
      return stream;
    }
    /**
     * closeStream is used to close a stream once both sides have
     * issued a close.
     */
    closeStream(id) {
      if (this.client === (id % 2 === 0)) {
        this.numInboundStreams--;
      } else {
        this.numOutboundStreams--;
      }
      this._streams.delete(id);
    }
    async keepAliveLoop() {
      var _a2;
      const abortPromise = new Promise((_resolve, reject) => {
        this.closeController.signal.addEventListener("abort", reject, { once: true });
      });
      (_a2 = this.log) == null ? void 0 : _a2.trace("muxer keepalive enabled interval=%s", this.config.keepAliveInterval);
      while (true) {
        let timeoutId;
        try {
          await Promise.race([
            abortPromise,
            new Promise((resolve) => {
              timeoutId = setTimeout(resolve, this.config.keepAliveInterval);
            })
          ]);
          this.ping().catch((e) => {
            var _a3;
            return (_a3 = this.log) == null ? void 0 : _a3.error("ping error: %s", e);
          });
        } catch (e) {
          clearInterval(timeoutId);
          return;
        }
      }
    }
    async handleFrame(header, readData) {
      var _a2;
      const { streamID, type, length: length4 } = header;
      (_a2 = this.log) == null ? void 0 : _a2.trace("received frame %o", header);
      if (streamID === 0) {
        switch (type) {
          case FrameType.Ping: {
            this.handlePing(header);
            return;
          }
          case FrameType.GoAway: {
            this.handleGoAway(length4);
            return;
          }
          default:
            throw new InvalidFrameError("Invalid frame type");
        }
      } else {
        switch (header.type) {
          case FrameType.Data:
          case FrameType.WindowUpdate: {
            await this.handleStreamMessage(header, readData);
            return;
          }
          default:
            throw new InvalidFrameError("Invalid frame type");
        }
      }
    }
    handlePing(header) {
      var _a2, _b2;
      if (header.flag === Flag.SYN) {
        (_a2 = this.log) == null ? void 0 : _a2.trace("received ping request pingId=%s", header.length);
        this.sendPing(header.length, Flag.ACK);
      } else if (header.flag === Flag.ACK) {
        (_b2 = this.log) == null ? void 0 : _b2.trace("received ping response pingId=%s", header.length);
        this.handlePingResponse(header.length);
      } else {
        throw new InvalidFrameError("Invalid frame flag");
      }
    }
    handlePingResponse(pingId) {
      if (this.activePing === void 0) {
        throw new UnrequestedPingError("ping not requested");
      }
      if (this.activePing.id !== pingId) {
        throw new NotMatchingPingError("ping doesn't match our id");
      }
      this.activePing.resolve();
    }
    handleGoAway(reason) {
      var _a2;
      (_a2 = this.log) == null ? void 0 : _a2.trace("received GoAway reason=%s", GoAwayCode[reason] ?? "unknown");
      this.remoteGoAway = reason;
      for (const stream of this._streams.values()) {
        stream.reset();
      }
      this._closeMuxer();
    }
    async handleStreamMessage(header, readData) {
      var _a2, _b2;
      const { streamID, flag, type } = header;
      if ((flag & Flag.SYN) === Flag.SYN) {
        this.incomingStream(streamID);
      }
      const stream = this._streams.get(streamID);
      if (stream === void 0) {
        if (type === FrameType.Data) {
          (_a2 = this.log) == null ? void 0 : _a2.call(this, "discarding data for stream id=%s", streamID);
          if (readData === void 0) {
            throw new Error("unreachable");
          }
          await readData();
        } else {
          (_b2 = this.log) == null ? void 0 : _b2.trace("frame for missing stream id=%s", streamID);
        }
        return;
      }
      switch (type) {
        case FrameType.WindowUpdate: {
          stream.handleWindowUpdate(header);
          return;
        }
        case FrameType.Data: {
          if (readData === void 0) {
            throw new Error("unreachable");
          }
          await stream.handleData(header, readData);
          return;
        }
        default:
          throw new Error("unreachable");
      }
    }
    incomingStream(id) {
      var _a2, _b2, _c;
      if (this.client !== (id % 2 === 0)) {
        throw new InvalidParametersError("Both endpoints are clients");
      }
      if (this._streams.has(id)) {
        return;
      }
      (_a2 = this.log) == null ? void 0 : _a2.trace("new incoming stream id=%s", id);
      if (this.localGoAway !== void 0) {
        this.sendFrame({
          type: FrameType.WindowUpdate,
          flag: Flag.RST,
          streamID: id,
          length: 0
        });
        return;
      }
      if (this.numInboundStreams >= this.config.maxInboundStreams) {
        (_b2 = this.log) == null ? void 0 : _b2.call(this, "maxIncomingStreams exceeded, forcing stream reset");
        this.sendFrame({
          type: FrameType.WindowUpdate,
          flag: Flag.RST,
          streamID: id,
          length: 0
        });
        return;
      }
      const stream = this._newStream(id, void 0, StreamState.SYNReceived, "inbound");
      this.numInboundStreams++;
      this._streams.set(id, stream);
      (_c = this.onIncomingStream) == null ? void 0 : _c.call(this, stream);
    }
    sendFrame(header, data) {
      var _a2;
      (_a2 = this.log) == null ? void 0 : _a2.trace("sending frame %o", header);
      if (header.type === FrameType.Data) {
        if (data === void 0) {
          throw new InvalidFrameError("Invalid frame");
        }
        this.source.push(new Uint8ArrayList(encodeHeader(header), data));
      } else {
        this.source.push(encodeHeader(header));
      }
    }
    sendPing(pingId, flag = Flag.SYN) {
      var _a2, _b2;
      if (flag === Flag.SYN) {
        (_a2 = this.log) == null ? void 0 : _a2.trace("sending ping request pingId=%s", pingId);
      } else {
        (_b2 = this.log) == null ? void 0 : _b2.trace("sending ping response pingId=%s", pingId);
      }
      this.sendFrame({
        type: FrameType.Ping,
        flag,
        streamID: 0,
        length: pingId
      });
    }
    sendGoAway(reason = GoAwayCode.NormalTermination) {
      var _a2;
      (_a2 = this.log) == null ? void 0 : _a2.call(this, "sending GoAway reason=%s", GoAwayCode[reason]);
      this.localGoAway = reason;
      this.sendFrame({
        type: FrameType.GoAway,
        flag: 0,
        streamID: 0,
        length: reason
      });
    }
  };
  function isPromise5(thing) {
    return thing != null && typeof thing.then === "function";
  }

  // node_modules/@chainsafe/libp2p-yamux/dist/src/index.js
  function yamux(init = {}) {
    return (components) => new Yamux(components, init);
  }

  // node_modules/@libp2p/identify/dist/src/index.js
  var import_browser_shims357 = __toESM(require_browser_shims(), 1);

  // node_modules/it-protobuf-stream/dist/src/index.js
  var import_browser_shims351 = __toESM(require_browser_shims(), 1);
  function pbStream(duplex, opts) {
    const lp = lpStream(duplex, opts);
    const W = {
      read: async (proto, options) => {
        const value = await lp.read(options);
        return proto.decode(value);
      },
      write: async (message2, proto, options) => {
        await lp.write(proto.encode(message2), options);
      },
      writeV: async (messages2, proto, options) => {
        await lp.writeV(messages2.map((message2) => proto.encode(message2)), options);
      },
      pb: (proto) => {
        return {
          read: async (options) => W.read(proto, options),
          write: async (d2, options) => W.write(d2, proto, options),
          writeV: async (d2, options) => W.writeV(d2, proto, options),
          unwrap: () => W
        };
      },
      unwrap: () => {
        return lp.unwrap();
      }
    };
    return W;
  }

  // node_modules/@libp2p/identify/dist/src/consts.js
  var import_browser_shims352 = __toESM(require_browser_shims(), 1);
  var IDENTIFY_PROTOCOL_VERSION = "0.1.0";
  var MULTICODEC_IDENTIFY_PROTOCOL_NAME = "id";
  var MULTICODEC_IDENTIFY_PROTOCOL_VERSION = "1.0.0";
  var MAX_IDENTIFY_MESSAGE_SIZE = 1024 * 8;
  var MAX_PUSH_CONCURRENCY = 32;

  // node_modules/@libp2p/identify/dist/src/pb/message.js
  var import_browser_shims353 = __toESM(require_browser_shims(), 1);
  var Identify;
  (function(Identify3) {
    let _codec;
    Identify3.codec = () => {
      if (_codec == null) {
        _codec = message((obj, w2, opts = {}) => {
          if (opts.lengthDelimited !== false) {
            w2.fork();
          }
          if (obj.protocolVersion != null) {
            w2.uint32(42);
            w2.string(obj.protocolVersion);
          }
          if (obj.agentVersion != null) {
            w2.uint32(50);
            w2.string(obj.agentVersion);
          }
          if (obj.publicKey != null) {
            w2.uint32(10);
            w2.bytes(obj.publicKey);
          }
          if (obj.listenAddrs != null) {
            for (const value of obj.listenAddrs) {
              w2.uint32(18);
              w2.bytes(value);
            }
          }
          if (obj.observedAddr != null) {
            w2.uint32(34);
            w2.bytes(obj.observedAddr);
          }
          if (obj.protocols != null) {
            for (const value of obj.protocols) {
              w2.uint32(26);
              w2.string(value);
            }
          }
          if (obj.signedPeerRecord != null) {
            w2.uint32(66);
            w2.bytes(obj.signedPeerRecord);
          }
          if (opts.lengthDelimited !== false) {
            w2.ldelim();
          }
        }, (reader, length4, opts = {}) => {
          var _a2, _b2;
          const obj = {
            listenAddrs: [],
            protocols: []
          };
          const end = length4 == null ? reader.len : reader.pos + length4;
          while (reader.pos < end) {
            const tag = reader.uint32();
            switch (tag >>> 3) {
              case 5: {
                obj.protocolVersion = reader.string();
                break;
              }
              case 6: {
                obj.agentVersion = reader.string();
                break;
              }
              case 1: {
                obj.publicKey = reader.bytes();
                break;
              }
              case 2: {
                if (((_a2 = opts.limits) == null ? void 0 : _a2.listenAddrs) != null && obj.listenAddrs.length === opts.limits.listenAddrs) {
                  throw new MaxLengthError('Decode error - map field "listenAddrs" had too many elements');
                }
                obj.listenAddrs.push(reader.bytes());
                break;
              }
              case 4: {
                obj.observedAddr = reader.bytes();
                break;
              }
              case 3: {
                if (((_b2 = opts.limits) == null ? void 0 : _b2.protocols) != null && obj.protocols.length === opts.limits.protocols) {
                  throw new MaxLengthError('Decode error - map field "protocols" had too many elements');
                }
                obj.protocols.push(reader.string());
                break;
              }
              case 8: {
                obj.signedPeerRecord = reader.bytes();
                break;
              }
              default: {
                reader.skipType(tag & 7);
                break;
              }
            }
          }
          return obj;
        });
      }
      return _codec;
    };
    Identify3.encode = (obj) => {
      return encodeMessage(obj, Identify3.codec());
    };
    Identify3.decode = (buf, opts) => {
      return decodeMessage(buf, Identify3.codec(), opts);
    };
  })(Identify || (Identify = {}));

  // node_modules/@libp2p/identify/dist/src/utils.js
  var import_browser_shims354 = __toESM(require_browser_shims(), 1);
  var defaultValues4 = {
    protocolPrefix: "ipfs",
    timeout: 5e3,
    maxInboundStreams: 1,
    maxOutboundStreams: 1,
    maxObservedAddresses: 10,
    maxMessageSize: MAX_IDENTIFY_MESSAGE_SIZE,
    runOnConnectionOpen: true,
    runOnSelfUpdate: true,
    runOnLimitedConnection: true,
    concurrency: MAX_PUSH_CONCURRENCY
  };
  function getCleanMultiaddr(addr) {
    if (addr != null && addr.length > 0) {
      try {
        return multiaddr(addr);
      } catch {
      }
    }
  }
  function getAgentVersion(nodeInfo, agentVersion) {
    if (agentVersion != null) {
      return agentVersion;
    }
    return nodeInfo.userAgent;
  }
  async function consumeIdentifyMessage(peerStore, events, log2, connection, message2) {
    log2("received identify from %p", connection.remotePeer);
    if (message2 == null) {
      throw new InvalidMessageError("message was null or undefined");
    }
    const peer = {};
    if (message2.listenAddrs.length > 0) {
      peer.addresses = message2.listenAddrs.map((buf) => ({
        isCertified: false,
        multiaddr: multiaddr(buf)
      }));
    }
    if (message2.protocols.length > 0) {
      peer.protocols = message2.protocols;
    }
    if (message2.publicKey != null) {
      const publicKey = publicKeyFromProtobuf(message2.publicKey);
      const peerId2 = peerIdFromPublicKey(publicKey);
      if (!peerId2.equals(connection.remotePeer)) {
        throw new InvalidMessageError("public key did not match remote PeerId");
      }
      peer.publicKey = publicKey;
    }
    let output;
    if (message2.signedPeerRecord != null) {
      log2.trace("received signedPeerRecord from %p", connection.remotePeer);
      let peerRecordEnvelope2 = message2.signedPeerRecord;
      const envelope = await RecordEnvelope.openAndCertify(peerRecordEnvelope2, PeerRecord2.DOMAIN);
      let peerRecord = PeerRecord2.createFromProtobuf(envelope.payload);
      const envelopePeer = peerIdFromCID(envelope.publicKey.toCID());
      if (!peerRecord.peerId.equals(envelopePeer)) {
        throw new InvalidMessageError("signing key does not match PeerId in the PeerRecord");
      }
      if (!connection.remotePeer.equals(peerRecord.peerId)) {
        throw new InvalidMessageError("signing key does not match remote PeerId");
      }
      let existingPeer;
      try {
        existingPeer = await peerStore.get(peerRecord.peerId);
      } catch (err) {
        if (err.name !== "NotFoundError") {
          throw err;
        }
      }
      if (existingPeer != null) {
        peer.metadata = existingPeer.metadata;
        if (existingPeer.peerRecordEnvelope != null) {
          const storedEnvelope = RecordEnvelope.createFromProtobuf(existingPeer.peerRecordEnvelope);
          const storedRecord = PeerRecord2.createFromProtobuf(storedEnvelope.payload);
          if (storedRecord.seqNumber >= peerRecord.seqNumber) {
            log2("sequence number was lower or equal to existing sequence number - stored: %d received: %d", storedRecord.seqNumber, peerRecord.seqNumber);
            peerRecord = storedRecord;
            peerRecordEnvelope2 = existingPeer.peerRecordEnvelope;
          }
        }
      }
      peer.peerRecordEnvelope = peerRecordEnvelope2;
      peer.addresses = peerRecord.multiaddrs.map((multiaddr2) => ({
        isCertified: true,
        multiaddr: multiaddr2
      }));
      output = {
        seq: peerRecord.seqNumber,
        addresses: peerRecord.multiaddrs
      };
    } else {
      log2("%p did not send a signed peer record", connection.remotePeer);
    }
    log2.trace("patching %p with", connection.remotePeer, peer);
    await peerStore.patch(connection.remotePeer, peer);
    if (message2.agentVersion != null || message2.protocolVersion != null) {
      const metadata = {};
      if (message2.agentVersion != null) {
        metadata.AgentVersion = fromString2(message2.agentVersion);
      }
      if (message2.protocolVersion != null) {
        metadata.ProtocolVersion = fromString2(message2.protocolVersion);
      }
      log2.trace("merging %p metadata", connection.remotePeer, metadata);
      await peerStore.merge(connection.remotePeer, {
        metadata
      });
    }
    const result = {
      peerId: connection.remotePeer,
      protocolVersion: message2.protocolVersion,
      agentVersion: message2.agentVersion,
      publicKey: message2.publicKey,
      listenAddrs: message2.listenAddrs.map((buf) => multiaddr(buf)),
      observedAddr: message2.observedAddr == null ? void 0 : multiaddr(message2.observedAddr),
      protocols: message2.protocols,
      signedPeerRecord: output,
      connection
    };
    events.safeDispatchEvent("peer:identify", { detail: result });
    return result;
  }
  var AbstractIdentify = class {
    host;
    protocol;
    started;
    timeout;
    peerId;
    privateKey;
    peerStore;
    registrar;
    addressManager;
    maxInboundStreams;
    maxOutboundStreams;
    maxMessageSize;
    maxObservedAddresses;
    events;
    runOnLimitedConnection;
    log;
    constructor(components, init) {
      this.protocol = init.protocol;
      this.started = false;
      this.peerId = components.peerId;
      this.privateKey = components.privateKey;
      this.peerStore = components.peerStore;
      this.registrar = components.registrar;
      this.addressManager = components.addressManager;
      this.events = components.events;
      this.log = init.log;
      this.timeout = init.timeout ?? defaultValues4.timeout;
      this.maxInboundStreams = init.maxInboundStreams ?? defaultValues4.maxInboundStreams;
      this.maxOutboundStreams = init.maxOutboundStreams ?? defaultValues4.maxOutboundStreams;
      this.maxMessageSize = init.maxMessageSize ?? defaultValues4.maxMessageSize;
      this.maxObservedAddresses = init.maxObservedAddresses ?? defaultValues4.maxObservedAddresses;
      this.runOnLimitedConnection = init.runOnLimitedConnection ?? defaultValues4.runOnLimitedConnection;
      this.host = {
        protocolVersion: `${init.protocolPrefix ?? defaultValues4.protocolPrefix}/${IDENTIFY_PROTOCOL_VERSION}`,
        agentVersion: getAgentVersion(components.nodeInfo, init.agentVersion)
      };
    }
    isStarted() {
      return this.started;
    }
    async start() {
      if (this.started) {
        return;
      }
      await this.peerStore.merge(this.peerId, {
        metadata: {
          AgentVersion: fromString2(this.host.agentVersion),
          ProtocolVersion: fromString2(this.host.protocolVersion)
        }
      });
      await this.registrar.handle(this.protocol, (data) => {
        void this.handleProtocol(data).catch((err) => {
          this.log.error(err);
        });
      }, {
        maxInboundStreams: this.maxInboundStreams,
        maxOutboundStreams: this.maxOutboundStreams,
        runOnLimitedConnection: this.runOnLimitedConnection
      });
      this.started = true;
    }
    async stop() {
      await this.registrar.unhandle(this.protocol);
      this.started = false;
    }
  };

  // node_modules/@libp2p/identify/dist/src/identify.js
  var import_browser_shims356 = __toESM(require_browser_shims(), 1);

  // node_modules/@libp2p/utils/dist/src/multiaddr/is-global-unicast.js
  var import_browser_shims355 = __toESM(require_browser_shims(), 1);
  var CODEC_IP66 = 41;
  function isGlobalUnicast(ma) {
    try {
      const [[codec, value]] = ma.stringTuples();
      if (value == null) {
        return false;
      }
      if (codec === CODEC_IP66) {
        return cidrContains("2000::/3", value);
      }
    } catch {
    }
    return false;
  }

  // node_modules/@libp2p/identify/dist/src/identify.js
  var CODEC_IP67 = 41;
  var Identify2 = class extends AbstractIdentify {
    constructor(components, init = {}) {
      super(components, {
        ...init,
        protocol: `/${init.protocolPrefix ?? defaultValues4.protocolPrefix}/${MULTICODEC_IDENTIFY_PROTOCOL_NAME}/${MULTICODEC_IDENTIFY_PROTOCOL_VERSION}`,
        log: components.logger.forComponent("libp2p:identify")
      });
      if (init.runOnConnectionOpen ?? defaultValues4.runOnConnectionOpen) {
        components.events.addEventListener("connection:open", (evt) => {
          const connection = evt.detail;
          this.identify(connection).catch((err) => {
            if (err.name === UnsupportedProtocolError.name) {
              return;
            }
            this.log.error("error during identify trigged by connection:open", err);
          });
        });
      }
    }
    [serviceCapabilities] = [
      "@libp2p/identify"
    ];
    async _identify(connection, options = {}) {
      let stream;
      if (options.signal == null) {
        const signal = AbortSignal.timeout(this.timeout);
        setMaxListeners(Infinity, signal);
        options = {
          ...options,
          signal
        };
      }
      try {
        stream = await connection.newStream(this.protocol, {
          ...options,
          runOnLimitedConnection: this.runOnLimitedConnection
        });
        const pb = pbStream(stream, {
          maxDataLength: this.maxMessageSize
        }).pb(Identify);
        const message2 = await pb.read(options);
        await stream.close(options);
        return message2;
      } catch (err) {
        stream == null ? void 0 : stream.abort(err);
        throw err;
      }
    }
    async identify(connection, options = {}) {
      const message2 = await this._identify(connection, options);
      const { publicKey, protocols, observedAddr } = message2;
      if (publicKey == null) {
        throw new InvalidMessageError("public key was missing from identify message");
      }
      const key = publicKeyFromProtobuf(publicKey);
      const id = peerIdFromCID(key.toCID());
      if (!connection.remotePeer.equals(id)) {
        throw new InvalidMessageError("identified peer does not match the expected peer");
      }
      if (this.peerId.equals(id)) {
        throw new InvalidMessageError("identified peer is our own peer id?");
      }
      this.maybeAddObservedAddress(observedAddr);
      this.log("identify completed for peer %p and protocols %o", id, protocols);
      return consumeIdentifyMessage(this.peerStore, this.events, this.log, connection, message2);
    }
    maybeAddObservedAddress(observedAddr) {
      const cleanObservedAddr = getCleanMultiaddr(observedAddr);
      if (cleanObservedAddr == null) {
        return;
      }
      this.log.trace("our observed address was %a", cleanObservedAddr);
      if (isPrivate(cleanObservedAddr)) {
        this.log.trace("our observed address was private");
        return;
      }
      const tuples = cleanObservedAddr.stringTuples();
      if (tuples[0][0] === CODEC_IP67 && !isGlobalUnicast(cleanObservedAddr)) {
        this.log.trace("our observed address was IPv6 but not a global unicast address");
        return;
      }
      if (TCP.exactMatch(cleanObservedAddr)) {
        return;
      }
      this.log.trace("storing the observed address");
      this.addressManager.addObservedAddr(cleanObservedAddr);
    }
    /**
     * Sends the `Identify` response with the Signed Peer Record
     * to the requesting peer over the given `connection`
     */
    async handleProtocol(data) {
      const { connection, stream } = data;
      const signal = AbortSignal.timeout(this.timeout);
      setMaxListeners(Infinity, signal);
      try {
        const peerData = await this.peerStore.get(this.peerId);
        const multiaddrs = this.addressManager.getAddresses().map((ma) => ma.decapsulateCode(getProtocol("p2p").code));
        let signedPeerRecord = peerData.peerRecordEnvelope;
        if (multiaddrs.length > 0 && signedPeerRecord == null) {
          const peerRecord = new PeerRecord2({
            peerId: this.peerId,
            multiaddrs
          });
          const envelope = await RecordEnvelope.seal(peerRecord, this.privateKey);
          signedPeerRecord = envelope.marshal().subarray();
        }
        let observedAddr = connection.remoteAddr.bytes;
        if (!IP_OR_DOMAIN.matches(connection.remoteAddr)) {
          observedAddr = void 0;
        }
        const pb = pbStream(stream).pb(Identify);
        await pb.write({
          protocolVersion: this.host.protocolVersion,
          agentVersion: this.host.agentVersion,
          publicKey: publicKeyToProtobuf(this.privateKey.publicKey),
          listenAddrs: multiaddrs.map((addr) => addr.bytes),
          signedPeerRecord,
          observedAddr,
          protocols: peerData.protocols
        }, {
          signal
        });
        await stream.close({
          signal
        });
      } catch (err) {
        this.log.error("could not respond to identify request", err);
        stream.abort(err);
      }
    }
  };

  // node_modules/@libp2p/identify/dist/src/index.js
  function identify(init = {}) {
    return (components) => new Identify2(components, init);
  }

  // node_modules/@libp2p/kad-dht/dist/src/index.js
  var import_browser_shims401 = __toESM(require_browser_shims(), 1);

  // node_modules/@libp2p/kad-dht/dist/src/kad-dht.js
  var import_browser_shims400 = __toESM(require_browser_shims(), 1);

  // node_modules/@libp2p/kad-dht/dist/src/constants.js
  var import_browser_shims358 = __toESM(require_browser_shims(), 1);
  var second2 = 1e3;
  var minute2 = 60 * second2;
  var hour = 60 * minute2;
  var MAX_RECORD_AGE = 36 * hour;
  var PROTOCOL = "/ipfs/kad/1.0.0";
  var RECORD_KEY_PREFIX = "/dht/record";
  var PROVIDER_KEY_PREFIX = "/dht/provider";
  var PROVIDERS_LRU_CACHE_SIZE = 256;
  var PROVIDERS_VALIDITY = 24 * hour;
  var PROVIDERS_CLEANUP_INTERVAL = hour;
  var READ_MESSAGE_TIMEOUT = 10 * second2;
  var K = 20;
  var ALPHA = 3;
  var QUERY_SELF_INTERVAL = 5 * minute2;
  var QUERY_SELF_INITIAL_INTERVAL = second2;
  var QUERY_SELF_TIMEOUT = 5 * second2;
  var TABLE_REFRESH_INTERVAL = 5 * minute2;
  var TABLE_REFRESH_QUERY_TIMEOUT = 30 * second2;
  var DEFAULT_QUERY_TIMEOUT = 180 * second2;

  // node_modules/@libp2p/kad-dht/dist/src/content-fetching/index.js
  var import_browser_shims369 = __toESM(require_browser_shims(), 1);

  // node_modules/@libp2p/record/dist/src/index.js
  var import_browser_shims361 = __toESM(require_browser_shims(), 1);

  // node_modules/@libp2p/record/dist/src/record.js
  var import_browser_shims359 = __toESM(require_browser_shims(), 1);
  var Record;
  (function(Record3) {
    let _codec;
    Record3.codec = () => {
      if (_codec == null) {
        _codec = message((obj, w2, opts = {}) => {
          if (opts.lengthDelimited !== false) {
            w2.fork();
          }
          if (obj.key != null && obj.key.byteLength > 0) {
            w2.uint32(10);
            w2.bytes(obj.key);
          }
          if (obj.value != null && obj.value.byteLength > 0) {
            w2.uint32(18);
            w2.bytes(obj.value);
          }
          if (obj.timeReceived != null && obj.timeReceived !== "") {
            w2.uint32(42);
            w2.string(obj.timeReceived);
          }
          if (opts.lengthDelimited !== false) {
            w2.ldelim();
          }
        }, (reader, length4, opts = {}) => {
          const obj = {
            key: alloc(0),
            value: alloc(0),
            timeReceived: ""
          };
          const end = length4 == null ? reader.len : reader.pos + length4;
          while (reader.pos < end) {
            const tag = reader.uint32();
            switch (tag >>> 3) {
              case 1: {
                obj.key = reader.bytes();
                break;
              }
              case 2: {
                obj.value = reader.bytes();
                break;
              }
              case 5: {
                obj.timeReceived = reader.string();
                break;
              }
              default: {
                reader.skipType(tag & 7);
                break;
              }
            }
          }
          return obj;
        });
      }
      return _codec;
    };
    Record3.encode = (obj) => {
      return encodeMessage(obj, Record3.codec());
    };
    Record3.decode = (buf, opts) => {
      return decodeMessage(buf, Record3.codec(), opts);
    };
  })(Record || (Record = {}));

  // node_modules/@libp2p/record/dist/src/utils.js
  var import_browser_shims360 = __toESM(require_browser_shims(), 1);
  function toRFC3339(time) {
    const year = time.getUTCFullYear();
    const month = String(time.getUTCMonth() + 1).padStart(2, "0");
    const day = String(time.getUTCDate()).padStart(2, "0");
    const hour2 = String(time.getUTCHours()).padStart(2, "0");
    const minute3 = String(time.getUTCMinutes()).padStart(2, "0");
    const seconds = String(time.getUTCSeconds()).padStart(2, "0");
    const milliseconds = time.getUTCMilliseconds();
    const nanoseconds = String(milliseconds * 1e3 * 1e3).padStart(9, "0");
    return `${year}-${month}-${day}T${hour2}:${minute3}:${seconds}.${nanoseconds}Z`;
  }
  function parseRFC3339(time) {
    const rfc3339Matcher = new RegExp(
      // 2006-01-02T
      "(\\d{4})-(\\d{2})-(\\d{2})T(\\d{2}):(\\d{2}):(\\d{2})\\.(\\d+)Z"
    );
    const m2 = String(time).trim().match(rfc3339Matcher);
    if (m2 == null) {
      throw new Error("Invalid format");
    }
    const year = parseInt(m2[1], 10);
    const month = parseInt(m2[2], 10) - 1;
    const date = parseInt(m2[3], 10);
    const hour2 = parseInt(m2[4], 10);
    const minute3 = parseInt(m2[5], 10);
    const second3 = parseInt(m2[6], 10);
    const millisecond = parseInt(m2[7].slice(0, -6), 10);
    return new Date(Date.UTC(year, month, date, hour2, minute3, second3, millisecond));
  }

  // node_modules/@libp2p/record/dist/src/index.js
  var Libp2pRecord = class _Libp2pRecord {
    key;
    value;
    timeReceived;
    constructor(key, value, timeReceived) {
      if (!(key instanceof Uint8Array)) {
        throw new Error("key must be a Uint8Array");
      }
      if (!(value instanceof Uint8Array)) {
        throw new Error("value must be a Uint8Array");
      }
      this.key = key;
      this.value = value;
      this.timeReceived = timeReceived;
    }
    serialize() {
      return Record.encode(this.prepareSerialize());
    }
    /**
     * Return the object format ready to be given to the protobuf library.
     */
    prepareSerialize() {
      return {
        key: this.key,
        value: this.value,
        timeReceived: toRFC3339(this.timeReceived)
      };
    }
    /**
     * Decode a protobuf encoded record
     */
    static deserialize(raw) {
      const rec = Record.decode(raw);
      return new _Libp2pRecord(rec.key, rec.value, new Date(rec.timeReceived));
    }
    /**
     * Create a record from the raw object returned from the protobuf library
     */
    static fromDeserialized(obj) {
      const receivedTime = parseRFC3339(obj.timeReceived);
      if (obj.key == null) {
        throw new Error("key missing from deserialized object");
      }
      if (obj.value == null) {
        throw new Error("value missing from deserialized object");
      }
      const rec = new _Libp2pRecord(obj.key, obj.value, receivedTime);
      return rec;
    }
  };

  // node_modules/it-map/dist/src/index.js
  var import_browser_shims362 = __toESM(require_browser_shims(), 1);
  function isAsyncIterable12(thing) {
    return thing[Symbol.asyncIterator] != null;
  }
  function map(source, func2) {
    let index = 0;
    if (isAsyncIterable12(source)) {
      return async function* () {
        for await (const val of source) {
          yield func2(val, index++);
        }
      }();
    }
    const peekable2 = src_default4(source);
    const { value, done } = peekable2.next();
    if (done === true) {
      return function* () {
      }();
    }
    const res = func2(value, index++);
    if (typeof res.then === "function") {
      return async function* () {
        yield await res;
        for (const val of peekable2) {
          yield func2(val, index++);
        }
      }();
    }
    const fn = func2;
    return function* () {
      yield res;
      for (const val of peekable2) {
        yield fn(val, index++);
      }
    }();
  }
  var src_default10 = map;

  // node_modules/@libp2p/kad-dht/dist/src/errors.js
  var import_browser_shims363 = __toESM(require_browser_shims(), 1);
  var QueryError = class extends Error {
    constructor(message2 = "Query error") {
      super(message2);
      this.name = "QueryError";
    }
  };
  var QueryAbortedError = class extends Error {
    constructor(message2 = "Query aborted") {
      super(message2);
      this.name = "QueryAbortedError";
    }
  };
  var InvalidRecordError = class extends Error {
    constructor(message2 = "Invalid record") {
      super(message2);
      this.name = "InvalidRecordError";
    }
  };
  var MissingSelectorError = class extends Error {
    constructor(message2 = "No selector function configured for prefix") {
      super(message2);
      this.name = "MissingSelectorError";
    }
  };

  // node_modules/@libp2p/kad-dht/dist/src/message/dht.js
  var import_browser_shims364 = __toESM(require_browser_shims(), 1);
  var Record2;
  (function(Record3) {
    let _codec;
    Record3.codec = () => {
      if (_codec == null) {
        _codec = message((obj, w2, opts = {}) => {
          if (opts.lengthDelimited !== false) {
            w2.fork();
          }
          if (obj.key != null) {
            w2.uint32(10);
            w2.bytes(obj.key);
          }
          if (obj.value != null) {
            w2.uint32(18);
            w2.bytes(obj.value);
          }
          if (obj.author != null) {
            w2.uint32(26);
            w2.bytes(obj.author);
          }
          if (obj.signature != null) {
            w2.uint32(34);
            w2.bytes(obj.signature);
          }
          if (obj.timeReceived != null) {
            w2.uint32(42);
            w2.string(obj.timeReceived);
          }
          if (opts.lengthDelimited !== false) {
            w2.ldelim();
          }
        }, (reader, length4, opts = {}) => {
          const obj = {};
          const end = length4 == null ? reader.len : reader.pos + length4;
          while (reader.pos < end) {
            const tag = reader.uint32();
            switch (tag >>> 3) {
              case 1: {
                obj.key = reader.bytes();
                break;
              }
              case 2: {
                obj.value = reader.bytes();
                break;
              }
              case 3: {
                obj.author = reader.bytes();
                break;
              }
              case 4: {
                obj.signature = reader.bytes();
                break;
              }
              case 5: {
                obj.timeReceived = reader.string();
                break;
              }
              default: {
                reader.skipType(tag & 7);
                break;
              }
            }
          }
          return obj;
        });
      }
      return _codec;
    };
    Record3.encode = (obj) => {
      return encodeMessage(obj, Record3.codec());
    };
    Record3.decode = (buf, opts) => {
      return decodeMessage(buf, Record3.codec(), opts);
    };
  })(Record2 || (Record2 = {}));
  var MessageType;
  (function(MessageType2) {
    MessageType2["PUT_VALUE"] = "PUT_VALUE";
    MessageType2["GET_VALUE"] = "GET_VALUE";
    MessageType2["ADD_PROVIDER"] = "ADD_PROVIDER";
    MessageType2["GET_PROVIDERS"] = "GET_PROVIDERS";
    MessageType2["FIND_NODE"] = "FIND_NODE";
    MessageType2["PING"] = "PING";
  })(MessageType || (MessageType = {}));
  var __MessageTypeValues;
  (function(__MessageTypeValues2) {
    __MessageTypeValues2[__MessageTypeValues2["PUT_VALUE"] = 0] = "PUT_VALUE";
    __MessageTypeValues2[__MessageTypeValues2["GET_VALUE"] = 1] = "GET_VALUE";
    __MessageTypeValues2[__MessageTypeValues2["ADD_PROVIDER"] = 2] = "ADD_PROVIDER";
    __MessageTypeValues2[__MessageTypeValues2["GET_PROVIDERS"] = 3] = "GET_PROVIDERS";
    __MessageTypeValues2[__MessageTypeValues2["FIND_NODE"] = 4] = "FIND_NODE";
    __MessageTypeValues2[__MessageTypeValues2["PING"] = 5] = "PING";
  })(__MessageTypeValues || (__MessageTypeValues = {}));
  (function(MessageType2) {
    MessageType2.codec = () => {
      return enumeration(__MessageTypeValues);
    };
  })(MessageType || (MessageType = {}));
  var ConnectionType;
  (function(ConnectionType2) {
    ConnectionType2["NOT_CONNECTED"] = "NOT_CONNECTED";
    ConnectionType2["CONNECTED"] = "CONNECTED";
    ConnectionType2["CAN_CONNECT"] = "CAN_CONNECT";
    ConnectionType2["CANNOT_CONNECT"] = "CANNOT_CONNECT";
  })(ConnectionType || (ConnectionType = {}));
  var __ConnectionTypeValues;
  (function(__ConnectionTypeValues2) {
    __ConnectionTypeValues2[__ConnectionTypeValues2["NOT_CONNECTED"] = 0] = "NOT_CONNECTED";
    __ConnectionTypeValues2[__ConnectionTypeValues2["CONNECTED"] = 1] = "CONNECTED";
    __ConnectionTypeValues2[__ConnectionTypeValues2["CAN_CONNECT"] = 2] = "CAN_CONNECT";
    __ConnectionTypeValues2[__ConnectionTypeValues2["CANNOT_CONNECT"] = 3] = "CANNOT_CONNECT";
  })(__ConnectionTypeValues || (__ConnectionTypeValues = {}));
  (function(ConnectionType2) {
    ConnectionType2.codec = () => {
      return enumeration(__ConnectionTypeValues);
    };
  })(ConnectionType || (ConnectionType = {}));
  var PeerInfo;
  (function(PeerInfo2) {
    let _codec;
    PeerInfo2.codec = () => {
      if (_codec == null) {
        _codec = message((obj, w2, opts = {}) => {
          if (opts.lengthDelimited !== false) {
            w2.fork();
          }
          if (obj.id != null && obj.id.byteLength > 0) {
            w2.uint32(10);
            w2.bytes(obj.id);
          }
          if (obj.multiaddrs != null) {
            for (const value of obj.multiaddrs) {
              w2.uint32(18);
              w2.bytes(value);
            }
          }
          if (obj.connection != null) {
            w2.uint32(24);
            ConnectionType.codec().encode(obj.connection, w2);
          }
          if (opts.lengthDelimited !== false) {
            w2.ldelim();
          }
        }, (reader, length4, opts = {}) => {
          var _a2;
          const obj = {
            id: alloc(0),
            multiaddrs: []
          };
          const end = length4 == null ? reader.len : reader.pos + length4;
          while (reader.pos < end) {
            const tag = reader.uint32();
            switch (tag >>> 3) {
              case 1: {
                obj.id = reader.bytes();
                break;
              }
              case 2: {
                if (((_a2 = opts.limits) == null ? void 0 : _a2.multiaddrs) != null && obj.multiaddrs.length === opts.limits.multiaddrs) {
                  throw new MaxLengthError('Decode error - map field "multiaddrs" had too many elements');
                }
                obj.multiaddrs.push(reader.bytes());
                break;
              }
              case 3: {
                obj.connection = ConnectionType.codec().decode(reader);
                break;
              }
              default: {
                reader.skipType(tag & 7);
                break;
              }
            }
          }
          return obj;
        });
      }
      return _codec;
    };
    PeerInfo2.encode = (obj) => {
      return encodeMessage(obj, PeerInfo2.codec());
    };
    PeerInfo2.decode = (buf, opts) => {
      return decodeMessage(buf, PeerInfo2.codec(), opts);
    };
  })(PeerInfo || (PeerInfo = {}));
  var Message;
  (function(Message4) {
    let _codec;
    Message4.codec = () => {
      if (_codec == null) {
        _codec = message((obj, w2, opts = {}) => {
          if (opts.lengthDelimited !== false) {
            w2.fork();
          }
          if (obj.type != null && __MessageTypeValues[obj.type] !== 0) {
            w2.uint32(8);
            MessageType.codec().encode(obj.type, w2);
          }
          if (obj.clusterLevel != null) {
            w2.uint32(80);
            w2.int32(obj.clusterLevel);
          }
          if (obj.key != null) {
            w2.uint32(18);
            w2.bytes(obj.key);
          }
          if (obj.record != null) {
            w2.uint32(26);
            w2.bytes(obj.record);
          }
          if (obj.closer != null) {
            for (const value of obj.closer) {
              w2.uint32(66);
              PeerInfo.codec().encode(value, w2);
            }
          }
          if (obj.providers != null) {
            for (const value of obj.providers) {
              w2.uint32(74);
              PeerInfo.codec().encode(value, w2);
            }
          }
          if (opts.lengthDelimited !== false) {
            w2.ldelim();
          }
        }, (reader, length4, opts = {}) => {
          var _a2, _b2, _c, _d;
          const obj = {
            type: MessageType.PUT_VALUE,
            closer: [],
            providers: []
          };
          const end = length4 == null ? reader.len : reader.pos + length4;
          while (reader.pos < end) {
            const tag = reader.uint32();
            switch (tag >>> 3) {
              case 1: {
                obj.type = MessageType.codec().decode(reader);
                break;
              }
              case 10: {
                obj.clusterLevel = reader.int32();
                break;
              }
              case 2: {
                obj.key = reader.bytes();
                break;
              }
              case 3: {
                obj.record = reader.bytes();
                break;
              }
              case 8: {
                if (((_a2 = opts.limits) == null ? void 0 : _a2.closer) != null && obj.closer.length === opts.limits.closer) {
                  throw new MaxLengthError('Decode error - map field "closer" had too many elements');
                }
                obj.closer.push(PeerInfo.codec().decode(reader, reader.uint32(), {
                  limits: (_b2 = opts.limits) == null ? void 0 : _b2.closer$
                }));
                break;
              }
              case 9: {
                if (((_c = opts.limits) == null ? void 0 : _c.providers) != null && obj.providers.length === opts.limits.providers) {
                  throw new MaxLengthError('Decode error - map field "providers" had too many elements');
                }
                obj.providers.push(PeerInfo.codec().decode(reader, reader.uint32(), {
                  limits: (_d = opts.limits) == null ? void 0 : _d.providers$
                }));
                break;
              }
              default: {
                reader.skipType(tag & 7);
                break;
              }
            }
          }
          return obj;
        });
      }
      return _codec;
    };
    Message4.encode = (obj) => {
      return encodeMessage(obj, Message4.codec());
    };
    Message4.decode = (buf, opts) => {
      return decodeMessage(buf, Message4.codec(), opts);
    };
  })(Message || (Message = {}));

  // node_modules/@libp2p/kad-dht/dist/src/query/events.js
  var import_browser_shims365 = __toESM(require_browser_shims(), 1);
  function sendQueryEvent(fields, options = {}) {
    var _a2;
    const event = {
      ...fields,
      name: "SEND_QUERY",
      type: 0,
      messageName: fields.type,
      messageType: fields.type
    };
    (_a2 = options.onProgress) == null ? void 0 : _a2.call(options, new CustomEvent("kad-dht:query:send-query", { detail: event }));
    return event;
  }
  function peerResponseEvent(fields, options = {}) {
    var _a2;
    const event = {
      ...fields,
      name: "PEER_RESPONSE",
      type: 1,
      messageName: fields.messageType,
      closer: fields.closer ?? [],
      providers: fields.providers ?? []
    };
    (_a2 = options.onProgress) == null ? void 0 : _a2.call(options, new CustomEvent("kad-dht:query:peer-response", { detail: event }));
    return event;
  }
  function finalPeerEvent(fields, options = {}) {
    var _a2;
    const event = {
      ...fields,
      name: "FINAL_PEER",
      type: 2
    };
    (_a2 = options.onProgress) == null ? void 0 : _a2.call(options, new CustomEvent("kad-dht:query:final-peer", { detail: event }));
    return event;
  }
  function queryErrorEvent(fields, options = {}) {
    var _a2;
    const event = {
      ...fields,
      name: "QUERY_ERROR",
      type: 3
    };
    (_a2 = options.onProgress) == null ? void 0 : _a2.call(options, new CustomEvent("kad-dht:query:query-error", { detail: event }));
    return event;
  }
  function providerEvent(fields, options = {}) {
    var _a2;
    const event = {
      ...fields,
      name: "PROVIDER",
      type: 4
    };
    (_a2 = options.onProgress) == null ? void 0 : _a2.call(options, new CustomEvent("kad-dht:query:provider", { detail: event }));
    return event;
  }
  function valueEvent(fields, options = {}) {
    var _a2;
    const event = {
      ...fields,
      name: "VALUE",
      type: 5
    };
    (_a2 = options.onProgress) == null ? void 0 : _a2.call(options, new CustomEvent("kad-dht:query:value", { detail: event }));
    return event;
  }
  function dialPeerEvent(fields, options = {}) {
    var _a2;
    const event = {
      ...fields,
      name: "DIAL_PEER",
      type: 7
    };
    (_a2 = options.onProgress) == null ? void 0 : _a2.call(options, new CustomEvent("kad-dht:query:dial-peer", { detail: event }));
    return event;
  }

  // node_modules/@libp2p/kad-dht/dist/src/record/selectors.js
  var import_browser_shims366 = __toESM(require_browser_shims(), 1);
  function bestRecord(selectors2, k, records) {
    if (records.length === 0) {
      throw new InvalidParametersError("No records given");
    }
    const kStr = toString2(k);
    const parts = kStr.split("/");
    if (parts.length < 3) {
      throw new InvalidParametersError("Record key does not have a selector function");
    }
    const selector = selectors2[parts[1].toString()];
    if (selector == null) {
      throw new MissingSelectorError(`No selector function configured for key type "${parts[1]}"`);
    }
    if (records.length === 1) {
      return 0;
    }
    return selector(k, records);
  }
  function publickKey(k, records) {
    return 0;
  }
  var selectors = {
    pk: publickKey
  };

  // node_modules/@libp2p/kad-dht/dist/src/record/validators.js
  var import_browser_shims367 = __toESM(require_browser_shims(), 1);
  async function verifyRecord(validators2, record) {
    const key = record.key;
    const keyString = toString2(key);
    const parts = keyString.split("/");
    if (parts.length < 3) {
      return;
    }
    const validator = validators2[parts[1].toString()];
    if (validator == null) {
      throw new InvalidParametersError(`No validator available for key type "${parts[1]}"`);
    }
    await validator(key, record.value);
  }
  var validatePublicKeyRecord = async (key, publicKey) => {
    if (!(key instanceof Uint8Array)) {
      throw new InvalidParametersError('"key" must be a Uint8Array');
    }
    if (key.byteLength < 5) {
      throw new InvalidParametersError("Invalid public key record");
    }
    const prefix = toString2(key.subarray(0, 4));
    if (prefix !== "/pk/") {
      throw new InvalidParametersError("key was not prefixed with /pk/");
    }
    const pubKey = publicKeyFromProtobuf(publicKey);
    const keyhash = key.slice(4);
    if (!equals3(keyhash, pubKey.toMultihash().bytes)) {
      throw new InvalidParametersError("public key does not match passed in key");
    }
  };
  var validators = {
    pk: validatePublicKeyRecord
  };

  // node_modules/@libp2p/kad-dht/dist/src/utils.js
  var import_browser_shims368 = __toESM(require_browser_shims(), 1);
  var PK_PREFIX = fromString2("/pk/");
  function removePrivateAddressesMapper(peer) {
    return {
      ...peer,
      multiaddrs: peer.multiaddrs.filter((multiaddr2) => {
        const [[type, addr]] = multiaddr2.stringTuples();
        if (type === 53 || type === 54 || type === 55) {
          if (addr === "localhost") {
            return false;
          }
          return true;
        }
        if (type !== 4 && type !== 6) {
          return false;
        }
        if (addr == null) {
          return false;
        }
        const isPrivate2 = isPrivateIp(addr);
        if (isPrivate2 == null) {
          return true;
        }
        return !isPrivate2;
      })
    };
  }
  async function convertBuffer(buf) {
    const multihash = await sha256.digest(buf);
    return multihash.digest;
  }
  async function convertPeerId(peerId2) {
    return convertBuffer(peerId2.toMultihash().bytes);
  }
  function bufferToRecordKey(buf) {
    return new Key(`${RECORD_KEY_PREFIX}/${toString2(buf, "base32")}`, false);
  }
  function keyForPublicKey(peerId2) {
    return concat([
      PK_PREFIX,
      peerId2.toMultihash().bytes
    ]);
  }
  function isPublicKeyKey(key) {
    return toString2(key.subarray(0, 4)) === "/pk/";
  }
  function fromPublicKeyKey(key) {
    const multihash = decode4(key.subarray(4));
    return peerIdFromMultihash(multihash);
  }
  function createPutRecord(key, value) {
    const timeReceived = /* @__PURE__ */ new Date();
    const rec = new Libp2pRecord(key, value, timeReceived);
    return rec.serialize();
  }
  function debounce3(callback, wait = 100) {
    let timeout;
    return () => {
      clearTimeout(timeout);
      timeout = setTimeout(() => {
        callback();
      }, wait);
    };
  }
  var P2P_CIRCUIT_CODE = 290;
  var DNS4_CODE = 54;
  var DNS6_CODE = 55;
  var DNSADDR_CODE = 56;
  var IP4_CODE = 4;
  var IP6_CODE = 41;
  function multiaddrIsPublic(multiaddr2) {
    const tuples = multiaddr2.stringTuples();
    for (const tuple of tuples) {
      if (tuple[0] === P2P_CIRCUIT_CODE) {
        return false;
      }
    }
    if (tuples[0][0] === DNS4_CODE || tuples[0][0] === DNS6_CODE || tuples[0][0] === DNSADDR_CODE) {
      return true;
    }
    if (tuples[0][0] === IP4_CODE || tuples[0][0] === IP6_CODE) {
      const result = isPrivateIp(`${tuples[0][1]}`);
      const isPublic = result == null || !result;
      return isPublic;
    }
    return false;
  }

  // node_modules/@libp2p/kad-dht/dist/src/content-fetching/index.js
  var ContentFetching = class {
    log;
    components;
    validators;
    selectors;
    peerRouting;
    queryManager;
    network;
    constructor(components, init) {
      const { validators: validators2, selectors: selectors2, peerRouting, queryManager, network, logPrefix } = init;
      this.components = components;
      this.log = components.logger.forComponent(`${logPrefix}:content-fetching`);
      this.validators = validators2;
      this.selectors = selectors2;
      this.peerRouting = peerRouting;
      this.queryManager = queryManager;
      this.network = network;
    }
    /**
     * Attempt to retrieve the value for the given key from
     * the local datastore
     */
    async getLocal(key) {
      this.log("getLocal %b", key);
      const dsKey = bufferToRecordKey(key);
      this.log("fetching record for key %k", dsKey);
      const raw = await this.components.datastore.get(dsKey);
      this.log("found %k in local datastore", dsKey);
      const rec = Libp2pRecord.deserialize(raw);
      await verifyRecord(this.validators, rec);
      return rec;
    }
    /**
     * Send the best record found to any peers that have an out of date record
     */
    async *sendCorrectionRecord(key, vals, best, options = {}) {
      this.log("sendCorrection for %b", key);
      const fixupRec = createPutRecord(key, best);
      for (const { value, from: from3 } of vals) {
        if (equals3(value, best)) {
          this.log("record was ok");
          continue;
        }
        if (this.components.peerId.equals(from3)) {
          try {
            const dsKey = bufferToRecordKey(key);
            this.log(`Storing corrected record for key ${dsKey.toString()}`);
            await this.components.datastore.put(dsKey, fixupRec.subarray());
          } catch (err) {
            this.log.error("Failed error correcting self", err);
          }
          continue;
        }
        let sentCorrection = false;
        const request = {
          type: MessageType.PUT_VALUE,
          key,
          record: fixupRec
        };
        for await (const event of this.network.sendRequest(from3, request, options)) {
          if (event.name === "PEER_RESPONSE" && event.record != null && equals3(event.record.value, Libp2pRecord.deserialize(fixupRec).value)) {
            sentCorrection = true;
          }
          yield event;
        }
        if (!sentCorrection) {
          yield queryErrorEvent({ from: from3, error: new QueryError("Value not put correctly") }, options);
        }
        this.log.error("Failed error correcting entry");
      }
    }
    /**
     * Store the given key/value pair in the DHT
     */
    async *put(key, value, options = {}) {
      this.log("put key %b value %b", key, value);
      const record = createPutRecord(key, value);
      const dsKey = bufferToRecordKey(key);
      this.log(`storing record for key ${dsKey.toString()}`);
      await this.components.datastore.put(dsKey, record.subarray());
      yield* pipe(this.peerRouting.getClosestPeers(key, { signal: options.signal }), (source) => src_default10(source, (event) => {
        return async () => {
          if (event.name !== "FINAL_PEER") {
            return [event];
          }
          const events = [];
          const msg = {
            type: MessageType.PUT_VALUE,
            key,
            record
          };
          this.log("send put to %p", event.peer.id);
          for await (const putEvent of this.network.sendRequest(event.peer.id, msg, options)) {
            events.push(putEvent);
            if (putEvent.name !== "PEER_RESPONSE") {
              continue;
            }
            if (!(putEvent.record != null && equals3(putEvent.record.value, Libp2pRecord.deserialize(record).value))) {
              events.push(queryErrorEvent({ from: event.peer.id, error: new QueryError("Value not put correctly") }, options));
            }
          }
          return events;
        };
      }), (source) => parallel(source, {
        ordered: false,
        concurrency: ALPHA
      }), async function* (source) {
        for await (const events of source) {
          yield* events;
        }
      });
    }
    /**
     * Get the value to the given key
     */
    async *get(key, options = {}) {
      this.log("get %b", key);
      const vals = [];
      for await (const event of this.getMany(key, options)) {
        if (event.name === "VALUE") {
          vals.push(event);
        }
        yield event;
      }
      if (vals.length === 0) {
        return;
      }
      const records = vals.map((v) => v.value);
      let i = 0;
      try {
        i = bestRecord(this.selectors, key, records);
      } catch (err) {
        if (err.name !== "InvalidParametersError") {
          throw err;
        }
      }
      const best = records[i];
      this.log("GetValue %b %b", key, best);
      if (best == null) {
        throw new NotFoundError("Best value was not found");
      }
      yield* this.sendCorrectionRecord(key, vals, best, options);
      yield vals[i];
    }
    /**
     * Get the `n` values to the given key without sorting
     */
    async *getMany(key, options = {}) {
      this.log("getMany values for %b", key);
      try {
        const localRec = await this.getLocal(key);
        yield valueEvent({
          value: localRec.value,
          from: this.components.peerId
        }, options);
      } catch (err) {
        this.log("error getting local value for %b", key, err);
      }
      const self = this;
      const getValueQuery = async function* ({ peer, signal }) {
        for await (const event of self.peerRouting.getValueOrPeers(peer, key, { signal })) {
          yield event;
          if (event.name === "PEER_RESPONSE" && event.record != null) {
            yield valueEvent({ from: peer, value: event.record.value }, options);
          }
        }
      };
      yield* this.queryManager.run(key, getValueQuery, options);
    }
  };

  // node_modules/@libp2p/kad-dht/dist/src/content-routing/index.js
  var import_browser_shims371 = __toESM(require_browser_shims(), 1);

  // node_modules/@libp2p/kad-dht/dist/src/message/utils.js
  var import_browser_shims370 = __toESM(require_browser_shims(), 1);
  function toPbPeerInfo(peer, connection) {
    const output = {
      id: peer.id.toMultihash().bytes,
      multiaddrs: (peer.multiaddrs ?? []).map((m2) => m2.bytes),
      connection
    };
    return output;
  }
  function fromPbPeerInfo(peer) {
    if (peer.id == null) {
      throw new Error("Invalid peer in message");
    }
    const multihash = decode4(peer.id);
    return {
      id: peerIdFromMultihash(multihash),
      multiaddrs: (peer.multiaddrs ?? []).map((a) => multiaddr(a))
    };
  }

  // node_modules/@libp2p/kad-dht/dist/src/content-routing/index.js
  var ContentRouting = class {
    log;
    components;
    network;
    peerRouting;
    queryManager;
    routingTable;
    providers;
    constructor(components, init) {
      const { network, peerRouting, queryManager, routingTable, providers, logPrefix } = init;
      this.components = components;
      this.log = components.logger.forComponent(`${logPrefix}:content-routing`);
      this.network = network;
      this.peerRouting = peerRouting;
      this.queryManager = queryManager;
      this.routingTable = routingTable;
      this.providers = providers;
    }
    /**
     * Announce to the network that we can provide the value for a given key and
     * are contactable on the given multiaddrs
     */
    async *provide(key, multiaddrs, options = {}) {
      this.log("provide %s", key);
      const target = key.multihash.bytes;
      await this.providers.addProvider(key, this.components.peerId);
      const msg = {
        type: MessageType.ADD_PROVIDER,
        key: target,
        providers: [
          toPbPeerInfo({
            id: this.components.peerId,
            multiaddrs
          })
        ]
      };
      let sent = 0;
      const maybeNotifyPeer = (event) => {
        return async () => {
          if (event.name !== "FINAL_PEER") {
            return [event];
          }
          const events = [];
          this.log("putProvider %s to %p", key, event.peer.id);
          try {
            this.log("sending provider record for %s to %p", key, event.peer.id);
            for await (const sendEvent of this.network.sendMessage(event.peer.id, msg, options)) {
              if (sendEvent.name === "PEER_RESPONSE") {
                this.log("sent provider record for %s to %p", key, event.peer.id);
                sent++;
              }
              events.push(sendEvent);
            }
          } catch (err) {
            this.log.error("error sending provide record to peer %p", event.peer.id, err);
            events.push(queryErrorEvent({ from: event.peer.id, error: err }, options));
          }
          return events;
        };
      };
      yield* pipe(this.peerRouting.getClosestPeers(target, options), (source) => src_default10(source, (event) => maybeNotifyPeer(event)), (source) => parallel(source, {
        ordered: false,
        concurrency: ALPHA
      }), async function* (source) {
        for await (const events of source) {
          yield* events;
        }
      });
      this.log("sent provider records to %d peers", sent);
    }
    /**
     * Search the dht for up to `K` providers of the given CID.
     */
    async *findProviders(key, options) {
      const toFind = this.routingTable.kBucketSize;
      let found = 0;
      const target = key.multihash.bytes;
      const self = this;
      this.log("findProviders %c", key);
      const provs = await this.providers.getProviders(key);
      if (provs.length > 0) {
        const providers2 = [];
        for (const peerId2 of provs.slice(0, toFind)) {
          try {
            const peer = await this.components.peerStore.get(peerId2);
            providers2.push({
              id: peerId2,
              multiaddrs: peer.addresses.map(({ multiaddr: multiaddr2 }) => multiaddr2)
            });
          } catch (err) {
            if (err.name !== "NotFoundError") {
              throw err;
            }
            this.log("no peer store entry for %p", peerId2);
          }
        }
        yield peerResponseEvent({ from: this.components.peerId, messageType: MessageType.GET_PROVIDERS, providers: providers2 }, options);
        yield providerEvent({ from: this.components.peerId, providers: providers2 }, options);
        found += providers2.length;
        if (found >= toFind) {
          return;
        }
      }
      const findProvidersQuery = async function* ({ peer, signal }) {
        const request = {
          type: MessageType.GET_PROVIDERS,
          key: target
        };
        yield* self.network.sendRequest(peer, request, {
          ...options,
          signal
        });
      };
      const providers = new PeerSet(provs);
      for await (const event of this.queryManager.run(target, findProvidersQuery, options)) {
        yield event;
        if (event.name === "PEER_RESPONSE") {
          this.log("Found %d provider entries for %c and %d closer peers", event.providers.length, key, event.closer.length);
          const newProviders = [];
          for (const peer of event.providers) {
            if (providers.has(peer.id)) {
              continue;
            }
            providers.add(peer.id);
            newProviders.push(peer);
          }
          if (newProviders.length > 0) {
            yield providerEvent({ from: event.from, providers: newProviders }, options);
            found += newProviders.length;
            if (found >= toFind) {
              return;
            }
          }
        }
      }
    }
  };

  // node_modules/@libp2p/kad-dht/dist/src/network.js
  var import_browser_shims378 = __toESM(require_browser_shims(), 1);

  // node_modules/@libp2p/kad-dht/node_modules/it-protobuf-stream/dist/src/index.js
  var import_browser_shims377 = __toESM(require_browser_shims(), 1);

  // node_modules/@libp2p/kad-dht/node_modules/it-length-prefixed-stream/dist/src/index.js
  var import_browser_shims376 = __toESM(require_browser_shims(), 1);

  // node_modules/@libp2p/kad-dht/node_modules/it-byte-stream/dist/src/index.js
  var import_browser_shims374 = __toESM(require_browser_shims(), 1);

  // node_modules/@libp2p/kad-dht/node_modules/it-queueless-pushable/dist/src/index.js
  var import_browser_shims372 = __toESM(require_browser_shims(), 1);
  var QueuelessPushable2 = class {
    readNext;
    haveNext;
    ended;
    nextResult;
    constructor() {
      this.ended = false;
      this.readNext = pDefer();
      this.haveNext = pDefer();
    }
    [Symbol.asyncIterator]() {
      return this;
    }
    async next() {
      if (this.nextResult == null) {
        await this.haveNext.promise;
      }
      if (this.nextResult == null) {
        throw new Error("HaveNext promise resolved but nextResult was undefined");
      }
      const nextResult = this.nextResult;
      this.nextResult = void 0;
      this.readNext.resolve();
      this.readNext = pDefer();
      return nextResult;
    }
    async throw(err) {
      this.ended = true;
      if (err != null) {
        this.haveNext.promise.catch(() => {
        });
        this.haveNext.reject(err);
      }
      const result = {
        done: true,
        value: void 0
      };
      return result;
    }
    async return() {
      const result = {
        done: true,
        value: void 0
      };
      this.ended = true;
      this.nextResult = result;
      this.haveNext.resolve();
      return result;
    }
    async push(value, options) {
      await this._push(value, options);
    }
    async end(err, options) {
      if (err != null) {
        await this.throw(err);
      } else {
        await this._push(void 0, options);
      }
    }
    async _push(value, options) {
      if (value != null && this.ended) {
        throw new Error("Cannot push value onto an ended pushable");
      }
      while (this.nextResult != null) {
        await this.readNext.promise;
      }
      if (value != null) {
        this.nextResult = { done: false, value };
      } else {
        this.ended = true;
        this.nextResult = { done: true, value: void 0 };
      }
      this.haveNext.resolve();
      this.haveNext = pDefer();
      await raceSignal(this.readNext.promise, options == null ? void 0 : options.signal, options);
    }
  };
  function queuelessPushable2() {
    return new QueuelessPushable2();
  }

  // node_modules/@libp2p/kad-dht/node_modules/it-byte-stream/dist/src/errors.js
  var import_browser_shims373 = __toESM(require_browser_shims(), 1);
  var UnexpectedEOFError5 = class extends Error {
    name = "UnexpectedEOFError";
    code = "ERR_UNEXPECTED_EOF";
  };

  // node_modules/@libp2p/kad-dht/node_modules/it-byte-stream/dist/src/index.js
  var CodeError = class extends Error {
    code;
    constructor(message2, code2) {
      super(message2);
      this.code = code2;
    }
  };
  var AbortError8 = class extends CodeError {
    type;
    constructor(message2) {
      super(message2, "ABORT_ERR");
      this.type = "aborted";
      this.name = "AbortError";
    }
  };
  function byteStream2(duplex, opts) {
    const write3 = queuelessPushable2();
    duplex.sink(write3).catch(async (err) => {
      await write3.end(err);
    });
    duplex.sink = async (source2) => {
      for await (const buf of source2) {
        await write3.push(buf);
      }
      await write3.end();
    };
    let source = duplex.source;
    if (duplex.source[Symbol.iterator] != null) {
      source = duplex.source[Symbol.iterator]();
    } else if (duplex.source[Symbol.asyncIterator] != null) {
      source = duplex.source[Symbol.asyncIterator]();
    }
    const readBuffer = new Uint8ArrayList();
    const W = {
      read: async (bytes, options) => {
        var _a2, _b2;
        (_a2 = options == null ? void 0 : options.signal) == null ? void 0 : _a2.throwIfAborted();
        let listener;
        const abortPromise = new Promise((resolve, reject) => {
          var _a3;
          listener = () => {
            reject(new AbortError8("Read aborted"));
          };
          (_a3 = options == null ? void 0 : options.signal) == null ? void 0 : _a3.addEventListener("abort", listener);
        });
        try {
          if (bytes == null) {
            const { done, value } = await Promise.race([
              source.next(),
              abortPromise
            ]);
            if (done === true) {
              return new Uint8ArrayList();
            }
            return value;
          }
          while (readBuffer.byteLength < bytes) {
            const { value, done } = await Promise.race([
              source.next(),
              abortPromise
            ]);
            if (done === true) {
              throw new UnexpectedEOFError5("unexpected end of input");
            }
            readBuffer.append(value);
          }
          const buf = readBuffer.sublist(0, bytes);
          readBuffer.consume(bytes);
          return buf;
        } finally {
          if (listener != null) {
            (_b2 = options == null ? void 0 : options.signal) == null ? void 0 : _b2.removeEventListener("abort", listener);
          }
        }
      },
      write: async (data, options) => {
        var _a2;
        (_a2 = options == null ? void 0 : options.signal) == null ? void 0 : _a2.throwIfAborted();
        if (data instanceof Uint8Array) {
          await write3.push(data, options);
        } else {
          await write3.push(data.subarray(), options);
        }
      },
      unwrap: () => {
        if (readBuffer.byteLength > 0) {
          const originalStream = duplex.source;
          duplex.source = async function* () {
            if ((opts == null ? void 0 : opts.yieldBytes) === false) {
              yield readBuffer;
            } else {
              yield* readBuffer;
            }
            yield* originalStream;
          }();
        }
        return duplex;
      }
    };
    return W;
  }

  // node_modules/@libp2p/kad-dht/node_modules/it-length-prefixed-stream/dist/src/errors.js
  var import_browser_shims375 = __toESM(require_browser_shims(), 1);
  var InvalidMessageLengthError5 = class extends Error {
    name = "InvalidMessageLengthError";
    code = "ERR_INVALID_MSG_LENGTH";
  };
  var InvalidDataLengthError5 = class extends Error {
    name = "InvalidDataLengthError";
    code = "ERR_MSG_DATA_TOO_LONG";
  };
  var InvalidDataLengthLengthError5 = class extends Error {
    name = "InvalidDataLengthLengthError";
    code = "ERR_MSG_LENGTH_TOO_LONG";
  };

  // node_modules/@libp2p/kad-dht/node_modules/it-length-prefixed-stream/dist/src/index.js
  function lpStream2(duplex, opts = {}) {
    const bytes = byteStream2(duplex, opts);
    if (opts.maxDataLength != null && opts.maxLengthLength == null) {
      opts.maxLengthLength = encodingLength2(opts.maxDataLength);
    }
    const decodeLength = (opts == null ? void 0 : opts.lengthDecoder) ?? decode6;
    const encodeLength2 = (opts == null ? void 0 : opts.lengthEncoder) ?? encode5;
    const W = {
      read: async (options) => {
        let dataLength = -1;
        const lengthBuffer = new Uint8ArrayList();
        while (true) {
          lengthBuffer.append(await bytes.read(1, options));
          try {
            dataLength = decodeLength(lengthBuffer);
          } catch (err) {
            if (err instanceof RangeError) {
              continue;
            }
            throw err;
          }
          if (dataLength < 0) {
            throw new InvalidMessageLengthError5("Invalid message length");
          }
          if ((opts == null ? void 0 : opts.maxLengthLength) != null && lengthBuffer.byteLength > opts.maxLengthLength) {
            throw new InvalidDataLengthLengthError5("message length length too long");
          }
          if (dataLength > -1) {
            break;
          }
        }
        if ((opts == null ? void 0 : opts.maxDataLength) != null && dataLength > opts.maxDataLength) {
          throw new InvalidDataLengthError5("message length too long");
        }
        return bytes.read(dataLength, options);
      },
      write: async (data, options) => {
        await bytes.write(new Uint8ArrayList(encodeLength2(data.byteLength), data), options);
      },
      writeV: async (data, options) => {
        const list = new Uint8ArrayList(...data.flatMap((buf) => [encodeLength2(buf.byteLength), buf]));
        await bytes.write(list, options);
      },
      unwrap: () => {
        return bytes.unwrap();
      }
    };
    return W;
  }

  // node_modules/@libp2p/kad-dht/node_modules/it-protobuf-stream/dist/src/index.js
  function pbStream2(duplex, opts) {
    const lp = lpStream2(duplex, opts);
    const W = {
      read: async (proto, options) => {
        const value = await lp.read(options);
        return proto.decode(value);
      },
      write: async (message2, proto, options) => {
        await lp.write(proto.encode(message2), options);
      },
      writeV: async (messages2, proto, options) => {
        await lp.writeV(messages2.map((message2) => proto.encode(message2)), options);
      },
      pb: (proto) => {
        return {
          read: async (options) => W.read(proto, options),
          write: async (d2, options) => W.write(d2, proto, options),
          writeV: async (d2, options) => W.writeV(d2, proto, options),
          unwrap: () => W
        };
      },
      unwrap: () => {
        return lp.unwrap();
      }
    };
    return W;
  }

  // node_modules/@libp2p/kad-dht/dist/src/network.js
  var Network = class extends TypedEventEmitter {
    log;
    protocol;
    running;
    components;
    timeout;
    metrics;
    /**
     * Create a new network
     */
    constructor(components, init) {
      var _a2, _b2;
      super();
      const { protocol } = init;
      this.components = components;
      this.log = components.logger.forComponent(`${init.logPrefix}:network`);
      this.running = false;
      this.protocol = protocol;
      this.timeout = new AdaptiveTimeout({
        ...init.timeout ?? {},
        metrics: components.metrics,
        metricName: `${init.logPrefix.replaceAll(":", "_")}_network_message_send_times_milliseconds`
      });
      this.metrics = {
        operations: (_a2 = components.metrics) == null ? void 0 : _a2.registerCounterGroup(`${init.logPrefix.replaceAll(":", "_")}_outbound_rpc_requests_total`),
        errors: (_b2 = components.metrics) == null ? void 0 : _b2.registerCounterGroup(`${init.logPrefix.replaceAll(":", "_")}_outbound_rpc_errors_total`)
      };
    }
    /**
     * Start the network
     */
    async start() {
      if (this.running) {
        return;
      }
      this.running = true;
    }
    /**
     * Stop all network activity
     */
    async stop() {
      this.running = false;
    }
    /**
     * Is the network online?
     */
    isStarted() {
      return this.running;
    }
    /**
     * Send a request and record RTT for latency measurements
     */
    async *sendRequest(to, msg, options = {}) {
      var _a2, _b2, _c;
      if (!this.running) {
        return;
      }
      const type = msg.type;
      if (type == null) {
        throw new InvalidParametersError("Message type was missing");
      }
      this.log("sending %s to %p", msg.type, to);
      yield dialPeerEvent({ peer: to }, options);
      yield sendQueryEvent({ to, type }, options);
      let stream;
      const signal = this.timeout.getTimeoutSignal(options);
      options = {
        ...options,
        signal
      };
      try {
        (_a2 = this.metrics.operations) == null ? void 0 : _a2.increment({ [type]: true });
        const connection = await this.components.connectionManager.openConnection(to, options);
        stream = await connection.newStream(this.protocol, options);
        const response = await this._writeReadMessage(stream, msg, options);
        stream.close(options).catch((err) => {
          this.log.error("error closing stream to %p", to, err);
          stream == null ? void 0 : stream.abort(err);
        });
        yield peerResponseEvent({
          from: to,
          messageType: response.type,
          closer: response.closer.map(fromPbPeerInfo),
          providers: response.providers.map(fromPbPeerInfo),
          record: response.record == null ? void 0 : Libp2pRecord.deserialize(response.record)
        }, options);
      } catch (err) {
        (_b2 = this.metrics.errors) == null ? void 0 : _b2.increment({ [type]: true });
        stream == null ? void 0 : stream.abort(err);
        if (((_c = options.signal) == null ? void 0 : _c.aborted) !== true) {
          this.log.error("could not send %s to %p - %e", msg.type, to, err);
        }
        yield queryErrorEvent({ from: to, error: err }, options);
      } finally {
        this.timeout.cleanUp(signal);
      }
    }
    /**
     * Sends a message without expecting an answer
     */
    async *sendMessage(to, msg, options = {}) {
      var _a2, _b2;
      if (!this.running) {
        return;
      }
      const type = msg.type;
      if (type == null) {
        throw new InvalidParametersError("Message type was missing");
      }
      this.log("sending %s to %p", msg.type, to);
      yield dialPeerEvent({ peer: to }, options);
      yield sendQueryEvent({ to, type }, options);
      let stream;
      const signal = this.timeout.getTimeoutSignal(options);
      options = {
        ...options,
        signal
      };
      try {
        (_a2 = this.metrics.operations) == null ? void 0 : _a2.increment({ [type]: true });
        const connection = await this.components.connectionManager.openConnection(to, options);
        stream = await connection.newStream(this.protocol, options);
        await this._writeMessage(stream, msg, options);
        stream.close(options).catch((err) => {
          this.log.error("error closing stream to %p", to, err);
          stream == null ? void 0 : stream.abort(err);
        });
        yield peerResponseEvent({ from: to, messageType: type }, options);
      } catch (err) {
        (_b2 = this.metrics.errors) == null ? void 0 : _b2.increment({ [type]: true });
        stream == null ? void 0 : stream.abort(err);
        yield queryErrorEvent({ from: to, error: err }, options);
      } finally {
        this.timeout.cleanUp(signal);
      }
    }
    /**
     * Write a message to the given stream
     */
    async _writeMessage(stream, msg, options) {
      const pb = pbStream2(stream);
      await pb.write(msg, Message, options);
      await pb.unwrap().close(options);
    }
    /**
     * Write a message and read its response.
     * If no response is received after the specified timeout
     * this will error out.
     */
    async _writeReadMessage(stream, msg, options) {
      const pb = pbStream2(stream);
      await pb.write(msg, Message, options);
      const message2 = await pb.read(Message, options);
      await pb.unwrap().close(options);
      message2.closer.forEach((peerData) => {
        this.safeDispatchEvent("peer", {
          detail: fromPbPeerInfo(peerData)
        });
      });
      message2.providers.forEach((peerData) => {
        this.safeDispatchEvent("peer", {
          detail: fromPbPeerInfo(peerData)
        });
      });
      return message2;
    }
  };

  // node_modules/@libp2p/kad-dht/dist/src/peer-routing/index.js
  var import_browser_shims381 = __toESM(require_browser_shims(), 1);

  // node_modules/@libp2p/kad-dht/dist/src/peer-list/peer-distance-list.js
  var import_browser_shims380 = __toESM(require_browser_shims(), 1);

  // node_modules/uint8arrays/dist/src/xor-compare.js
  var import_browser_shims379 = __toESM(require_browser_shims(), 1);
  function xorCompare(a, b) {
    if (a.byteLength !== b.byteLength) {
      throw new Error("Inputs should have the same length");
    }
    for (let i = 0; i < a.byteLength; i++) {
      if (a[i] === b[i]) {
        continue;
      }
      return a[i] < b[i] ? -1 : 1;
    }
    return 0;
  }

  // node_modules/@libp2p/kad-dht/dist/src/peer-list/peer-distance-list.js
  var PeerDistanceList = class {
    /**
     * The DHT key from which distance is calculated
     */
    originDhtKey;
    /**
     * The maximum size of the list
     */
    capacity;
    peerDistances;
    constructor(originDhtKey, capacity) {
      this.originDhtKey = originDhtKey;
      this.capacity = capacity;
      this.peerDistances = [];
    }
    /**
     * The length of the list
     */
    get length() {
      return this.peerDistances.length;
    }
    /**
     * The peers in the list, in order of distance from the origin key
     */
    get peers() {
      return this.peerDistances.map((pd) => pd.peer);
    }
    /**
     * Add a peerId to the list.
     */
    async add(peer) {
      const dhtKey = await convertPeerId(peer.id);
      this.addWitKadId(peer, dhtKey);
    }
    /**
     * Add a peerId to the list.
     */
    addWitKadId(peer, kadId) {
      if (this.peerDistances.find((pd) => pd.peer.id.equals(peer.id)) != null) {
        return;
      }
      const el = {
        peer,
        distance: xor(this.originDhtKey, kadId)
      };
      this.peerDistances.push(el);
      this.peerDistances.sort((a, b) => xorCompare(a.distance, b.distance));
      this.peerDistances = this.peerDistances.slice(0, this.capacity);
    }
    /**
     * Indicates whether any of the peerIds passed as a parameter are closer
     * to the origin key than the furthest peerId in the PeerDistanceList.
     */
    async isCloser(peerId2) {
      if (this.length === 0) {
        return true;
      }
      const dhtKey = await convertPeerId(peerId2);
      const dhtKeyXor = xor(dhtKey, this.originDhtKey);
      const furthestDistance = this.peerDistances[this.peerDistances.length - 1].distance;
      return xorCompare(dhtKeyXor, furthestDistance) === -1;
    }
    /**
     * Indicates whether any of the peerIds passed as a parameter are closer
     * to the origin key than the furthest peerId in the PeerDistanceList.
     */
    async anyCloser(peerIds) {
      if (peerIds.length === 0) {
        return false;
      }
      return Promise.any(peerIds.map(async (peerId2) => this.isCloser(peerId2)));
    }
  };

  // node_modules/@libp2p/kad-dht/dist/src/peer-routing/index.js
  var PeerRouting = class {
    log;
    routingTable;
    network;
    validators;
    queryManager;
    peerStore;
    peerId;
    constructor(components, init) {
      const { routingTable, network, validators: validators2, queryManager, logPrefix } = init;
      this.routingTable = routingTable;
      this.network = network;
      this.validators = validators2;
      this.queryManager = queryManager;
      this.peerStore = components.peerStore;
      this.peerId = components.peerId;
      this.log = components.logger.forComponent(`${logPrefix}:peer-routing`);
    }
    /**
     * Look if we are connected to a peer with the given id.
     * Returns its id and addresses, if found, otherwise `undefined`.
     */
    async findPeerLocal(peer) {
      let peerData;
      const p = await this.routingTable.find(peer);
      if (p != null) {
        this.log("findPeerLocal found %p in routing table", peer);
        try {
          peerData = await this.peerStore.get(p);
        } catch (err) {
          if (err.name !== "NotFoundError") {
            throw err;
          }
        }
      }
      if (peerData == null) {
        try {
          peerData = await this.peerStore.get(peer);
        } catch (err) {
          if (err.name !== "NotFoundError") {
            throw err;
          }
        }
      }
      if (peerData != null) {
        this.log("findPeerLocal found %p in peer store", peer);
        return {
          id: peerData.id,
          multiaddrs: peerData.addresses.map((address) => address.multiaddr)
        };
      }
      return void 0;
    }
    /**
     * Get a value via rpc call for the given parameters
     */
    async *_getValueSingle(peer, key, options = {}) {
      const msg = {
        type: MessageType.GET_VALUE,
        key
      };
      yield* this.network.sendRequest(peer, msg, options);
    }
    /**
     * Get the public key directly from a node
     */
    async *getPublicKeyFromNode(peer, options = {}) {
      const pkKey = keyForPublicKey(peer);
      for await (const event of this._getValueSingle(peer, pkKey, options)) {
        yield event;
        if (event.name === "PEER_RESPONSE" && event.record != null) {
          const publicKey = publicKeyFromProtobuf(event.record.value);
          const recPeer = peerIdFromPublicKey(publicKey);
          if (!recPeer.equals(peer)) {
            throw new InvalidPublicKeyError("public key does not match id");
          }
          if (recPeer.publicKey == null) {
            throw new InvalidPublicKeyError("public key missing");
          }
          yield valueEvent({
            from: peer,
            value: event.record.value
          }, options);
        }
      }
      throw new QueryError(`Node not responding with its public key: ${peer.toString()}`);
    }
    /**
     * Search for a peer with the given ID
     */
    async *findPeer(id, options = {}) {
      this.log("findPeer %p", id);
      if (options.useCache !== false) {
        const pi = await this.findPeerLocal(id);
        if (pi != null) {
          this.log("found local");
          yield finalPeerEvent({
            from: this.peerId,
            peer: pi
          }, options);
          return;
        }
      }
      let foundPeer = false;
      if (options.useNetwork !== false) {
        const self = this;
        const findPeerQuery = async function* ({ peer, signal }) {
          const request = {
            type: MessageType.FIND_NODE,
            key: id.toMultihash().bytes
          };
          for await (const event of self.network.sendRequest(peer, request, {
            ...options,
            signal
          })) {
            yield event;
            if (event.name === "PEER_RESPONSE") {
              const match = event.closer.find((p) => p.id.equals(id));
              if (match != null) {
                yield finalPeerEvent({ from: event.from, peer: match }, options);
              }
            }
          }
        };
        for await (const event of this.queryManager.run(id.toMultihash().bytes, findPeerQuery, options)) {
          if (event.name === "FINAL_PEER") {
            foundPeer = true;
          }
          yield event;
        }
      }
      if (!foundPeer) {
        yield queryErrorEvent({ from: this.peerId, error: new NotFoundError("Not found") }, options);
      }
    }
    /**
     * Kademlia 'FIND_NODE' operation on a key, which could be the bytes from
     * a multihash or a peer ID
     */
    async *getClosestPeers(key, options = {}) {
      this.log("getClosestPeers to %b", key);
      const kadId = await convertBuffer(key);
      const tablePeers = this.routingTable.closestPeers(kadId);
      const self = this;
      const peers = new PeerDistanceList(kadId, this.routingTable.kBucketSize);
      await Promise.all(tablePeers.map(async (peer) => {
        await peers.add({ id: peer, multiaddrs: [] });
      }));
      const getCloserPeersQuery = async function* ({ peer, signal }) {
        self.log("closerPeersSingle %s from %p", toString2(key, "base32"), peer);
        const request = {
          type: MessageType.FIND_NODE,
          key
        };
        yield* self.network.sendRequest(peer, request, {
          ...options,
          signal
        });
      };
      for await (const event of this.queryManager.run(key, getCloserPeersQuery, options)) {
        if (event.name === "PEER_RESPONSE") {
          await Promise.all(event.closer.map(async (peerData) => {
            await peers.add(peerData);
          }));
        }
        yield event;
      }
      this.log("found %d peers close to %b", peers.length, key);
      for (const peer of peers.peers) {
        yield finalPeerEvent({
          from: this.peerId,
          peer
        }, options);
      }
    }
    /**
     * Query a particular peer for the value for the given key.
     * It will either return the value or a list of closer peers.
     *
     * Note: The peerStore is updated with new addresses found for the given peer.
     */
    async *getValueOrPeers(peer, key, options = {}) {
      for await (const event of this._getValueSingle(peer, key, options)) {
        if (event.name === "PEER_RESPONSE") {
          if (event.record != null) {
            try {
              await this._verifyRecordOnline(event.record);
            } catch (err) {
              const errMsg = "invalid record received, discarded";
              this.log(errMsg);
              yield queryErrorEvent({ from: event.from, error: new QueryError(errMsg) }, options);
              continue;
            }
          }
        }
        yield event;
      }
    }
    /**
     * Verify a record, fetching missing public keys from the network.
     * Throws an error if the record is invalid.
     */
    async _verifyRecordOnline(record) {
      if (record.timeReceived == null) {
        throw new InvalidRecordError("invalid record received");
      }
      await verifyRecord(this.validators, new Libp2pRecord(record.key, record.value, record.timeReceived));
    }
    /**
     * Get the nearest peers to the given query, but if closer
     * than self
     */
    async getCloserPeersOffline(key, closerThan) {
      const id = await convertBuffer(key);
      const ids = this.routingTable.closestPeers(id);
      const output = [];
      for (const peerId2 of ids) {
        if (peerId2.equals(closerThan)) {
          continue;
        }
        try {
          const peer = await this.peerStore.get(peerId2);
          output.push({
            id: peerId2,
            multiaddrs: peer.addresses.map(({ multiaddr: multiaddr2 }) => multiaddr2)
          });
        } catch (err) {
          if (err.name !== "NotFoundError") {
            throw err;
          }
        }
      }
      if (output.length > 0) {
        this.log("getCloserPeersOffline found %d peer(s) closer to %b than %p", output.length, key, closerThan);
      } else {
        this.log("getCloserPeersOffline could not find peer closer to %b than %p with %d peers in the routing table", key, closerThan, this.routingTable.size);
      }
      return output;
    }
  };

  // node_modules/@libp2p/kad-dht/dist/src/providers.js
  var import_browser_shims382 = __toESM(require_browser_shims(), 1);
  var import_hashlru2 = __toESM(require_hashlru(), 1);
  var Providers = class {
    log;
    datastore;
    cache;
    cleanupInterval;
    provideValidity;
    syncQueue;
    started;
    cleaner;
    constructor(components, init = {}) {
      const { cacheSize, cleanupInterval, provideValidity } = init;
      this.log = components.logger.forComponent("libp2p:kad-dht:providers");
      this.datastore = components.datastore;
      this.cleanupInterval = cleanupInterval ?? PROVIDERS_CLEANUP_INTERVAL;
      this.provideValidity = provideValidity ?? PROVIDERS_VALIDITY;
      this.cache = (0, import_hashlru2.default)(cacheSize ?? PROVIDERS_LRU_CACHE_SIZE);
      this.syncQueue = new PQueue({ concurrency: 1 });
      this.started = false;
    }
    isStarted() {
      return this.started;
    }
    /**
     * Start the provider cleanup service
     */
    async start() {
      if (this.started) {
        return;
      }
      this.started = true;
      this.cleaner = setInterval(() => {
        this._cleanup().catch((err) => {
          this.log.error(err);
        });
      }, this.cleanupInterval);
    }
    /**
     * Release any resources.
     */
    async stop() {
      this.started = false;
      if (this.cleaner != null) {
        clearInterval(this.cleaner);
        this.cleaner = void 0;
      }
    }
    /**
     * Check all providers if they are still valid, and if not delete them
     */
    async _cleanup() {
      await this.syncQueue.add(async () => {
        const start2 = Date.now();
        let count = 0;
        let deleteCount = 0;
        const deleted = /* @__PURE__ */ new Map();
        const batch = this.datastore.batch();
        const query = this.datastore.query({ prefix: PROVIDER_KEY_PREFIX });
        for await (const entry of query) {
          try {
            const { cid, peerId: peerId2 } = parseProviderKey(entry.key);
            const time = readTime(entry.value).getTime();
            const now = Date.now();
            const delta = now - time;
            const expired = delta > this.provideValidity;
            this.log("comparing: %d - %d = %d > %d %s", now, time, delta, this.provideValidity, expired ? "(expired)" : "");
            if (expired) {
              deleteCount++;
              batch.delete(entry.key);
              const peers = deleted.get(cid) ?? /* @__PURE__ */ new Set();
              peers.add(peerId2);
              deleted.set(cid, peers);
            }
            count++;
          } catch (err) {
            this.log.error(err.message);
          }
        }
        if (deleted.size > 0) {
          this.log("deleting %d / %d entries", deleteCount, count);
          await batch.commit();
        } else {
          this.log("nothing to delete");
        }
        for (const [cid, peers] of deleted) {
          const key = makeProviderKey(cid);
          const provs = this.cache.get(key);
          if (provs != null) {
            for (const peerId2 of peers) {
              provs.delete(peerId2);
            }
            if (provs.size === 0) {
              this.cache.remove(key);
            } else {
              this.cache.set(key, provs);
            }
          }
        }
        this.log("Cleanup successful (%dms)", Date.now() - start2);
      });
    }
    /**
     * Get the currently known provider peer ids for a given CID
     */
    async _getProvidersMap(cid) {
      const cacheKey = makeProviderKey(cid);
      let provs = this.cache.get(cacheKey);
      if (provs == null) {
        provs = await loadProviders(this.datastore, cid);
        this.cache.set(cacheKey, provs);
      }
      return provs;
    }
    /**
     * Add a new provider for the given CID
     */
    async addProvider(cid, provider) {
      await this.syncQueue.add(async () => {
        this.log("%p provides %s", provider, cid);
        const provs = await this._getProvidersMap(cid);
        this.log("loaded %s provs", provs.size);
        const now = /* @__PURE__ */ new Date();
        provs.set(provider.toString(), now);
        const dsKey = makeProviderKey(cid);
        this.cache.set(dsKey, provs);
        await writeProviderEntry(this.datastore, cid, provider, now);
      });
    }
    /**
     * Get a list of providers for the given CID
     */
    async getProviders(cid) {
      return this.syncQueue.add(async () => {
        this.log("get providers for %s", cid);
        const provs = await this._getProvidersMap(cid);
        return [...provs.keys()].map((peerIdStr) => {
          return peerIdFromString(peerIdStr);
        });
      }, {
        // no timeout is specified for this queue so it will not
        // throw, but this is required to get the right return
        // type since p-queue@7.3.4
        throwOnTimeout: true
      });
    }
  };
  function makeProviderKey(cid) {
    const cidStr = typeof cid === "string" ? cid : toString2(cid.multihash.bytes, "base32");
    return `${PROVIDER_KEY_PREFIX}/${cidStr}`;
  }
  async function writeProviderEntry(store, cid, peer, time) {
    const dsKey = [
      makeProviderKey(cid),
      "/",
      peer.toString()
    ].join("");
    const key = new Key(dsKey);
    const buffer = encode5(time.getTime());
    await store.put(key, buffer);
  }
  function parseProviderKey(key) {
    const parts = key.toString().split("/");
    if (parts.length !== 5) {
      throw new Error(`incorrectly formatted provider entry key in datastore: ${key.toString()}`);
    }
    return {
      cid: parts[3],
      peerId: parts[4]
    };
  }
  async function loadProviders(store, cid) {
    const providers = /* @__PURE__ */ new Map();
    const query = store.query({ prefix: makeProviderKey(cid) });
    for await (const entry of query) {
      const { peerId: peerId2 } = parseProviderKey(entry.key);
      providers.set(peerId2, readTime(entry.value));
    }
    return providers;
  }
  function readTime(buf) {
    return new Date(decode6(buf));
  }

  // node_modules/@libp2p/kad-dht/dist/src/query/manager.js
  var import_browser_shims384 = __toESM(require_browser_shims(), 1);

  // node_modules/@libp2p/kad-dht/dist/src/query/query-path.js
  var import_browser_shims383 = __toESM(require_browser_shims(), 1);
  async function* queryPath(options) {
    const { key, startingPeer, ourPeerId, signal, query, alpha, pathIndex, numPaths, queryFuncTimeout, log: log2, peersSeen, connectionManager } = options;
    const queue = new Queue2({
      concurrency: alpha,
      sort: (a, b) => xorCompare(a.options.distance, b.options.distance)
    });
    const kadId = await convertBuffer(key);
    function queryPeer(peer, peerKadId) {
      if (peer == null) {
        return;
      }
      peersSeen.add(peer);
      const peerXor = xor(peerKadId, kadId);
      queue.add(async () => {
        const signals = [signal];
        if (queryFuncTimeout != null) {
          signals.push(AbortSignal.timeout(queryFuncTimeout));
        }
        const compoundSignal = anySignal(signals);
        setMaxListeners(Infinity, compoundSignal);
        try {
          for await (const event of query({
            key,
            peer,
            signal: compoundSignal,
            pathIndex,
            numPaths
          })) {
            if (compoundSignal.aborted) {
              return;
            }
            if (event.name === "PEER_RESPONSE") {
              for (const closerPeer of event.closer) {
                if (peersSeen.has(closerPeer.id)) {
                  log2.trace("already seen %p in query", closerPeer.id);
                  continue;
                }
                if (ourPeerId.equals(closerPeer.id)) {
                  log2("not querying ourselves");
                  continue;
                }
                if (!await connectionManager.isDialable(closerPeer.multiaddrs)) {
                  log2("not querying undialable peer");
                  continue;
                }
                const closerPeerKadId = await convertPeerId(closerPeer.id);
                const closerPeerXor = xor(closerPeerKadId, kadId);
                if (xorCompare(closerPeerXor, peerXor) !== -1) {
                  log2.trace("skipping %p as they are not closer to %b than %p", closerPeer.id, key, peer);
                  continue;
                }
                log2.trace("querying closer peer %p", closerPeer.id);
                queryPeer(closerPeer.id, closerPeerKadId);
              }
            }
            queue.safeDispatchEvent("completed", {
              detail: event
            });
          }
        } catch (err) {
          if (!signal.aborted) {
            return queryErrorEvent({
              from: peer,
              error: err
            }, options);
          }
        } finally {
          compoundSignal.clear();
        }
      }, {
        distance: peerXor
      }).catch((err) => {
        log2.error(err);
      });
    }
    queryPeer(startingPeer, await convertPeerId(startingPeer));
    try {
      for await (const event of queue.toGenerator({ signal })) {
        if (event != null) {
          yield event;
        }
      }
    } catch (err) {
      if (signal.aborted) {
        throw new QueryAbortedError("Query aborted");
      }
      throw err;
    }
  }

  // node_modules/@libp2p/kad-dht/dist/src/query/manager.js
  var QueryManager = class {
    disjointPaths;
    alpha;
    shutDownController;
    running;
    logger;
    peerId;
    connectionManager;
    routingTable;
    initialQuerySelfHasRun;
    logPrefix;
    metrics;
    constructor(components, init) {
      var _a2, _b2, _c;
      const { disjointPaths = K, alpha = ALPHA, logPrefix } = init;
      this.logPrefix = logPrefix;
      this.disjointPaths = disjointPaths ?? K;
      this.running = false;
      this.alpha = alpha ?? ALPHA;
      this.initialQuerySelfHasRun = init.initialQuerySelfHasRun;
      this.routingTable = init.routingTable;
      this.logger = components.logger;
      this.peerId = components.peerId;
      this.connectionManager = components.connectionManager;
      this.metrics = {
        queries: (_a2 = components.metrics) == null ? void 0 : _a2.registerCounter(`${logPrefix.replaceAll(":", "_")}_queries_total`),
        errors: (_b2 = components.metrics) == null ? void 0 : _b2.registerCounter(`${logPrefix.replaceAll(":", "_")}_query_errors_total`),
        queryTime: (_c = components.metrics) == null ? void 0 : _c.registerMetric(`${logPrefix.replaceAll(":", "_")}_query_time_seconds`)
      };
      this.shutDownController = new AbortController();
      setMaxListeners(Infinity, this.shutDownController.signal);
    }
    isStarted() {
      return this.running;
    }
    /**
     * Starts the query manager
     */
    async start() {
      this.running = true;
      this.shutDownController = new AbortController();
      setMaxListeners(Infinity, this.shutDownController.signal);
    }
    /**
     * Stops all queries
     */
    async stop() {
      this.running = false;
      this.shutDownController.abort();
    }
    async *run(key, queryFunc, options = {}) {
      var _a2, _b2, _c, _d, _e;
      if (!this.running) {
        throw new Error("QueryManager not started");
      }
      const stopQueryTimer = (_a2 = this.metrics.queryTime) == null ? void 0 : _a2.timer();
      if (options.signal == null) {
        const signal2 = AbortSignal.timeout(DEFAULT_QUERY_TIMEOUT);
        setMaxListeners(Infinity, signal2);
        options = {
          ...options,
          signal: signal2
        };
      }
      const queryEarlyExitController = new AbortController();
      const signal = anySignal([
        this.shutDownController.signal,
        queryEarlyExitController.signal,
        options.signal
      ]);
      setMaxListeners(Infinity, signal, queryEarlyExitController.signal);
      const log2 = this.logger.forComponent(`${this.logPrefix}:query:` + toString2(key, "base58btc"));
      const startTime = Date.now();
      let queryFinished = false;
      try {
        if (options.isSelfQuery !== true && this.initialQuerySelfHasRun != null) {
          log2("waiting for initial query-self query before continuing");
          await raceSignal(this.initialQuerySelfHasRun.promise, signal);
          this.initialQuerySelfHasRun = void 0;
        }
        log2("query:start");
        (_c = (_b2 = this.metrics) == null ? void 0 : _b2.queries) == null ? void 0 : _c.increment();
        const id = await convertBuffer(key);
        const peers = this.routingTable.closestPeers(id);
        const peersToQuery = peers.slice(0, Math.min(this.disjointPaths, peers.length));
        if (peers.length === 0) {
          log2.error("Running query with no peers");
          return;
        }
        const peersSeen = new PeerSet();
        const paths = peersToQuery.map((peer, index) => {
          return queryPath({
            key,
            startingPeer: peer,
            ourPeerId: this.peerId,
            signal,
            query: queryFunc,
            pathIndex: index,
            numPaths: peersToQuery.length,
            alpha: this.alpha,
            queryFuncTimeout: options.queryFuncTimeout,
            log: log2,
            peersSeen,
            onProgress: options.onProgress,
            connectionManager: this.connectionManager
          });
        });
        for await (const event of src_default8(...paths)) {
          if (event.name === "QUERY_ERROR") {
            log2.error("query error", event.error);
          }
          if (event.name === "PEER_RESPONSE") {
            for (const peer of [...event.closer, ...event.providers]) {
              if (!await this.connectionManager.isDialable(peer.multiaddrs)) {
                continue;
              }
              await this.routingTable.add(peer.id);
            }
          }
          yield event;
        }
        queryFinished = true;
      } catch (err) {
        if (!queryFinished) {
          (_e = (_d = this.metrics) == null ? void 0 : _d.errors) == null ? void 0 : _e.increment();
        }
        if (!this.running && err.name === "QueryAbortedError") {
        } else {
          throw err;
        }
      } finally {
        if (!queryFinished) {
          log2("query exited early");
          queryEarlyExitController.abort();
        }
        signal.clear();
        stopQueryTimer == null ? void 0 : stopQueryTimer();
        log2("query:done in %dms", Date.now() - startTime);
      }
    }
  };

  // node_modules/@libp2p/kad-dht/dist/src/query-self.js
  var import_browser_shims387 = __toESM(require_browser_shims(), 1);

  // node_modules/it-length/dist/src/index.js
  var import_browser_shims385 = __toESM(require_browser_shims(), 1);
  function isAsyncIterable13(thing) {
    return thing[Symbol.asyncIterator] != null;
  }
  function length3(source) {
    if (isAsyncIterable13(source)) {
      return (async () => {
        let count = 0;
        for await (const _ of source) {
          count++;
        }
        return count;
      })();
    } else {
      let count = 0;
      for (const _ of source) {
        count++;
      }
      return count;
    }
  }
  var src_default11 = length3;

  // node_modules/p-event/index.js
  var import_browser_shims386 = __toESM(require_browser_shims(), 1);
  var normalizeEmitter = (emitter) => {
    const addListener = emitter.addEventListener || emitter.on || emitter.addListener;
    const removeListener = emitter.removeEventListener || emitter.off || emitter.removeListener;
    if (!addListener || !removeListener) {
      throw new TypeError("Emitter is not compatible");
    }
    return {
      addListener: addListener.bind(emitter),
      removeListener: removeListener.bind(emitter)
    };
  };
  function pEventMultiple(emitter, event, options) {
    let cancel;
    const returnValue = new Promise((resolve, reject) => {
      var _a2;
      options = {
        rejectionEvents: ["error"],
        multiArgs: false,
        resolveImmediately: false,
        ...options
      };
      if (!(options.count >= 0 && (options.count === Number.POSITIVE_INFINITY || Number.isInteger(options.count)))) {
        throw new TypeError("The `count` option should be at least 0 or more");
      }
      (_a2 = options.signal) == null ? void 0 : _a2.throwIfAborted();
      const events = [event].flat();
      const items = [];
      const { addListener, removeListener } = normalizeEmitter(emitter);
      const onItem = (...arguments_) => {
        const value = options.multiArgs ? arguments_ : arguments_[0];
        if (options.filter && !options.filter(value)) {
          return;
        }
        items.push(value);
        if (options.count === items.length) {
          cancel();
          resolve(items);
        }
      };
      const rejectHandler = (error) => {
        cancel();
        reject(error);
      };
      cancel = () => {
        for (const event2 of events) {
          removeListener(event2, onItem);
        }
        for (const rejectionEvent of options.rejectionEvents) {
          removeListener(rejectionEvent, rejectHandler);
        }
      };
      for (const event2 of events) {
        addListener(event2, onItem);
      }
      for (const rejectionEvent of options.rejectionEvents) {
        addListener(rejectionEvent, rejectHandler);
      }
      if (options.signal) {
        options.signal.addEventListener("abort", () => {
          rejectHandler(options.signal.reason);
        }, { once: true });
      }
      if (options.resolveImmediately) {
        resolve(items);
      }
    });
    returnValue.cancel = cancel;
    if (typeof options.timeout === "number") {
      const timeout = pTimeout(returnValue, { milliseconds: options.timeout });
      timeout.cancel = cancel;
      return timeout;
    }
    return returnValue;
  }
  function pEvent(emitter, event, options) {
    if (typeof options === "function") {
      options = { filter: options };
    }
    options = {
      ...options,
      count: 1,
      resolveImmediately: false
    };
    const arrayPromise = pEventMultiple(emitter, event, options);
    const promise = arrayPromise.then((array) => array[0]);
    promise.cancel = arrayPromise.cancel;
    return promise;
  }

  // node_modules/@libp2p/kad-dht/dist/src/query-self.js
  var QuerySelf = class {
    log;
    peerId;
    peerRouting;
    routingTable;
    count;
    interval;
    initialInterval;
    queryTimeout;
    started;
    timeoutId;
    controller;
    initialQuerySelfHasRun;
    querySelfPromise;
    constructor(components, init) {
      const { peerRouting, logPrefix, count, interval, queryTimeout, routingTable } = init;
      this.peerId = components.peerId;
      this.log = components.logger.forComponent(`${logPrefix}:query-self`);
      this.started = false;
      this.peerRouting = peerRouting;
      this.routingTable = routingTable;
      this.count = count ?? K;
      this.interval = interval ?? QUERY_SELF_INTERVAL;
      this.initialInterval = init.initialInterval ?? QUERY_SELF_INITIAL_INTERVAL;
      this.queryTimeout = queryTimeout ?? QUERY_SELF_TIMEOUT;
      this.initialQuerySelfHasRun = init.initialQuerySelfHasRun;
    }
    isStarted() {
      return this.started;
    }
    start() {
      if (this.started) {
        return;
      }
      this.started = true;
      clearTimeout(this.timeoutId);
      this.timeoutId = setTimeout(() => {
        this.querySelf().catch((err) => {
          this.log.error("error running self-query", err);
        });
      }, this.initialInterval);
    }
    stop() {
      this.started = false;
      if (this.timeoutId != null) {
        clearTimeout(this.timeoutId);
      }
      if (this.controller != null) {
        this.controller.abort();
      }
    }
    async querySelf() {
      if (!this.started) {
        this.log("skip self-query because we are not started");
        return;
      }
      if (this.querySelfPromise != null) {
        this.log("joining existing self query");
        return this.querySelfPromise.promise;
      }
      this.querySelfPromise = pDefer();
      if (this.started) {
        this.controller = new AbortController();
        const timeoutSignal = AbortSignal.timeout(this.queryTimeout);
        const signal = anySignal([this.controller.signal, timeoutSignal]);
        setMaxListeners(Infinity, signal, this.controller.signal, timeoutSignal);
        try {
          if (this.routingTable.size === 0) {
            this.log("routing table was empty, waiting for some peers before running query");
            await pEvent(this.routingTable, "peer:add", {
              signal
            });
          }
          this.log("run self-query, look for %d peers timing out after %dms", this.count, this.queryTimeout);
          const start2 = Date.now();
          const found = await pipe(this.peerRouting.getClosestPeers(this.peerId.toMultihash().bytes, {
            signal,
            isSelfQuery: true
          }), (source) => src_default7(source, this.count), async (source) => src_default11(source));
          this.log("self-query found %d peers in %dms", found, Date.now() - start2);
        } catch (err) {
          this.log.error("self-query error", err);
        } finally {
          signal.clear();
          if (this.initialQuerySelfHasRun != null) {
            this.initialQuerySelfHasRun.resolve();
            this.initialQuerySelfHasRun = void 0;
          }
        }
      }
      this.querySelfPromise.resolve();
      this.querySelfPromise = void 0;
      if (!this.started) {
        return;
      }
      this.timeoutId = setTimeout(() => {
        this.querySelf().catch((err) => {
          this.log.error("error running self-query", err);
        });
      }, this.interval);
    }
  };

  // node_modules/@libp2p/kad-dht/dist/src/routing-table/index.js
  var import_browser_shims389 = __toESM(require_browser_shims(), 1);

  // node_modules/@libp2p/kad-dht/dist/src/routing-table/k-bucket.js
  var import_browser_shims388 = __toESM(require_browser_shims(), 1);
  function arrayEquals2(array1, array2) {
    if (array1 === array2) {
      return true;
    }
    if (array1.length !== array2.length) {
      return false;
    }
    for (let i = 0, length4 = array1.length; i < length4; ++i) {
      if (array1[i] !== array2[i]) {
        return false;
      }
    }
    return true;
  }
  function ensureInt8(name3, val) {
    if (!(val instanceof Uint8Array)) {
      throw new TypeError(name3 + " is not a Uint8Array");
    }
    if (val.byteLength !== 32) {
      throw new TypeError(name3 + " had incorrect length");
    }
  }
  function isLeafBucket(obj) {
    return Array.isArray(obj == null ? void 0 : obj.peers);
  }
  var KBucket = class extends TypedEventEmitter {
    root;
    localPeer;
    prefixLength;
    splitThreshold;
    kBucketSize;
    numberOfNodesToPing;
    constructor(options) {
      super();
      this.localPeer = options.localPeer;
      this.prefixLength = options.prefixLength;
      this.kBucketSize = options.kBucketSize ?? KBUCKET_SIZE;
      this.splitThreshold = options.splitThreshold ?? this.kBucketSize;
      this.numberOfNodesToPing = options.numberOfNodesToPing ?? 3;
      ensureInt8("options.localPeer.kadId", options.localPeer.kadId);
      this.root = {
        prefix: "",
        depth: 0,
        peers: []
      };
    }
    /**
     * Adds a contact to the k-bucket.
     *
     * @param {Peer} peer - the contact object to add
     */
    add(peer) {
      ensureInt8("peer.kadId", peer == null ? void 0 : peer.kadId);
      const bucket = this._determineBucket(peer.kadId);
      if (this._indexOf(bucket, peer.kadId) > -1) {
        return;
      }
      if (bucket.peers.length === this.splitThreshold && bucket.depth < this.prefixLength) {
        this._split(bucket);
        this.add(peer);
        return;
      }
      if (bucket.peers.length < this.kBucketSize) {
        bucket.peers.push(peer);
        this.safeDispatchEvent("added", { detail: peer });
        return;
      }
      this.safeDispatchEvent("ping", {
        detail: {
          oldContacts: bucket.peers.slice(0, this.numberOfNodesToPing),
          newContact: peer
        }
      });
    }
    /**
     * Get 0-n closest contacts to the provided node id. "Closest" here means:
     * closest according to the XOR metric of the contact node id.
     *
     * @param {Uint8Array} id - Contact node id
     * @returns {Generator<Peer, void, undefined>} Array Maximum of n closest contacts to the node id
     */
    *closest(id, n = this.kBucketSize) {
      const list = new PeerDistanceList(id, n);
      for (const peer of this.toIterable()) {
        list.addWitKadId({ id: peer.peerId, multiaddrs: [] }, peer.kadId);
      }
      yield* src_default10(list.peers, (info) => info.id);
    }
    /**
     * Counts the total number of contacts in the tree.
     *
     * @returns {number} The number of contacts held in the tree
     */
    count() {
      function countBucket(bucket) {
        if (isLeafBucket(bucket)) {
          return bucket.peers.length;
        }
        let count = 0;
        if (bucket.left != null) {
          count += countBucket(bucket.left);
        }
        if (bucket.right != null) {
          count += countBucket(bucket.right);
        }
        return count;
      }
      return countBucket(this.root);
    }
    /**
     * Get a contact by its exact ID.
     * If this is a leaf, loop through the bucket contents and return the correct
     * contact if we have it or null if not. If this is an inner node, determine
     * which branch of the tree to traverse and repeat.
     *
     * @param {Uint8Array} kadId - The ID of the contact to fetch.
     * @returns {object | undefined} The contact if available, otherwise null
     */
    get(kadId) {
      const bucket = this._determineBucket(kadId);
      const index = this._indexOf(bucket, kadId);
      return bucket.peers[index];
    }
    /**
     * Removes contact with the provided id.
     *
     * @param {Uint8Array} kadId - The ID of the contact to remove
     */
    remove(kadId) {
      const bucket = this._determineBucket(kadId);
      const index = this._indexOf(bucket, kadId);
      if (index > -1) {
        const peer = bucket.peers.splice(index, 1)[0];
        this.safeDispatchEvent("removed", {
          detail: peer
        });
      }
    }
    /**
     * Similar to `toArray()` but instead of buffering everything up into an
     * array before returning it, yields contacts as they are encountered while
     * walking the tree.
     *
     * @returns {Iterable} All of the contacts in the tree, as an iterable
     */
    *toIterable() {
      function* iterate(bucket) {
        if (isLeafBucket(bucket)) {
          yield* bucket.peers;
          return;
        }
        yield* iterate(bucket.left);
        yield* iterate(bucket.right);
      }
      yield* iterate(this.root);
    }
    /**
     * Default distance function. Finds the XOR distance between firstId and
     * secondId.
     *
     * @param  {Uint8Array} firstId - Uint8Array containing first id.
     * @param  {Uint8Array} secondId - Uint8Array containing second id.
     * @returns {number} Integer The XOR distance between firstId and secondId.
     */
    distance(firstId, secondId) {
      return BigInt("0x" + toString2(xor(firstId, secondId), "base16"));
    }
    /**
     * Determines whether the id at the bitIndex is 0 or 1
     * Return left leaf if `id` at `bitIndex` is 0, right leaf otherwise
     *
     * @param {Uint8Array} kadId - Id to compare localNodeId with
     * @returns {LeafBucket} left leaf if id at bitIndex is 0, right leaf otherwise.
     */
    _determineBucket(kadId) {
      const bitString = toString2(kadId, "base2");
      const prefix = bitString.substring(0, this.prefixLength);
      function findBucket(bucket, bitIndex = 0) {
        if (isLeafBucket(bucket)) {
          return bucket;
        }
        const bit = prefix[bitIndex];
        if (bit === "0") {
          return findBucket(bucket.left, bitIndex + 1);
        }
        return findBucket(bucket.right, bitIndex + 1);
      }
      return findBucket(this.root);
    }
    /**
     * Returns the index of the contact with provided
     * id if it exists, returns -1 otherwise.
     *
     * @param {object} bucket - internal object that has 2 leafs: left and right
     * @param {Uint8Array} kadId - KadId of peer
     * @returns {number} Integer Index of contact with provided id if it exists, -1 otherwise.
     */
    _indexOf(bucket, kadId) {
      return bucket.peers.findIndex((peer) => arrayEquals2(peer.kadId, kadId));
    }
    /**
     * Modify the bucket, turn it from a leaf bucket to an internal bucket
     *
     * @param {any} bucket - bucket for splitting
     */
    _split(bucket) {
      const depth = bucket.depth + 1;
      const left = {
        prefix: "0",
        depth,
        peers: []
      };
      const right = {
        prefix: "1",
        depth,
        peers: []
      };
      for (const peer of bucket.peers) {
        const bitString = toString2(peer.kadId, "base2");
        if (bitString[depth] === "0") {
          left.peers.push(peer);
        } else {
          right.peers.push(peer);
        }
      }
      delete bucket.peers;
      bucket.left = left;
      bucket.right = right;
    }
  };

  // node_modules/@libp2p/kad-dht/dist/src/routing-table/index.js
  var KAD_CLOSE_TAG_NAME = "kad-close";
  var KAD_CLOSE_TAG_VALUE = 50;
  var KBUCKET_SIZE = 20;
  var PREFIX_LENGTH = 32;
  var PING_TIMEOUT = 1e4;
  var PING_CONCURRENCY = 10;
  var RoutingTable = class extends TypedEventEmitter {
    kBucketSize;
    kb;
    pingQueue;
    log;
    components;
    prefixLength;
    splitThreshold;
    pingTimeout;
    pingConcurrency;
    running;
    protocol;
    tagName;
    tagValue;
    metrics;
    constructor(components, init) {
      super();
      this.components = components;
      this.log = components.logger.forComponent(`${init.logPrefix}:routing-table`);
      this.kBucketSize = init.kBucketSize ?? KBUCKET_SIZE;
      this.pingTimeout = init.pingTimeout ?? PING_TIMEOUT;
      this.pingConcurrency = init.pingConcurrency ?? PING_CONCURRENCY;
      this.running = false;
      this.protocol = init.protocol;
      this.tagName = init.tagName ?? KAD_CLOSE_TAG_NAME;
      this.tagValue = init.tagValue ?? KAD_CLOSE_TAG_VALUE;
      this.prefixLength = init.prefixLength ?? PREFIX_LENGTH;
      this.splitThreshold = init.splitThreshold ?? KBUCKET_SIZE;
      this.pingQueue = new PeerQueue({
        concurrency: this.pingConcurrency,
        metricName: `${init.logPrefix.replaceAll(":", "_")}_ping_queue`,
        metrics: this.components.metrics
      });
      this.pingQueue.addEventListener("error", (evt) => {
        this.log.error("error pinging peer", evt.detail);
      });
      if (this.components.metrics != null) {
        this.metrics = {
          routingTableSize: this.components.metrics.registerMetric(`${init.logPrefix.replaceAll(":", "_")}_routing_table_size`),
          routingTableKadBucketTotal: this.components.metrics.registerMetric(`${init.logPrefix.replaceAll(":", "_")}_routing_table_kad_bucket_total`),
          routingTableKadBucketAverageOccupancy: this.components.metrics.registerMetric(`${init.logPrefix.replaceAll(":", "_")}_routing_table_kad_bucket_average_occupancy`),
          routingTableKadBucketMaxDepth: this.components.metrics.registerMetric(`${init.logPrefix.replaceAll(":", "_")}_routing_table_kad_bucket_max_depth`),
          kadBucketEvents: this.components.metrics.registerCounterGroup(`${init.logPrefix.replaceAll(":", "_")}_kad_bucket_events_total`)
        };
      }
    }
    isStarted() {
      return this.running;
    }
    async start() {
      this.running = true;
      const kBuck = new KBucket({
        localPeer: {
          kadId: await convertPeerId(this.components.peerId),
          peerId: this.components.peerId
        },
        kBucketSize: this.kBucketSize,
        prefixLength: this.prefixLength,
        splitThreshold: this.splitThreshold,
        numberOfNodesToPing: 1
      });
      this.kb = kBuck;
      kBuck.addEventListener("ping", (evt) => {
        var _a2;
        (_a2 = this.metrics) == null ? void 0 : _a2.kadBucketEvents.increment({ ping: true });
        this._onPing(evt).catch((err) => {
          var _a3;
          (_a3 = this.metrics) == null ? void 0 : _a3.kadBucketEvents.increment({ ping_error: true });
          this.log.error("could not process k-bucket ping event", err);
        });
      });
      let peerStorePeers = 0;
      for (const peer of await this.components.peerStore.all()) {
        if (peer.protocols.includes(this.protocol)) {
          const id = await convertPeerId(peer.id);
          this.kb.add({ kadId: id, peerId: peer.id });
          peerStorePeers++;
        }
      }
      this.log("added %d peer store peers to the routing table", peerStorePeers);
      this._tagPeers(kBuck);
    }
    async stop() {
      this.running = false;
      this.pingQueue.clear();
      this.kb = void 0;
    }
    /**
     * Keep track of our k-closest peers and tag them in the peer store as such
     * - this will lower the chances that connections to them get closed when
     * we reach connection limits
     */
    _tagPeers(kBuck) {
      let kClosest = new PeerSet();
      const updatePeerTags = debounce3(() => {
        const newClosest = new PeerSet(kBuck.closest(kBuck.localPeer.kadId, KBUCKET_SIZE));
        const addedPeers = newClosest.difference(kClosest);
        const removedPeers = kClosest.difference(newClosest);
        Promise.resolve().then(async () => {
          for (const peer of addedPeers) {
            await this.components.peerStore.merge(peer, {
              tags: {
                [this.tagName]: {
                  value: this.tagValue
                }
              }
            });
          }
          for (const peer of removedPeers) {
            await this.components.peerStore.merge(peer, {
              tags: {
                [this.tagName]: void 0
              }
            });
          }
        }).catch((err) => {
          this.log.error("Could not update peer tags", err);
        });
        kClosest = newClosest;
      });
      kBuck.addEventListener("added", (evt) => {
        var _a2;
        updatePeerTags();
        (_a2 = this.metrics) == null ? void 0 : _a2.kadBucketEvents.increment({ peer_added: true });
        this.safeDispatchEvent("peer:add", { detail: evt.detail.peerId });
      });
      kBuck.addEventListener("removed", (evt) => {
        var _a2;
        updatePeerTags();
        (_a2 = this.metrics) == null ? void 0 : _a2.kadBucketEvents.increment({ peer_removed: true });
        this.safeDispatchEvent("peer:remove", { detail: evt.detail.peerId });
      });
    }
    /**
     * Called on the `ping` event from `k-bucket` when a bucket is full
     * and cannot split.
     *
     * `oldContacts.length` is defined by the `numberOfNodesToPing` param
     * passed to the `k-bucket` constructor.
     *
     * `oldContacts` will not be empty and is the list of contacts that
     * have not been contacted for the longest.
     */
    async _onPing(evt) {
      if (!this.running) {
        return;
      }
      const { oldContacts, newContact } = evt.detail;
      const results = await Promise.all(oldContacts.map(async (oldContact) => {
        const pingJob = this.pingQueue.find(oldContact.peerId);
        if (pingJob != null) {
          return pingJob.join();
        }
        return this.pingQueue.add(async () => {
          let stream;
          try {
            const options = {
              signal: AbortSignal.timeout(this.pingTimeout)
            };
            this.log("pinging old contact %p", oldContact.peerId);
            const connection = await this.components.connectionManager.openConnection(oldContact.peerId, options);
            stream = await connection.newStream(this.protocol, options);
            const pb = pbStream2(stream);
            await pb.write({
              type: MessageType.PING
            }, Message, options);
            const response = await pb.read(Message, options);
            await pb.unwrap().close();
            if (response.type !== MessageType.PING) {
              throw new InvalidMessageError(`Incorrect message type received, expected PING got ${response.type}`);
            }
            return true;
          } catch (err) {
            if (this.running && this.kb != null) {
              this.log.error("could not ping peer %p", oldContact.peerId, err);
              this.log("evicting old contact after ping failed %p", oldContact.peerId);
              this.kb.remove(oldContact.kadId);
            }
            stream == null ? void 0 : stream.abort(err);
            return false;
          } finally {
            this.updateMetrics();
          }
        }, {
          peerId: oldContact.peerId
        });
      }));
      const responded = results.filter((res) => res).length;
      if (this.running && responded < oldContacts.length && this.kb != null) {
        this.log("adding new contact %p", newContact.peerId);
        this.kb.add(newContact);
      }
    }
    // -- Public Interface
    /**
     * Amount of currently stored peers
     */
    get size() {
      if (this.kb == null) {
        return 0;
      }
      return this.kb.count();
    }
    /**
     * Find a specific peer by id
     */
    async find(peer) {
      var _a2, _b2;
      const key = await convertPeerId(peer);
      return (_b2 = (_a2 = this.kb) == null ? void 0 : _a2.get(key)) == null ? void 0 : _b2.peerId;
    }
    /**
     * Retrieve the closest peers to the given kadId
     */
    closestPeer(kadId) {
      const res = this.closestPeers(kadId, 1);
      if (res.length > 0) {
        return res[0];
      }
      return void 0;
    }
    /**
     * Retrieve the `count`-closest peers to the given kadId
     */
    closestPeers(kadId, count = this.kBucketSize) {
      if (this.kb == null) {
        return [];
      }
      return [...this.kb.closest(kadId, count)];
    }
    /**
     * Add or update the routing table with the given peer
     */
    async add(peerId2) {
      if (this.kb == null) {
        throw new Error("RoutingTable is not started");
      }
      const kadId = await convertPeerId(peerId2);
      this.kb.add({ kadId, peerId: peerId2 });
      this.log.trace("added %p with kad id %b", peerId2, kadId);
      this.updateMetrics();
    }
    /**
     * Remove a given peer from the table
     */
    async remove(peer) {
      if (this.kb == null) {
        throw new Error("RoutingTable is not started");
      }
      const id = await convertPeerId(peer);
      this.kb.remove(id);
      this.updateMetrics();
    }
    updateMetrics() {
      if (this.metrics == null || this.kb == null) {
        return;
      }
      let size = 0;
      let buckets = 0;
      let maxDepth = 0;
      function count(bucket) {
        if (isLeafBucket(bucket)) {
          if (bucket.depth > maxDepth) {
            maxDepth = bucket.depth;
          }
          buckets++;
          size += bucket.peers.length;
          return;
        }
        count(bucket.left);
        count(bucket.right);
      }
      count(this.kb.root);
      this.metrics.routingTableSize.update(size);
      this.metrics.routingTableKadBucketTotal.update(buckets);
      this.metrics.routingTableKadBucketAverageOccupancy.update(Math.round(size / buckets));
      this.metrics.routingTableKadBucketMaxDepth.update(maxDepth);
    }
  };

  // node_modules/@libp2p/kad-dht/dist/src/routing-table/refresh.js
  var import_browser_shims391 = __toESM(require_browser_shims(), 1);

  // node_modules/@libp2p/kad-dht/dist/src/routing-table/generated-prefix-list-browser.js
  var import_browser_shims390 = __toESM(require_browser_shims(), 1);
  var generated_prefix_list_browser_default = [
    77591,
    22417,
    43971,
    28421,
    740,
    29829,
    71467,
    228973,
    196661,
    78537,
    27689,
    36431,
    44415,
    14362,
    19456,
    106025,
    96308,
    2882,
    49509,
    21149,
    87173,
    131409,
    75844,
    23676,
    121838,
    30291,
    17492,
    2953,
    7564,
    110620,
    129477,
    127283,
    53113,
    72417,
    165166,
    109690,
    21200,
    102125,
    24049,
    71504,
    90342,
    25307,
    72039,
    26812,
    26715,
    32264,
    133800,
    71161,
    88956,
    171987,
    51779,
    24425,
    16671,
    30251,
    186294,
    247761,
    14202,
    2121,
    8465,
    35024,
    4876,
    85917,
    169730,
    3638,
    256836,
    96184,
    943,
    18678,
    6583,
    52907,
    35807,
    112254,
    214097,
    18796,
    11595,
    9243,
    23554,
    887,
    268203,
    382004,
    24590,
    111335,
    11625,
    16619,
    29039,
    102425,
    69006,
    97976,
    92362,
    32552,
    63717,
    41433,
    128974,
    137630,
    59943,
    10019,
    13986,
    35430,
    33665,
    108037,
    43799,
    43280,
    38195,
    29078,
    58629,
    18265,
    14425,
    46832,
    235538,
    40830,
    77881,
    110717,
    58937,
    3463,
    325358,
    51300,
    47623,
    117252,
    19007,
    10170,
    20540,
    91237,
    294813,
    4951,
    79841,
    56232,
    36270,
    128547,
    69209,
    66275,
    100156,
    32063,
    73531,
    34439,
    80937,
    28892,
    44466,
    88595,
    216307,
    32583,
    49620,
    16605,
    82127,
    45807,
    21630,
    78726,
    20235,
    40163,
    111007,
    96926,
    5567,
    72083,
    21665,
    58844,
    39419,
    179767,
    48328,
    42662,
    51550,
    5251,
    37811,
    49608,
    81056,
    50854,
    55513,
    20922,
    18891,
    197409,
    164656,
    32593,
    71449,
    220474,
    58919,
    85682,
    67854,
    13758,
    35066,
    3565,
    61905,
    214793,
    119572,
    141419,
    21504,
    10302,
    27354,
    67003,
    46131,
    32668,
    15165,
    64871,
    34450,
    17821,
    2757,
    11452,
    34189,
    5160,
    12257,
    85523,
    560,
    53385,
    65887,
    119549,
    135620,
    312353,
    115979,
    122356,
    10867,
    193231,
    124537,
    54783,
    90675,
    120791,
    4715,
    142253,
    50943,
    17271,
    43358,
    25331,
    4917,
    120566,
    34580,
    12878,
    33786,
    160528,
    32523,
    4869,
    301307,
    104817,
    81491,
    23276,
    8832,
    97911,
    31265,
    52065,
    7998,
    49622,
    9715,
    43998,
    34091,
    84587,
    20664,
    69041,
    29419,
    53205,
    10838,
    58288,
    116145,
    6185,
    5154,
    141795,
    35924,
    21307,
    144738,
    43730,
    12085,
    8279,
    10002,
    119,
    133779,
    199668,
    72938,
    31768,
    39176,
    67875,
    38453,
    9700,
    44144,
    4121,
    116048,
    41733,
    12868,
    82669,
    92308,
    128,
    34262,
    11332,
    7712,
    90764,
    36141,
    13553,
    71312,
    77470,
    117314,
    96549,
    49135,
    23602,
    54468,
    28605,
    6327,
    62308,
    17171,
    67531,
    21319,
    14105,
    894,
    107722,
    46157,
    8503,
    51069,
    100472,
    45138,
    15246,
    14577,
    35609,
    191464,
    1757,
    13364,
    161349,
    32067,
    91705,
    81144,
    52339,
    5408,
    91066,
    21983,
    14157,
    100545,
    4372,
    26630,
    129112,
    1423,
    29676,
    213626,
    4397,
    88436,
    99190,
    6877,
    49958,
    26122,
    114348,
    60661,
    29818,
    293118,
    50042,
    179738,
    16400,
    163423,
    89627,
    31040,
    43973,
    36638,
    45952,
    5153,
    1894,
    109322,
    1898,
    134021,
    12402,
    112077,
    68309,
    190269,
    69866,
    31938,
    107383,
    11522,
    105232,
    11248,
    14868,
    39852,
    71707,
    186525,
    16530,
    38162,
    106212,
    11700,
    5130,
    16608,
    26998,
    59586,
    108399,
    230033,
    43683,
    48135,
    82179,
    2073,
    5015,
    196684,
    189293,
    16378,
    23452,
    8301,
    35640,
    11632,
    214551,
    29240,
    57644,
    33137,
    91949,
    55157,
    52384,
    117313,
    5090,
    17717,
    89668,
    49363,
    82238,
    241035,
    66216,
    29066,
    184088,
    97206,
    62820,
    26595,
    4241,
    135635,
    173672,
    8202,
    459,
    71355,
    146294,
    29587,
    3008,
    135385,
    141203,
    14803,
    6634,
    45094,
    69362,
    50925,
    546,
    51884,
    62011,
    83296,
    234584,
    44515,
    56050,
    89476,
    87751,
    19373,
    12691,
    149923,
    19794,
    13833,
    35846,
    87557,
    58339,
    2884,
    19145,
    25647,
    12224,
    11024,
    77338,
    64608,
    122297,
    53025,
    7205,
    36189,
    36294,
    170779,
    21750,
    7739,
    173883,
    75192,
    35664,
    224240,
    113121,
    30181,
    26267,
    27036,
    117827,
    92015,
    106516,
    55628,
    203549,
    67949,
    60462,
    60844,
    35911,
    20457,
    1820,
    920,
    19773,
    8738,
    73173,
    181993,
    38521,
    98254,
    76257,
    46008,
    92796,
    5384,
    26868,
    151566,
    22124,
    2411,
    15919,
    186872,
    180021,
    28099,
    152961,
    78811,
    80237,
    62352,
    102653,
    74259,
    184890,
    16792,
    123702,
    224945,
    29940,
    19512,
    75283,
    14059,
    112691,
    92811,
    233329,
    20411,
    138569,
    53341,
    109802,
    50600,
    134528,
    66747,
    5529,
    166531,
    31578,
    64732,
    67189,
    1596,
    126357,
    967,
    167999,
    206598,
    109752,
    119431,
    207825,
    78791,
    91938,
    10301,
    27311,
    24233,
    252343,
    28831,
    32812,
    66002,
    112267,
    90895,
    8786,
    8095,
    16824,
    22866,
    21813,
    60507,
    174833,
    19549,
    130985,
    117051,
    52110,
    6938,
    81923,
    123864,
    38061,
    919,
    18680,
    53534,
    46739,
    112893,
    161529,
    85429,
    26761,
    11900,
    81121,
    91968,
    15390,
    217947,
    56524,
    1713,
    6654,
    37089,
    85630,
    138866,
    61850,
    16491,
    75577,
    16884,
    98296,
    73523,
    6140,
    44645,
    6062,
    36366,
    29844,
    57946,
    37932,
    42472,
    5266,
    20834,
    19309,
    33753,
    127182,
    134259,
    35810,
    41805,
    45878,
    312001,
    14881,
    47757,
    49251,
    120050,
    44252,
    3708,
    25856,
    107864,
    120347,
    1228,
    36550,
    41682,
    34496,
    47025,
    8393,
    173365,
    246526,
    12894,
    161607,
    35670,
    90785,
    126572,
    2095,
    124731,
    157033,
    58694,
    554,
    12786,
    9642,
    4817,
    16136,
    47864,
    174698,
    66992,
    4639,
    69284,
    10625,
    40710,
    27763,
    51738,
    30404,
    264105,
    137904,
    109882,
    52487,
    42824,
    57514,
    2740,
    10479,
    146799,
    107390,
    16586,
    88038,
    174951,
    9410,
    16185,
    44158,
    5568,
    40658,
    46108,
    12763,
    97385,
    26175,
    108859,
    664,
    230732,
    67470,
    46663,
    14395,
    50750,
    141320,
    93140,
    15361,
    47997,
    55784,
    6791,
    307840,
    118569,
    107326,
    18056,
    58281,
    260415,
    54691,
    8790,
    73332,
    45633,
    7511,
    45674,
    143373,
    14031,
    11799,
    94491,
    35646,
    96544,
    14560,
    26049,
    32983,
    25791,
    83814,
    42094,
    231370,
    63955,
    139212,
    2359,
    169908,
    3108,
    183486,
    105867,
    28197,
    32941,
    124968,
    26402,
    88267,
    149768,
    23053,
    3078,
    19091,
    52924,
    25383,
    19209,
    111548,
    97361,
    3959,
    24880,
    235061,
    9099,
    24921,
    161254,
    151405,
    20508,
    7159,
    34381,
    20133,
    11434,
    74036,
    19974,
    34769,
    36585,
    1076,
    22454,
    17354,
    38727,
    235160,
    111547,
    96454,
    117448,
    156940,
    91330,
    37299,
    7310,
    26915,
    117060,
    51369,
    22620,
    61861,
    322264,
    106850,
    111694,
    15091,
    2624,
    40345,
    300446,
    177064,
    1707,
    27389,
    54792,
    327783,
    132669,
    183543,
    59003,
    17744,
    20603,
    151134,
    106923,
    53084,
    71803,
    279424,
    319816,
    11579,
    21946,
    16728,
    38274,
    72711,
    5085,
    83391,
    88646,
    40159,
    25027,
    34680,
    10752,
    12988,
    54126,
    30365,
    18338,
    100445,
    230674,
    44874,
    84974,
    143877,
    123253,
    139372,
    28082,
    91477,
    144002,
    13096,
    219729,
    46016,
    50029,
    42377,
    14601,
    6660,
    58244,
    58978,
    23918,
    88206,
    113611,
    64452,
    17541,
    41032,
    10942,
    12021,
    49189,
    10978,
    40175,
    37156,
    10947,
    71709,
    106894,
    112538,
    57007,
    137486,
    150608,
    152719,
    40615,
    7746,
    279716,
    13101,
    19524,
    28708,
    40578,
    72320,
    1096,
    182051,
    94527,
    51275,
    22833,
    45164,
    81917,
    77519,
    48508,
    5421,
    140302,
    37845,
    149830,
    5587,
    27579,
    5357,
    428725,
    248187,
    6326,
    206760,
    39814,
    32585,
    89923,
    44341,
    288753,
    284443,
    96368,
    31201,
    94189,
    119504,
    20359,
    52073,
    103216,
    179,
    27934,
    32801,
    96035,
    34111,
    34309,
    101326,
    18198,
    20704,
    210266,
    37643,
    27880,
    141873,
    106e3,
    19414,
    56614,
    167714,
    66483,
    107885,
    86602,
    4379,
    20796,
    75467,
    4987,
    5017,
    118857,
    26003,
    34308,
    114428,
    29198,
    6686,
    29697,
    73632,
    3739,
    69795,
    16798,
    41504,
    7207,
    30722,
    21436,
    36735,
    28067,
    28545,
    3239,
    11221,
    36031,
    41889,
    100010,
    19247,
    317673,
    29495,
    174554,
    6424,
    129725,
    53845,
    94986,
    7955,
    59676,
    2604,
    191497,
    19735,
    102214,
    62954,
    23844,
    11872,
    179525,
    261436,
    34492,
    428,
    78404,
    142035,
    16747,
    17246,
    27578,
    37021,
    33672,
    57944,
    26056,
    135760,
    2369,
    61674,
    122066,
    31327,
    19374,
    157065,
    40553,
    130982,
    69619,
    71290,
    38855,
    72100,
    92903,
    95940,
    51422,
    165999,
    65713,
    57873,
    50726,
    7288,
    20272,
    2081,
    42326,
    22624,
    81120,
    57914,
    79352,
    19447,
    1684,
    72302,
    11774,
    302559,
    161481,
    96396,
    13692,
    414988,
    3721,
    79066,
    56627,
    46883,
    21150,
    11747,
    12184,
    5856,
    113458,
    176117,
    84416,
    52079,
    27933,
    3354,
    59765,
    141359,
    2212,
    216309,
    2555,
    23458,
    196722,
    142463,
    45701,
    44548,
    28798,
    19418,
    215,
    29916,
    9396,
    10574,
    114226,
    84475,
    13520,
    18694,
    34056,
    4524,
    90302,
    62930,
    13539,
    19407,
    77209,
    7728,
    38088,
    9535,
    2263,
    23875,
    183945,
    17750,
    26274,
    67172,
    10585,
    28042,
    22199,
    7478,
    51331,
    66030,
    26774,
    192929,
    31434,
    25850,
    50197,
    52926,
    178158,
    4679,
    181256,
    70184,
    229600,
    9959,
    105594,
    72158,
    73974,
    2726,
    35085,
    78087,
    23284,
    35568,
    51713,
    155676,
    5401,
    27254,
    11966,
    17569,
    223253,
    71993,
    103357,
    111477,
    55722,
    30504,
    26034,
    46774,
    35392,
    36285,
    214814,
    41143,
    163465,
    1051,
    16094,
    81044,
    6636,
    76489,
    179102,
    20712,
    39178,
    35683,
    125177,
    54219,
    30617,
    52994,
    25324,
    50123,
    2543,
    87529,
    58995,
    10688,
    125199,
    12388,
    60158,
    125481,
    131646,
    7642,
    133350,
    65874,
    3438,
    97277,
    101450,
    10075,
    56344,
    116821,
    50778,
    60547,
    98016,
    106135,
    13859,
    14255,
    16300,
    77373,
    173521,
    8285,
    45932,
    37426,
    4054,
    114295,
    55947,
    7703,
    39114,
    52,
    51119,
    128135,
    19714,
    60715,
    9554,
    50492,
    88180,
    2823,
    118271,
    52993,
    122625,
    97919,
    23859,
    37895,
    25040,
    33614,
    32102,
    20431,
    3577,
    9275,
    15686,
    43031,
    157741,
    110358,
    1884,
    40291,
    125391,
    13736,
    5008,
    64881,
    87336,
    77381,
    70711,
    43032,
    49155,
    118587,
    70494,
    4318,
    10168,
    30126,
    12580,
    10524,
    280104,
    104001,
    145413,
    2862,
    84140,
    6603,
    106005,
    13566,
    12780,
    11251,
    42830,
    571,
    179910,
    82443,
    13146,
    469,
    42714,
    32591,
    265217,
    424024,
    92553,
    54721,
    134100,
    6007,
    15242,
    114681,
    59030,
    16718,
    85465,
    200214,
    85982,
    55174,
    165013,
    23493,
    56964,
    82529,
    109150,
    32706,
    27568,
    82442,
    5350,
    14976,
    13165,
    44890,
    60021,
    21343,
    33978,
    17264,
    4655,
    22328,
    27819,
    75730,
    16567,
    55483,
    14510,
    17926,
    45827,
    150609,
    3704,
    7385,
    272531,
    161543,
    76904,
    122163,
    52405,
    2039,
    19165,
    41623,
    14423,
    228354,
    3369,
    176360,
    85491,
    7122,
    35789,
    303724,
    4465,
    13628,
    2233,
    55311,
    118771,
    20713,
    10006,
    221519,
    45115,
    71021,
    35650,
    29775,
    7337,
    10864,
    20665,
    21142,
    1746,
    15080,
    1624,
    32449,
    10905,
    105743,
    229797,
    7701,
    3940,
    22997,
    178467,
    57208,
    389057,
    39683,
    59403,
    63344,
    63125,
    54847,
    69691,
    18336,
    56448,
    3362,
    37202,
    18282,
    29648,
    138224,
    35867,
    10495,
    5911,
    28814,
    26653,
    31514,
    176702,
    26550,
    45621,
    11734,
    4525,
    40543,
    73944,
    121080,
    27858,
    155561,
    14887,
    44670,
    30742,
    8796,
    107455,
    113472,
    56369,
    75581,
    183777,
    240095,
    133699,
    153299,
    8768,
    160464,
    26058,
    49078,
    103971,
    21875,
    71486,
    44888,
    17156,
    9678,
    89541,
    123019,
    102337,
    3972,
    83930,
    21245,
    87852,
    109660,
    287918,
    183019,
    686,
    10100,
    39177,
    283941,
    11274,
    24736,
    26793,
    26214,
    25995,
    77011,
    141580,
    4070,
    23742,
    46285,
    46632,
    30700,
    26669,
    19056,
    35951,
    115575,
    174034,
    56097,
    35463,
    87425,
    24575,
    44245,
    38701,
    82317,
    85922,
    281616,
    100333,
    147697,
    61503,
    7730,
    84330,
    8530,
    59917,
    61597,
    17173,
    9092,
    32658,
    90288,
    193136,
    39023,
    20381,
    56654,
    31132,
    7779,
    1919,
    1375,
    117128,
    30819,
    11169,
    40938,
    23935,
    115201,
    101155,
    151034,
    4835,
    11231,
    74550,
    89388,
    59951,
    91704,
    107312,
    167882,
    115062,
    12732,
    72738,
    88703,
    464019,
    158267,
    57995,
    60496,
    737,
    14371,
    123867,
    4174,
    243339,
    159946,
    7568,
    16025,
    134556,
    110916,
    38103,
    191,
    80226,
    88794,
    29688,
    27230,
    10454,
    76308,
    57647,
    77409,
    113483,
    66864,
    14745,
    19808,
    12023,
    46583,
    84805,
    16015,
    17102,
    2231,
    20611,
    3547,
    95740,
    250131,
    34559,
    108894,
    8498,
    15853,
    159169,
    148920,
    20942,
    2813,
    93160,
    45188,
    210613,
    45531,
    52587,
    149062,
    39782,
    28194,
    57849,
    60965,
    84954,
    89766,
    84453,
    100927,
    16501,
    27658,
    165311,
    103841,
    54192,
    207341,
    19558,
    20084,
    319622,
    5672,
    205467,
    98462,
    61849,
    36279,
    13609,
    147177,
    24726,
    165015,
    209489,
    59591,
    31157,
    6551,
    117580,
    75060,
    141146,
    277310,
    21072,
    22023,
    106474,
    63041,
    137443,
    122965,
    68371,
    5383,
    42146,
    98961,
    113467,
    30863,
    23794,
    4843,
    99630,
    30392,
    82679,
    13699,
    241612,
    33601,
    93146,
    24319,
    18643,
    32155,
    95669,
    40440,
    15333,
    34089,
    67799,
    142144,
    58245,
    38633,
    114531,
    117400,
    77861,
    188726,
    5507,
    2568,
    8853,
    10987,
    107222,
    2663,
    2421,
    11530,
    13345,
    30075,
    41785,
    118661,
    104786,
    17459,
    12490,
    16281,
    71936,
    193555,
    17431,
    5944,
    71758,
    26485,
    77317,
    20803,
    367167,
    158,
    7362,
    93430,
    11735,
    172445,
    46002,
    11532,
    54482,
    930,
    62911,
    2235,
    23004,
    179236,
    4764,
    101859,
    208113,
    22477,
    55163,
    95579,
    14098,
    67320,
    162556,
    90709,
    156949,
    3826,
    57492,
    4025,
    34092,
    87442,
    104565,
    6718,
    186015,
    28214,
    14209,
    10039,
    107186,
    233912,
    58877,
    81637,
    55265,
    39828,
    6194,
    145813,
    50831,
    105849,
    4974,
    88319,
    122296,
    10272,
    197216,
    95714,
    51540,
    72418,
    23324,
    91555,
    8743,
    140452,
    250249,
    51666,
    34124,
    7229,
    38592,
    129641,
    78169,
    174242,
    22464,
    149964,
    51450,
    14034,
    10026,
    95376,
    26190,
    120062,
    14401,
    8700,
    265,
    31386,
    143573,
    7203,
    229889,
    61567,
    4227,
    140981,
    2466,
    72052,
    10787,
    10062,
    30958,
    6099,
    38471,
    30103,
    23202,
    208101,
    70847,
    467,
    58934,
    32271,
    32984,
    36637,
    24107,
    30771,
    17109,
    73353,
    13650,
    2098,
    157040,
    67366,
    66904,
    106018,
    265380,
    107238,
    18535,
    44025,
    32681,
    144983,
    62505,
    91295,
    56120,
    3082,
    77508,
    10322,
    63023,
    36700,
    81885,
    224127,
    16721,
    45023,
    239261,
    111272,
    13852,
    7866,
    149243,
    204199,
    32309,
    22084,
    42029,
    38316,
    126644,
    104973,
    14406,
    43454,
    67322,
    61310,
    15789,
    40285,
    24026,
    181047,
    6301,
    70927,
    23319,
    115823,
    27248,
    66693,
    115875,
    278566,
    63007,
    146844,
    56841,
    59007,
    87368,
    180001,
    22370,
    42114,
    80605,
    12022,
    10374,
    308,
    25079,
    14689,
    12618,
    63368,
    7936,
    264973,
    212291,
    136713,
    95999,
    105801,
    18965,
    32075,
    48700,
    52230,
    35119,
    96912,
    32992,
    8586,
    16606,
    101333,
    101812,
    14969,
    39930,
    759,
    193090,
    27387,
    42914,
    12937,
    5058,
    62646,
    64528,
    38624,
    25743,
    37502,
    3716,
    4435,
    30352,
    178687,
    26461,
    132611,
    42002,
    138442,
    35833,
    59582,
    16345,
    8048,
    60319,
    49349,
    309,
    47800,
    49739,
    90482,
    26405,
    34470,
    63786,
    32479,
    85028,
    39866,
    47846,
    11649,
    23934,
    29466,
    2816,
    42864,
    31828,
    7410,
    74885,
    49632,
    47629,
    111801,
    90749,
    19536,
    18767,
    105764,
    59606,
    21223,
    10746,
    76298,
    22220,
    39408,
    7190,
    79654,
    64856,
    11602,
    82156,
    272765,
    17079,
    70089,
    245473,
    51813,
    184407,
    384678,
    1576,
    122249,
    5064,
    27481,
    6188,
    25790,
    74361,
    27541,
    318284,
    45430,
    31488,
    620,
    93579,
    45723,
    192118,
    22670,
    51913,
    4162,
    70244,
    35966,
    26397,
    16199,
    50899,
    209613,
    121702,
    287507,
    2993,
    36101,
    132229,
    67345,
    33062,
    76295,
    118628,
    78705,
    52316,
    34375,
    107083,
    107454,
    44863,
    127561,
    33964,
    3073,
    154010,
    190914,
    55967,
    39074,
    6272,
    31047,
    5550,
    41123,
    26154,
    98638,
    47110,
    19998,
    148091,
    50229,
    31329,
    59900,
    195442,
    19106,
    61347,
    73497,
    70015,
    682,
    45850,
    25776,
    38022,
    148951,
    6288,
    37411,
    232526,
    109277,
    27286,
    32342,
    9262,
    5220,
    16651,
    23175,
    46740,
    129438,
    78614,
    121925,
    66914,
    88710,
    127952,
    5563,
    21500,
    34521,
    10739,
    14863,
    191006,
    62956,
    17359,
    16749,
    67027,
    56284,
    69134,
    43301,
    35039,
    58883,
    54466,
    60823,
    404451,
    75743,
    59856,
    86979,
    7923,
    34273,
    83785,
    32142,
    7693,
    268986,
    197428,
    282681,
    17049,
    22346,
    22990,
    92245,
    107180,
    3357,
    37104,
    96724,
    49153,
    7683,
    31197,
    43267,
    82231,
    164276,
    23696,
    20848,
    188364,
    22309,
    24821,
    158707,
    1018,
    22514,
    70922,
    27792,
    45589,
    59709,
    10765,
    736,
    35218,
    63479,
    51987,
    24275,
    63588,
    55361,
    92929,
    81964,
    4658,
    20122,
    12330,
    44058,
    13065,
    311456,
    72224,
    8337,
    211229,
    38979,
    22590,
    138478,
    52757,
    32595,
    133600,
    8838,
    31549,
    94412,
    43391,
    90056,
    1585,
    94802,
    127271,
    6223,
    31889,
    137038,
    132910,
    2165,
    57616,
    230152,
    6080,
    10748,
    36737,
    74579,
    134062,
    50525,
    180532,
    119270,
    34556,
    76155,
    82394,
    52595,
    29258,
    31435,
    87820,
    67996,
    26943,
    183878,
    38007,
    2410,
    13526,
    180297,
    69856,
    3503,
    187396,
    167700,
    7838,
    16701,
    9199,
    56267,
    3661,
    37407,
    65994,
    23767,
    5708,
    62508,
    221700,
    67088,
    86978,
    46776,
    84434,
    32088,
    5612,
    9149,
    88244,
    21685,
    95151,
    46750,
    189612,
    2979,
    506311,
    2594,
    3628,
    40074,
    105039,
    78243,
    28523,
    6651,
    38058,
    71999,
    30992,
    12764,
    68261,
    108991,
    6165,
    26450,
    61961,
    13400,
    22426,
    7490,
    60890,
    109623,
    2070,
    12958,
    50355,
    67979,
    257096,
    7213,
    42578,
    52121,
    35716,
    65461,
    7516,
    124758,
    39268,
    302,
    64712,
    14977,
    1467,
    219452,
    2840,
    34229,
    11121,
    21602,
    19270,
    63574,
    8024,
    1532,
    17331,
    79839,
    78885,
    52029,
    180767,
    57957,
    6069,
    91265,
    61380,
    55767,
    8927,
    32881,
    287603,
    22149,
    35029,
    68876,
    6428,
    199567,
    46926,
    13412,
    104132,
    21434,
    366616,
    45060,
    110046,
    81924,
    128910,
    45886,
    52821,
    130416,
    29416,
    77342,
    21762,
    67329,
    121432,
    79924,
    11724,
    38625,
    81006,
    102033,
    28338,
    13326,
    3250,
    82056,
    82526,
    38212,
    21112,
    12382,
    111495,
    3263,
    7414,
    86274,
    93490,
    40844,
    30224,
    45212,
    24019,
    48411,
    71367,
    24941,
    76729,
    57776,
    3769,
    38114,
    202019,
    197745,
    31953,
    237533,
    33270,
    201580,
    255648,
    100798,
    44741,
    32241,
    98468,
    106931,
    10085,
    15090,
    170358,
    33154,
    66787,
    18819,
    69760,
    25061,
    234005,
    82660,
    6295,
    131975,
    16874,
    9076,
    4094,
    25005,
    17740,
    40908,
    19533,
    220019,
    44330,
    99792,
    50040,
    19619,
    13950,
    55228,
    24423,
    31253,
    95308,
    103177,
    184795,
    28590,
    82285,
    5059,
    3210,
    75525,
    49894,
    70007,
    56178,
    10580,
    36051,
    139681,
    21617,
    98736,
    3555,
    106306,
    164189,
    37352,
    63915,
    47824,
    24883,
    145530,
    61904,
    28444,
    11483,
    19837,
    145446,
    30420,
    112972,
    85939,
    11835,
    191233,
    2262,
    20705,
    58630,
    1753,
    148334,
    1197,
    144714,
    6887,
    11223,
    107667,
    60879,
    77914,
    4151,
    57417,
    81594,
    96681,
    169430,
    1784,
    20444,
    95138,
    254041,
    27038,
    596,
    7117,
    72808,
    13759,
    3353,
    126776,
    21074,
    55322,
    27081,
    36942,
    39547,
    139830,
    179275,
    4453,
    713,
    8722,
    71399,
    19204,
    25785,
    22794,
    23923,
    104114,
    11291,
    25458,
    102309,
    88396,
    75288,
    230440,
    206396,
    104551,
    58447,
    130857,
    37247,
    94734,
    31548,
    176529,
    226077,
    65159,
    20104,
    10096,
    66881,
    94191,
    237909,
    27109,
    37404,
    1520,
    27421,
    25220,
    113003,
    23423,
    24884,
    50585,
    6286,
    231877,
    150800,
    11789,
    3226,
    90004,
    60642,
    5053,
    202400,
    61442,
    132531,
    175329,
    57138,
    30116,
    103847,
    9973,
    75367,
    16452,
    32360,
    59119,
    21246,
    10191,
    164804,
    23305,
    61051,
    37348,
    154530,
    13214,
    5468,
    50403,
    66754,
    130976,
    50559,
    80515,
    14436,
    155492,
    84017,
    5472,
    43107,
    41240,
    2890,
    90431,
    70188,
    382,
    76234,
    48040,
    50211,
    281038,
    237007,
    32115,
    142178,
    1536,
    22761,
    96429,
    1811,
    31243,
    1679,
    49143,
    55209,
    17402,
    235054,
    61494,
    7462,
    77030,
    34925,
    87609,
    78002,
    9499,
    9027,
    73289,
    201078,
    101379,
    63544,
    27666,
    5469,
    10642,
    30029,
    49816,
    132979,
    95620,
    58086,
    351930,
    116300,
    2110,
    2043,
    30845,
    6154,
    11279,
    16727,
    4122,
    2277,
    27281,
    4971,
    3650,
    39060,
    61970,
    65951,
    39674,
    75686,
    38151,
    11370,
    130809,
    177895,
    32665,
    63725,
    122267,
    7857,
    39618,
    118483,
    44792,
    157755,
    178624,
    136994,
    24260,
    41308,
    22471,
    12404,
    21707,
    12486,
    30473,
    52781,
    50246,
    20247,
    39065,
    909,
    56825,
    103158,
    128603,
    31542,
    1089,
    41935,
    32744,
    12428,
    37963,
    84420,
    33134,
    72921,
    208449,
    42622,
    168151,
    127335,
    147107,
    46699,
    38216,
    12591,
    94342,
    85814,
    31423,
    24944,
    2605,
    87542,
    67473,
    192551,
    4496,
    56321,
    91819,
    17630,
    6300,
    256183,
    114569,
    202090,
    33209,
    35289,
    34897,
    24967,
    40520,
    43470,
    5344,
    10199,
    34810,
    14283,
    10381,
    10017,
    62923,
    49924,
    23233,
    64539,
    13051,
    35686,
    19698,
    11570,
    135555,
    120868,
    44924,
    87065,
    52318,
    52335,
    47586,
    140906,
    245885,
    109834,
    78668,
    9065,
    46990,
    25258,
    72022,
    61243,
    40838,
    4545,
    146387,
    10537,
    11557,
    17470,
    36930,
    68104,
    46711,
    24264,
    79401,
    81043,
    18225,
    120488,
    24746,
    84338,
    81652,
    28266,
    13776,
    21878,
    46973,
    1047,
    230465,
    73357,
    95777,
    24973,
    210160,
    62210,
    58404,
    110633,
    169651,
    6937,
    41870,
    9909,
    26822,
    191062,
    76553,
    27519,
    96256,
    239070,
    2478,
    205678,
    67955,
    58532,
    20601,
    50120,
    19148,
    78501,
    195724,
    110740,
    8249,
    109665,
    27446,
    30568,
    57631,
    31425,
    49752,
    32820,
    65504,
    50079,
    3663,
    102256,
    219898,
    23849,
    211315,
    14645,
    4359,
    91767,
    9528,
    12449,
    49366,
    7941,
    49763,
    107848,
    8930,
    27086,
    50686,
    9744,
    10447,
    81935,
    39513,
    46514,
    1670,
    29229,
    6172,
    22312,
    137280,
    97759,
    9806,
    14445,
    22976,
    56458,
    73391,
    34983,
    93760,
    174219,
    52573,
    33149,
    59747,
    2429,
    136277,
    75123,
    165263,
    91040,
    7446,
    57632,
    48633,
    97140,
    246081,
    84766,
    151684,
    79918,
    93268,
    120346,
    54059,
    54875,
    77858,
    32996,
    103590,
    45276,
    11968,
    19600,
    25849,
    17159,
    132907,
    42828,
    16817,
    4913,
    99462,
    103303,
    27395,
    5737,
    74184,
    20749,
    21160,
    14377,
    77062,
    131403,
    158735,
    10999,
    27799,
    77785,
    9320,
    34366,
    51593,
    61070,
    33746,
    47048,
    29268,
    36675,
    30262,
    53297,
    9832,
    82e3,
    20188,
    122292,
    39917,
    7331,
    18160,
    68301,
    185935,
    134830,
    15031,
    4935,
    10004,
    165845,
    185534,
    46923,
    30109,
    44134,
    122631,
    18874,
    22903,
    112790,
    26561,
    18549,
    348902,
    82871,
    140345,
    255565,
    135390,
    63556,
    103747,
    145055,
    179600,
    145662,
    296111,
    61661,
    211987,
    23952,
    52342,
    126343,
    48450,
    32919,
    44277,
    82185,
    9591,
    62139,
    205363,
    376969,
    394874,
    108461,
    18040,
    120885,
    14798,
    39863,
    16571,
    16794,
    58271,
    81025,
    55206,
    14640,
    118656,
    6361,
    44092,
    85970,
    6262,
    153863,
    108244,
    180200,
    72264,
    79947,
    38044,
    10050,
    5735,
    61221,
    80712,
    5471,
    115689,
    11391,
    11661,
    184257,
    20010,
    60116,
    30320,
    19327,
    134598,
    45455,
    27542,
    18004,
    125092,
    452272,
    1549,
    91523,
    46567,
    180063,
    156026,
    2608,
    11174,
    58848,
    37788,
    65907,
    80194,
    30490,
    5786,
    40775,
    119519,
    106241,
    11323,
    156297,
    8425,
    61495,
    2617,
    29675,
    2425,
    59886,
    112582,
    49142,
    59618,
    4863,
    50597,
    86710,
    50650,
    168632,
    27693,
    85641,
    83643,
    18993,
    25768,
    84284,
    28090,
    93592,
    36627,
    312804,
    43381,
    9887,
    9402,
    100931,
    97165,
    3311,
    173330,
    66805,
    28935,
    4963,
    184460,
    3201,
    78102,
    19126,
    21607,
    37496,
    24938,
    22615,
    16153,
    32862,
    134792,
    153318,
    61120,
    6067,
    2812,
    12826,
    12792,
    23825,
    37559,
    64662,
    202250,
    102694,
    155488,
    85881,
    149193,
    46233,
    65383,
    15521,
    106982,
    11358,
    176786,
    25752,
    39717,
    34208,
    24510,
    32464,
    77742,
    39371,
    72028,
    138229,
    60688,
    71386,
    102834,
    132477,
    2208,
    11548,
    63670,
    271279,
    28351,
    30338,
    38620,
    32491,
    99845,
    143885,
    152266,
    13252,
    2825,
    178663,
    108097,
    1775,
    78201,
    14897,
    113573,
    163346,
    62292,
    171129,
    22183,
    96598,
    38733,
    64971,
    166776,
    117445,
    9968,
    146393,
    44677,
    74867,
    20908,
    97328,
    12761,
    25656,
    26785,
    9148,
    112344,
    26115,
    99176,
    110121,
    22437,
    49547,
    6180,
    79320,
    5835,
    31392,
    43328,
    33377,
    75870,
    119860,
    69497,
    80273,
    7325,
    155219,
    43167,
    111173,
    28347,
    20222,
    3763,
    71752,
    55041,
    47252,
    14618,
    28088,
    15012,
    97805,
    194698,
    54636,
    2036,
    41349,
    6173,
    96604,
    61530,
    51859,
    43782,
    13361,
    24334,
    22668,
    24792,
    7070,
    23441,
    16789,
    3209,
    36211,
    208475,
    26242,
    32880,
    122181,
    182407,
    21444,
    31060,
    88459,
    29929,
    77907,
    12716,
    10934,
    97005,
    20599,
    31690,
    8403,
    58445,
    30303,
    22700,
    10336,
    86731,
    103115,
    337709,
    72556,
    46788,
    112566,
    47684,
    67089,
    53548,
    36874,
    56487,
    41387,
    125985,
    26893,
    40071,
    106683,
    73712,
    18787,
    40105,
    72992,
    67246,
    137276,
    50802,
    36790,
    70328,
    138827,
    22466,
    39263,
    183295,
    29858,
    50975,
    9322,
    57397,
    10654,
    24364,
    30383,
    55799,
    41600,
    23584,
    127295,
    296610,
    129078,
    143558,
    244131,
    86397,
    36049,
    1085,
    80677,
    3820,
    108139,
    5476,
    34767,
    24683,
    7758,
    13060,
    7239,
    131671,
    250593,
    59556,
    103392,
    29810,
    4188,
    252323,
    39404,
    116877,
    7651,
    43600,
    40338,
    13554,
    157253,
    39196,
    25978,
    144387,
    61211,
    234,
    50104,
    6129,
    10449,
    93777,
    9240,
    356378,
    274148,
    4439,
    72970,
    3724,
    147770,
    78680,
    62570,
    115877,
    40027,
    40547,
    36817,
    224392,
    64609,
    34795,
    165027,
    67440,
    2477,
    37206,
    23431,
    50754,
    164797,
    46018,
    94995,
    170982,
    27051,
    7957,
    22767,
    3674,
    27900,
    56419,
    18930,
    60701,
    41302,
    2692,
    84749,
    339721,
    61996,
    111094,
    80221,
    50129,
    1045,
    8153,
    62945,
    19202,
    8250,
    37208,
    37418,
    32560,
    79477,
    41106,
    88569,
    33963,
    36693,
    5892,
    30570,
    1581,
    66471,
    49647,
    11922,
    160717,
    29442,
    5643,
    114865,
    82962,
    95982,
    132098,
    22633,
    22838,
    94726,
    54556,
    28566,
    205039,
    162340,
    33216,
    16849,
    35847,
    221339,
    94851,
    26533,
    71469,
    1805,
    3804,
    12935,
    45483,
    71020,
    36310,
    65381,
    192960,
    34240,
    35165,
    59773,
    1248,
    46954,
    155332,
    96864,
    4246,
    388800,
    16129,
    57133,
    74592,
    44807,
    442014,
    38203,
    42574,
    80818,
    91592,
    26377,
    36424,
    65760,
    977,
    77387,
    22628,
    147610,
    28018,
    30561,
    98454,
    6969,
    119628,
    63648,
    18170,
    36854,
    26601,
    64018,
    22027,
    37279,
    51395,
    152934,
    21153,
    9430,
    58760,
    194742,
    5330,
    55115,
    34158,
    28917,
    174111,
    13171,
    122326,
    1526,
    43896,
    66094,
    25325,
    4234,
    148354,
    11450,
    275,
    18999,
    112191,
    44365,
    22723,
    68409,
    8733,
    57746,
    96565,
    75007,
    14196,
    108844,
    29475,
    88599,
    177563,
    100792,
    106156,
    86323,
    93726,
    14248,
    135341,
    194131,
    40126,
    47099,
    14779,
    8272,
    39597,
    95983,
    171398,
    65882,
    28052,
    10393,
    47213,
    40689,
    22120,
    72212,
    106829,
    34964,
    109146,
    753,
    648,
    21660,
    30047,
    17527,
    181025,
    5619,
    145357,
    4085,
    216883,
    9359,
    186951,
    24779,
    53931,
    24545,
    36197,
    223296,
    62628,
    168101,
    4243,
    107313,
    30321,
    26642,
    13049,
    51059,
    31027,
    107912,
    807,
    73550,
    26551,
    84369,
    122422,
    165872,
    49754,
    74213,
    234264,
    33151,
    52014,
    33100,
    87183,
    22365,
    52500,
    40013,
    23302,
    5652,
    72723,
    21404,
    26107,
    48434,
    587,
    94049,
    168493,
    96418,
    32871,
    70860,
    31709,
    25128,
    443,
    71597,
    166253,
    15670,
    70994,
    26341,
    133675,
    28280,
    75491,
    54756,
    47955,
    56028,
    26182,
    11952,
    113272,
    472197,
    64640,
    110753,
    17919,
    337,
    50642,
    22576,
    142,
    87371,
    53391,
    93210,
    126694,
    15285,
    19642,
    85667,
    14148,
    1506,
    42092,
    52962,
    33243,
    11970,
    20734,
    135843,
    57044,
    58880,
    13002,
    219134,
    22876,
    64754,
    232519,
    4257,
    43120,
    321573,
    24799,
    64526,
    124728,
    52579,
    81472,
    70831,
    276848,
    17403,
    74359,
    23021,
    182101,
    74597,
    23744,
    148267,
    12055,
    7976,
    5349,
    11772,
    67540,
    167347,
    65318,
    18720,
    127832,
    108238,
    22828,
    90233,
    9987,
    259080,
    118185,
    73209,
    79270,
    13775,
    90100,
    137742,
    90799,
    70569,
    15699,
    19961,
    9087,
    67475,
    57872,
    39731,
    8810,
    134897,
    131868,
    146849,
    19898,
    3334,
    2281,
    167061,
    91073,
    60356,
    467742,
    74712,
    188,
    53179,
    137679,
    92769,
    29241,
    9537,
    132595,
    80119,
    1041,
    88962,
    5976,
    40171,
    44911,
    102859,
    139059,
    104558,
    98987,
    47761,
    19272,
    71472,
    113864,
    175377,
    73338,
    10857,
    23402,
    23758,
    1591,
    139864,
    5644,
    4076,
    118760,
    16427,
    134198,
    18853,
    20291,
    100849,
    37423,
    22038,
    36677,
    19071,
    195521,
    57445,
    11069,
    31869,
    55718,
    66882,
    148490,
    44,
    41296,
    75242,
    49704,
    166810,
    9906,
    20943,
    122258,
    49112,
    105667,
    15969,
    10344,
    6408,
    187694,
    21399,
    72742,
    58970,
    14867,
    14376,
    81889,
    41856,
    23225,
    15042,
    56993,
    16074,
    131389,
    74276,
    72407,
    53875,
    383108,
    53597,
    37363,
    68993,
    44854,
    122548,
    430927,
    198279,
    38430,
    80409,
    12245,
    2981,
    628,
    2818,
    17760,
    37437,
    238229,
    7968,
    46892,
    2200,
    3730,
    34190,
    65983,
    37959,
    112291,
    87850,
    70827,
    6522,
    20750,
    73913,
    111621,
    41652,
    19587,
    2780,
    58668,
    25916,
    85259,
    18200,
    168962,
    95781,
    42445,
    102050,
    7776,
    57662,
    103313,
    47742,
    96358,
    41964,
    66174,
    100396,
    29069,
    204735,
    19679,
    27978,
    7479,
    40264,
    22534,
    61183,
    36081,
    107436,
    58223,
    14680,
    23002,
    101311,
    24716,
    124108,
    12908,
    5646,
    31750,
    40380,
    14215,
    232799,
    102772,
    14122,
    96775,
    61398,
    50917,
    12096,
    149880,
    67833,
    598749,
    124194,
    155871,
    49216,
    790,
    14677,
    65319,
    56917,
    7440,
    145744,
    95701,
    12206,
    49405,
    129269,
    76199,
    45732,
    9767,
    11058,
    9047,
    210885,
    11051,
    7392,
    26307,
    2130,
    8132,
    147526,
    20802,
    232698,
    115660,
    50060,
    59789,
    57344,
    107623,
    80343,
    112676,
    23291,
    9866,
    160971,
    34032,
    118291,
    15719,
    59730,
    164911,
    28975,
    2659,
    58046,
    78480,
    21854,
    66209,
    53863,
    109085,
    116045,
    29021,
    46481,
    107552,
    22130,
    18764,
    70254,
    31272,
    11300,
    52460,
    43933,
    84738,
    20721,
    53869,
    190840,
    79673,
    105300,
    7561,
    321817,
    66924,
    13940,
    33281,
    101046,
    183181,
    32176,
    71878,
    5678,
    62924,
    79535,
    56646,
    40303,
    19559,
    27703,
    93042,
    73368,
    42187,
    3670,
    37376,
    46440,
    7023,
    36816,
    109628,
    20680,
    5940,
    276440,
    275233,
    170848,
    112093,
    136996,
    14984,
    20226,
    111441,
    77693,
    112960,
    48577,
    39370,
    55707,
    50314,
    123404,
    26570,
    54281,
    61372,
    123391,
    4857,
    35928,
    246740,
    132507,
    106646,
    44241,
    7196,
    92258,
    9825,
    37688,
    51197,
    303141,
    5590,
    15476,
    132986,
    10955,
    85782,
    34486,
    26696,
    7991,
    28813,
    18858,
    39546,
    11703,
    11365,
    38185,
    5716,
    93555,
    11925,
    40121,
    60002,
    6985,
    10976,
    171384,
    3887,
    43394,
    13337,
    56346,
    6381,
    252336,
    39573,
    75042,
    53711,
    1028,
    31781,
    44295,
    95925,
    131713,
    7214,
    68125,
    43571,
    70954,
    213234,
    1628,
    8760,
    13391,
    65485,
    17320,
    56038,
    1710,
    25248,
    60803,
    57399,
    19839,
    3870,
    326,
    281556,
    50945,
    72400,
    21460,
    316244,
    75619,
    56246,
    98775,
    481,
    13513,
    55765,
    50427,
    7388,
    123519,
    32929,
    57908,
    27124,
    61316,
    101097,
    57467,
    30228,
    48792,
    10788,
    20402,
    37318,
    50526,
    155730,
    34456,
    158065,
    145305,
    17832,
    43733,
    64052,
    4506,
    35072,
    205355,
    177028,
    184004,
    187081,
    68616,
    35938,
    83703,
    10367,
    36892,
    93186,
    260137,
    51934,
    89970,
    4985,
    23445,
    26755,
    21558,
    7948,
    78741,
    23376,
    124405,
    85594,
    68596,
    57536,
    49351,
    12619,
    56593,
    132668,
    99924,
    109728,
    71844,
    71935,
    196018,
    65464,
    17617,
    14987,
    89701,
    143773,
    33997,
    8687,
    22701,
    33258,
    2914,
    4436,
    72108,
    85610,
    9671,
    49067,
    2327,
    82988,
    1361,
    1672,
    44033,
    35777,
    30269,
    24057,
    10605,
    82236,
    616,
    15793,
    13919,
    47249,
    112086,
    116698,
    9484,
    80207,
    90574,
    33304,
    68624,
    93127,
    56101,
    42210,
    160929,
    4827,
    38995,
    38095,
    4701,
    125119,
    5027,
    33680,
    9236,
    231236,
    14135,
    87837,
    23318,
    70261,
    78893,
    30151,
    81482,
    14332,
    1084,
    74256,
    27532,
    46644,
    79185,
    3148,
    62615,
    6981,
    55672,
    31668,
    36825,
    1849,
    14536,
    37446,
    14738,
    23779,
    43058,
    162749,
    72199,
    1168,
    21346,
    5592,
    85932,
    85302,
    9668,
    18351,
    57135,
    150360,
    2080,
    228015,
    77953,
    34670,
    119302,
    151751,
    31009,
    106725,
    84265,
    45214,
    59289,
    74178,
    113071,
    263206,
    111009,
    4021,
    44449,
    188119,
    192629,
    123592,
    392506,
    292847,
    114487,
    12831,
    205858,
    9852,
    20780,
    79648,
    75767,
    357014,
    97721,
    18166,
    21005,
    67950,
    33226,
    204009,
    16536,
    2987,
    11335,
    66717,
    144910,
    47950,
    17262,
    55060,
    15063,
    2934,
    51038,
    26775,
    178497,
    66008,
    3427,
    49433,
    128592,
    20036,
    157553,
    63861,
    3089,
    23015,
    51210,
    28696,
    35933,
    49942,
    71135,
    231518,
    99620,
    17248,
    21835,
    176536,
    20676,
    16944,
    38700,
    165831,
    233253,
    295625,
    36723,
    13023,
    52745,
    10907,
    19423,
    67972,
    125868,
    95473,
    82875,
    1183,
    108455,
    52685,
    33417,
    64095,
    21433,
    52438,
    33191,
    127809,
    44505,
    211823,
    7810,
    2752,
    95548,
    162031,
    7185,
    91196,
    47563,
    61721,
    33359,
    17897,
    23682,
    42806,
    178101,
    22874,
    49707,
    199897,
    75419,
    82456,
    8618,
    11171,
    79712,
    116847,
    18783,
    44190,
    46564,
    5346,
    59046,
    95032,
    7893,
    14916,
    3214,
    26800,
    24172,
    121453,
    34362,
    10250,
    17408,
    18888,
    4840,
    68696,
    22831,
    13162,
    36005,
    32512,
    14800,
    62357,
    41723,
    45046,
    27247,
    37486,
    5372,
    2564,
    34261,
    298500,
    66509,
    133920,
    89138,
    31305,
    117697,
    19097,
    108304,
    81386,
    84106,
    23802,
    46411,
    63304,
    946,
    51417,
    41777,
    41041,
    19501,
    115864,
    60743,
    294354,
    37955,
    94165,
    18116,
    1156,
    17937,
    20645,
    57114,
    90804,
    58042,
    48643,
    92288,
    9861,
    2557,
    88546,
    61333,
    101008,
    12853,
    5148,
    87856,
    4152,
    144503,
    73841,
    18718,
    9789,
    147565,
    10846,
    42085,
    12789,
    30223,
    8993,
    56352,
    67203,
    2448,
    28215,
    6052,
    23540,
    126319,
    75933,
    36689,
    80235,
    23231,
    23561,
    21383,
    38800,
    77548,
    102798,
    21234,
    31468,
    158608,
    46188,
    63960,
    191679,
    8051,
    67014,
    11185,
    170078,
    42186,
    28827,
    34777,
    41930,
    212079,
    12421,
    34750,
    24111,
    110344,
    73918,
    45171,
    70826,
    141949,
    40063,
    23979,
    24254,
    37309,
    26724,
    27179,
    24718,
    83648,
    54938,
    14591,
    17425,
    29525,
    102675,
    48975,
    48654,
    12316,
    8929,
    60640,
    41709,
    50168,
    63264,
    89812,
    50716,
    48632,
    38755,
    138583,
    160123,
    55579,
    71829,
    24230,
    233277,
    46322,
    39650,
    166388,
    34718,
    24108,
    98252,
    7031,
    106695,
    62498,
    18258,
    35062,
    217827,
    78731,
    34824,
    33354,
    19520,
    60852,
    2432,
    60224,
    8587,
    2836,
    62955,
    702,
    20227,
    42285,
    40560,
    95592,
    62486,
    11094,
    53035,
    143291,
    18842,
    46177,
    77994,
    1770,
    9657,
    107422,
    172915,
    32655,
    128716,
    25886,
    25164,
    156740,
    119928,
    165875,
    85817,
    11007,
    89110,
    33956,
    12652,
    65156,
    180266,
    8494,
    36889,
    19958,
    20955,
    96,
    1264,
    118288,
    135769,
    44754,
    86671,
    5632,
    19026,
    168220,
    289120,
    33569,
    93821,
    66144,
    70635,
    7687,
    5642,
    2714,
    55445,
    56636,
    71545,
    184182,
    93133,
    7332,
    37389,
    12643,
    52315,
    22729,
    11014,
    158742,
    17050,
    152889,
    50178,
    34601,
    41945,
    52136,
    9948,
    26914,
    63548,
    95721,
    115951,
    40759,
    8960,
    158258,
    38938,
    49232,
    48325,
    42234,
    81523,
    253019,
    66128,
    40978,
    20048,
    238048,
    38760,
    62928,
    122560,
    118532,
    43687,
    137472,
    163689,
    26680,
    9878,
    17448,
    51035,
    16211,
    60834,
    36749,
    29178,
    14241,
    59868,
    150086,
    2305,
    26477,
    42422,
    34342,
    165341,
    83279,
    33894,
    14257,
    29928,
    12743,
    13957,
    125571,
    89134,
    66712,
    10952,
    16507,
    147839,
    30146,
    7249,
    16565,
    45399,
    39874,
    114565,
    215780,
    31990,
    230881,
    171477,
    102,
    196546,
    44538,
    10880,
    84948,
    281705,
    86651,
    10617,
    31395,
    2342,
    453658,
    43569,
    60561,
    132901,
    21845,
    17727,
    58556,
    258242,
    22262,
    58728,
    4008,
    77997,
    11806,
    37431,
    30599,
    81375,
    109137,
    185787,
    114085,
    217292,
    97453,
    169085,
    30593,
    60212,
    11544,
    102056,
    65580,
    2384,
    91655,
    4855,
    95725,
    7295,
    157994,
    16228,
    20669,
    53276,
    141590,
    105246,
    17334,
    25440,
    76067,
    17967,
    39321,
    38911,
    11362,
    28559,
    63807,
    21627,
    26468,
    85816,
    40120,
    1025,
    15234,
    58319,
    69516,
    66512,
    124548,
    75845,
    78873,
    22137,
    46681,
    51242,
    85683,
    32909,
    76747,
    35555,
    43396,
    101465,
    1765,
    73094,
    1077,
    2962,
    39028,
    66777,
    57831,
    42048,
    15828,
    13962,
    36041,
    63657,
    52412,
    5242,
    58846,
    2141,
    5506,
    219012,
    134451,
    3936,
    182230,
    17558,
    17153,
    152237,
    22621,
    49377,
    170216,
    35257,
    68233,
    65374,
    6510,
    11126,
    212151,
    7184,
    2480,
    22517,
    3437,
    33073,
    30156,
    16557,
    3768,
    55067,
    86829,
    91e3,
    12350,
    148650,
    66017,
    79424,
    70885,
    49066,
    28250,
    21369,
    51213,
    34533,
    11510,
    3258,
    18176,
    18465,
    84413,
    6315,
    36411,
    163765,
    4346,
    356,
    107618,
    598,
    13727,
    285026,
    162695,
    8749,
    14583,
    7132,
    63521,
    184253,
    32378,
    25991,
    5604,
    30961,
    53675,
    4874,
    84693,
    5086,
    34811,
    26978,
    56564,
    7904,
    33519,
    51221,
    113942,
    69253,
    6664,
    125563,
    22055,
    220680,
    102008,
    742,
    51930,
    19494,
    176108,
    44424,
    35123,
    13025,
    75685,
    11759,
    74335,
    22250,
    181453,
    131147,
    16984,
    132115,
    154311,
    11991,
    76452,
    52609,
    85351,
    196,
    30969,
    9198,
    74919,
    2529,
    56838,
    71779,
    29187,
    116304,
    3504,
    62330,
    41190,
    86153,
    28393,
    254926,
    104228,
    105189,
    13264,
    84359,
    3574,
    12415,
    8534,
    57147,
    10175,
    188174,
    59504,
    60932,
    66318,
    16407,
    107921,
    17638,
    99103,
    49278,
    28403,
    39786,
    145865,
    8462,
    3558,
    43406,
    142271,
    29139,
    21989,
    36552,
    93955,
    72365,
    7176,
    13556,
    106185,
    37957,
    321774,
    17782,
    129017,
    51154,
    27938,
    24952,
    1935,
    39366,
    2791,
    33489,
    41582,
    56078,
    24558,
    9311,
    5449,
    218786,
    27808,
    190429,
    68013,
    36020,
    86003,
    29735,
    3404,
    87348,
    119357,
    115714,
    2324,
    86796,
    81973,
    40992,
    43376,
    93621,
    28784,
    16808,
    36367,
    2517,
    2909,
    191926,
    24978,
    55303,
    53308,
    205724,
    60068,
    3098,
    21375,
    64784,
    23949,
    26579,
    63121,
    12319,
    80145,
    39967,
    97861,
    6757,
    70143,
    67642,
    37082,
    34698,
    69140,
    122883,
    46151,
    62187,
    80934,
    429,
    19437,
    135071,
    137885,
    222647,
    13331,
    154065,
    327,
    61778,
    74257,
    40116,
    37493,
    14855,
    85079,
    237641,
    42342,
    102164,
    199965,
    71204,
    4662,
    29368,
    5042,
    113914,
    122214,
    8955,
    13149,
    102503,
    43173,
    5659,
    163787,
    69003,
    307084,
    63392,
    171080,
    21390,
    81918,
    86666,
    36622,
    24126,
    28887,
    5736,
    28054,
    207170,
    163428,
    79891,
    346467,
    95363,
    38980,
    111806,
    80828,
    9200,
    19288,
    294896,
    114468,
    87405,
    111715,
    141705,
    7015,
    72754,
    68463,
    48738,
    243147,
    33397,
    101210,
    37051,
    98801,
    82847,
    20397,
    4940,
    185559,
    18716,
    54718,
    83491,
    11725,
    40803,
    1128,
    12128,
    23060,
    5174,
    7745,
    67007,
    46701,
    1571,
    27807,
    180186,
    256996,
    18975,
    16837,
    7877,
    212758,
    250379,
    15440,
    87954,
    57755,
    24719,
    124057,
    83461,
    258,
    50864,
    8874,
    29038,
    71289,
    31627,
    15429,
    9005,
    4061,
    113851,
    107716,
    82819,
    13651,
    79656,
    117851,
    17539,
    111446,
    12938,
    39724,
    190787,
    4352,
    15402,
    21070,
    62708,
    8539,
    23777,
    73853,
    13552,
    38810,
    86117,
    16285,
    56400,
    1718,
    75342,
    142863,
    29033,
    378,
    110113,
    180321,
    32586,
    23606,
    26393,
    160984,
    207987,
    23783,
    8406,
    16904,
    24596,
    47274,
    11693,
    46539,
    60524,
    78595,
    48423,
    31718,
    20170,
    9009,
    146268,
    15183,
    191060,
    172765,
    1349,
    138436,
    37365,
    10970,
    40509,
    225817,
    20021,
    70394,
    152138,
    21541,
    66559,
    66544,
    89352,
    2725,
    17258,
    91345,
    7313,
    3815,
    115868,
    8660,
    40362,
    4071,
    103524,
    39388,
    118275,
    21950,
    6549,
    38226,
    32754,
    209574,
    29201,
    43495,
    18028,
    20296,
    40597,
    18370,
    47520,
    202450,
    24134,
    2219,
    8195,
    69545,
    38041,
    136934,
    46374,
    19041,
    159811,
    84865,
    58620,
    846,
    98749,
    13569,
    30714,
    97246,
    32186,
    4479,
    27355,
    92973,
    35214,
    151491,
    75963,
    37631,
    1561,
    27200,
    238083,
    23182,
    60756,
    12291,
    25766,
    39355,
    102333,
    87362,
    65741,
    59906,
    19538,
    201575,
    48772,
    102938,
    24438,
    292580,
    39964,
    66366,
    9004,
    61379,
    50548,
    37622,
    38732,
    28379,
    68180,
    76622,
    17488,
    69849,
    5963,
    7219,
    48143,
    43413,
    55358,
    540,
    58691,
    29506,
    19245,
    52193,
    48621,
    5518,
    13048,
    118625,
    44755,
    191081,
    42061,
    89197,
    2259,
    60665,
    66994,
    71210,
    51232,
    3585,
    142096,
    55024,
    7892,
    8345,
    58653,
    463307,
    65658,
    64319,
    137941,
    136323,
    53499,
    12746,
    43492,
    6978,
    95163,
    29925,
    60175,
    5128,
    7352,
    41463,
    184756,
    121146,
    20473,
    18426,
    4598,
    5309,
    54580,
    14277,
    121151,
    10691,
    56711,
    43880,
    63409,
    76682,
    11830,
    172218,
    264898,
    32632,
    66536,
    81062,
    31649,
    25788,
    92774,
    60222,
    11100,
    63159,
    9432,
    224657,
    25240,
    53613,
    152,
    138620,
    163829,
    2397,
    85345,
    12501,
    37507,
    64932,
    38575,
    43522,
    65789,
    80198,
    78796,
    35226,
    3851,
    108891,
    73311,
    3060,
    28391,
    93671,
    39663,
    46142,
    30982,
    66041,
    37281,
    68157,
    26553,
    71872,
    81142,
    211527,
    39747,
    118119,
    22695,
    2859,
    11066,
    20232,
    168911,
    7933,
    197005,
    17066,
    111071,
    44434,
    133994,
    120798,
    12766,
    227798,
    45756,
    132852,
    29917,
    36076,
    55352,
    65281,
    129800,
    41958,
    18944,
    84678,
    18580,
    168093,
    132621,
    39997,
    54092,
    27740,
    32354,
    3770,
    114118,
    103242,
    43918,
    15899,
    18574,
    145944,
    3190,
    123469,
    219903,
    24169,
    100571,
    62403,
    16776,
    92779,
    14535,
    17168,
    16475,
    14304,
    37231,
    1712,
    28218,
    242754,
    61688,
    28980,
    1318,
    51359,
    222657,
    99200,
    67989,
    31772,
    23932,
    35351,
    201251,
    49041,
    27306,
    19128,
    40135,
    3986,
    77333,
    19649,
    120683,
    151927,
    21081,
    7076,
    78375,
    77501,
    101599,
    8011,
    89585,
    96715,
    58179,
    5378,
    102138,
    106793,
    26051,
    217276,
    4197,
    16297,
    27014,
    46721,
    13322,
    22806,
    5278,
    29629,
    70632,
    9647,
    71519,
    58818,
    40603,
    128530,
    8903,
    36770,
    56900,
    31483,
    26935,
    43845,
    34265,
    34920,
    87658,
    6114,
    84767,
    64250,
    47318,
    50720,
    19264,
    162514,
    33357,
    13117,
    6705,
    46696,
    75032,
    71054,
    87004,
    42035,
    69138,
    11903,
    99854,
    102328,
    19611,
    34525,
    69312,
    6431,
    49842,
    101600,
    133178,
    108751,
    41829,
    89939,
    225664,
    48916,
    99556,
    9195,
    130387,
    5960,
    36857,
    116724,
    53518,
    94002,
    39077,
    53996,
    6945,
    22261,
    64291,
    8314,
    152785,
    57588,
    16522,
    9091,
    5048,
    87671,
    35441,
    39509,
    1945,
    12423,
    158923,
    178413,
    37549,
    14095,
    1475,
    73188,
    62878,
    4819,
    24012,
    68534,
    42606,
    4010,
    120809,
    57497,
    59564,
    101758,
    103718,
    32701,
    80116,
    12345,
    95834,
    46918,
    21468,
    53213,
    15665,
    31200,
    3867,
    5140,
    96013,
    250744,
    21016,
    10069,
    13968,
    35449,
    180829,
    27683,
    39704,
    59956,
    22893,
    3115,
    26293,
    32785,
    75934,
    62445,
    141162,
    62720,
    2018,
    83638,
    19949,
    114012,
    95006,
    3330,
    99829,
    130935,
    309272,
    9565,
    55874,
    121727,
    37017,
    23586,
    319858,
    40970,
    27602,
    8625,
    112329,
    61060,
    100088,
    118525,
    25922,
    16232,
    1907,
    60671,
    51583,
    44553,
    80993,
    5262,
    94679,
    8676,
    940,
    20736,
    11823,
    3020,
    16476,
    12340,
    152600,
    97416,
    3703,
    25744,
    66826,
    16245,
    16876,
    46446,
    84798,
    74227,
    176020,
    45192,
    61955,
    75496,
    23946,
    23626,
    40372,
    26036,
    6149,
    11822,
    30582,
    16541,
    41914,
    82385,
    232823,
    40921,
    80773,
    14930,
    3631,
    7517,
    39619,
    4348,
    36180,
    126106,
    138939,
    62611,
    1477,
    113512,
    47321,
    25052,
    14546,
    118881,
    29060,
    23589,
    128322,
    36795,
    18401,
    137921,
    104699,
    267929,
    36194,
    172791,
    18113,
    4766,
    188215,
    30083,
    332586,
    94089,
    5805,
    77909,
    22194,
    68234,
    154976,
    43220,
    40660,
    70001,
    184893,
    138095,
    11128,
    103010,
    22663,
    5108,
    212615,
    8485,
    5565,
    49222,
    54614,
    26530,
    42639,
    16319,
    55062,
    152662,
    105595,
    21114,
    22216,
    10294,
    68158,
    10436,
    86950,
    7206,
    62115,
    3977,
    3657,
    59874,
    456,
    118617,
    18156,
    106663,
    112229,
    80992,
    17442,
    8217,
    55551,
    5133,
    34344,
    251927,
    51153,
    39364,
    201321,
    7816,
    66803,
    23057,
    156724,
    145664,
    14276,
    95705,
    979,
    2796,
    6875,
    13429,
    212525,
    50602,
    26276,
    28284,
    3424,
    19465,
    52397,
    46963,
    31420,
    51399,
    206476,
    92317,
    48851,
    637,
    100820,
    83349,
    10317,
    60227,
    21972,
    6908,
    282439,
    32857,
    224767,
    95629,
    83882,
    42106,
    87338,
    69757,
    29840,
    68709,
    37665,
    45244,
    114577,
    49188,
    175943,
    54009,
    186746,
    106158,
    70168,
    3358,
    234002,
    50555,
    9221,
    129338,
    9562,
    20118,
    32923,
    78479,
    118280,
    65752,
    4977,
    10474,
    102174,
    60947,
    129006,
    10570,
    83451,
    8598,
    8078,
    159367,
    123785,
    80438,
    16742,
    5905,
    5281,
    181513,
    42402,
    6977,
    163136,
    93179,
    42191,
    14968,
    50421,
    112401,
    105440,
    33456,
    57347,
    121611,
    4221,
    94954,
    36517,
    24046,
    27796,
    6255,
    33394,
    72990,
    135408,
    116627,
    1233,
    57874,
    25654,
    95419,
    68156,
    401399,
    313338,
    55208,
    45573,
    93124,
    119251,
    47200,
    38196,
    11909,
    130667,
    45391,
    73904,
    64964,
    167846,
    4137,
    115606,
    52036,
    62214,
    7969,
    160925,
    7187,
    1132,
    134835,
    40309,
    73195,
    64494,
    80472,
    444841,
    61111,
    26500,
    45323,
    40743,
    53625,
    52797,
    22659,
    15631,
    29739,
    36706,
    28841,
    39147,
    102836,
    26794,
    10536,
    14845,
    87305,
    45874,
    12241,
    127587,
    83833,
    57183,
    79722,
    30844,
    41304,
    84655,
    20825,
    92500,
    3722,
    25655,
    27811,
    10157,
    81634,
    31362,
    34088,
    92487,
    70123,
    22190,
    185100,
    72658,
    139035,
    192523,
    88241,
    2078,
    230490,
    44528,
    85638,
    100198,
    22088,
    29982,
    291233,
    241062,
    13865,
    4445,
    137791,
    37835,
    107218,
    31726,
    19718,
    38234,
    72528,
    23046,
    19177,
    66695,
    5109,
    17251,
    28077,
    5617,
    21554,
    47839,
    72425,
    133825,
    1486,
    73065,
    181275,
    141508,
    21768,
    62971,
    63082,
    2512,
    34200,
    9904,
    120309,
    6392,
    91243,
    68416,
    268253,
    41199,
    116757,
    138551,
    185526,
    41246,
    28986,
    4093,
    19057,
    17295,
    4148,
    245766,
    122360,
    35356,
    112075,
    20301,
    75441,
    10998,
    7977,
    19769,
    62922,
    937,
    63547,
    100196,
    26427,
    157820,
    20983,
    236696,
    22935,
    8140,
    90315,
    156004,
    47204,
    140973,
    7726,
    45097,
    52725,
    22636,
    23436,
    257282,
    105247,
    522,
    88389,
    216031,
    202204,
    46812,
    211666,
    19693,
    68828,
    81691,
    45925,
    11256,
    30292,
    372,
    5236,
    167826,
    88328,
    232776,
    151611,
    5360,
    82104,
    18841,
    80393,
    25465,
    18285,
    20320,
    72377,
    31730,
    33160,
    45803,
    38715,
    27705,
    37379,
    24163,
    18360,
    103586,
    4015,
    32305,
    269494,
    91252,
    20080,
    36567,
    54650,
    7797,
    57073,
    12650,
    31164,
    42209,
    6375,
    261663,
    105528,
    81661,
    106002,
    2800,
    5375,
    17247,
    43151,
    4442,
    15727,
    194619,
    100855,
    144898,
    62320,
    78465,
    39929,
    16454,
    1967,
    28311,
    61363,
    17219,
    9395,
    8745,
    121445,
    76939,
    80385,
    162380,
    22009,
    54191,
    44248,
    16299,
    122830,
    48151,
    74429,
    78291,
    64755,
    14238,
    44966,
    2511,
    17712,
    67954,
    93583,
    829,
    105899,
    49935,
    84750,
    11591,
    33185,
    85447,
    42717,
    27409,
    208542,
    28965,
    62052,
    52525,
    5597,
    25694,
    65594,
    16343,
    63224,
    276188,
    12475,
    9331,
    127507,
    38522,
    57287,
    24128,
    133161,
    79723,
    105548,
    133695,
    48917,
    27558,
    43278,
    46520,
    13778,
    141954,
    110785,
    83366,
    17715,
    46317,
    105763,
    66298,
    147013,
    41086,
    94180,
    16478,
    220447,
    44611,
    730,
    19722,
    78975,
    117889,
    125643,
    26254,
    16574,
    18480,
    65006,
    15806,
    38549,
    246418,
    46052,
    36056,
    8440,
    34984,
    30170,
    3163,
    59800,
    4458,
    115442,
    4283,
    41970,
    33507,
    104078,
    1653,
    22,
    121158,
    276486,
    3655,
    6338,
    24048,
    133421,
    23641,
    2161,
    24422,
    36006,
    8086,
    10675,
    181474,
    12307,
    29514,
    59143,
    14729,
    52509,
    87128,
    122470,
    19446,
    80852,
    33314,
    24573,
    119864,
    14237,
    9652,
    57779,
    6612,
    51851,
    15284,
    98871,
    90581,
    124466,
    156831,
    21190,
    22015,
    71380,
    161906,
    87247,
    69201,
    18392,
    17908,
    108470,
    72962,
    40719,
    14338,
    17911,
    95260,
    43339,
    20610,
    78916,
    20710,
    72451,
    11315,
    31448,
    17263,
    58853,
    178878,
    48111,
    116002,
    45497,
    80506,
    82605,
    85880,
    36300,
    121755,
    25215,
    36118,
    301929,
    88728,
    405223,
    276136,
    553,
    34704,
    212438,
    49970,
    78329,
    922,
    20711,
    25036,
    257130,
    38295,
    145369,
    18128,
    15385,
    30829,
    55656,
    48345,
    8012,
    3561,
    28004,
    122041,
    192900,
    58338,
    112508,
    41085,
    29976,
    87040,
    47117,
    23905,
    4336,
    92061,
    138880,
    97407,
    42083,
    172121,
    6256,
    25192,
    172671,
    5,
    93568,
    1420,
    12677,
    31605,
    56743,
    40620,
    6015,
    78415,
    231077,
    31298,
    80026,
    13902,
    19048,
    24924,
    170586,
    32955,
    176119,
    87859,
    36731,
    6773,
    27711,
    24658,
    26475,
    115216,
    133207,
    93250,
    95820,
    88522,
    8317,
    5714,
    124047,
    55219,
    86860,
    19677,
    23961,
    22928,
    162209,
    8904,
    225992,
    359835,
    56084,
    96201,
    29392,
    96558,
    86071,
    93643,
    55114,
    13347,
    8183,
    95129,
    82012,
    2017,
    123336,
    34219,
    115554,
    157159,
    47747,
    101684,
    41008,
    18735,
    193781,
    104151,
    226906,
    7552,
    179874,
    124113,
    31159,
    21162,
    44010,
    14771,
    51268,
    166128,
    31382,
    73124,
    77438,
    92830,
    205709,
    12113,
    1292,
    38937,
    13114,
    1334,
    2118,
    15597,
    69581,
    14449,
    21934,
    76618,
    48728,
    67038,
    14967,
    51495,
    24243,
    87736,
    147249,
    26720,
    11119,
    46063,
    43749,
    5843,
    44147,
    152629,
    133428,
    65703,
    14269,
    45604,
    57982,
    28672,
    55616,
    45957,
    8438,
    95433,
    37698,
    220862,
    132034,
    39456,
    61870,
    4161,
    26501,
    73560,
    56418,
    9845,
    4654,
    20916,
    10456,
    88920,
    119358,
    9015,
    65931,
    96507,
    48029,
    38534,
    21676,
    109081,
    43078,
    34943,
    25089,
    6131,
    28766,
    23665,
    5477,
    10255,
    16695,
    67,
    45778,
    42443,
    42770,
    29534,
    23733,
    100513,
    62617,
    42630,
    48746,
    14191,
    43753,
    50295,
    26007,
    8792,
    57243,
    43119,
    54725,
    164253,
    58250,
    112304,
    131796,
    25165,
    4651,
    3188,
    24831,
    47748,
    3705,
    19540,
    13211,
    102095,
    5593,
    18699,
    23666,
    32005,
    117571,
    33541,
    60584,
    74573,
    86311,
    99443,
    25172,
    27222,
    168938,
    7143,
    11853,
    53560,
    18834,
    19960,
    86522,
    28217,
    53266,
    117700,
    72989,
    34323,
    18721,
    66450,
    34346,
    74056,
    47217,
    202002,
    46269,
    9429,
    68582,
    75458,
    37823,
    82843,
    96652,
    32549,
    145144,
    27958,
    19820,
    158086,
    31955,
    201406,
    135379,
    31207,
    192545,
    12950,
    51704,
    9094,
    248263,
    76147,
    64028,
    110009,
    79407,
    89345,
    99284,
    223492,
    47966,
    26848,
    15359,
    201137,
    2861,
    110507,
    71231,
    72297,
    31851,
    118777,
    71039,
    151051,
    240855,
    16333,
    50766,
    14727,
    7939,
    4149,
    80908,
    418780,
    88378,
    59276,
    1327,
    7284,
    38576,
    79814,
    65820,
    42199,
    84860,
    49574,
    62596,
    12396,
    70598,
    40117,
    8648,
    7994,
    16836,
    7630,
    14047,
    359699,
    106878,
    525,
    29037,
    28064,
    13380,
    11675,
    50669,
    74216,
    103539,
    180314,
    27449,
    56299,
    172344,
    19274,
    7301,
    246099,
    32043,
    19422,
    36506,
    129317,
    6806,
    30140,
    4614,
    46639,
    66926,
    932,
    86600,
    6322,
    27847,
    233103,
    10541,
    39025,
    34887,
    3517,
    12972,
    26220,
    2031,
    66561,
    115015,
    48658,
    47596,
    12714,
    33845,
    3893,
    16165,
    35237,
    89983,
    14769,
    11962,
    147224,
    47018,
    29977,
    27979,
    5552,
    82338,
    86023,
    131368,
    1218,
    24853,
    237840,
    132193,
    15455,
    40873,
    3668,
    65351,
    53388,
    15229,
    59889,
    272245,
    47934,
    11858,
    34347,
    18038,
    90853,
    86981,
    300602,
    19343,
    114181,
    29362,
    84921,
    6095,
    106059,
    79472,
    38015,
    1206,
    48741,
    6208,
    8e4,
    21916,
    17423,
    6002,
    108083,
    24479,
    34931,
    56661,
    9511,
    26995,
    100694,
    163853,
    35997,
    81254,
    58321,
    18919,
    171890,
    86877,
    91341,
    74503,
    70477,
    53412,
    7027,
    59281,
    39892,
    131302,
    5864,
    15947,
    61301,
    67466,
    162369,
    47956,
    27874,
    35624,
    282324,
    21270,
    111847,
    102548,
    41482,
    30955,
    116737,
    28264,
    8592,
    55458,
    22301,
    75090,
    29821,
    30697,
    51709,
    3041,
    19208,
    8038,
    24634,
    30467,
    87509,
    126428,
    19389,
    18814,
    152686,
    20701,
    83474,
    45832,
    80891,
    105808,
    11378,
    153223,
    120770,
    98186,
    150633,
    49838,
    9141,
    12755,
    30962,
    5260,
    74490,
    21256,
    31678,
    65062,
    33326,
    289838,
    187831,
    20595,
    89768,
    2805,
    58535,
    10844,
    70085,
    12090,
    2451,
    138068,
    98544,
    24461,
    4511,
    6754,
    41684,
    28203,
    3383,
    65355,
    82833,
    30161,
    83924,
    234361,
    128424,
    28921,
    222594,
    33975,
    125491,
    34069,
    11508,
    67464,
    144226,
    41850,
    98703,
    34371,
    7901,
    21254,
    38398,
    65651,
    23549,
    53883,
    213340,
    123269,
    12028,
    71764,
    177701,
    28758,
    2623,
    68395,
    11549,
    15232,
    68603,
    9660,
    63116,
    36079,
    57093,
    31198,
    20475,
    48467,
    89984,
    35619,
    186847,
    107469,
    31389,
    43631,
    73867,
    41949,
    68841,
    114250,
    1605,
    30564,
    63403,
    17588,
    27680,
    99533,
    12641,
    70325,
    50428,
    73426,
    78379,
    11855,
    91651,
    72081,
    91720,
    60198,
    15743,
    12065,
    83398,
    140046,
    6761,
    46598,
    45900,
    5068,
    886,
    62448,
    148968,
    37347,
    19405,
    9680,
    15819,
    43496,
    63370,
    75667,
    163700,
    37639,
    3633,
    22774,
    34341,
    183131,
    134335,
    37200,
    23915,
    7054,
    14194,
    12970,
    26438,
    13350,
    285521,
    25594,
    8219,
    104410,
    91039,
    168804,
    138480,
    149734,
    15907,
    33818,
    61132,
    60082,
    4622,
    110187,
    56736,
    13551,
    73571,
    3945,
    73463,
    65498,
    17758,
    263266,
    17593,
    2710,
    27585,
    54469,
    38200,
    45367,
    63754,
    28881,
    3473,
    12791,
    98287,
    31895,
    65787,
    4463,
    94536,
    24951,
    36332,
    59901,
    28803,
    52130,
    86403,
    7668,
    181822,
    74831,
    18977,
    9850,
    177206,
    145485,
    109798,
    7292,
    31421,
    26280,
    77211,
    58511,
    12507,
    127004,
    11113,
    147,
    8729,
    56208,
    43066,
    79926,
    129937,
    31345,
    83947,
    39915,
    46146,
    98763,
    42566,
    1337,
    13192,
    18323,
    105163,
    80570,
    117753,
    16555,
    72883,
    11077,
    159438,
    40764,
    70933,
    83329,
    26066,
    12276,
    72059,
    21655,
    173836,
    126713,
    69454,
    153482,
    91585,
    70644,
    102558,
    110483,
    6764,
    127864,
    190133,
    3961,
    101798,
    20945,
    71138,
    82402,
    90884,
    69669,
    44753,
    923,
    16939,
    59700,
    164258,
    25969,
    27082,
    31399,
    43846,
    6306,
    246093,
    51342,
    6153,
    151581,
    202801,
    182731,
    56475,
    162188,
    89426,
    141356,
    14355,
    121815,
    27536,
    28023,
    65257,
    77523,
    106668,
    127314,
    24947,
    12790,
    38796,
    169698,
    23555,
    10725,
    44573,
    183083,
    42088,
    62716,
    43265,
    105958,
    32050,
    44067,
    50118,
    1668,
    3874,
    6243,
    318411,
    16599,
    1691,
    94999,
    52378,
    28671,
    216728,
    123258,
    2059,
    34969,
    69225,
    5913,
    136280,
    171443,
    141515,
    91662,
    22175,
    135282,
    80020,
    92270,
    1663,
    4808,
    4482,
    3495,
    34691,
    5226,
    109830,
    108512,
    17342,
    107488,
    11606,
    123190,
    100247,
    29666,
    146527,
    113014,
    15794,
    30894,
    13224,
    39585,
    243192,
    22351,
    9903,
    7836,
    47699,
    11078,
    25468,
    122291,
    48821,
    26780,
    122679,
    75521,
    81450,
    630,
    4895,
    92900,
    55074,
    74293,
    17441,
    3563,
    111657,
    103102,
    51613,
    12318,
    52370,
    36191,
    68245,
    34269,
    40445,
    41354,
    122901,
    168604,
    182500,
    62012,
    42557,
    11259,
    24428,
    115113,
    86345,
    12362,
    3909,
    78430,
    86852,
    134602,
    20459,
    47853,
    93879,
    22577,
    7659,
    3688,
    38555,
    13349,
    17381,
    56715,
    91639,
    12493,
    10895,
    92438,
    3142,
    37057,
    28928,
    2004,
    36427,
    32268,
    34222,
    209974,
    10432,
    67436,
    41989,
    173518,
    107930,
    27079,
    62729,
    30908,
    55558,
    5828,
    45031,
    14902,
    53546,
    8204,
    144263,
    60255,
    14520,
    88212,
    86582,
    109589,
    69356,
    8064,
    47449,
    8505,
    66558,
    16886,
    4844,
    52817,
    111260,
    215129,
    12941,
    91118,
    650,
    20770,
    6273,
    73089,
    40618,
    62790,
    2873,
    35002,
    14023,
    97208,
    19386,
    102646,
    36993,
    143736,
    135457,
    35385,
    113601,
    17893,
    32627,
    84439,
    100619,
    56016,
    6581,
    57264,
    172160,
    45452,
    111710,
    203627,
    70131,
    24100,
    322787,
    1996,
    35665,
    70078,
    22358,
    90922,
    83658,
    4097,
    63200,
    58499,
    14542,
    99153,
    52159,
    6615,
    12414,
    63415,
    31986,
    16823,
    1579,
    65405,
    137809,
    8841,
    16898,
    48082,
    259,
    33014,
    42375,
    12260,
    179850,
    73667,
    91389,
    98882,
    29532,
    17311,
    326251,
    41092,
    5928,
    20742,
    44964,
    48019,
    43505,
    9317,
    49265,
    6643,
    192712,
    48424,
    163487,
    19861,
    20113,
    70848,
    31928,
    105333,
    23685,
    78563,
    14638,
    54755,
    7158,
    24142,
    44018,
    20774,
    125255,
    20331,
    24280,
    10163,
    1285,
    2336,
    39851,
    4299,
    117269,
    46714,
    63816,
    87779,
    159624,
    11731,
    9971,
    990,
    137317,
    108831,
    50994,
    74554,
    162680,
    23640,
    131597,
    146962,
    170620,
    34829,
    91205,
    21184,
    1913,
    63616,
    18427,
    93136,
    156592,
    17519,
    67565,
    115882,
    138220,
    78622,
    88535,
    18115,
    2711,
    33554,
    109492,
    54298,
    971,
    24914,
    25863,
    36363,
    45715,
    27099,
    194995,
    14299,
    178181,
    111488,
    72395,
    322385,
    157719,
    130787,
    11897,
    81843,
    83999,
    11369,
    49280,
    118604,
    40922,
    61332,
    110343,
    53407,
    75639,
    40582,
    300440,
    54722,
    25637,
    13694,
    48248,
    48278,
    194521,
    56203,
    52779,
    48783,
    72627,
    10953,
    376,
    16733,
    280238,
    26351,
    230789,
    15132,
    25168,
    137270,
    3588,
    63704,
    73376,
    94031,
    74284,
    19443,
    159557,
    9697,
    39901,
    13351,
    119050,
    15406,
    146455,
    3460,
    29556,
    75195,
    37673,
    102524,
    92329,
    47289,
    98413,
    15311,
    100684,
    56345,
    7116,
    95480,
    11590,
    7200,
    167,
    23610,
    58426,
    17730,
    136656,
    27944,
    53151,
    2701,
    8824,
    103124,
    3017,
    90744,
    113588,
    53216,
    79736,
    65940,
    26931,
    498,
    29568,
    80540,
    143543,
    21292,
    1740,
    59268,
    16561,
    180816,
    42323,
    50174,
    40890,
    52866,
    10703,
    57169,
    4700,
    17191,
    4424,
    93511,
    49698,
    166650,
    26972,
    48631,
    165169,
    82879,
    69326,
    202970,
    4007,
    2376,
    231325,
    139592,
    22119,
    62851,
    37504,
    68816,
    58345,
    67398,
    186643,
    43331,
    277416,
    53749,
    15746,
    23102,
    17432,
    4793,
    151138,
    48822,
    54265,
    48203,
    198688,
    14305,
    54287,
    2291,
    18018,
    113378,
    123260,
    7180,
    97549,
    87027,
    120085,
    2920,
    76080,
    8190,
    102005,
    5641,
    64580,
    14955,
    59802,
    54028,
    58884,
    19367,
    81779,
    412567,
    85957,
    97053,
    103637,
    78871,
    29364,
    27637,
    141728,
    4767,
    30686,
    112738,
    130146,
    42745,
    12730,
    105040,
    14844,
    232,
    210944,
    36581,
    152317,
    135543,
    29744,
    3129,
    55647,
    58149,
    46319,
    27265,
    17499,
    28005,
    59948,
    7170,
    34138,
    5702,
    293047,
    110892,
    408,
    91760,
    218674,
    18469,
    46095,
    81403,
    14389,
    4610,
    35672,
    73060,
    11006,
    74848,
    104820,
    118143,
    190357,
    20043,
    105358,
    141735,
    5115,
    27093,
    45924,
    123073,
    52599,
    29433,
    9616,
    238350,
    78610,
    24851,
    58858,
    26769,
    31969,
    24613,
    18294,
    4982,
    32735,
    39639,
    143563,
    112073,
    202205,
    12567,
    4873,
    88601,
    44897,
    81503,
    101648,
    81362,
    34662,
    85277,
    17574,
    48173,
    21435,
    221188,
    40215,
    39576,
    80786,
    26544,
    64668,
    81841,
    10731,
    37733,
    247986,
    149188,
    127703,
    495,
    18382,
    54388,
    72446,
    43071,
    30974,
    198723,
    89608,
    41360,
    190,
    33045,
    8386,
    31658,
    19992,
    237838,
    119015,
    137622,
    50890,
    100913,
    6460,
    116233,
    267230,
    26621,
    104129,
    65114,
    14190,
    41542,
    14888,
    85962,
    23342,
    23041,
    26453,
    43725,
    71809,
    45186,
    4770,
    46452,
    53894,
    56616,
    221286,
    18973,
    9038,
    109299,
    55365,
    19366,
    26863,
    18808,
    60909,
    69353,
    41738,
    83463,
    12100,
    68561,
    72860,
    3980,
    13796,
    49340,
    12332,
    31311,
    27418,
    4255,
    53430,
    18976,
    45523,
    510,
    14224,
    30477,
    26581,
    4530,
    3651,
    101663,
    139840,
    22709,
    150861,
    31996,
    63923,
    120623,
    262522,
    3076,
    10528,
    2929,
    14672,
    130238,
    18087,
    9816,
    121894,
    100308,
    25085,
    55111,
    14565,
    18952,
    53293,
    2042,
    369988,
    23674,
    61789,
    133529,
    28783,
    108293,
    35477,
    47119,
    36448,
    71049,
    40015,
    33055,
    78598,
    198442,
    1833,
    159937,
    40654,
    77444,
    189245,
    113153,
    8621,
    18599,
    38553,
    35223,
    166072,
    2375,
    11659,
    21786,
    89523,
    6032,
    12116,
    63046,
    159398,
    18454,
    3678,
    32521,
    47626,
    11411,
    103527,
    38896,
    42946,
    15696,
    26370,
    10185,
    8413,
    37080,
    165583,
    4331,
    63555,
    14907,
    72220,
    50056,
    6623,
    62236,
    36565,
    49783,
    10049,
    17503,
    100581,
    55951,
    146244,
    24724,
    9626,
    17969,
    25524,
    109300,
    173965,
    99994,
    101056,
    46459,
    43647,
    53737,
    277968,
    8347,
    123521,
    74858,
    33829,
    44762,
    77574,
    877,
    81377,
    222525,
    123532,
    30602,
    43881,
    53145,
    2973,
    16284,
    81940,
    61281,
    127044,
    63620,
    9875,
    14756,
    114829,
    19032,
    9202,
    52759,
    119141,
    23928,
    120551,
    19607,
    3599,
    33401,
    76821,
    73233,
    117430,
    39968,
    36539,
    7071,
    5446,
    121735,
    194059,
    15206,
    45283,
    6706,
    15603,
    65615,
    1207,
    165723,
    92275,
    34773,
    104447,
    8396,
    32353,
    205240,
    164323,
    13600,
    60555,
    79205,
    25532,
    22907,
    33410,
    57480,
    107111,
    69630,
    32137,
    47832,
    70913,
    33161,
    20321,
    2371,
    117348,
    10714,
    86246,
    1625,
    11763,
    17900,
    268,
    78457,
    99175,
    97940,
    101092,
    86660,
    32221,
    14041,
    128504,
    125080,
    53744,
    124263,
    31017,
    13897,
    403,
    31859,
    21964,
    5633,
    111630,
    5547,
    77329,
    17961,
    18241,
    84995,
    25984,
    12983,
    67491,
    62168,
    47262,
    5241,
    297,
    51191,
    7351,
    8967,
    147212,
    82060,
    16821,
    782,
    11033,
    82431,
    62957,
    5026,
    43459,
    77963,
    203477,
    53528,
    6247,
    191852,
    87774,
    74164,
    215654,
    13467,
    1522,
    219964,
    28589,
    244104,
    16242,
    117821,
    67725,
    72570,
    156792,
    17186,
    15979,
    26990,
    44128,
    193014,
    35276,
    57125,
    16212,
    166451,
    68017,
    6905,
    77608,
    16364,
    53777,
    75921,
    76426,
    37975,
    26203,
    269296,
    64099,
    84122,
    12077,
    38533,
    830,
    4407,
    20139,
    963,
    43028,
    38902,
    42911,
    37503,
    83343,
    85045,
    16979,
    1165,
    60835,
    137387,
    58380,
    86990,
    110066,
    134540,
    56331,
    193845,
    81238,
    17922,
    163093,
    38744,
    110641,
    12502,
    56404,
    34862,
    26865,
    125964,
    12965,
    111648,
    25547,
    7771,
    27196,
    136980,
    9555,
    29551,
    107158,
    57885,
    18831,
    37705,
    35505,
    101742,
    13970,
    102109,
    62548,
    124657,
    23328,
    11124,
    89592,
    146376,
    248050,
    6241,
    22033,
    18337,
    80685,
    29898,
    11908,
    216623,
    67721,
    106162,
    146610,
    21377,
    15085,
    91552,
    42041,
    62560,
    122532,
    125336,
    102365,
    121537,
    142559,
    29693,
    223919,
    11515,
    110495,
    18776,
    22494,
    5895,
    185059,
    103592,
    229351,
    51220,
    100102,
    37027,
    257855,
    29359,
    54123,
    36066,
    106493,
    12244,
    79258,
    32002,
    432,
    56205,
    94836,
    90182,
    6726,
    14762,
    29391,
    48938,
    26864,
    38083,
    60364,
    3310,
    60192,
    14766,
    205567,
    57504,
    110760,
    22649,
    24666,
    46333,
    21517,
    3430,
    13135,
    28873,
    27052,
    158809,
    11597,
    20529,
    6695,
    23138,
    22960,
    37137,
    45574,
    6545,
    305877,
    43423,
    26153,
    24769,
    59844,
    14501,
    10430,
    134352,
    56169,
    13213,
    103432,
    49523,
    35181,
    13435,
    12408,
    129475,
    64620,
    230854,
    77390,
    51990,
    15653,
    83248,
    33466,
    44571,
    117828,
    51481,
    2187,
    10559,
    68019,
    18021,
    54895,
    48247,
    18354,
    33737,
    4554,
    108595,
    37288,
    39767,
    116707,
    9175,
    3726,
    108877,
    21616,
    83684,
    49862,
    1938,
    8543,
    276466,
    20134,
    108498,
    48770,
    102254,
    31914,
    131520,
    185291,
    100559,
    51890,
    209,
    19526,
    76471,
    50544,
    71814,
    99351,
    8172,
    198526,
    28816,
    20419,
    9109,
    98389,
    136777,
    76479,
    75596,
    30635,
    165417,
    48216,
    120220,
    25955,
    211071,
    39314,
    24308,
    32164,
    2559,
    146280,
    43403,
    9233,
    17947,
    90585,
    1786,
    86920,
    125662,
    2457,
    64741,
    32152,
    32918,
    122882,
    78538,
    44001,
    31723,
    56426,
    23375,
    103172,
    88177,
    145697,
    52506,
    49319,
    68016,
    31664,
    41488,
    18486,
    110400,
    7030,
    28241,
    986,
    109199,
    19900,
    42147,
    56864,
    65287,
    49183,
    7858,
    24e3,
    30453,
    840,
    16673,
    25907,
    68916,
    89927,
    6309,
    158335,
    36407,
    199737,
    130464,
    13137,
    59603,
    201778,
    195292,
    21015,
    42466,
    179062,
    172561,
    89492,
    11075,
    180407,
    31868,
    72493,
    20998,
    60217,
    9865,
    19530,
    39274,
    130266,
    54539,
    21623,
    12535,
    13505,
    40641,
    73375,
    4087,
    85633,
    2153,
    3117,
    70680,
    55788,
    92096,
    47509,
    98493,
    37490,
    271936,
    151475,
    3032,
    16171,
    96642,
    34106,
    78425,
    125761,
    19591,
    3366,
    19316,
    54508,
    24183,
    50786,
    194248,
    91528,
    33253,
    34622,
    108355,
    41741,
    705,
    3814,
    3883,
    108929,
    13203,
    67831,
    10142,
    59754,
    68208,
    29128,
    84820,
    56880,
    38794,
    24972,
    48571,
    40821,
    40476,
    18137,
    164254,
    24064,
    236309,
    79181,
    11282,
    395,
    39169,
    2013,
    51587,
    28551,
    9645,
    701,
    109513,
    115899,
    113566,
    12762,
    62045,
    58322,
    103726,
    41343,
    40866,
    244102,
    143816,
    2490,
    70346,
    40973,
    52618,
    15412,
    30720,
    104315,
    38917,
    42027,
    93676,
    17513,
    107418,
    20706,
    123890,
    13399,
    97727,
    24044,
    87962,
    65606,
    44250,
    98044,
    65276,
    74790,
    101473,
    19350,
    91570,
    1326,
    87790,
    172042,
    7577,
    100813,
    86896,
    85891,
    41512,
    108130,
    27794,
    14875,
    71431,
    12835,
    156250,
    58135,
    3759,
    22476,
    42176,
    115873,
    34686,
    56523,
    73643,
    108505,
    51491,
    20838,
    12721,
    32863,
    45700,
    29496,
    13700,
    34294,
    55360,
    29206,
    155942,
    123812,
    7706,
    163234,
    203,
    132720,
    49358,
    144431,
    8130,
    175788,
    35818,
    3270,
    76832,
    25710,
    54095,
    97274,
    28779,
    94621,
    74396,
    19092,
    128242,
    58067,
    20885,
    14670,
    93255,
    15107,
    63291,
    23654,
    126900,
    129421,
    59294,
    262659,
    9798,
    3251,
    67344,
    28600,
    44629,
    50672,
    29072,
    26999,
    31526,
    23183,
    49175,
    165843,
    175455,
    17282,
    175411,
    32022,
    45989,
    30298,
    90690,
    78118,
    83156,
    23749,
    35636,
    31317,
    7069,
    80381,
    94561,
    133756,
    14960,
    97404,
    6138,
    41065,
    78041,
    32843,
    16601,
    34123,
    9559,
    146529,
    123377,
    96395,
    54441,
    42012,
    84257,
    123541,
    10745,
    22139,
    106459,
    11720,
    150883,
    172651,
    154996,
    110538,
    4728,
    53447,
    25704,
    2009,
    71152,
    119354,
    21166,
    66604,
    1429,
    216162,
    8637,
    122250,
    63520,
    27180,
    29172,
    36124,
    276428,
    107787,
    77184,
    4680,
    14952,
    104903,
    24418,
    14793,
    51561,
    52931,
    8371,
    26342,
    48526,
    7118,
    92066,
    67280,
    40653,
    8847,
    34597,
    105438,
    14198,
    50163,
    61188,
    146286,
    50315,
    41205,
    170829,
    161496,
    585,
    197359,
    95056,
    1687,
    365794,
    91349,
    48507,
    5804,
    49263,
    5146,
    104902,
    96365,
    117343,
    132222,
    46084,
    96919,
    16875,
    8073,
    262381,
    79982,
    52663,
    13928,
    16056,
    153908,
    15145,
    109256,
    132308,
    18763,
    24904,
    167644,
    13618,
    40750,
    18686,
    147124,
    114709,
    150038,
    52849,
    2938,
    12568,
    48617,
    8778,
    5459,
    44202,
    44591,
    74914,
    17183,
    248689,
    13878,
    7822,
    80060,
    23116,
    194037,
    18487,
    2067,
    7798,
    43077,
    33678,
    244028,
    31320,
    74273,
    2794,
    19466,
    8218,
    36280,
    183997,
    48124,
    19416,
    29656,
    19280,
    98734,
    7715,
    18311,
    30701,
    133602,
    150307,
    126956,
    7378,
    2933,
    79903,
    13178,
    12593,
    86571,
    26604,
    92446,
    13574,
    44205,
    65699,
    427599,
    21118,
    8245,
    14407,
    27877,
    47936,
    33542,
    7916,
    26460,
    117762,
    21596,
    37818,
    2249,
    127359,
    209394,
    60044,
    47677,
    308089,
    36791,
    154971,
    31417,
    6998,
    150042,
    174360,
    12255,
    43009,
    29335,
    48739,
    3912,
    101398,
    53340,
    2580,
    146939,
    151295,
    45360,
    125275,
    15273,
    45383,
    27456,
    48761,
    23314,
    8750,
    60801,
    85823,
    104759,
    27894,
    123685,
    66968,
    39480,
    26917,
    55290,
    83305,
    2696,
    98390,
    57569,
    145853,
    340733,
    4919,
    20024,
    52268,
    30884,
    7413,
    203685,
    70989,
    112855,
    4129,
    50536,
    349518,
    68205,
    332641,
    159581,
    135361,
    236026,
    37563,
    176404,
    64899,
    6578,
    122033,
    63871,
    1850,
    85234,
    82089,
    66124,
    74145,
    121098,
    107351,
    12687,
    36881,
    117334,
    13136,
    14698,
    85933,
    93866,
    18047,
    32620,
    310,
    15094,
    46e3,
    88451,
    23632,
    36645,
    27940,
    87618,
    80520,
    58892,
    20976,
    27702,
    140090,
    96075,
    67841,
    103292,
    238964,
    87778,
    107338,
    17019,
    83427,
    67522,
    7302,
    8261,
    47570,
    116787,
    8730,
    80484,
    61772,
    174422,
    56005,
    131193,
    52875,
    14588,
    28471,
    59817,
    9586,
    15720,
    158155,
    51307,
    109734,
    15196,
    11025,
    59331,
    3884,
    52626,
    102602,
    84797,
    25158,
    27314,
    4437,
    20488,
    76214,
    189248,
    35023,
    114952,
    157376,
    2827,
    62439,
    102878,
    129749,
    36405,
    10329,
    109339,
    108633,
    36662,
    1254,
    13267,
    5470,
    87105,
    58004,
    15397,
    10434,
    159667,
    21864,
    52022,
    179464,
    3013,
    32147,
    31496,
    116832,
    18494,
    105502,
    129227,
    107267,
    50033,
    13481,
    9954,
    24267,
    22141,
    16257,
    116154,
    36185,
    950,
    115685,
    11305,
    176708,
    2048,
    178671,
    112573,
    287867,
    162328,
    497663,
    95170,
    50979,
    193861,
    50987,
    30368,
    136257,
    31830,
    46549,
    15119,
    169876,
    23788,
    17462,
    249887,
    57377,
    1949,
    35448,
    14791,
    43769,
    210091,
    3783,
    34612,
    282103,
    88380,
    245190,
    5457,
    20491,
    98908,
    11402,
    86899,
    117916,
    16028,
    162584,
    60644,
    320177,
    156096,
    31065,
    55876,
    22e3,
    77655,
    9992,
    23397,
    13757,
    317623,
    63978,
    215255,
    2443,
    17648,
    93231,
    27388,
    104529,
    93807,
    55505,
    140477,
    12046,
    112040,
    70887,
    40152,
    94365,
    112353,
    25063,
    114679,
    266061,
    71248,
    119555,
    15589,
    2244,
    617,
    14129,
    211431,
    70110,
    100652,
    7777,
    4383,
    85911,
    89221,
    21010,
    120615,
    58357,
    86405,
    37554,
    41647,
    18,
    15143,
    69662,
    60491,
    14714,
    186134,
    148344,
    42347,
    5410,
    168175,
    44535,
    42449,
    343894,
    129417,
    99682,
    20659,
    27272,
    140483,
    63455,
    222159,
    17536,
    13722,
    42637,
    62324,
    11976,
    114691,
    148109,
    2283,
    32057,
    182393,
    4295,
    147364,
    33705,
    2075,
    44303,
    30274,
    28331,
    63740,
    69740,
    29148,
    10346,
    44862,
    33716,
    73937,
    153333,
    12930,
    38784,
    247159,
    2515,
    41053,
    20256,
    83368,
    256189,
    54639,
    115240,
    5096,
    24661,
    175419,
    153552,
    26516,
    141,
    138176,
    63885,
    34115,
    47222,
    55709,
    2765,
    28479,
    38875,
    236608,
    12229,
    22921,
    77291,
    54426,
    45388,
    2860,
    57787,
    114579,
    295139,
    105782,
    17826,
    71066,
    19119,
    54364,
    69385,
    16568,
    12323,
    28057,
    33346,
    34919,
    124763,
    155533,
    101386,
    31644,
    8627,
    49001,
    303600,
    29868,
    63213,
    9103,
    77280,
    71333,
    9696,
    138789,
    37059,
    24823,
    5057,
    21352,
    32368,
    114208,
    56803,
    19424,
    10445,
    58514,
    8661,
    209508,
    26187,
    171838,
    10460,
    63454,
    14016,
    122504,
    41328,
    21329,
    46618,
    32493,
    38225,
    7855,
    31763,
    7945,
    29876,
    8734,
    6438,
    24205,
    97490,
    139977,
    130740,
    47323,
    33195,
    85390,
    57194,
    13813,
    60600,
    21313,
    96251,
    7699,
    27584,
    170521,
    139271,
    1363,
    4402,
    336738,
    129223,
    84983,
    69150,
    13147,
    3590,
    163929,
    207225,
    155260,
    55916,
    20288,
    4503,
    8398,
    98490,
    11773,
    27512,
    37113,
    84976,
    86558,
    28365,
    11756,
    116005,
    182148,
    13733,
    115313,
    47644,
    67208,
    85069,
    9347,
    14995,
    226141,
    14704,
    101835,
    41159,
    35314,
    13113,
    63526,
    214039,
    29978,
    50446,
    83339,
    17440,
    129441,
    72522,
    118641,
    97816,
    24907,
    73844,
    15717,
    118884,
    167255,
    96509,
    162793,
    30847,
    36849,
    51297,
    78974,
    77793,
    10427,
    1873,
    2972,
    9999,
    35074,
    28190,
    64297,
    146836,
    46298,
    60038,
    163007,
    108919,
    61219,
    2403,
    75022,
    127339,
    4233,
    110389,
    69022,
    9833,
    128097,
    88016,
    79390,
    222936,
    22570,
    94657,
    28462,
    56956,
    38803,
    81536,
    30474,
    152794,
    19566,
    16481,
    147408,
    74574,
    81895,
    20731,
    1918,
    1366,
    76367,
    187321,
    54494,
    24366,
    21690,
    61696,
    33283,
    107477,
    77499,
    31112,
    414383,
    74362,
    18463,
    218441,
    120929,
    59848,
    258629,
    201924,
    69269,
    454,
    19989,
    13054,
    59894,
    3623,
    58908,
    20681,
    35723,
    78523,
    102680,
    38988,
    184112,
    108087,
    50944,
    132704,
    52966,
    21699,
    18860,
    96349,
    201411,
    82697,
    85395,
    95658,
    5093,
    6427,
    177894,
    44191,
    32755,
    26961,
    155739,
    6249,
    31310,
    81030,
    26574,
    84311,
    120155,
    86730,
    113535,
    7424,
    48888,
    13516,
    45747,
    98098,
    20077,
    183995,
    81945,
    43210,
    26704,
    40420,
    75831,
    45648,
    11180,
    6855,
    57927,
    65528,
    124096,
    34851,
    2598,
    156633,
    107572,
    127352,
    38169,
    123845,
    60142,
    62722,
    105584,
    232364,
    23211,
    68120,
    1601,
    22169,
    89299,
    747,
    258039,
    80572,
    7258,
    152249,
    11862,
    101204,
    8834,
    121434,
    33761,
    19175,
    133142,
    46343,
    40178,
    48723,
    3589,
    41977,
    30210,
    38868,
    62257,
    10087,
    82658,
    87827,
    90646,
    16415,
    47552,
    351723,
    28298,
    72225,
    91146,
    272760,
    1701,
    11295,
    1652,
    109651,
    300747,
    51863,
    198800,
    29446,
    11794,
    32345,
    37538,
    22356,
    33102,
    37590,
    113544,
    37970,
    11478,
    179743,
    25454,
    103417,
    59905,
    221970,
    105196,
    145604,
    7817,
    164809,
    102360,
    16974,
    75840,
    255333,
    56902,
    6659,
    1954,
    645,
    59400,
    67769,
    7689,
    18675,
    5215,
    13793,
    20536,
    27852,
    3387,
    29523,
    259718,
    16860,
    94625,
    43143,
    29245,
    15848,
    233581,
    22685,
    63631,
    78557,
    22836,
    133302,
    84513,
    1348,
    51826,
    47129,
    98836,
    58284,
    1830,
    1749,
    94642,
    10933,
    6145,
    12506,
    10975,
    13879,
    103781,
    144434,
    10268,
    28409,
    32346,
    52968,
    121567,
    107374,
    77268,
    23686,
    35097,
    10501,
    155275,
    15303,
    47136,
    21102,
    168741,
    55332,
    90385,
    15996,
    84817,
    681,
    137803,
    25054,
    142275,
    6163,
    38175,
    8056,
    124296,
    240642,
    65621,
    4934,
    178205,
    16101,
    62803,
    60964,
    18230,
    100622,
    76465,
    44689,
    14545,
    9543,
    47514,
    16852,
    93380,
    28048,
    12047,
    107106,
    37575,
    101485,
    77047,
    57326,
    34819,
    96137,
    76916,
    6469,
    46264,
    115983,
    75768,
    87668,
    69942,
    13027,
    165,
    8373,
    114231,
    26434,
    52844,
    42799,
    182044,
    23580,
    146254,
    38081,
    43236,
    33883,
    146220,
    382894,
    14606,
    46035,
    36481,
    166621,
    35417,
    95382,
    2957,
    59384,
    60428,
    36358,
    66343,
    75378,
    22267,
    22950,
    83528,
    17577,
    56474,
    25285,
    4619,
    179691,
    75355,
    95836,
    53295,
    34588,
    171410,
    4487,
    14679,
    84208,
    44015,
    18562,
    109133,
    54101,
    11531,
    86052,
    174479,
    303157,
    28095,
    9953,
    35642,
    14564,
    39802,
    16145,
    77606,
    117406,
    53038,
    121117,
    53624,
    22062,
    1212,
    7632,
    127157,
    237292,
    189087,
    10478,
    127345,
    102515,
    181997,
    86752,
    87623,
    10966,
    121602,
    68783,
    68681,
    83042,
    114380,
    138349,
    191305,
    67176,
    50085,
    39016,
    1427,
    42384,
    1412,
    67118,
    122616,
    72389,
    25260,
    2237,
    13576,
    137346,
    19938,
    20304,
    2191,
    68759,
    5373,
    61364,
    238507,
    75814,
    23931,
    69565,
    38993,
    131741,
    38364,
    12528,
    87762,
    5679,
    129853,
    5310,
    186831,
    32653,
    90338,
    260176,
    389531,
    108118,
    26843,
    43985,
    50175,
    30563,
    25106,
    56965,
    18130,
    140428,
    4542,
    165503,
    117991,
    24219,
    229605,
    1819,
    129663,
    1240,
    3797,
    76093,
    18398,
    71339,
    51919,
    93043,
    27175,
    47060,
    216257,
    6483,
    35051,
    1217,
    16512,
    80798,
    129064,
    13225,
    69339,
    8548,
    237079,
    72298,
    2575,
    34280,
    51379,
    117910,
    55671,
    53345,
    247552,
    29486,
    39328,
    140821,
    34681,
    57045,
    60177,
    5004,
    90269,
    78522,
    2479,
    322607,
    48474,
    61296,
    13057,
    31558,
    4678,
    59271,
    6699,
    27044,
    31988,
    35944,
    12503,
    83480,
    4389,
    136508,
    3781,
    114121,
    70279,
    4488,
    155829,
    42214,
    2898,
    68191,
    75695,
    305850,
    45041,
    74344,
    106509,
    30087,
    17429,
    93292,
    12477,
    290,
    23080,
    114802,
    35714,
    18751,
    26554,
    105424,
    17775,
    2144,
    2412,
    100610,
    65192,
    113975,
    52975,
    180272,
    135050,
    129815,
    76238,
    106483,
    21440,
    63186,
    4260,
    46189,
    9711,
    28249,
    4169,
    23429,
    23390,
    8324,
    141585,
    63809,
    67668,
    38457,
    38063,
    39226,
    59972,
    1189,
    203916,
    62368,
    14403,
    16949,
    61767,
    85801,
    1739,
    40147,
    35049,
    76757,
    33124,
    62102,
    15780,
    103593,
    103009,
    53484,
    22952,
    67973,
    114645,
    6566,
    5245,
    50462,
    7601,
    8288,
    3513,
    194571,
    80276,
    1908,
    54592,
    5124,
    58571,
    2513,
    6800,
    273997,
    193904,
    1119,
    17991,
    117245,
    2508,
    129156,
    82366,
    26278,
    71465,
    63341,
    56943,
    39662,
    106116,
    94966,
    156875,
    9736,
    2204,
    122308,
    94418,
    27134,
    1280,
    24539,
    49022,
    45314,
    3764,
    50904,
    46424,
    30699,
    28087,
    293839,
    9400,
    33646,
    40165,
    822,
    147499,
    50263,
    116179,
    29085,
    11863,
    31314,
    5578,
    17797,
    5104,
    12454,
    1604,
    15342,
    219206,
    10232,
    67800,
    94261,
    25872,
    13565,
    90339,
    78971,
    75377,
    26649,
    41184,
    47695,
    11514,
    35369,
    20767,
    14227,
    41953,
    309396,
    148270,
    147938,
    33074,
    14453,
    27499,
    109019,
    39018,
    25738,
    240196,
    158931,
    52820,
    8612,
    95853,
    21524,
    137010,
    84901,
    70869,
    70021,
    116794,
    48404,
    38771,
    6732,
    1070,
    70990,
    187297,
    49140,
    5238,
    576,
    3564,
    253975,
    16027,
    16483,
    2811,
    37775,
    19034,
    25259,
    4053,
    2e3,
    70083,
    95774,
    19713,
    33431,
    92703,
    91314,
    42381,
    288770,
    48194,
    95985,
    3991,
    77418,
    13406,
    241328,
    245086,
    56533,
    35275,
    62725,
    9246,
    51924,
    70181,
    95331,
    16163,
    31410,
    79016,
    39312,
    120878,
    119371,
    275987,
    80124,
    27712,
    9186,
    220,
    23598,
    146167,
    85209,
    68238,
    282190,
    57048,
    31273,
    30555,
    80913,
    17594,
    75779,
    59160,
    135002,
    101219,
    189377,
    29225,
    96735,
    60126,
    62522,
    104e3,
    27620,
    86814,
    17240,
    147533,
    11001,
    5425,
    43682,
    410,
    49460,
    87270,
    69480,
    46315,
    59448,
    1816,
    76201,
    9431,
    11788,
    87960,
    29063,
    65539,
    47347,
    11678,
    33846,
    7008,
    196704,
    9895,
    6753,
    8633,
    120892,
    59970,
    572824,
    115934,
    6646,
    202559,
    892,
    48351,
    37611,
    251282,
    57823,
    67263,
    57750,
    26527,
    34485,
    90747,
    7685,
    88370,
    6144,
    64182,
    1709,
    41969,
    21458,
    62327,
    181657,
    49247,
    225330,
    122600,
    114574,
    107124,
    85361,
    111833,
    63243,
    71420,
    15655,
    191178,
    72430,
    18063,
    51425,
    54002,
    12364,
    53225,
    86557,
    18193,
    97580,
    41232,
    138398,
    67821,
    128724,
    8944,
    233212,
    101353,
    52099,
    42127,
    14006,
    120107,
    32789,
    32132,
    3498,
    18123,
    33758,
    56058,
    5779,
    128760,
    59888,
    98869,
    18445,
    84702,
    51911,
    13234,
    218379,
    20093,
    39031,
    8074,
    70195,
    20708,
    23462,
    24355,
    131384,
    60189,
    26390,
    10403,
    41060,
    7140,
    10781,
    49410,
    42261,
    87202,
    82566,
    41663,
    43105,
    60276,
    2768,
    5733,
    74176,
    28329,
    2297,
    145430,
    131632,
    83615,
    122915,
    105441,
    655,
    224102,
    5284,
    136426,
    67763,
    16294,
    188511,
    32538,
    61049,
    27893,
    3394,
    13951,
    159099,
    28542,
    17930,
    145360,
    9492,
    190122,
    32285,
    78855,
    26440,
    13570,
    58648,
    73908,
    4239,
    124561,
    2444,
    74172,
    53131,
    11468,
    10794,
    73566,
    11623,
    35343,
    64710,
    30481,
    4163,
    10328,
    38309,
    29901,
    10538,
    154377,
    76132,
    92405,
    24839,
    11679,
    3465,
    13449,
    11637,
    7824,
    2337,
    57754,
    1260,
    14458,
    41118,
    19878,
    38661,
    13416,
    159180,
    37074,
    163164,
    54137,
    28627,
    52134,
    184900,
    8520,
    40385,
    29546,
    30502,
    22386,
    66527,
    107458,
    6850,
    24022,
    47983,
    30603,
    35083,
    8934,
    304066,
    39500,
    9,
    28261,
    33026,
    77251,
    9374,
    44833,
    116312,
    34990,
    29236,
    63563,
    125639,
    135405,
    165398,
    159055,
    55690,
    88141,
    69643,
    236964,
    31983,
    25572,
    20436,
    36746,
    60896,
    31850,
    16179,
    11828,
    5888,
    3043,
    66368,
    9750,
    31167,
    7915,
    53111,
    36430,
    1333,
    64344,
    93659,
    20061,
    60596,
    180191,
    51630,
    6792,
    30244,
    43509,
    101058,
    22409,
    420,
    44210,
    109783,
    43223,
    27030,
    72477,
    72831,
    32679,
    29235,
    7675,
    47556,
    12258,
    39907,
    149412,
    84926,
    118247,
    24692,
    71717,
    105038,
    86009,
    45941,
    41189,
    89453,
    29856,
    52543,
    30627,
    226798,
    67303,
    59230,
    67415,
    34408,
    1367,
    99685,
    16867,
    128419,
    52147,
    4111,
    125381,
    117881,
    16173,
    44093,
    102224,
    31575,
    23234,
    24870,
    83790,
    127407,
    239098,
    3200,
    994,
    1255,
    100903,
    242275,
    117266,
    55116,
    38205,
    16140,
    29662,
    11307,
    40414,
    208793,
    123355,
    56470,
    4862,
    75600,
    30119,
    58218,
    70828,
    24075,
    26974,
    7802,
    192353,
    4851,
    5475,
    78720,
    66596,
    3409,
    28573,
    64396,
    30381,
    30690,
    59859,
    88256,
    5406,
    99945,
    103064,
    34463,
    37727,
    24238,
    86643,
    60088,
    4057,
    23741,
    5967,
    162904,
    38240,
    28356,
    93858,
    25510,
    122879,
    6897,
    3278,
    7057,
    11971,
    4400,
    35461,
    211413,
    21395,
    59615,
    39471,
    87233,
    55795,
    128426,
    3051,
    22470,
    41950,
    14705,
    3974,
    180108,
    80476,
    78442,
    204996,
    91987,
    15634,
    67610,
    139015,
    142373,
    35611,
    51134,
    10387,
    4353,
    153456,
    57749,
    181039,
    14183,
    68447,
    151532,
    21107,
    36452,
    20551,
    3186,
    46247,
    46383,
    129666,
    88736,
    140662,
    146243,
    2066,
    8360,
    7978,
    64818,
    106963,
    17896,
    47801,
    10723,
    114821,
    223295,
    74192,
    3293,
    3393,
    16987,
    74064,
    11277,
    91622,
    4270,
    29828,
    27951,
    387869,
    103235,
    1374,
    61988,
    120083,
    477,
    145892,
    128378,
    11779,
    211263,
    61354,
    18221,
    17869,
    46530,
    83061,
    108538,
    157981,
    90608,
    67199,
    95080,
    49064,
    195814,
    12302,
    66307,
    10348,
    231346,
    160732,
    112859,
    63633,
    146558,
    21271,
    31037,
    198802,
    47622,
    12862,
    95710,
    3910,
    77850,
    73961,
    85585,
    34752,
    61e3,
    4082,
    24595,
    103679,
    71107,
    8208,
    79568,
    150019,
    16615,
    24961,
    139857,
    32664,
    197366,
    4559,
    54735,
    32696,
    4126,
    162019,
    75698,
    13916,
    70108,
    159638,
    19834,
    9349,
    24675,
    175560,
    49643,
    18206,
    52459,
    27992,
    10809,
    88865,
    401975,
    133172,
    29e3,
    34558,
    30915,
    3658,
    25834,
    42430,
    36562,
    125265,
    18182,
    10155,
    40149,
    97082,
    208980,
    19575,
    60853,
    90529,
    66545,
    9600,
    789,
    46420,
    2317,
    88593,
    55595,
    98980,
    115302,
    5742,
    169155,
    1073,
    177901,
    3472,
    11189,
    63711,
    78643,
    65472,
    50459,
    127979,
    93,
    42202,
    67053,
    21720,
    157650,
    11145,
    141378,
    42033,
    22824,
    85705,
    79114,
    35584,
    15974,
    1510,
    54172,
    28562,
    12451,
    104226,
    19190,
    97151,
    73024,
    20948,
    5151,
    81741,
    21499,
    29006,
    84183,
    198074,
    54003,
    45120,
    170125,
    26240,
    35177,
    28389,
    64863,
    79974,
    60778,
    176915,
    232183,
    45342,
    2038,
    80253,
    41564,
    40703,
    32689,
    5430,
    100689,
    5366,
    23007,
    134279,
    14266,
    26712,
    73993,
    24934,
    64242,
    52113,
    102887,
    61801,
    46415,
    201049,
    54251,
    62133,
    122757,
    164883,
    30815,
    139966,
    2319,
    30842,
    766,
    13362,
    10287,
    134518,
    86111,
    81665,
    82440,
    28333,
    43019,
    18963,
    8804,
    161944,
    23439,
    102144,
    101145,
    80029,
    39052,
    248708,
    30350,
    117340,
    11878,
    128467,
    974,
    138625,
    63961,
    5237,
    74778,
    61834,
    67040,
    43814,
    13690,
    65947,
    33809,
    232476,
    115258,
    181745,
    28824,
    94013,
    9510,
    10246,
    93722,
    81976,
    7217,
    114383,
    3493,
    16014,
    69045,
    72692,
    12145,
    80981,
    9507,
    6692,
    1620,
    60820,
    330444,
    35474,
    33962,
    4797,
    7053,
    295463,
    46445,
    27026,
    12491,
    77988,
    49524,
    35675,
    90947,
    29114,
    166705,
    101385,
    133782,
    32704,
    6186,
    84595,
    176031,
    185623,
    45966,
    151302,
    63069,
    1699,
    107491,
    947,
    15458,
    74452,
    196212,
    6046,
    10498,
    12163,
    10239,
    35191,
    243951,
    9277,
    9090,
    29539,
    54460,
    22820,
    26514,
    112549,
    60372,
    51753,
    48756,
    21812,
    70861,
    260326,
    41,
    44222,
    10441,
    16961,
    48148,
    138771,
    216194,
    5914,
    52153,
    53400,
    212036,
    56519,
    26245,
    10117,
    45888,
    15294,
    138019,
    90913,
    26368,
    43842,
    42111,
    23348,
    6082,
    194845,
    161089,
    156206,
    51546,
    11647,
    30759,
    302912,
    262094,
    8635,
    78876,
    26535,
    35283,
    54183,
    31183,
    85484,
    147873,
    12989,
    5197,
    6356,
    72894,
    65347,
    20150,
    27370,
    73787,
    1493,
    45918,
    12366,
    190217,
    20724,
    13858,
    10981,
    67449,
    81213,
    7553,
    14115,
    72242,
    271517,
    11842,
    48310,
    88743,
    143726,
    22177,
    3290,
    243231,
    58452,
    62937,
    12592,
    1654,
    40066,
    33477,
    13751,
    9921,
    128442,
    15868,
    7106,
    75236,
    83773,
    10775,
    36938,
    10482,
    170465,
    17368,
    17469,
    161508,
    32752,
    98340,
    800,
    19824,
    264456,
    3901,
    87319,
    2867,
    26782,
    9630,
    113102,
    185815,
    24197,
    44584,
    86366,
    40224,
    3636,
    140916,
    31731,
    267731,
    9567,
    53678,
    72984,
    29389,
    27963,
    17106,
    50282,
    284911,
    60170,
    8322,
    12608,
    23374,
    89652,
    5268,
    39044,
    229766,
    8869,
    151350,
    31436,
    177342,
    12269,
    183212,
    120418,
    116270,
    2843,
    78888,
    69192,
    7865,
    184099,
    1086,
    129897,
    18383,
    70508,
    20242,
    18508,
    229924,
    124569,
    35749,
    50589,
    55626,
    9884,
    83115,
    40971,
    30671,
    18135,
    14452,
    38861,
    17844,
    201826,
    5549,
    26413,
    17189,
    13561,
    38539,
    10679,
    143331,
    3314,
    36785,
    171194,
    49685,
    187713,
    67506,
    4618,
    104039,
    17060,
    195080,
    50648,
    33159,
    19238,
    67559,
    134840,
    28599,
    157523,
    17130,
    38064,
    117398,
    94355,
    31918,
    13575,
    34538,
    40326,
    13997,
    3494,
    348283,
    62481,
    26862,
    3603,
    104426,
    244363,
    153709,
    112487,
    304612,
    199674,
    41239,
    35545,
    54869,
    293005,
    28223,
    26277,
    26899,
    4533,
    18518,
    15492,
    38587,
    80488,
    70485,
    160395,
    263,
    60162,
    11382,
    222152,
    4696,
    250751,
    51921,
    182609,
    10707,
    48463,
    46243,
    1227,
    49111,
    111564,
    46502,
    33342,
    56846,
    68541,
    63559,
    858,
    139927,
    16654,
    229375,
    76759,
    26478,
    33205,
    95828,
    23399,
    92945,
    2637,
    35630,
    28470,
    143992,
    50214,
    14174,
    21456,
    166191,
    65665,
    1711,
    21594,
    78019,
    97599,
    111701,
    36,
    147151,
    110246,
    189022,
    43021,
    30397,
    40757,
    131935,
    42065,
    73335,
    48039,
    26596,
    28984,
    15102,
    2361,
    7421,
    202167,
    69744,
    43766,
    52826,
    3642,
    83304,
    33873,
    75140,
    63169,
    192389,
    36551,
    92748,
    13039,
    123959,
    233220,
    21738,
    84447,
    77230,
    20228,
    187852,
    19095,
    25799,
    92136,
    108774,
    29237,
    53947,
    2299,
    118106,
    2687,
    8830,
    42331,
    202924,
    33667,
    2023,
    73763,
    30704,
    19363,
    19779,
    16737,
    35629,
    48081,
    24068,
    101013,
    162338,
    291912,
    13749,
    24745,
    328289,
    167679,
    70086,
    48299,
    23306,
    16732,
    17801,
    43322,
    54589,
    3586,
    63653,
    43624,
    53474,
    925,
    109177,
    251316,
    43805,
    13082,
    19511,
    86565,
    142182,
    92461,
    17117,
    101033,
    103319,
    64589,
    4022,
    4351,
    235897,
    5352,
    82705,
    107142,
    46391,
    156084,
    5860,
    61365,
    10558,
    13045,
    7717,
    18357,
    33922,
    12590,
    33065,
    6928,
    46993,
    783,
    46937,
    67846,
    8952,
    26295,
    6107,
    119656,
    18799,
    17458,
    50747,
    4229,
    179559,
    112727,
    118080,
    20683,
    41464,
    125468,
    51560,
    49749,
    44231,
    7359,
    35339,
    62988,
    136487,
    67015,
    5208,
    29150,
    24956,
    105186,
    48858,
    6143,
    18097,
    6972,
    16404,
    73489,
    58742,
    97196,
    36357,
    164616,
    5834,
    32267,
    13746,
    147733,
    15113,
    132091,
    34127,
    106298,
    39729,
    106426,
    22294,
    9780,
    15602,
    36213,
    71502,
    42808,
    66802,
    599,
    60755,
    5851,
    39120,
    67363,
    108623,
    126368,
    72770,
    91263,
    32486,
    30596,
    151717,
    7951,
    52002,
    43103,
    11768,
    68942,
    40901,
    39344,
    24037,
    127500,
    116890,
    48403,
    16926,
    86750,
    17745,
    48648,
    159545,
    34460,
    58419,
    5634,
    114317,
    67865,
    31462,
    23352,
    24010,
    98185,
    125708,
    69686,
    68337,
    13610,
    26271,
    70691,
    2980,
    4768,
    27225,
    102402,
    75453,
    28106,
    8104,
    6931,
    1176,
    6274,
    6475,
    112635,
    22498,
    6176,
    238686,
    26832,
    28893,
    90319,
    14441,
    15682,
    15087,
    39517,
    45270,
    109134,
    104440,
    45965,
    47645,
    81772,
    7876,
    52683,
    87720,
    12898,
    4505,
    185665,
    2769,
    113401,
    15664,
    57592,
    105229,
    137381,
    97059,
    119268,
    6876,
    43309,
    33886,
    128363,
    35476,
    144249,
    67013,
    143587,
    83367,
    25703,
    91436,
    59347,
    53236,
    2289,
    16519,
    19844,
    46309,
    58558,
    99834,
    23313,
    218816,
    231303,
    36388,
    51333,
    183535,
    109792,
    139277,
    54306,
    90139,
    18235,
    8275,
    32710,
    37677,
    82464,
    86025,
    92204,
    88842,
    117723,
    37570,
    128723,
    234242,
    76350,
    73795,
    34896,
    148247,
    58424,
    11105,
    11744,
    45746,
    63372,
    17118,
    49772,
    199520,
    81902,
    38004,
    22911,
    33752,
    3125,
    1995,
    53792,
    4689,
    26909,
    108150,
    146062,
    69674,
    41811,
    161444,
    84855,
    8999,
    28561,
    16731,
    93937,
    3189,
    21967,
    24890,
    22943,
    1356,
    145300,
    51569,
    28802,
    517,
    118679,
    31703,
    40607,
    48098,
    108854,
    25003,
    10233,
    73969,
    177495,
    5248,
    24516,
    215347,
    146192,
    48712,
    60626,
    69188,
    40735,
    5866,
    586,
    101541,
    6509,
    47590,
    52129,
    5969,
    222045,
    110933,
    25733,
    24223,
    65339,
    62812,
    2414,
    155418,
    35819,
    16022,
    78423,
    43138,
    20995,
    128255,
    240673,
    46745,
    236093,
    72176,
    57085,
    97841,
    61248,
    107,
    36068,
    193177,
    105427,
    55726,
    215229,
    20446,
    47228,
    100420,
    87091,
    14429,
    121708,
    23605,
    21157,
    187721,
    21880,
    2997,
    203976,
    99166,
    95068,
    25877,
    7724,
    98925,
    83401,
    4829,
    13182,
    18229,
    13718,
    239662,
    38653,
    116505,
    153497,
    30589,
    89029,
    38962,
    181302,
    43853,
    78872,
    180301,
    4786,
    248240,
    7401,
    106136,
    112590,
    77745,
    19731,
    60880,
    77789,
    125748,
    135487,
    5975,
    48627,
    34084,
    12419,
    215770,
    47557,
    254582,
    10364,
    106495,
    21856,
    67539,
    88981,
    38805,
    21428,
    48732,
    42316,
    12149,
    16078,
    52808,
    25327,
    51322,
    33850,
    51147,
    12253,
    122354,
    46077,
    56483,
    254553,
    115417,
    81834,
    150991,
    94662,
    86668,
    7381,
    12841,
    100650,
    18218,
    15741,
    22372,
    68294,
    50705,
    15535,
    84660,
    61887,
    22553,
    72299,
    31361,
    24824,
    17743,
    46820,
    64288,
    31582,
    77006,
    111674,
    116384,
    30760,
    80920,
    86149,
    77192,
    51979,
    79691,
    60342,
    122805,
    103800,
    240873,
    160744,
    233114,
    78962,
    54920,
    8608,
    3484,
    316104,
    72548,
    24337,
    5088,
    230040,
    21926,
    10172,
    36838,
    26,
    86221,
    83458,
    102176,
    12062,
    17571,
    41929,
    41170,
    28428,
    68239,
    41750,
    103930,
    2634,
    18313,
    53019,
    34825,
    97837,
    63115,
    24606,
    73157,
    152474,
    14715,
    91439,
    37033,
    109806,
    140259,
    30668,
    174760,
    380,
    135597,
    95673,
    136073,
    65073,
    134249,
    13829,
    17279,
    122305,
    4420,
    46444,
    10237,
    64848,
    203623,
    70728,
    10349,
    182885,
    65075,
    24519,
    25783,
    40318,
    34139,
    22222,
    63394,
    55266,
    102764,
    41422,
    20126,
    65100,
    90408,
    53640,
    35128,
    48932,
    11192,
    38935,
    96839,
    34782,
    39492,
    19396,
    41332,
    6250,
    5511,
    19492,
    51304,
    25936,
    104466,
    54099,
    73771,
    86115,
    5080,
    7669,
    30891,
    111700,
    13931,
    25276,
    72289,
    135447,
    14820,
    258641,
    25265,
    31005,
    281179,
    75286,
    393,
    95359,
    14623,
    13584,
    6680,
    101227,
    80173,
    44933,
    76666,
    54542,
    13244,
    39348,
    458,
    25379,
    109451,
    134348,
    81143,
    6959,
    65554,
    12027,
    51311,
    8716,
    57589,
    140731,
    28467,
    23316,
    17272,
    30458,
    25980,
    55229,
    77197,
    83798,
    28302,
    114784,
    7428,
    34548,
    26241,
    14712,
    39336,
    103304,
    18928,
    54080,
    12870,
    334,
    87722,
    15208,
    16895,
    142098,
    114262,
    39820,
    83913,
    57817,
    28682,
    7721,
    14900,
    108672,
    11250,
    62246,
    42849,
    415188,
    1724,
    26555,
    24549,
    25505,
    26443,
    107450,
    145899,
    61035,
    43528,
    6901,
    60726,
    65906,
    267741,
    21338,
    147590,
    42079,
    18924,
    73017,
    135236,
    15393,
    5206,
    4026,
    84185,
    1531,
    5988,
    113890,
    82647,
    303391,
    7386,
    69844,
    71611,
    189865,
    76523,
    31877,
    13315,
    19314,
    198575,
    32821,
    1928,
    67641,
    25913,
    104475,
    103489,
    3297,
    70391,
    18406,
    15446,
    113347,
    19295,
    93790,
    27856,
    1792,
    167471,
    116449,
    8541,
    4408,
    41757,
    63233,
    25765,
    86680,
    64501,
    27034,
    24816,
    34975,
    6079,
    4486,
    49693,
    36229,
    16917,
    21581,
    62426,
    27862,
    11612,
    54284,
    35702,
    194034,
    355,
    24277,
    48262,
    87411,
    70504,
    310164,
    118018,
    12516,
    47559,
    43502,
    57433,
    107139,
    9290,
    66533,
    80863,
    14634,
    34312,
    91725,
    28606,
    21342,
    67241,
    72355,
    43244,
    375789,
    37402,
    174015,
    105070,
    8342,
    44167,
    67494,
    1890,
    16365,
    11723,
    271002,
    1865,
    47918,
    8350,
    45564,
    27742,
    25110,
    125803,
    8553,
    49504,
    81925,
    62211,
    4534,
    15491,
    19011,
    80373,
    206920,
    667,
    102405,
    128623,
    245524,
    5553,
    113309,
    192739,
    65766,
    19567,
    22832,
    261958,
    29679,
    21293,
    71134,
    20962,
    105123,
    24721,
    860,
    21752,
    33448,
    18372,
    157167,
    94822,
    35770,
    173224,
    232737,
    75729,
    28937,
    46828,
    28062,
    25453,
    5207,
    140366,
    36665,
    30652,
    6169,
    67920,
    150458,
    92040,
    23186,
    184604,
    92330,
    20891,
    176492,
    49427,
    27828,
    38305,
    42495,
    143982,
    49560,
    25503,
    90043,
    29747,
    65328,
    47830,
    12932,
    11068,
    77721,
    9003,
    25213,
    94205,
    140426,
    46090,
    89945,
    138173,
    192691,
    33329,
    112232,
    129905,
    35709,
    27514,
    1841,
    19957,
    31411,
    127476,
    53572,
    17497,
    173549,
    55063,
    175135,
    19841,
    69314,
    5192,
    237921,
    117660,
    150697,
    4060,
    273045,
    50414,
    98940,
    65348,
    153665,
    164423,
    58804,
    156695,
    48994,
    213928,
    86036,
    28608,
    8355,
    39574,
    34540,
    16927,
    135680,
    18374,
    151587,
    10830,
    53805,
    16878,
    16623,
    4282,
    48030,
    8537,
    14986,
    46102,
    13062,
    72897,
    72,
    33050,
    108227,
    39451,
    45935,
    651,
    113320,
    40535,
    95176,
    57450,
    48843,
    5003,
    19019,
    10407,
    211163,
    3848,
    1068,
    4988,
    32091,
    30095,
    41692,
    15099,
    43602,
    107434,
    50744,
    7627,
    171349,
    16313,
    150832,
    352665,
    207750,
    33937,
    38256,
    51091,
    156e3,
    87889,
    90663,
    84175,
    24908,
    114900,
    50365,
    31494,
    83829,
    5398,
    169342,
    47521,
    54818,
    18935,
    8356,
    43094,
    41212,
    174536,
    10082,
    92550,
    6678,
    60614,
    23355,
    69721,
    14796,
    34149,
    128830,
    58187,
    3179,
    208,
    40325,
    28399,
    225029,
    401412,
    51150,
    31580,
    207268,
    6657,
    10993,
    69818,
    64282,
    289845,
    23308,
    12961,
    38447,
    6681,
    52944,
    31855,
    2572,
    47646,
    120728,
    179148,
    37240,
    45196,
    218274,
    4816,
    3695,
    21961,
    50084,
    35209,
    18073,
    51452,
    27004,
    6100,
    33941,
    1377,
    84831,
    171214,
    85,
    141510,
    9078,
    99227,
    32610,
    6417,
    11718,
    49868,
    65579,
    87902,
    73018,
    49062,
    46280,
    61742,
    21512,
    40862,
    107733,
    15941,
    29168,
    157765,
    144919,
    14487,
    5767,
    158014,
    140070,
    7241,
    573,
    71584,
    16921,
    223566,
    40331,
    179473,
    35081,
    47926,
    140885,
    41508,
    52104,
    59180,
    42310,
    32811,
    29048,
    123517,
    102413,
    80208,
    10104,
    14746,
    12649,
    153641,
    126022,
    37965,
    113017,
    4171,
    83,
    142592,
    2809,
    6362,
    50416,
    71323,
    116894,
    260776,
    16204,
    1524,
    5760,
    30351,
    12658,
    20703,
    54403,
    36083,
    45408,
    74772,
    4946,
    14485,
    50759,
    111222,
    10890,
    2195,
    167147,
    92962,
    130534,
    16283,
    177256,
    35016,
    15472,
    210156,
    151187,
    73922,
    117691,
    43250,
    52051,
    37392,
    24811,
    24358,
    30830,
    5775,
    818,
    21969,
    1476,
    127322,
    151783,
    58392,
    31021,
    106913,
    65215,
    89407,
    90802,
    28531,
    11690,
    20234,
    95249,
    44602,
    37256,
    18707,
    11928,
    5161,
    4410,
    26571,
    51903,
    49768,
    22008,
    25252,
    65780,
    209499,
    68769,
    203726,
    13249,
    137363,
    48845,
    86823,
    6658,
    5674,
    31881,
    1083,
    1823,
    108676,
    34518,
    166752,
    13791,
    14287,
    91576,
    91429,
    8665,
    11529,
    26401,
    16191,
    91972,
    30964,
    5254,
    28486,
    54697,
    79613,
    66520,
    18447,
    22870,
    45203,
    194466,
    22822,
    51703,
    12278,
    76716,
    44595,
    73455,
    33546,
    12235,
    144843,
    36154,
    51247,
    11116,
    33040,
    3180,
    225753,
    60864,
    1972,
    28469,
    12891,
    28879,
    10338,
    144157,
    56294,
    353058,
    38302,
    41447,
    87532,
    110616,
    27065,
    168438,
    6557,
    1213,
    50804,
    144643,
    24817,
    2390,
    136531,
    38174,
    247513,
    16190,
    4059,
    122791,
    131994,
    137430,
    39506,
    57650,
    16305,
    5188,
    54309,
    106128,
    20628,
    88071,
    67394,
    395446,
    250285,
    66176,
    91254,
    1399,
    114196,
    43915,
    60230,
    44853,
    27206,
    106353,
    43013,
    18733,
    345105,
    226453,
    51202,
    16607,
    57106,
    117175,
    35492,
    10476,
    89598,
    127439,
    15187,
    39624,
    13688,
    61570,
    10615,
    31111,
    59370,
    6238,
    175252,
    32143,
    224492,
    41388,
    95408,
    34384,
    148238,
    78307,
    38959,
    9340,
    160091,
    61443,
    15737,
    11216,
    41244,
    170,
    38299,
    102443,
    113097,
    26382,
    14027,
    33707,
    3957,
    76300,
    66160,
    19431,
    18900,
    6952,
    1717,
    108656,
    82206,
    188021,
    257335,
    27295,
    43999,
    41210,
    31777,
    46956,
    57457,
    12657,
    11489,
    15697,
    48060,
    204748,
    53583,
    82422,
    284790,
    30503,
    137341,
    8120,
    19615,
    220311,
    15991,
    10217,
    63424,
    9808,
    67431,
    70976,
    98221,
    4491,
    15177,
    28535,
    144789,
    751,
    13230,
    2394,
    1504,
    33977,
    132104,
    30316,
    22230,
    931,
    97193,
    185240,
    24826,
    22687,
    174322,
    15307,
    22988,
    1390,
    188745,
    180325,
    29580,
    59068,
    74903,
    18994,
    29195,
    79,
    15436,
    7622,
    38462,
    11566,
    138710,
    44828,
    45774,
    37768,
    99236,
    68137,
    84083,
    19282,
    22698,
    17134,
    74807,
    126662,
    173497,
    46248,
    16938,
    119735,
    3212,
    28292,
    213652,
    49013,
    9975,
    32180,
    45660,
    86250,
    4801,
    68788,
    95490,
    77482,
    113751,
    11994,
    44624,
    94452,
    46839,
    128497,
    100316,
    5798,
    58588,
    73184,
    202987,
    65417,
    37790,
    88524,
    1606,
    43156,
    97964,
    105717,
    34947,
    11203,
    100060,
    37742,
    130074,
    93653,
    107799,
    94311,
    196106,
    41347,
    8035,
    10780,
    16390,
    27883,
    118236,
    167395,
    1979,
    25006,
    19375,
    31628,
    18916,
    144723,
    78502,
    114047,
    103107,
    86492,
    107686,
    5844,
    20934,
    206963,
    23556,
    22591,
    16562,
    146333,
    20167,
    10471,
    117434,
    33085,
    2863,
    9740,
    36669,
    41849,
    37271,
    22790,
    18209,
    28979,
    8231,
    12952,
    54408,
    21731,
    25130,
    45208,
    55748,
    138120,
    75826,
    414,
    29593,
    9925,
    292865,
    25999,
    683,
    123149,
    7036,
    92159,
    86055,
    61827,
    103680,
    23176,
    54918,
    58466,
    57578,
    13305,
    5709,
    86479,
    16697,
    31064,
    17660,
    200919,
    10770,
    49793,
    33423,
    32370,
    52047,
    16488,
    62555,
    6459,
    8426,
    83493,
    7763,
    59725,
    82812,
    18628,
    67760,
    79405,
    68557,
    9612,
    7673,
    28102,
    56517,
    69620,
    171797,
    32458,
    29541,
    15870,
    81109,
    32080,
    207644,
    71495,
    21202,
    11039,
    91036,
    61230,
    2810,
    130800,
    32260,
    4613,
    60590,
    37112,
    75214,
    33979,
    126402,
    155062,
    30642,
    63875,
    12810,
    194463,
    82799,
    47664,
    16725,
    36685,
    43367,
    61099,
    449,
    172150,
    102867,
    21691,
    301838,
    36745,
    7130,
    18671,
    57316,
    34852,
    38034,
    54182,
    35578,
    65900,
    99486,
    19771,
    3456,
    2658,
    16914,
    99866,
    28390,
    28109,
    8262,
    21147,
    34353,
    20006,
    4228,
    137085,
    1675,
    203023,
    283196,
    198286,
    214375,
    163329,
    290603,
    152574,
    40471,
    83506,
    30068,
    14730,
    23177,
    131539,
    34759,
    27668,
    32178,
    71896,
    104799,
    116305,
    85430,
    119262,
    42860,
    25160,
    8911,
    23428,
    49437,
    105322,
    6519,
    16203,
    6349,
    74711,
    1230,
    38045,
    8540,
    75165,
    44736,
    25909,
    51026,
    317034,
    4984,
    32281,
    91312,
    27060,
    44431,
    17817,
    45363,
    155937,
    239085,
    35697,
    59784,
    91993,
    29531,
    126740,
    213757,
    76560,
    167776,
    285273,
    24262,
    8237,
    65030,
    41160,
    74437,
    48804,
    118916,
    13159,
    37842,
    1031,
    75349,
    1478,
    11655,
    108777,
    23435,
    277425,
    101734,
    67469,
    70231,
    124711,
    43532,
    28514,
    65526,
    54956,
    1e3,
    21882,
    17728,
    25302,
    40952,
    52214,
    149632,
    1999,
    2111,
    3259,
    63362,
    89961,
    220561,
    39777,
    26335,
    9063,
    10572,
    12416,
    34551,
    34623,
    38604,
    24723,
    5947,
    15588,
    69927,
    66252,
    119177,
    69173,
    46629,
    28714,
    70715,
    212408,
    20521,
    406913,
    74380,
    11716,
    50659,
    50862,
    37009,
    88460,
    130101,
    7210,
    53853,
    538,
    65120,
    151950,
    55806,
    163748,
    52837,
    13153,
    21100,
    16674,
    64536,
    6091,
    138201,
    44837,
    58547,
    3723,
    163,
    2177,
    32288,
    85454,
    34033,
    8497,
    14282,
    25742,
    10535,
    10741,
    79559,
    117493,
    243787,
    49337,
    100718,
    79495,
    40139,
    42956,
    7551,
    55433,
    15421,
    31509,
    23034,
    45081,
    547,
    61176,
    53434,
    328001,
    8470,
    36263,
    30145,
    4519,
    74173,
    53935,
    11845,
    73774,
    60211,
    78025,
    3,
    4102,
    73782,
    109293,
    315332,
    48412,
    26683,
    13714,
    6865,
    20128,
    18490,
    104141,
    325,
    39470,
    171970,
    115860,
    15707,
    7268,
    73301,
    74336,
    31370,
    2368,
    111827,
    107757,
    136231,
    142844,
    97138,
    96638,
    84053,
    38691,
    23801,
    1588,
    10573,
    122098,
    77039,
    240,
    186135,
    146101,
    11996,
    18143,
    112963,
    46171,
    155836,
    348769,
    47795,
    121213,
    116266,
    132515,
    3344,
    144804,
    31286,
    99187,
    255838,
    129694,
    35894,
    48779,
    55235,
    148582,
    71967,
    65282,
    15174,
    13920,
    47080,
    6147,
    108242,
    157593,
    125025,
    7136,
    1286,
    28957,
    127956,
    28402,
    98813,
    20805,
    7532,
    109417,
    40610,
    5041,
    32958,
    15142,
    18408,
    108596,
    33543,
    50517,
    27748,
    80114,
    233434,
    91447,
    487,
    37094,
    100048,
    30541,
    43477,
    10639,
    89862,
    155868,
    37667,
    8726,
    60684,
    237903,
    73408,
    99589,
    12190,
    38739,
    97348,
    3914,
    13594,
    2680,
    149016,
    13907,
    30171,
    28343,
    23530,
    115225,
    61104,
    35821,
    147679,
    14337,
    4297,
    244282,
    24085,
    326976,
    56428,
    7851,
    21303,
    131620,
    71446,
    83253,
    68692,
    111870,
    5224,
    15813,
    38197,
    49026,
    45057,
    13660,
    3306,
    76345,
    40671,
    27905,
    91072,
    996,
    68527,
    62085,
    91351,
    122634,
    55109,
    168209,
    2024,
    27560,
    112707,
    17352,
    8306,
    167115,
    169921,
    166958,
    5031,
    46020,
    11844,
    67284,
    19130,
    76185,
    6920,
    32849,
    5450,
    14610,
    22451,
    21002,
    17392,
    31872,
    66682,
    84796,
    13709,
    40210,
    59898,
    12029,
    8719,
    53564,
    21462,
    91884,
    21647,
    88379,
    194428,
    12754,
    37797,
    132826,
    160016,
    22567,
    54383,
    53186,
    77611,
    31107,
    8339,
    4694,
    19185,
    90355,
    23597,
    17222,
    140675,
    28442,
    23668,
    55977,
    9128,
    61555,
    28774,
    155229,
    17658,
    9390,
    24379,
    69357,
    15752,
    127381,
    239631,
    62460,
    93181,
    55913,
    45133,
    140155,
    18676,
    25249,
    33164,
    29581,
    82837,
    67223,
    22362,
    29975,
    7317,
    52813,
    1943,
    29613,
    20012,
    207130,
    49617,
    49651,
    5636,
    15334,
    36313,
    29226,
    28084,
    95247,
    72072,
    19e3,
    224932,
    15811,
    114,
    32127,
    38097,
    37508,
    88507,
    37225,
    27359,
    91626,
    12193,
    69279,
    20608,
    11055,
    88156,
    92808,
    2152,
    57259,
    55275,
    72789,
    24475,
    104414,
    1708,
    9882,
    3818,
    48661,
    66897,
    1631,
    34806,
    227930,
    85815,
    87753,
    18321,
    250664,
    72733,
    25107,
    206797,
    50891,
    8082,
    196411,
    92596,
    96764,
    152823,
    65514,
    22819,
    387277,
    62176,
    51225,
    40329,
    15563,
    189,
    3659,
    73670,
    64357,
    51793,
    275136,
    33482,
    86653,
    74615,
    67058,
    11318,
    125720,
    15388,
    22388,
    8267,
    1730,
    102663,
    170910,
    40784,
    7144,
    85373,
    13040,
    7088,
    94309,
    583,
    44224,
    140424,
    77439,
    18496,
    164026,
    36578,
    4722,
    9151,
    5824,
    63365,
    26510,
    35199,
    40500,
    79277,
    32495,
    44614,
    35233,
    9566,
    203293,
    152144,
    7097,
    2330,
    183480,
    98629,
    13423,
    330887,
    44130,
    68600,
    30939,
    97829,
    31012,
    345465,
    56747,
    94879,
    4939,
    160027,
    149761,
    99423,
    46099,
    32251,
    15332,
    8761,
    96094,
    128555,
    5763,
    235318,
    222223,
    55729,
    30241,
    55420,
    201746,
    3987,
    81382,
    8259,
    49325,
    23287,
    7719,
    24633,
    251100,
    92311,
    18591,
    110533,
    64759,
    170260,
    393860,
    7175,
    21144,
    132887,
    3593,
    75346,
    101277,
    91109,
    16387,
    259187,
    11627,
    57459,
    173829,
    44694,
    55780,
    49797,
    89192,
    120443,
    62622,
    3904,
    14814,
    23887,
    1027,
    112258,
    64955,
    99800,
    11132,
    66353,
    36202,
    48624,
    18158,
    88481,
    96882,
    43059,
    11040,
    2455,
    7077,
    21651,
    181159,
    99126,
    100434,
    61388,
    68186,
    19161,
    110468,
    120052,
    8819,
    55324,
    41494,
    7014,
    37689,
    3618,
    87729,
    92615,
    207943,
    9823,
    128657,
    12587,
    15857,
    6379,
    67628,
    51216,
    71775,
    157617,
    63244,
    1503,
    3864,
    218754,
    110864,
    5769,
    21492,
    7243,
    1192,
    87921,
    85529,
    31512,
    18537,
    42698,
    35350,
    73510,
    84474,
    34301,
    8991,
    21013,
    35034,
    566,
    38832,
    19838,
    35586,
    37216,
    39413,
    55006,
    12178,
    59742,
    856,
    84563,
    6900,
    25632,
    17437,
    49786,
    30723,
    13847,
    70845,
    4044,
    7843,
    23944,
    235976,
    55530,
    48942,
    6518,
    20939,
    73769,
    192653,
    52936,
    95207,
    23895,
    132542,
    142982,
    22632,
    87452,
    48042,
    54018,
    178468,
    10728,
    26230,
    23559,
    363,
    81269,
    142012,
    5718,
    346258,
    31456,
    84333,
    246476,
    51018,
    66692,
    101804,
    120570,
    39962,
    30373,
    70593,
    2864,
    60541,
    19425,
    54209,
    104092,
    7201,
    31545,
    48018,
    25865,
    15442,
    46257,
    40443,
    8328,
    6451,
    111782,
    47527,
    97754,
    33046,
    470,
    245116,
    31095,
    39,
    91934,
    87208,
    73470,
    36708,
    36521,
    12801,
    70624,
    36272,
    8892,
    79768,
    12427,
    55454,
    103756,
    5908,
    52390,
    62962,
    22720,
    141138,
    94634,
    41689,
    128402,
    126390,
    6628,
    106394,
    35527,
    134394,
    82727,
    254651,
    194502,
    148064,
    89549,
    3202,
    28359,
    957,
    21954,
    27906,
    49840,
    142747,
    8307,
    24206,
    48978,
    1186,
    71728,
    133038,
    71474,
    91306,
    6333,
    110959,
    74600,
    70387,
    18983,
    62609,
    56057,
    22970,
    1147,
    135850,
    1321,
    28834,
    3578,
    59715,
    102227,
    32827,
    81415,
    99952,
    55636,
    257598,
    390,
    22702,
    35701,
    85872,
    402916,
    39216,
    189795,
    14929,
    19467,
    10112,
    144422,
    61514,
    5279,
    63421,
    134686,
    41436,
    8424,
    51925,
    10598,
    132295,
    124416,
    4604,
    194739,
    210929,
    57866,
    31829,
    51626,
    50007,
    9976,
    91878,
    61906,
    56168,
    81906,
    60918,
    61859,
    40017,
    23059,
    16887,
    40927,
    62064,
    12785,
    32893,
    32913,
    21782,
    93965,
    20169,
    44387,
    79084,
    38463,
    11457,
    93950,
    27127,
    157050,
    2697,
    337088,
    5116,
    54128,
    48255,
    33279,
    8821,
    27352,
    25515,
    124022,
    65710,
    28906,
    38557,
    33390,
    1722,
    104435,
    72215,
    38551,
    12094,
    30978,
    25113,
    6671,
    37355,
    175109,
    42862,
    98024,
    65406,
    221276,
    59624,
    118012,
    64637,
    78760,
    86697,
    21426,
    1639,
    40350,
    12584,
    67193,
    84144,
    31396,
    7863,
    143011,
    69629,
    63112,
    9454,
    28666,
    65798,
    46372,
    134721,
    6314,
    51402,
    30837,
    151922,
    2847,
    38676,
    38008,
    92823,
    136245,
    17540,
    5504,
    109295,
    205242,
    37606,
    5211,
    214892,
    1586,
    20670,
    208711,
    137743,
    19328,
    40652,
    16995,
    20023,
    14657,
    154919,
    34422,
    12996,
    13918,
    38221,
    47690,
    16398,
    2959,
    37680,
    89122,
    6721,
    198469,
    91876,
    172043,
    83898,
    101992,
    26084,
    94570,
    3635,
    76958,
    22853,
    76497,
    38266,
    176590,
    168403,
    44464,
    142840,
    79180,
    184594,
    1984,
    41806,
    83147,
    11985,
    6546,
    366068,
    59732,
    24533,
    271505,
    8736,
    39084,
    222992,
    93429,
    28962,
    58985,
    86665,
    8432,
    30028,
    14548,
    32439,
    54424,
    165029,
    55175,
    27458,
    69046,
    121277,
    46168,
    33732,
    20661,
    24581,
    135574,
    123110,
    37556,
    79260,
    72611,
    16957,
    12939,
    46162,
    58238,
    44907,
    72936,
    253758,
    41324,
    32518,
    96480,
    11949,
    124438,
    65280,
    43256,
    34107,
    53533,
    43531,
    37037,
    28366,
    45970,
    32741,
    173438,
    6121,
    194202,
    62969,
    26355,
    30314,
    58370,
    28455,
    1848,
    50519,
    82830,
    90393,
    21761,
    295490,
    10936,
    256940,
    133568,
    44050,
    20269,
    4089,
    27457,
    21610,
    219460,
    36743,
    14821,
    101388,
    52005,
    13124,
    30979,
    140816,
    167362,
    26054,
    18458,
    60789,
    34917,
    40447,
    26606,
    33422,
    9066,
    3452,
    83614,
    5761,
    20263,
    137238,
    25038,
    91310,
    101,
    52322,
    74548,
    42572,
    38084,
    214054,
    186568,
    31802,
    17665,
    30620,
    141936,
    37730,
    14420,
    4265,
    187218,
    49640,
    188208,
    51441,
    55388,
    96452,
    66659,
    40869,
    42039,
    60967,
    221027,
    19234,
    178581,
    29105,
    96050,
    9165,
    196118,
    157335,
    3738,
    40354,
    117436,
    2965,
    34136,
    59659,
    15570,
    50843,
    230035,
    31444,
    71260,
    43886,
    18316,
    5387,
    38500,
    168508,
    17406,
    32174,
    8828,
    103373,
    143806,
    90367,
    3560,
    18719,
    122310,
    16508,
    26719,
    2541,
    105429,
    6645,
    37998,
    73190,
    10591,
    235916,
    49737,
    87112,
    233941,
    53188,
    32193,
    79154,
    4544,
    52905,
    126477,
    7580,
    63501,
    57314,
    3216,
    31337,
    6541,
    103083,
    60846,
    49,
    9756,
    15481,
    1355,
    43840,
    14319,
    13743,
    27486,
    10222,
    73114,
    230718,
    418644,
    16706,
    6674,
    279748,
    23058,
    45273,
    295831,
    86306,
    2743,
    5535,
    88773,
    21829,
    35253,
    120938,
    31153,
    3169,
    16839,
    42847,
    8751,
    80974,
    33942,
    36867,
    35514,
    16485,
    26474,
    77775,
    56877,
    5391,
    48346,
    3882,
    108713,
    31403,
    27804,
    55248,
    26235,
    43821,
    136104,
    40118,
    175507,
    28034,
    203908,
    18732,
    1788,
    34030,
    106427,
    36958,
    54359,
    7251,
    44936,
    15356,
    69139,
    455,
    157915,
    22173,
    140291,
    50348,
    43275,
    82066,
    49621,
    54952,
    15216,
    36226,
    96695,
    66855,
    6936,
    1987,
    8227,
    196087,
    4631,
    68827,
    99004,
    47541,
    110265,
    17953,
    147605,
    110242,
    58520,
    31312,
    38724,
    329975,
    642,
    3155,
    34497,
    75937,
    6207,
    73843,
    6120,
    17249,
    51429,
    117746,
    3218,
    910,
    68961,
    319671,
    14938,
    29555,
    34700,
    1649,
    66673,
    72268,
    9655,
    76800,
    153087,
    6941,
    210168,
    27130,
    35398,
    1780,
    73242,
    3135,
    56689,
    19556,
    165307,
    8765,
    35967,
    121458,
    13333,
    70453,
    17350,
    117253,
    22265,
    13340,
    44265,
    39869,
    441,
    3742,
    135025,
    23581,
    33309,
    16543,
    17731,
    13291,
    157637,
    283005,
    21408,
    101360,
    63887,
    52312,
    83873,
    5338,
    233779,
    23759,
    186949,
    34531,
    177320,
    38069,
    156465,
    91004,
    19353,
    59852,
    68160,
    14891,
    1338,
    1072,
    29823,
    1950,
    28901,
    81407,
    313445,
    73038,
    84807,
    162348,
    240257,
    37162,
    138934,
    16111,
    58013,
    41253,
    102951,
    16457,
    96056,
    19541,
    56402,
    67217,
    41638,
    94381,
    89674,
    29481,
    37456,
    80815,
    151579,
    13937,
    13683,
    132537,
    19699,
    134545,
    67020,
    29816,
    222341,
    141235,
    427578,
    48868,
    129557,
    233342,
    23077,
    87871,
    16213,
    18728,
    16184,
    9469,
    37913,
    19680,
    2798,
    171356,
    178328,
    13216,
    50049,
    72690,
    71904,
    124644,
    55455,
    7504,
    29052,
    41036,
    266546,
    19899,
    30391,
    188755,
    8659,
    59469,
    16,
    104298,
    112943,
    53865,
    76203,
    138226,
    68857,
    139953,
    14125,
    107625,
    119795,
    173133,
    4398,
    50273,
    48808,
    54390,
    16466,
    122086,
    31835,
    67035,
    50971,
    48859,
    7508,
    46427,
    66477,
    73021,
    84615,
    39985,
    83076,
    46779,
    201569,
    53336,
    36443,
    60865,
    168164,
    143810,
    51393,
    25548,
    169307,
    32896,
    24485,
    38424,
    21837,
    29087,
    275813,
    51674,
    6714,
    64883,
    46169,
    187369,
    55186,
    76192,
    12852,
    12018,
    62134,
    31067,
    118303,
    16542,
    12125,
    10579,
    4928,
    26291,
    43854,
    7091,
    10946,
    253716,
    109062,
    39283,
    17261,
    113012,
    258512,
    47764,
    125126,
    32646,
    55892,
    80279,
    201623,
    149872,
    3192,
    385,
    1208,
    48750,
    5376,
    58738,
    22335,
    5427,
    82416,
    47811,
    32435,
    143086,
    38930,
    94128,
    59975,
    156037,
    37977,
    38224,
    62485,
    7698,
    50405,
    71027,
    16462,
    21559,
    136153,
    34131,
    107506,
    162069,
    63703,
    3101,
    215029,
    40407,
    4178,
    3774,
    9187,
    80019,
    17880,
    97926,
    67579,
    2600,
    18405,
    8351,
    47924,
    86638,
    70820,
    92206,
    86453,
    29610,
    42241,
    119200,
    3198,
    15466,
    67813,
    57863,
    35454,
    4779,
    99518,
    4649,
    104641,
    144269,
    33730,
    38073,
    65864,
    6838,
    109456,
    193298,
    154007,
    5623,
    45741,
    30846,
    182578,
    25573,
    157224,
    1543,
    58575,
    138703,
    146140,
    44971,
    49356,
    18275,
    59064,
    20300,
    13122,
    11848,
    24453,
    11973,
    9797,
    86843,
    2919,
    25530,
    49210,
    1130,
    161220,
    76788,
    75373,
    85604,
    34926,
    36014,
    17777,
    17255,
    51533,
    11676,
    92226,
    51845,
    119859,
    21525,
    5936,
    18507,
    28050,
    1140,
    31418,
    14857,
    34207,
    47859,
    10750,
    36382,
    32079,
    106909,
    59426,
    87757,
    38393,
    110042,
    15965,
    97104,
    33757,
    35344,
    97993,
    53979,
    33651,
    45407,
    41884,
    82515,
    173089,
    7177,
    58371,
    35365,
    47543,
    51927,
    35587,
    10670,
    23544,
    29306,
    84233,
    39976,
    76076,
    62097,
    9007,
    8668,
    28119,
    78281,
    120790,
    19835,
    143020,
    54968,
    18670,
    64959,
    20649,
    34469,
    42570,
    33001,
    136570,
    87796,
    120044,
    1106,
    58700,
    63951,
    127623,
    12805,
    83057,
    40212,
    31773,
    49850,
    7361,
    54336,
    347524,
    101314,
    23751,
    19569,
    48791,
    29174,
    49369,
    20467,
    7465,
    75842,
    38281,
    623,
    112457,
    60210,
    28849,
    51003,
    94720,
    6426,
    90047,
    85560,
    43761,
    3579,
    85105,
    34607,
    90410,
    118528,
    7224,
    42907,
    111163,
    18168,
    6960,
    161135,
    191298,
    5247,
    100584,
    127552,
    171568,
    20121,
    91173,
    12636,
    54615,
    20199,
    63730,
    98105,
    2396,
    40387,
    14438,
    125012,
    4765,
    33235,
    12865,
    45299,
    37728,
    82098,
    77872,
    114037,
    59253,
    19675,
    24838,
    398016,
    102561,
    11446,
    17069,
    57508,
    178277,
    65836,
    99941,
    26114,
    2585,
    271882,
    136866,
    50126,
    11027,
    155648,
    118367,
    14585,
    8910,
    123015,
    335383,
    40434,
    41016,
    53021,
    14439,
    87098,
    176860,
    201543,
    121888,
    2358,
    9286,
    5739,
    22666,
    54270,
    37884,
    169381,
    33984,
    93859,
    16124,
    89364,
    72207,
    51639,
    76366,
    99029,
    65812,
    2198,
    12147,
    174891,
    194289,
    6986,
    30252,
    88822,
    21284,
    11445,
    288337,
    160821,
    33034,
    100869,
    43852,
    25761,
    52882,
    1144,
    103809,
    1924,
    84458,
    86079,
    43411,
    13542,
    139276,
    18141,
    34978,
    41298,
    7276,
    26481,
    173800,
    33210,
    17951,
    142652,
    33616,
    33677,
    2210,
    19941,
    98568,
    2486,
    192414,
    80136,
    12058,
    235883,
    50963,
    249638,
    29572,
    27221,
    47034,
    6124,
    72107,
    63346,
    97620,
    158513,
    299699,
    40388,
    23235,
    37176,
    224244,
    198386,
    121323,
    67992,
    23827,
    63170,
    17838,
    106622,
    158590,
    26807,
    5345,
    23489,
    91891,
    55474,
    74834,
    37981,
    13058,
    5977,
    72552,
    34706,
    26828,
    145172,
    19904,
    21367,
    34043,
    960,
    77092,
    91381,
    4733,
    47446,
    7680,
    41697,
    5170,
    16960,
    14741,
    46101,
    13656,
    473,
    51842,
    37433,
    11103,
    11551,
    121951,
    13191,
    97536,
    165932,
    50397,
    51628,
    129028,
    9069,
    44885,
    6590,
    59195,
    47045,
    32940,
    225472,
    90345,
    21833,
    13303,
    29407,
    96615,
    141951,
    5198,
    6028,
    18395,
    7181,
    3861,
    14966,
    156358,
    167182,
    36529,
    55253,
    25942,
    173153,
    30959,
    27261,
    50691,
    150176,
    162201,
    38467,
    48462,
    80602,
    42163,
    118482,
    168,
    108756,
    26011,
    17166,
    54149,
    456538,
    22512,
    91374,
    13816,
    90358,
    131615,
    18132,
    226707,
    1824,
    28139,
    26860,
    42253,
    93877,
    77351,
    65575,
    8980,
    80574,
    22020,
    27948,
    40422,
    91324,
    76376,
    13528,
    39281,
    91685,
    82215,
    122541,
    144066,
    1983,
    193851,
    17283,
    26320,
    2739,
    194978,
    4790,
    26845,
    42627,
    61300,
    65815,
    174612,
    55133,
    4200,
    191130,
    79771,
    158321,
    52280,
    166796,
    221620,
    62461,
    11278,
    4067,
    88152,
    83409,
    31717,
    121367,
    13522,
    47325,
    37945,
    10406,
    174348,
    249321,
    154101,
    64912,
    29938,
    51775,
    17220,
    15776,
    166138,
    78890,
    84425,
    54121,
    42861,
    16368,
    24572,
    291647,
    10197,
    32073,
    22651,
    11677,
    97509,
    26952,
    35787,
    18424,
    41910,
    71614,
    94977,
    72318,
    41594,
    70024,
    275419,
    37702,
    60199,
    7335,
    39107,
    61315,
    18271,
    18394,
    33768,
    87884,
    104277,
    123724,
    7277,
    56288,
    71981,
    189803,
    49320,
    3352,
    6798,
    14240,
    8954,
    69220,
    94433,
    57372,
    28620,
    68863,
    193727,
    85575,
    42309,
    41667,
    67689,
    42081,
    22543,
    44824,
    12719,
    28540,
    114236,
    101553,
    27638,
    27296,
    4300,
    5353,
    4663,
    19379,
    94098,
    3758,
    95888,
    95144,
    80344,
    87320,
    28447,
    259518,
    12718,
    71391,
    152731,
    37063,
    24132,
    31911,
    104896,
    15672,
    103782,
    1521,
    4945,
    72541,
    23717,
    122632,
    15619,
    87175,
    206120,
    29428,
    189780,
    61416,
    28350,
    44457,
    972,
    1175,
    47233,
    198738,
    95789,
    41907,
    21953,
    97034,
    59341,
    22864,
    53713,
    16873,
    32971,
    20693,
    20954,
    31336,
    21477,
    16169,
    38370,
    16412,
    9019,
    3841,
    24599,
    21938,
    17085,
    6484,
    81198,
    76413,
    5849,
    72514,
    12320,
    65247,
    276175,
    37234,
    59796,
    52642,
    16312,
    57349,
    198507,
    94148,
    46134,
    18958,
    125552,
    1747,
    18725,
    151873,
    14901,
    5490,
    68287,
    29470,
    3689,
    64794,
    40814,
    26018,
    25692,
    54450,
    2703,
    88278,
    124886,
    173087,
    174e3,
    24159,
    179477,
    24276,
    46004,
    201876,
    209202,
    445,
    52876,
    31948,
    30206,
    157610,
    39180,
    18439,
    44124,
    50469,
    5774,
    96278,
    222758,
    200216,
    50290,
    45486,
    20435,
    46986,
    46276,
    140133,
    142326,
    15569,
    13363,
    47522,
    92583,
    2182,
    7135,
    16853,
    22998,
    30272,
    4952,
    63263,
    35623,
    39096,
    53789,
    44864,
    20053,
    110392,
    124213,
    4630,
    16087,
    28221,
    127787,
    25839,
    77481,
    44693,
    13464,
    113146,
    6983,
    27069,
    55717,
    50102,
    4760,
    7107,
    26186,
    66507,
    59145,
    36032,
    104182,
    71328,
    29425,
    64317,
    50781,
    47465,
    94298,
    69706,
    74899,
    22754,
    120756,
    25108,
    93077,
    56834,
    73286,
    39928,
    16218,
    41699,
    176763,
    7555,
    70819,
    50083,
    26895,
    23315,
    26014,
    16773,
    123079,
    41712,
    5719,
    31516,
    90427,
    158540,
    85051,
    183128,
    40864,
    27505,
    55392,
    9058,
    45224,
    96857,
    30901,
    136622,
    96557,
    56304,
    120061,
    11501,
    151448,
    5773,
    89743,
    7769,
    86069,
    2935,
    18471,
    41628,
    10114,
    33660,
    110170,
    49479,
    26745,
    92846,
    33221,
    26731,
    18795,
    87076,
    8550,
    2100,
    29972,
    120289,
    3077,
    72490,
    33784,
    2630,
    208722,
    50861,
    63483,
    79029,
    6419,
    39467,
    14302,
    45286,
    64207,
    9686,
    67513,
    44170,
    1050,
    77246,
    59266,
    17055,
    53801,
    7150,
    11111,
    42432,
    4278,
    94579,
    362117,
    36175,
    42902,
    41933,
    39002,
    98489,
    22913,
    74161,
    84773,
    57036,
    17556,
    162288,
    74485,
    178760,
    93867,
    73635,
    128860,
    50362,
    261,
    67455,
    80001,
    46080,
    35662,
    4368,
    25247,
    19230,
    74393,
    22588,
    1822,
    27682,
    235324,
    13798,
    85998,
    13194,
    235067,
    23514,
    71669,
    147632,
    23191,
    134748,
    214683,
    105101,
    1518,
    25489,
    247114,
    7380,
    54842,
    26922,
    3971,
    26361,
    20844,
    68642,
    170517,
    77339,
    123255,
    8963,
    77818,
    150998,
    48466,
    36806,
    2732,
    23261,
    11741,
    236162,
    18243,
    126216,
    28690,
    50546,
    16385,
    92760,
    197383,
    246558,
    201295,
    88255,
    67588,
    71687,
    176076,
    172653,
    169058,
    33906,
    63747,
    24835,
    157621,
    43338,
    30050,
    46152,
    132741,
    2770,
    51371,
    94835,
    6614,
    15112,
    11749,
    56936,
    1250,
    19027,
    399017,
    58036,
    100215,
    23388,
    55815,
    308768,
    124152,
    94803,
    9521,
    64186,
    8971,
    28,
    30427,
    62163,
    7616,
    103838,
    35079,
    29203,
    131235,
    7743,
    17389,
    10882,
    37420,
    61460,
    228512,
    85363,
    41581,
    131077,
    62822,
    119647,
    10130,
    54445,
    26925,
    19968,
    29016,
    24446,
    74028,
    24176,
    61448,
    67185,
    9254,
    8563,
    119129,
    9771,
    99184,
    37716,
    39514,
    10532,
    221512,
    258753,
    218630,
    55980,
    23394,
    32141,
    61924,
    66749,
    32411,
    3741,
    36475,
    26678,
    77010,
    44946,
    91203,
    128749,
    116953,
    20476,
    49625,
    53116,
    13735,
    102335,
    29376,
    51946,
    83407,
    67892,
    59212,
    34685,
    21083,
    1546,
    112982,
    32972,
    74397,
    1078,
    190545,
    16082,
    86140,
    58591,
    89611,
    101531,
    10061,
    105104,
    76319,
    20035,
    17551,
    52611,
    169061,
    190842,
    100780,
    23907,
    90413,
    115619,
    9675,
    34710,
    193435,
    49443,
    129734,
    11183,
    258877,
    16318,
    136182,
    126808,
    44635,
    27304,
    192375,
    2599,
    125648,
    47051,
    12091,
    23814,
    721,
    58800,
    40137,
    66726,
    97930,
    60877,
    74487,
    7942,
    54326,
    9841,
    41428,
    13762,
    8211,
    85383,
    6950,
    99177,
    79806,
    201786,
    296464,
    124087,
    13144,
    29741,
    41721,
    47634,
    55088,
    254286,
    106408,
    17041,
    99064,
    12942,
    64086,
    45233,
    14005,
    2612,
    55827,
    255,
    7984,
    13980,
    38574,
    12776,
    46654,
    73499,
    249951,
    2101,
    26676,
    25996,
    132326,
    116415,
    119062,
    50449,
    31033,
    23038,
    11589,
    179252,
    20007,
    14860,
    129270,
    21143,
    17796,
    144715,
    60106,
    70758,
    69842,
    34674,
    282133,
    44014,
    16774,
    57268,
    38528,
    24053,
    46373,
    201667,
    28327,
    471023,
    51889,
    102667,
    21193,
    114909,
    84132,
    69317,
    96723,
    67969,
    16134,
    68145,
    15058,
    28765,
    32035,
    2524,
    101089,
    98664,
    25045,
    76571,
    14957,
    86040,
    118506,
    262428,
    154764,
    81573,
    39681,
    283900,
    73287,
    127825,
    544,
    80448,
    52347,
    38512,
    175971,
    15180,
    45467,
    33086,
    46552,
    48894,
    81107,
    43213,
    36672,
    54025,
    76703,
    8053,
    7608,
    13299,
    56619,
    20752,
    238099,
    54164,
    105133,
    1444,
    32942,
    953,
    37564,
    8e3,
    66316,
    119463,
    106817,
    404,
    13667,
    149108,
    128597,
    31267,
    10269,
    49836,
    106150,
    1484,
    52330,
    76965,
    160486,
    171648,
    38456,
    31263,
    22424,
    37738,
    66245,
    67467,
    143369,
    60471,
    75610,
    20895,
    115528,
    86070,
    60854,
    40796,
    49347,
    18989,
    15030,
    11371,
    37578,
    15779,
    79867,
    10187,
    86462,
    46402,
    155626,
    93200,
    40229,
    7090,
    57547,
    108053,
    99598,
    11088,
    47505,
    41218,
    206017,
    2173,
    20988,
    30219,
    22919,
    80563,
    57566,
    42369,
    93141,
    41675,
    2407,
    182519,
    120495,
    27154,
    16702,
    29456,
    14349,
    7958,
    16688,
    117177,
    140375,
    42467,
    261919,
    74916,
    153569,
    10836,
    34742,
    49526,
    7621,
    105997,
    12212,
    2270,
    392377,
    7755,
    17959,
    25086,
    232152,
    138791,
    33847,
    13860,
    35316,
    5811,
    1344,
    71259,
    50452,
    207539,
    92635,
    50359,
    5821,
    33674,
    30255,
    2086,
    2587,
    96264,
    17543,
    42,
    6029,
    9580,
    43007,
    139248,
    82831,
    12917,
    29607,
    25786,
    51467,
    42137,
    85161,
    100698,
    31561,
    88989,
    121990,
    278500,
    3602,
    109344,
    37982,
    15279,
    116442,
    28936,
    30880,
    87894,
    58079,
    128661,
    126731,
    67392,
    28051,
    146885,
    4861,
    16216,
    97344,
    42827,
    147561,
    153948,
    22684,
    21335,
    47685,
    1853,
    43349,
    15185,
    59642,
    10229,
    25520,
    187921,
    108972,
    5579,
    98037,
    24945,
    6697,
    19193,
    63734,
    137934,
    75056,
    89740,
    19767,
    224268,
    56138,
    63643,
    151661,
    39313,
    70618,
    84031,
    89723,
    84074,
    13703,
    85626,
    35460,
    8867,
    64845,
    3439,
    57906,
    99776,
    63968,
    49270,
    81130,
    34356,
    16210,
    23547,
    36446,
    34090,
    140028,
    72439,
    2221,
    22163,
    57058,
    363492,
    113754,
    18913,
    95451,
    48663,
    54464,
    54037,
    176097,
    68425,
    3023,
    34906,
    29482,
    117389,
    341780,
    80431,
    58330,
    16753,
    92616,
    60907,
    94846,
    147486,
    4498,
    48646,
    7773,
    46801,
    7778,
    18946,
    464978,
    47558,
    33223,
    177444,
    7328,
    15626,
    63337,
    94700,
    11743,
    9351,
    255024,
    39098,
    16447,
    42647,
    96230,
    39769,
    58840,
    10068,
    63439,
    35800,
    65843,
    58823,
    413844,
    9156,
    51258,
    7434,
    61791,
    85018,
    6872,
    3692,
    28096,
    7121,
    33024,
    6009,
    75532,
    31997,
    192535,
    9661,
    3304,
    9547,
    14753,
    31987,
    25314,
    55689,
    15896,
    20430,
    39472,
    31340,
    99744,
    25398,
    115569,
    54883,
    28719,
    205423,
    23071,
    57855,
    64638,
    149867,
    25671,
    82403,
    37616,
    20668,
    39989,
    77996,
    74948,
    140555,
    175248,
    64810,
    36515,
    46595,
    4958,
    248773,
    24045,
    28728,
    136673,
    168704,
    20804,
    114833,
    100325,
    27135,
    21205,
    96151,
    153134,
    45992,
    7093,
    13992,
    76047,
    1980,
    19432,
    145001,
    75159,
    87462,
    17710,
    1013,
    45556,
    34297,
    144882,
    20648,
    26061,
    11319,
    129567,
    108555,
    18872,
    464580,
    33386,
    22717,
    65948,
    167189,
    5603,
    135042,
    79542,
    8801,
    202632,
    18114,
    91882,
    5973,
    5239,
    67315,
    4431,
    60916,
    47819,
    71693,
    32597,
    32606,
    18183,
    45072,
    80329,
    76385,
    24749,
    51305,
    40314,
    156514,
    14693,
    130345,
    13168,
    66214,
    18029,
    12858,
    34801,
    27628,
    14544,
    10823,
    40522,
    40185,
    33739,
    148694,
    23548,
    9923,
    61012,
    28859,
    17933,
    19442,
    34364,
    99849,
    164107,
    141167,
    30629,
    21054,
    6744,
    36491,
    8096,
    42474,
    41706,
    155060,
    30650,
    10600,
    163442,
    1143,
    96655,
    61390,
    52359,
    7559,
    51568,
    64256,
    203854,
    4467,
    22453,
    14504,
    436398,
    7878,
    6980,
    8293,
    63610,
    293747,
    16167,
    35763,
    19627,
    147603,
    15419,
    18032,
    110744,
    51346,
    33681,
    54571,
    40472,
    48615,
    39073,
    21604,
    13754,
    173027,
    92560,
    11083,
    47299,
    63062,
    11813,
    52007,
    29883,
    9734,
    139722,
    15953,
    1550,
    20651,
    13616,
    49306,
    16113,
    90089,
    92326,
    7584,
    30712,
    72424,
    164858,
    6831,
    152871,
    55746,
    197721,
    34167,
    196442,
    6022,
    112107,
    55215,
    7538,
    123381,
    4920,
    43539,
    77165,
    8939,
    50392,
    34192,
    20225,
    79762,
    22505,
    58667,
    40770,
    29788,
    97180,
    82835,
    4568,
    8579,
    13273,
    363569,
    35898,
    49983,
    436,
    36598,
    3237,
    131691,
    62418,
    35591,
    8101,
    4073,
    379438,
    65218,
    76072,
    33887,
    2968,
    27573,
    212619,
    288680,
    68278,
    72851,
    150504,
    217896,
    6913,
    121339,
    22017,
    35340,
    51072,
    43616,
    75043,
    31437,
    10833,
    81487,
    4364,
    22968,
    41454,
    106687,
    85446,
    19863,
    109625,
    149241,
    524,
    141850,
    214404,
    54376,
    657,
    237023,
    9401,
    108137,
    53800,
    32474,
    49712,
    53334,
    126876,
    27337,
    45552,
    177696,
    8269,
    15036,
    12097,
    42240,
    2328,
    125374,
    119295,
    99715,
    2500,
    19624,
    39441,
    27220,
    102691,
    60957,
    94543,
    39101,
    18566,
    67362,
    13975,
    78230,
    25017,
    34017,
    239007,
    90027,
    39351,
    41681,
    35354,
    43822,
    1043,
    916,
    58587,
    141983,
    94818,
    38799,
    75459,
    41114,
    67432,
    16195,
    36606,
    59568,
    22272,
    126769,
    31424,
    68659,
    12287,
    134302,
    257977,
    5756,
    207285,
    95637,
    47248,
    117689,
    19583,
    77451,
    22373,
    12200,
    54993,
    117118,
    34244,
    29386,
    34562,
    53819,
    71267,
    64172,
    77665,
    49368,
    7716,
    59301,
    25749,
    45426,
    194789,
    17297,
    2650,
    1766,
    32501,
    45198,
    20403,
    20984,
    6600,
    14171,
    94604,
    19037,
    5402,
    29896,
    9938,
    59935,
    109708,
    88081,
    145182,
    44844,
    39167,
    352626,
    164173,
    35374,
    45982,
    6122,
    154,
    73419,
    220487,
    53834,
    53601,
    17992,
    8609,
    229321,
    5610,
    68098,
    66815,
    71012,
    95069,
    140968,
    27396,
    8957,
    134489,
    24656,
    86659,
    56598,
    134852,
    17316,
    123838,
    255436,
    6613,
    41610,
    138033,
    81452,
    32023,
    32396,
    123687,
    63398,
    8693,
    29712,
    30407,
    19296,
    121188,
    3551,
    36099,
    20032,
    111948,
    56624,
    16547,
    27453,
    35916,
    15378,
    52039,
    56849,
    13489,
    22214,
    73177,
    53097,
    277349,
    2157,
    14029,
    187886,
    10260,
    141743,
    246460,
    91880,
    50869,
    3788,
    49486,
    133566,
    54950,
    33120,
    129337,
    53768,
    18333,
    9525,
    26902,
    312251,
    10297,
    9020,
    70759,
    16647,
    112432,
    59260,
    84609,
    9818,
    82766,
    73569,
    468,
    46001,
    75780,
    55028,
    52106,
    11498,
    43645,
    108069,
    17150,
    17753,
    29417,
    16705,
    31799,
    9606,
    289,
    122254,
    115975,
    8620,
    6133,
    255357,
    56908,
    14456,
    133464,
    43554,
    79224,
    11247,
    29630,
    160,
    12756,
    25464,
    65960,
    350428,
    62521,
    321796,
    100359,
    67358,
    35169,
    46172,
    113128,
    48988,
    88868,
    31094,
    33266,
    6847,
    60887,
    98188,
    49659,
    69117,
    92977,
    220228,
    13947,
    80181,
    35103,
    62170,
    97351,
    13475,
    2440,
    199768,
    19498,
    36597,
    46971,
    25234,
    67806,
    62881,
    84717,
    73648,
    181966,
    10488,
    94149,
    21550,
    26655,
    63436,
    48375,
    14405,
    165650,
    9621,
    24439,
    28043,
    42735,
    4490,
    29963,
    56674,
    45373,
    1934,
    262446,
    50855,
    67098,
    26898,
    5261,
    52696,
    40644,
    33900,
    9440,
    180286,
    87162,
    22940,
    19704,
    26936,
    69769,
    10254,
    101759,
    27406,
    12243,
    48e3,
    73926,
    113215,
    54935,
    5726,
    192787,
    4312,
    106216,
    9366,
    11550,
    52949,
    23457,
    212271,
    277152,
    133895,
    108374,
    6191,
    96477,
    29980,
    218916,
    58024,
    54696,
    40853,
    91124,
    65894,
    91170,
    65908,
    252552,
    6793,
    29212,
    15389,
    44516,
    122515,
    52617,
    35058,
    9017,
    103536,
    39510,
    49136,
    19242,
    130652,
    662077,
    74699,
    47024,
    31422,
    8517,
    73351,
    24399,
    13867,
    128360,
    4810,
    4434,
    61779,
    111983,
    61036,
    17798,
    110240,
    59722,
    102960,
    39688,
    10001,
    23803,
    23039,
    176498,
    56659,
    44814,
    134295,
    17188,
    77577,
    74466,
    226175,
    102472,
    154333,
    63900,
    111747,
    18062,
    41171,
    79669,
    32773,
    408933,
    42562,
    28931,
    30907,
    107388,
    43487,
    2946,
    240310,
    23938,
    24354,
    319,
    184983,
    7927,
    6488,
    1422,
    10790,
    68809,
    68209,
    64775,
    4361,
    202,
    17123,
    59634,
    51200,
    44391,
    18188,
    17843,
    2619,
    74278,
    3230,
    9540,
    47187,
    21702,
    36274,
    56894,
    43907,
    16310,
    34790,
    16866,
    6150,
    5561,
    13587,
    107545,
    108873,
    126867,
    86986,
    28640,
    33427,
    19017,
    5762,
    80637,
    17430,
    46903,
    2047,
    131055,
    25958,
    13558,
    5444,
    47152,
    13900,
    44563,
    122857,
    45348,
    70863,
    39593,
    54332,
    38068,
    33637,
    318,
    40310,
    143467,
    18502,
    24520,
    11377,
    62013,
    28942,
    27246,
    28269,
    83545,
    17999,
    59015,
    90707,
    30065,
    15161,
    34720,
    1263,
    37008,
    2012,
    6060,
    98575,
    92933,
    5721,
    299,
    199555,
    24578,
    29223,
    2985,
    743,
    115825,
    109523,
    136657,
    47454,
    26378,
    53586,
    3733,
    174945,
    93340,
    244456,
    5693,
    37386,
    28782,
    89767,
    27545,
    23573,
    18798,
    136425,
    34320,
    84778,
    20041,
    48453,
    38215,
    7477,
    71958,
    40621,
    8773,
    5874,
    187927,
    105965,
    51100,
    43533,
    18083,
    8443,
    10180,
    43597,
    2003,
    183999,
    69689,
    12216,
    129696,
    146188,
    62389,
    34044,
    68410,
    12765,
    43273,
    26949,
    266807,
    3345,
    34477,
    79197,
    5688,
    47539,
    213110,
    21634,
    22257,
    50092,
    32222,
    42346,
    39530,
    63668,
    98,
    134978,
    74022,
    5152,
    59088,
    174145,
    37220,
    9934,
    9545,
    118937,
    5724,
    87240,
    19875,
    15784,
    40143,
    23263,
    87513,
    181654,
    285152,
    37881,
    263241,
    4966,
    43934,
    10433,
    186657,
    6470,
    74416,
    225854,
    25908,
    142677,
    246262,
    32280,
    6192,
    75890,
    45546,
    143264,
    135305,
    29742,
    47013,
    77787,
    11732,
    126658,
    8763,
    37950,
    21806,
    57557,
    113464,
    89465,
    108995,
    164574,
    23894,
    22996,
    23169,
    15369,
    23117,
    17642,
    130607,
    40503,
    36239,
    280990,
    44666,
    9981,
    40427,
    147487,
    26869,
    168452,
    32886,
    32991,
    46798,
    240839,
    15111,
    70502,
    65697,
    88548,
    44145,
    28701,
    48767,
    31139,
    206777,
    35659,
    181164,
    166262,
    14554,
    171445,
    31786,
    66523,
    76607,
    17956,
    6507,
    31279,
    90476,
    116611,
    167918,
    6560,
    1243,
    115324,
    80128,
    41867,
    55897,
    187323,
    37069,
    32596,
    189444,
    145931,
    13390,
    105530,
    65709,
    26805,
    6999,
    55714,
    41300,
    22915,
    68951,
    22138,
    21120,
    22264,
    10058,
    19945,
    33635,
    56123,
    99085,
    10032,
    5818,
    6016,
    46649,
    57476,
    35264,
    94413,
    112522,
    262288,
    93686,
    83038,
    14341,
    23204,
    28807,
    66084,
    77987,
    6101,
    126673,
    7133,
    38126,
    5923,
    122091,
    170240,
    97772,
    46874,
    215746,
    43948,
    41622,
    3272,
    55596,
    8332,
    146411,
    251315,
    13533,
    8561,
    81521,
    115449,
    48616,
    175175,
    2063,
    186556,
    3036,
    134537,
    75772,
    29728,
    82360,
    22973,
    186559,
    86348,
    89100,
    38388,
    82297,
    45610,
    2613,
    87082,
    9986,
    177812,
    57884,
    23591,
    47485,
    42543,
    33582,
    44713,
    74439,
    257444,
    252451,
    31825,
    35631,
    38540,
    33066,
    5147,
    13973,
    4343,
    51830,
    70378,
    22827,
    26448,
    95560,
    36896,
    241741,
    48067,
    203953,
    298860,
    61620,
    20450,
    3220,
    67272,
    6586,
    107662,
    100160,
    108684,
    6929,
    57226,
    4762,
    7457,
    1320,
    40404,
    77204,
    99309,
    62750,
    208653,
    59977,
    44e3,
    74315,
    34332,
    5819,
    172217,
    64904,
    114077,
    18147,
    84012,
    1791,
    98456,
    90930,
    21446,
    116669,
    103938,
    7422,
    85140,
    59713,
    5768,
    326211,
    16239,
    75411,
    13229,
    29398,
    10758,
    236107,
    1539,
    112472,
    95979,
    152154,
    151294,
    306,
    21196,
    38146,
    10700,
    6891,
    84282,
    109646,
    56492,
    40539,
    6589,
    119491,
    51354,
    30685,
    140209,
    136906,
    29622,
    73617,
    49553,
    70525,
    51671,
    166869,
    139616,
    74395,
    37439,
    49595,
    45678,
    11959,
    33211,
    86560,
    52434,
    9282,
    62690,
    112155,
    130810,
    5243,
    108261,
    99970,
    265613,
    72551,
    80049,
    6391,
    33365,
    90721,
    66737,
    69872,
    87011,
    1860,
    9032,
    112544,
    60905,
    37371,
    89015,
    140351,
    19076,
    850,
    373531,
    2802,
    36725,
    218795,
    72062,
    28990,
    16550,
    24614,
    7815,
    6187,
    26336,
    33373,
    32162,
    42791,
    73555,
    32062,
    23386,
    10244,
    56392,
    49442,
    27076,
    136262,
    12412,
    14883,
    1134,
    33675,
    97153,
    199281,
    15608,
    100152,
    74072,
    47942,
    254301,
    36451,
    16026,
    10687,
    65067,
    56708,
    254030,
    30290,
    50490,
    13864,
    57941,
    259331,
    35588,
    23485,
    43486,
    24869,
    21620,
    92971,
    22072,
    88645,
    1048,
    182050,
    13343,
    32452,
    14825,
    19509,
    3325,
    216938,
    45740,
    99716,
    189082,
    53740,
    78245,
    25609,
    24311,
    176777,
    47340,
    308354,
    40669,
    66085,
    14102,
    125339,
    9225,
    128709,
    97207,
    1271,
    200933,
    78439,
    113451,
    88975,
    18324,
    46521,
    11819,
    18570,
    141756,
    72512,
    170020,
    52754,
    63550,
    118515,
    103073,
    93330,
    32736,
    50499,
    14722,
    31600,
    68452,
    398867,
    29316,
    172786,
    18417,
    104924,
    2606,
    5670,
    84818,
    16288,
    67106,
    59580,
    82929,
    607401,
    291,
    85829,
    359,
    15897,
    35830,
    50696,
    65630,
    52672,
    22115,
    356968,
    29895,
    40837,
    231192,
    34024,
    38957,
    26722,
    406,
    23335,
    124952,
    72068,
    68804,
    13268,
    147101,
    164740,
    276569,
    162596,
    66943,
    11569,
    26654,
    66358,
    4777,
    23229,
    102127,
    5848,
    978,
    2921,
    59666,
    5371,
    28212,
    90108,
    42938,
    39320,
    2499,
    4271,
    108792,
    33510,
    125072,
    71653,
    65239,
    38250,
    66357,
    38577,
    13964,
    86251,
    35708,
    50755,
    36010,
    29448,
    12209,
    3844,
    38222,
    206337,
    100876,
    67827,
    137088,
    14167,
    252225,
    84163,
    195270,
    1306,
    5703,
    54198,
    779,
    46802,
    22028,
    51124,
    86759,
    70560,
    113164,
    35685,
    162145,
    45471,
    34561,
    422,
    2611,
    6464,
    47486,
    19223,
    38246,
    9191,
    18331,
    89942,
    243642,
    212364,
    15893,
    17518,
    22617,
    6409,
    30046,
    126182,
    59716,
    36560,
    104428,
    18846,
    26592,
    19458,
    50793,
    147333,
    30826,
    1388,
    27647,
    10922,
    14495,
    33545,
    19269,
    135828,
    39727,
    41601,
    46931,
    233379,
    49169,
    131130,
    182112,
    16276,
    82381,
    118209,
    142445,
    128310,
    19672,
    28740,
    82907,
    33436,
    3118,
    102206,
    28723,
    24819,
    41937,
    38854,
    5157,
    3881,
    111491,
    1142,
    9776,
    421673,
    152241,
    29309,
    14961,
    87854,
    6054,
    15424,
    3796,
    82656,
    54996,
    2108,
    55367,
    239450,
    154525,
    9643,
    118103,
    106041,
    64601,
    68549,
    48707,
    30266,
    25772,
    18740,
    9462,
    229669,
    91798,
    112152,
    191327,
    14493,
    72828,
    8175,
    66636,
    236474,
    25817,
    87351,
    129027,
    76653,
    20422,
    22983,
    71240,
    27846,
    44661,
    12399,
    46158,
    77704,
    53101,
    35032,
    11072,
    17300,
    109294,
    33638,
    24408,
    1895,
    11241,
    760,
    17584,
    82479,
    125877,
    63150,
    141075,
    34259,
    23274,
    81698,
    15732,
    43577,
    48340,
    91584,
    14688,
    16379,
    24481,
    150280,
    96420,
    262050,
    48635,
    43727,
    61819,
    56268,
    72003,
    88178,
    17281,
    79912,
    13218,
    122519,
    125295,
    166396,
    11811,
    2171,
    118930,
    67746,
    17636,
    178278,
    174656,
    95661,
    173039,
    83845,
    79689,
    17473,
    98555,
    127696,
    203415,
    54730,
    22925,
    232239,
    9309,
    12136,
    175026,
    20740,
    180188,
    10747,
    39816,
    314017,
    266131,
    10040,
    175732,
    112550,
    220651,
    31974,
    37393,
    888,
    23008,
    86799,
    4303,
    64905,
    148467,
    75337,
    251,
    3284,
    370102,
    50264,
    9835,
    5438,
    23655,
    4481,
    29851,
    329,
    12855,
    7162,
    64931,
    78141,
    12804,
    42372,
    296771,
    83547,
    18624,
    34874,
    86271,
    3360,
    48665,
    77735,
    88767,
    11463,
    63527,
    28889,
    22258,
    29140,
    194315,
    113924,
    25499,
    6406,
    31334,
    1845,
    4802,
    49184,
    43455,
    35469,
    127594,
    92970,
    61038,
    115005,
    38840,
    87761,
    106838,
    8811,
    20572,
    55637,
    11162,
    96721,
    132425,
    108925,
    2948,
    125457,
    36356,
    3502,
    75270,
    27622,
    127192,
    2561,
    123095,
    49394,
    61155,
    16897,
    110064,
    9699,
    89448,
    53356,
    19628,
    220310,
    21622,
    83036,
    9885,
    112214,
    6087,
    26713,
    17901,
    161912,
    91492,
    3440,
    68594,
    9266,
    92238,
    8087,
    6866,
    150194,
    72175,
    80701,
    13459,
    31836,
    43243,
    239700,
    95846,
    44749,
    50647,
    21945,
    230538,
    120612,
    132371,
    244604,
    5193,
    105637,
    34661,
    41341,
    68775,
    85393,
    1874,
    8771,
    33718,
    49672,
    77403,
    595452,
    99507,
    6490,
    58895,
    128742,
    7704,
    39239,
    73217,
    43816,
    62824,
    37804,
    199976,
    22361,
    80005,
    87514,
    94832,
    14089,
    4574,
    139975,
    59142,
    75523,
    100268,
    43906,
    53442,
    15152,
    2547,
    186002,
    17011,
    19513,
    204282,
    3343,
    60568,
    128318,
    119250,
    4298,
    51871,
    41336,
    71759,
    21921,
    45074,
    98169,
    145889,
    99427,
    11350,
    1237,
    5520,
    28799,
    7803,
    53702,
    21026,
    136352,
    38293,
    128690,
    12158,
    90132,
    44600,
    10184,
    26957,
    39459,
    126025,
    78904,
    82999,
    59373,
    39301,
    150198,
    120529,
    153042,
    20177,
    50089,
    14764,
    271571,
    30530,
    123161,
    38975,
    101562,
    22941,
    5648,
    124654,
    109243,
    69817,
    71675,
    49162,
    106884,
    21241,
    107795,
    30258,
    16572,
    188262,
    141456,
    7688,
    60718,
    8271,
    11044,
    32440,
    104608,
    103419,
    236109,
    93156,
    43293,
    128929,
    42107,
    67180,
    25201,
    115254,
    185488,
    130954,
    72813,
    167547,
    20537,
    39969,
    38432,
    22582,
    184022,
    1139,
    27199,
    5655,
    17767,
    97412,
    122606,
    209377,
    27070,
    35871,
    326617,
    188954,
    42680,
    73512,
    80911,
    22629,
    3011,
    95021,
    315242,
    157737,
    383,
    41821,
    41808,
    19335,
    27950,
    15674,
    25677,
    110950,
    35375,
    76835,
    59108,
    57370,
    35262,
    16569,
    160415,
    37706,
    78086,
    32041,
    49691,
    137143,
    9782,
    172080,
    50148,
    77917,
    6323,
    10110,
    69172,
    17711,
    21795,
    59511,
    76184,
    135114,
    31046,
    132319,
    59105,
    157578,
    20549,
    80778,
    57649,
    158421,
    65143,
    4575,
    72235,
    21899,
    10797,
    92745,
    34035,
    106079,
    80159,
    4508,
    78304,
    25350,
    75457,
    46458,
    32937,
    25623,
    47,
    8531,
    104751,
    84953,
    8138,
    36508,
    187199,
    66310,
    115274,
    13253,
    32461,
    38536,
    1916,
    42007,
    187160,
    35055,
    26325,
    84394,
    35963,
    94216,
    45590,
    97782
  ];

  // node_modules/@libp2p/kad-dht/dist/src/routing-table/refresh.js
  var MAX_COMMON_PREFIX_LENGTH = 15;
  var RoutingTableRefresh = class {
    log;
    peerRouting;
    routingTable;
    refreshInterval;
    refreshQueryTimeout;
    commonPrefixLengthRefreshedAt;
    refreshTimeoutId;
    constructor(components, init) {
      const { peerRouting, routingTable, refreshInterval, refreshQueryTimeout, logPrefix } = init;
      this.log = components.logger.forComponent(`${logPrefix}:routing-table:refresh`);
      this.peerRouting = peerRouting;
      this.routingTable = routingTable;
      this.refreshInterval = refreshInterval ?? TABLE_REFRESH_INTERVAL;
      this.refreshQueryTimeout = refreshQueryTimeout ?? TABLE_REFRESH_QUERY_TIMEOUT;
      this.commonPrefixLengthRefreshedAt = [];
      this.refreshTable = this.refreshTable.bind(this);
    }
    async afterStart() {
      this.log(`refreshing routing table every ${this.refreshInterval}ms`);
      this.refreshTable(true);
    }
    async stop() {
      if (this.refreshTimeoutId != null) {
        clearTimeout(this.refreshTimeoutId);
      }
    }
    /**
     * To speed lookups, we seed the table with random PeerIds. This means
     * when we are asked to locate a peer on the network, we can find a KadId
     * that is close to the requested peer ID and query that, then network
     * peers will tell us who they know who is close to the fake ID
     */
    refreshTable(force = false) {
      this.log("refreshing routing table");
      const prefixLength = this._maxCommonPrefix();
      const refreshCpls = this._getTrackedCommonPrefixLengthsForRefresh(prefixLength);
      this.log(`max common prefix length ${prefixLength}`);
      this.log(`tracked CPLs [ ${refreshCpls.map((date) => date.toISOString()).join(", ")} ]`);
      Promise.all(refreshCpls.map(async (lastRefresh, index) => {
        try {
          await this._refreshCommonPrefixLength(index, lastRefresh, force);
          if (this._numPeersForCpl(prefixLength) === 0) {
            const lastCpl = Math.min(2 * (index + 1), refreshCpls.length - 1);
            for (let n = index + 1; n < lastCpl + 1; n++) {
              try {
                await this._refreshCommonPrefixLength(n, lastRefresh, force);
              } catch (err) {
                this.log.error(err);
              }
            }
          }
        } catch (err) {
          this.log.error(err);
        }
      })).catch((err) => {
        this.log.error(err);
      }).then(() => {
        this.refreshTimeoutId = setTimeout(this.refreshTable, this.refreshInterval);
        if (this.refreshTimeoutId.unref != null) {
          this.refreshTimeoutId.unref();
        }
      }).catch((err) => {
        this.log.error(err);
      });
    }
    async _refreshCommonPrefixLength(cpl, lastRefresh, force) {
      if (!force && lastRefresh.getTime() > Date.now() - this.refreshInterval) {
        this.log("not running refresh for cpl %s as time since last refresh not above interval", cpl);
        return;
      }
      const peerId2 = await this._generateRandomPeerId(cpl);
      this.log("starting refreshing cpl %s with key %p (routing table size was %s)", cpl, peerId2, this.routingTable.size);
      const signal = AbortSignal.timeout(this.refreshQueryTimeout);
      setMaxListeners(Infinity, signal);
      const peers = await src_default11(this.peerRouting.getClosestPeers(peerId2.toMultihash().bytes, {
        signal
      }));
      this.log(`found ${peers} peers that were close to imaginary peer %p`, peerId2);
      this.log("finished refreshing cpl %s with key %p (routing table size is now %s)", cpl, peerId2, this.routingTable.size);
    }
    _getTrackedCommonPrefixLengthsForRefresh(maxCommonPrefix) {
      if (maxCommonPrefix > MAX_COMMON_PREFIX_LENGTH) {
        maxCommonPrefix = MAX_COMMON_PREFIX_LENGTH;
      }
      const dates = [];
      for (let i = 0; i <= maxCommonPrefix; i++) {
        dates[i] = this.commonPrefixLengthRefreshedAt[i] ?? /* @__PURE__ */ new Date();
      }
      return dates;
    }
    async _generateRandomPeerId(targetCommonPrefixLength) {
      if (this.routingTable.kb == null) {
        throw new Error("Routing table not started");
      }
      const randomData = randomBytes2(2);
      const randomUint16 = (randomData[1] << 8) + randomData[0];
      const key = await this._makePeerId(this.routingTable.kb.localPeer.kadId, randomUint16, targetCommonPrefixLength);
      const multihash = decode4(key);
      return peerIdFromMultihash(multihash);
    }
    async _makePeerId(localKadId, randomPrefix, targetCommonPrefixLength) {
      if (targetCommonPrefixLength > MAX_COMMON_PREFIX_LENGTH) {
        throw new Error(`Cannot generate peer ID for common prefix length greater than ${MAX_COMMON_PREFIX_LENGTH}`);
      }
      const view = new DataView(localKadId.buffer, localKadId.byteOffset, localKadId.byteLength);
      const localPrefix = view.getUint16(0, false);
      const toggledLocalPrefix = localPrefix ^ 32768 >> targetCommonPrefixLength;
      const mask = 65535 << 16 - (targetCommonPrefixLength + 1);
      const targetPrefix = toggledLocalPrefix & mask | randomPrefix & ~mask;
      const keyPrefix = generated_prefix_list_browser_default[targetPrefix];
      const keyBuffer = new ArrayBuffer(34);
      const keyView = new DataView(keyBuffer, 0, keyBuffer.byteLength);
      keyView.setUint8(0, sha256.code);
      keyView.setUint8(1, 32);
      keyView.setUint32(2, keyPrefix, false);
      return new Uint8Array(keyView.buffer, keyView.byteOffset, keyView.byteLength);
    }
    /**
     * returns the maximum common prefix length between any peer in the table
     * and the current peer
     */
    _maxCommonPrefix() {
      let prefixLength = 0;
      for (const length4 of this._prefixLengths()) {
        if (length4 > prefixLength) {
          prefixLength = length4;
        }
      }
      return prefixLength;
    }
    /**
     * Returns the number of peers in the table with a given prefix length
     */
    _numPeersForCpl(prefixLength) {
      let count = 0;
      for (const length4 of this._prefixLengths()) {
        if (length4 === prefixLength) {
          count++;
        }
      }
      return count;
    }
    /**
     * Yields the common prefix length of every peer in the table
     */
    *_prefixLengths() {
      if (this.routingTable.kb == null) {
        return;
      }
      for (const { kadId } of this.routingTable.kb.toIterable()) {
        const distance = xor(this.routingTable.kb.localPeer.kadId, kadId);
        let leadingZeros = 0;
        for (const byte of distance) {
          if (byte === 0) {
            leadingZeros++;
          } else {
            break;
          }
        }
        yield leadingZeros;
      }
    }
  };

  // node_modules/@libp2p/kad-dht/dist/src/rpc/index.js
  var import_browser_shims398 = __toESM(require_browser_shims(), 1);

  // node_modules/@libp2p/kad-dht/dist/src/rpc/handlers/add-provider.js
  var import_browser_shims392 = __toESM(require_browser_shims(), 1);
  var AddProviderHandler = class {
    providers;
    log;
    constructor(components, init) {
      this.log = components.logger.forComponent(`${init.logPrefix}:rpc:handlers:add-provider`);
      this.providers = init.providers;
    }
    async handle(peerId2, msg) {
      if (msg.key == null || msg.key.length === 0) {
        throw new InvalidMessageError("Missing key");
      }
      let cid;
      try {
        cid = CID.decode(msg.key);
      } catch (err) {
        throw new InvalidMessageError("Invalid CID");
      }
      if (msg.providers == null || msg.providers.length === 0) {
        this.log.error("no providers found in message");
      }
      this.log("%p asked us to store provider record for for %c", peerId2, cid);
      await Promise.all(msg.providers.map(async (pi) => {
        if (!peerId2.equals(pi.id)) {
          this.log("invalid provider peer %p from %p", pi.id, peerId2);
          return;
        }
        if (pi.multiaddrs.length < 1) {
          this.log("no valid addresses for provider %p. Ignore", peerId2);
          return;
        }
        this.log.trace("received provider %p for %s (addrs %s)", peerId2, cid, pi.multiaddrs.map((m2) => multiaddr(m2).toString()));
        const multihash = decode4(pi.id);
        await this.providers.addProvider(cid, peerIdFromMultihash(multihash));
      }));
      return void 0;
    }
  };

  // node_modules/@libp2p/kad-dht/dist/src/rpc/handlers/find-node.js
  var import_browser_shims393 = __toESM(require_browser_shims(), 1);
  var FindNodeHandler = class {
    peerRouting;
    peerInfoMapper;
    peerId;
    addressManager;
    log;
    constructor(components, init) {
      const { peerRouting, logPrefix } = init;
      this.log = components.logger.forComponent(`${logPrefix}:rpc:handlers:find-node`);
      this.peerId = components.peerId;
      this.addressManager = components.addressManager;
      this.peerRouting = peerRouting;
      this.peerInfoMapper = init.peerInfoMapper;
    }
    /**
     * Process `FindNode` DHT messages
     */
    async handle(peerId2, msg) {
      this.log("incoming request from %p for peers closer to %b", peerId2, msg.key);
      if (msg.key == null) {
        throw new InvalidMessageError("Invalid FIND_NODE message received - key was missing");
      }
      const closer = await this.peerRouting.getCloserPeersOffline(msg.key, peerId2);
      if (equals3(this.peerId.toMultihash().bytes, msg.key)) {
        closer.push({
          id: this.peerId,
          multiaddrs: this.addressManager.getAddresses().map((ma) => ma.decapsulateCode(getProtocol("p2p").code))
        });
      }
      const response = {
        type: MessageType.FIND_NODE,
        clusterLevel: msg.clusterLevel,
        closer: closer.map(this.peerInfoMapper).filter(({ multiaddrs }) => multiaddrs.length).map((peerInfo) => ({
          id: peerInfo.id.toMultihash().bytes,
          multiaddrs: peerInfo.multiaddrs.map((ma) => ma.bytes)
        })),
        providers: []
      };
      if (response.closer.length === 0) {
        this.log("could not find any peers closer to %b than %p", msg.key, peerId2);
      }
      return response;
    }
  };

  // node_modules/@libp2p/kad-dht/dist/src/rpc/handlers/get-providers.js
  var import_browser_shims394 = __toESM(require_browser_shims(), 1);
  var GetProvidersHandler = class {
    peerRouting;
    providers;
    peerStore;
    peerInfoMapper;
    log;
    constructor(components, init) {
      const { peerRouting, providers, logPrefix } = init;
      this.log = components.logger.forComponent(`${logPrefix}:rpc:handlers:get-providers`);
      this.peerStore = components.peerStore;
      this.peerRouting = peerRouting;
      this.providers = providers;
      this.peerInfoMapper = init.peerInfoMapper;
    }
    async handle(peerId2, msg) {
      if (msg.key == null) {
        throw new InvalidMessageError("Invalid GET_PROVIDERS message received - key was missing");
      }
      let cid;
      try {
        cid = CID.decode(msg.key);
      } catch (err) {
        throw new InvalidMessageError("Invalid CID");
      }
      this.log("%p asking for providers for %s", peerId2, cid);
      const [peers, closer] = await Promise.all([
        this.providers.getProviders(cid),
        this.peerRouting.getCloserPeersOffline(msg.key, peerId2)
      ]);
      const providerPeers = await this._getPeers(peers);
      const closerPeers = await this._getPeers(closer.map(({ id }) => id));
      const response = {
        type: MessageType.GET_PROVIDERS,
        key: msg.key,
        clusterLevel: msg.clusterLevel,
        closer: closerPeers.map(this.peerInfoMapper).filter(({ multiaddrs }) => multiaddrs.length).map((peerInfo) => ({
          id: peerInfo.id.toMultihash().bytes,
          multiaddrs: peerInfo.multiaddrs.map((ma) => ma.bytes)
        })),
        providers: providerPeers.map(this.peerInfoMapper).filter(({ multiaddrs }) => multiaddrs.length).map((peerInfo) => ({
          id: peerInfo.id.toMultihash().bytes,
          multiaddrs: peerInfo.multiaddrs.map((ma) => ma.bytes)
        }))
      };
      this.log("got %s providers %s closerPeers", response.providers.length, response.closer.length);
      return response;
    }
    async _getAddresses(peerId2) {
      return [];
    }
    async _getPeers(peerIds) {
      const output = [];
      for (const peerId2 of peerIds) {
        try {
          const peer = await this.peerStore.get(peerId2);
          const peerAfterFilter = this.peerInfoMapper({
            id: peerId2,
            multiaddrs: peer.addresses.map(({ multiaddr: multiaddr2 }) => multiaddr2)
          });
          if (peerAfterFilter.multiaddrs.length > 0) {
            output.push(peerAfterFilter);
          }
        } catch (err) {
          if (err.name !== "NotFoundError") {
            throw err;
          }
        }
      }
      return output;
    }
  };

  // node_modules/@libp2p/kad-dht/dist/src/rpc/handlers/get-value.js
  var import_browser_shims395 = __toESM(require_browser_shims(), 1);
  var GetValueHandler = class {
    peerStore;
    datastore;
    peerRouting;
    log;
    constructor(components, init) {
      this.log = components.logger.forComponent(`${init.logPrefix}:rpc:handlers:get-value`);
      this.peerStore = components.peerStore;
      this.datastore = components.datastore;
      this.peerRouting = init.peerRouting;
    }
    async handle(peerId2, msg) {
      const key = msg.key;
      this.log("%p asked for key %b", peerId2, key);
      if (key == null || key.length === 0) {
        throw new InvalidMessageError("Invalid key");
      }
      const response = {
        type: MessageType.GET_VALUE,
        key,
        clusterLevel: msg.clusterLevel,
        closer: [],
        providers: []
      };
      if (isPublicKeyKey(key)) {
        this.log("is public key");
        const idFromKey = fromPublicKeyKey(key);
        let pubKey;
        try {
          const peer = await this.peerStore.get(idFromKey);
          if (peer.id.publicKey == null) {
            throw new NotFoundError("No public key found in key book");
          }
          pubKey = publicKeyToProtobuf(peer.id.publicKey);
        } catch (err) {
          if (err.name !== "NotFoundError") {
            throw err;
          }
        }
        if (pubKey != null) {
          this.log("returning found public key");
          response.record = new Libp2pRecord(key, pubKey, /* @__PURE__ */ new Date()).serialize();
          return response;
        }
      }
      const [record, closer] = await Promise.all([
        this._checkLocalDatastore(key),
        this.peerRouting.getCloserPeersOffline(key, peerId2)
      ]);
      if (record != null) {
        this.log("had record for %b in local datastore", key);
        response.record = record.serialize();
      }
      if (closer.length > 0) {
        this.log("had %s closer peers in routing table", closer.length);
        response.closer = closer.map((peerInfo) => ({
          id: peerInfo.id.toMultihash().bytes,
          multiaddrs: peerInfo.multiaddrs.map((ma) => ma.bytes)
        }));
      }
      return response;
    }
    /**
     * Try to fetch a given record by from the local datastore.
     * Returns the record if it is still valid, meaning
     * - it was either authored by this node, or
     * - it was received less than `MAX_RECORD_AGE` ago.
     */
    async _checkLocalDatastore(key) {
      this.log("checkLocalDatastore looking for %b", key);
      const dsKey = bufferToRecordKey(key);
      let rawRecord;
      try {
        rawRecord = await this.datastore.get(dsKey);
      } catch (err) {
        if (err.name === "NotFoundError") {
          return void 0;
        }
        throw err;
      }
      const record = Libp2pRecord.deserialize(rawRecord);
      if (record.timeReceived == null || Date.now() - record.timeReceived.getTime() > MAX_RECORD_AGE) {
        await this.datastore.delete(dsKey);
        return void 0;
      }
      return record;
    }
  };

  // node_modules/@libp2p/kad-dht/dist/src/rpc/handlers/ping.js
  var import_browser_shims396 = __toESM(require_browser_shims(), 1);
  var PingHandler = class {
    log;
    constructor(components, init) {
      this.log = components.logger.forComponent(`${init.logPrefix}:rpc:handlers:ping`);
    }
    async handle(peerId2, msg) {
      this.log("ping from %p", peerId2);
      return msg;
    }
  };

  // node_modules/@libp2p/kad-dht/dist/src/rpc/handlers/put-value.js
  var import_browser_shims397 = __toESM(require_browser_shims(), 1);
  var PutValueHandler = class {
    components;
    validators;
    log;
    constructor(components, init) {
      const { validators: validators2 } = init;
      this.components = components;
      this.log = components.logger.forComponent(`${init.logPrefix}:rpc:handlers:put-value`);
      this.validators = validators2;
    }
    async handle(peerId2, msg) {
      const key = msg.key;
      this.log("%p asked us to store value for key %b", peerId2, key);
      if (msg.record == null) {
        const errMsg = `Empty record from: ${peerId2.toString()}`;
        this.log.error(errMsg);
        throw new InvalidMessageError(errMsg);
      }
      try {
        const deserializedRecord = Libp2pRecord.deserialize(msg.record);
        await verifyRecord(this.validators, deserializedRecord);
        deserializedRecord.timeReceived = /* @__PURE__ */ new Date();
        const recordKey = bufferToRecordKey(deserializedRecord.key);
        await this.components.datastore.put(recordKey, deserializedRecord.serialize().subarray());
        this.log("put record for %b into datastore under key %k", key, recordKey);
      } catch (err) {
        this.log("did not put record for key %b into datastore %o", key, err);
      }
      return msg;
    }
  };

  // node_modules/@libp2p/kad-dht/dist/src/rpc/index.js
  var RPC2 = class {
    handlers;
    routingTable;
    log;
    metrics;
    constructor(components, init) {
      var _a2, _b2;
      const { providers, peerRouting, validators: validators2, logPrefix, peerInfoMapper } = init;
      this.metrics = {
        operations: (_a2 = components.metrics) == null ? void 0 : _a2.registerCounterGroup(`${logPrefix.replaceAll(":", "_")}_inbound_rpc_requests_total`),
        errors: (_b2 = components.metrics) == null ? void 0 : _b2.registerCounterGroup(`${logPrefix.replaceAll(":", "_")}_inbound_rpc_errors_total`)
      };
      this.log = components.logger.forComponent(`${logPrefix}:rpc`);
      this.routingTable = init.routingTable;
      this.handlers = {
        [MessageType.GET_VALUE.toString()]: new GetValueHandler(components, { peerRouting, logPrefix }),
        [MessageType.PUT_VALUE.toString()]: new PutValueHandler(components, { validators: validators2, logPrefix }),
        [MessageType.FIND_NODE.toString()]: new FindNodeHandler(components, { peerRouting, logPrefix, peerInfoMapper }),
        [MessageType.ADD_PROVIDER.toString()]: new AddProviderHandler(components, { providers, logPrefix }),
        [MessageType.GET_PROVIDERS.toString()]: new GetProvidersHandler(components, { peerRouting, providers, logPrefix, peerInfoMapper }),
        [MessageType.PING.toString()]: new PingHandler(components, { logPrefix })
      };
    }
    /**
     * Process incoming DHT messages
     */
    async handleMessage(peerId2, msg) {
      var _a2, _b2;
      try {
        await this.routingTable.add(peerId2);
      } catch (err) {
        this.log.error("Failed to update the kbucket store", err);
      }
      const handler = this.handlers[msg.type];
      if (handler == null) {
        this.log.error(`no handler found for message type: ${msg.type}`);
        return;
      }
      try {
        (_a2 = this.metrics.operations) == null ? void 0 : _a2.increment({
          [msg.type]: true
        });
        return await handler.handle(peerId2, msg);
      } catch {
        (_b2 = this.metrics.errors) == null ? void 0 : _b2.increment({
          [msg.type]: true
        });
      }
    }
    /**
     * Handle incoming streams on the dht protocol
     */
    onIncomingStream(data) {
      Promise.resolve().then(async () => {
        const { stream, connection } = data;
        const peerId2 = connection.remotePeer;
        try {
          await this.routingTable.add(peerId2);
        } catch (err) {
          this.log.error(err);
        }
        const self = this;
        await pipe(stream, (source) => decode8(source), async function* (source) {
          for await (const msg of source) {
            const desMessage = Message.decode(msg);
            self.log("incoming %s from %p", desMessage.type, peerId2);
            const res = await self.handleMessage(peerId2, desMessage);
            if (res != null) {
              yield Message.encode(res);
            }
          }
        }, (source) => encode7(source), stream);
      }).catch((err) => {
        this.log.error(err);
      });
    }
  };

  // node_modules/@libp2p/kad-dht/dist/src/topology-listener.js
  var import_browser_shims399 = __toESM(require_browser_shims(), 1);
  var TopologyListener = class extends TypedEventEmitter {
    log;
    components;
    protocol;
    running;
    registrarId;
    constructor(components, init) {
      super();
      const { protocol, logPrefix } = init;
      this.components = components;
      this.log = components.logger.forComponent(`${logPrefix}:topology-listener`);
      this.running = false;
      this.protocol = protocol;
    }
    isStarted() {
      return this.running;
    }
    /**
     * Start the network
     */
    async start() {
      if (this.running) {
        return;
      }
      this.running = true;
      this.registrarId = await this.components.registrar.register(this.protocol, {
        onConnect: (peerId2) => {
          this.log("observed peer %p with protocol %s", peerId2, this.protocol);
          this.dispatchEvent(new CustomEvent("peer", {
            detail: peerId2
          }));
        }
      });
    }
    /**
     * Stop all network activity
     */
    async stop() {
      this.running = false;
      if (this.registrarId != null) {
        this.components.registrar.unregister(this.registrarId);
        this.registrarId = void 0;
      }
    }
  };

  // node_modules/@libp2p/kad-dht/dist/src/kad-dht.js
  var DHTContentRouting = class {
    dht;
    constructor(dht) {
      this.dht = dht;
    }
    async provide(cid, options = {}) {
      await src_default3(this.dht.provide(cid, options));
    }
    async *findProviders(cid, options = {}) {
      for await (const event of this.dht.findProviders(cid, options)) {
        if (event.name === "PROVIDER") {
          yield* event.providers;
        }
      }
    }
    async put(key, value, options) {
      await src_default3(this.dht.put(key, value, options));
    }
    async get(key, options) {
      for await (const event of this.dht.get(key, options)) {
        if (event.name === "VALUE") {
          return event.value;
        }
      }
      throw new NotFoundError("Could not find value for key");
    }
  };
  var DHTPeerRouting = class {
    dht;
    constructor(dht) {
      this.dht = dht;
    }
    async findPeer(peerId2, options = {}) {
      for await (const event of this.dht.findPeer(peerId2, options)) {
        if (event.name === "FINAL_PEER") {
          return event.peer;
        }
      }
      throw new NotFoundError("Peer not found");
    }
    async *getClosestPeers(key, options = {}) {
      for await (const event of this.dht.getClosestPeers(key, options)) {
        if (event.name === "FINAL_PEER") {
          yield event.peer;
        }
      }
    }
  };
  var DEFAULT_MAX_INBOUND_STREAMS2 = 32;
  var DEFAULT_MAX_OUTBOUND_STREAMS2 = 64;
  var KadDHT = class extends TypedEventEmitter {
    protocol;
    routingTable;
    providers;
    network;
    peerRouting;
    components;
    log;
    running;
    kBucketSize;
    clientMode;
    validators;
    selectors;
    queryManager;
    contentFetching;
    contentRouting;
    routingTableRefresh;
    rpc;
    topologyListener;
    querySelf;
    maxInboundStreams;
    maxOutboundStreams;
    dhtContentRouting;
    dhtPeerRouting;
    peerInfoMapper;
    /**
     * Create a new KadDHT
     */
    constructor(components, init = {}) {
      super();
      const { kBucketSize, clientMode, validators: validators2, selectors: selectors2, querySelfInterval, protocol, logPrefix, pingTimeout, pingConcurrency, maxInboundStreams, maxOutboundStreams, providers: providersInit } = init;
      const loggingPrefix = logPrefix ?? "libp2p:kad-dht";
      this.running = false;
      this.components = components;
      this.log = components.logger.forComponent(loggingPrefix);
      this.protocol = protocol ?? PROTOCOL;
      this.kBucketSize = kBucketSize ?? 20;
      this.clientMode = clientMode ?? true;
      this.maxInboundStreams = maxInboundStreams ?? DEFAULT_MAX_INBOUND_STREAMS2;
      this.maxOutboundStreams = maxOutboundStreams ?? DEFAULT_MAX_OUTBOUND_STREAMS2;
      this.peerInfoMapper = init.peerInfoMapper ?? removePrivateAddressesMapper;
      this.routingTable = new RoutingTable(components, {
        kBucketSize,
        pingTimeout,
        pingConcurrency,
        protocol: this.protocol,
        logPrefix: loggingPrefix
      });
      this.providers = new Providers(components, providersInit ?? {});
      this.validators = {
        ...validators,
        ...validators2
      };
      this.selectors = {
        ...selectors,
        ...selectors2
      };
      this.network = new Network(components, {
        protocol: this.protocol,
        logPrefix: loggingPrefix
      });
      const initialQuerySelfHasRun = pDefer();
      if (init.allowQueryWithZeroPeers === true) {
        initialQuerySelfHasRun.resolve();
      }
      this.queryManager = new QueryManager(components, {
        // Number of disjoint query paths to use - This is set to `kBucketSize/2` per the S/Kademlia paper
        disjointPaths: Math.ceil(this.kBucketSize / 2),
        logPrefix: loggingPrefix,
        initialQuerySelfHasRun,
        routingTable: this.routingTable
      });
      this.peerRouting = new PeerRouting(components, {
        routingTable: this.routingTable,
        network: this.network,
        validators: this.validators,
        queryManager: this.queryManager,
        logPrefix: loggingPrefix
      });
      this.contentFetching = new ContentFetching(components, {
        validators: this.validators,
        selectors: this.selectors,
        peerRouting: this.peerRouting,
        queryManager: this.queryManager,
        network: this.network,
        logPrefix: loggingPrefix
      });
      this.contentRouting = new ContentRouting(components, {
        network: this.network,
        peerRouting: this.peerRouting,
        queryManager: this.queryManager,
        routingTable: this.routingTable,
        providers: this.providers,
        logPrefix: loggingPrefix
      });
      this.routingTableRefresh = new RoutingTableRefresh(components, {
        peerRouting: this.peerRouting,
        routingTable: this.routingTable,
        logPrefix: loggingPrefix
      });
      this.rpc = new RPC2(components, {
        routingTable: this.routingTable,
        providers: this.providers,
        peerRouting: this.peerRouting,
        validators: this.validators,
        logPrefix: loggingPrefix,
        peerInfoMapper: this.peerInfoMapper
      });
      this.topologyListener = new TopologyListener(components, {
        protocol: this.protocol,
        logPrefix: loggingPrefix
      });
      this.querySelf = new QuerySelf(components, {
        peerRouting: this.peerRouting,
        interval: querySelfInterval,
        initialInterval: init.initialQuerySelfInterval,
        logPrefix: loggingPrefix,
        initialQuerySelfHasRun,
        routingTable: this.routingTable
      });
      this.network.addEventListener("peer", (evt) => {
        const peerData = evt.detail;
        this.onPeerConnect(peerData).catch((err) => {
          this.log.error("could not add %p to routing table", peerData.id, err);
        });
        this.dispatchEvent(new CustomEvent("peer", {
          detail: peerData
        }));
      });
      this.topologyListener.addEventListener("peer", (evt) => {
        const peerId2 = evt.detail;
        Promise.resolve().then(async () => {
          const peer = await this.components.peerStore.get(peerId2);
          const peerData = {
            id: peerId2,
            multiaddrs: peer.addresses.map(({ multiaddr: multiaddr2 }) => multiaddr2),
            protocols: peer.protocols
          };
          await this.onPeerConnect(peerData);
        }).catch((err) => {
          this.log.error("could not add %p to routing table", peerId2, err);
        });
      });
      this.dhtPeerRouting = new DHTPeerRouting(this);
      this.dhtContentRouting = new DHTContentRouting(this);
      if (init.clientMode == null) {
        components.events.addEventListener("self:peer:update", (evt) => {
          this.log("received update of self-peer info");
          void Promise.resolve().then(async () => {
            const hasPublicAddress = evt.detail.peer.addresses.some(({ multiaddr: multiaddr2 }) => multiaddrIsPublic(multiaddr2));
            const mode = this.getMode();
            if (hasPublicAddress && mode === "client") {
              await this.setMode("server");
            } else if (mode === "server" && !hasPublicAddress) {
              await this.setMode("client");
            }
          }).catch((err) => {
            this.log.error("error setting dht server mode", err);
          });
        });
      }
    }
    [Symbol.toStringTag] = "@libp2p/kad-dht";
    [serviceCapabilities] = [
      "@libp2p/content-routing",
      "@libp2p/peer-routing",
      "@libp2p/peer-discovery"
    ];
    [serviceDependencies] = [
      "@libp2p/identify"
    ];
    get [contentRoutingSymbol]() {
      return this.dhtContentRouting;
    }
    get [peerRoutingSymbol]() {
      return this.dhtPeerRouting;
    }
    get [peerDiscoverySymbol]() {
      return this;
    }
    async onPeerConnect(peerData) {
      this.log.trace("peer %p connected", peerData.id);
      peerData = this.peerInfoMapper(peerData);
      if (peerData.multiaddrs.length === 0) {
        this.log.trace("ignoring %p as there were no valid addresses in %s after filtering", peerData.id, peerData.multiaddrs.map((addr) => addr.toString()));
        return;
      }
      try {
        await this.routingTable.add(peerData.id);
      } catch (err) {
        this.log.error("could not add %p to routing table", peerData.id, err);
      }
    }
    /**
     * Is this DHT running.
     */
    isStarted() {
      return this.running;
    }
    /**
     * If 'server' this node will respond to DHT queries, if 'client' this node will not
     */
    getMode() {
      return this.clientMode ? "client" : "server";
    }
    /**
     * If 'server' this node will respond to DHT queries, if 'client' this node will not
     */
    async setMode(mode, force = false) {
      if (mode === this.getMode() && !force) {
        this.log("already in %s mode", mode);
        return;
      }
      await this.components.registrar.unhandle(this.protocol);
      if (mode === "client") {
        this.log("enabling client mode");
        this.clientMode = true;
      } else {
        this.log("enabling server mode");
        this.clientMode = false;
        await this.components.registrar.handle(this.protocol, this.rpc.onIncomingStream.bind(this.rpc), {
          maxInboundStreams: this.maxInboundStreams,
          maxOutboundStreams: this.maxOutboundStreams
        });
      }
    }
    /**
     * Start listening to incoming connections.
     */
    async start() {
      this.running = true;
      await this.setMode(this.clientMode ? "client" : "server", true);
      await start(this.querySelf, this.providers, this.queryManager, this.network, this.routingTable, this.topologyListener, this.routingTableRefresh);
    }
    /**
     * Stop accepting incoming connections and sending outgoing
     * messages.
     */
    async stop() {
      this.running = false;
      await stop(this.querySelf, this.providers, this.queryManager, this.network, this.routingTable, this.routingTableRefresh, this.topologyListener);
    }
    /**
     * Store the given key/value pair in the DHT
     */
    async *put(key, value, options = {}) {
      yield* this.contentFetching.put(key, value, options);
    }
    /**
     * Get the value that corresponds to the passed key
     */
    async *get(key, options = {}) {
      yield* this.contentFetching.get(key, options);
    }
    // ----------- Content Routing
    /**
     * Announce to the network that we can provide given key's value
     */
    async *provide(key, options = {}) {
      yield* this.contentRouting.provide(key, this.components.addressManager.getAddresses(), options);
    }
    /**
     * Search the dht for providers of the given CID
     */
    async *findProviders(key, options = {}) {
      yield* this.contentRouting.findProviders(key, options);
    }
    // ----------- Peer Routing -----------
    /**
     * Search for a peer with the given ID
     */
    async *findPeer(id, options = {}) {
      yield* this.peerRouting.findPeer(id, options);
    }
    /**
     * Kademlia 'node lookup' operation
     */
    async *getClosestPeers(key, options = {}) {
      yield* this.peerRouting.getClosestPeers(key, options);
    }
    async refreshRoutingTable() {
      this.routingTableRefresh.refreshTable(true);
    }
  };

  // node_modules/@libp2p/kad-dht/dist/src/index.js
  var EventTypes;
  (function(EventTypes2) {
    EventTypes2[EventTypes2["SEND_QUERY"] = 0] = "SEND_QUERY";
    EventTypes2[EventTypes2["PEER_RESPONSE"] = 1] = "PEER_RESPONSE";
    EventTypes2[EventTypes2["FINAL_PEER"] = 2] = "FINAL_PEER";
    EventTypes2[EventTypes2["QUERY_ERROR"] = 3] = "QUERY_ERROR";
    EventTypes2[EventTypes2["PROVIDER"] = 4] = "PROVIDER";
    EventTypes2[EventTypes2["VALUE"] = 5] = "VALUE";
    EventTypes2[EventTypes2["ADD_PEER"] = 6] = "ADD_PEER";
    EventTypes2[EventTypes2["DIAL_PEER"] = 7] = "DIAL_PEER";
  })(EventTypes || (EventTypes = {}));
  function kadDHT(init = {}) {
    return (components) => new KadDHT(components, init);
  }

  // node_modules/@libp2p/websockets/dist/src/index.js
  var import_browser_shims414 = __toESM(require_browser_shims(), 1);

  // node_modules/@multiformats/multiaddr-to-uri/dist/src/index.js
  var import_browser_shims402 = __toESM(require_browser_shims(), 1);
  var ASSUME_HTTP_CODES = [
    getProtocol("tcp").code,
    getProtocol("dns").code,
    getProtocol("dnsaddr").code,
    getProtocol("dns4").code,
    getProtocol("dns6").code
  ];
  function extractSNI(ma) {
    var _a2;
    return (_a2 = extractTuple("sni", ma)) == null ? void 0 : _a2[1];
  }
  function extractPort(ma) {
    var _a2;
    const port = (_a2 = extractTuple("tcp", ma)) == null ? void 0 : _a2[1];
    if (port == null) {
      return "";
    }
    return `:${port}`;
  }
  function extractTuple(name3, ma) {
    let code2;
    try {
      code2 = getProtocol(name3).code;
    } catch (e) {
      return;
    }
    for (const [proto, value] of ma) {
      if (proto === code2 && value != null) {
        return [proto, value];
      }
    }
  }
  function hasTLS(ma) {
    return ma.some(([proto, _]) => proto === getProtocol("tls").code);
  }
  function interpretNext(headProtoCode, headProtoVal, restMa) {
    const interpreter = interpreters[getProtocol(headProtoCode).name];
    if (interpreter == null) {
      throw new Error(`Can't interpret protocol ${getProtocol(headProtoCode).name}`);
    }
    const restVal = interpreter(headProtoVal, restMa);
    if (headProtoCode === getProtocol("ip6").code) {
      return `[${restVal}]`;
    }
    return restVal;
  }
  var interpreters = {
    ip4: (value, restMa) => value,
    ip6: (value, restMa) => {
      if (restMa.length === 0) {
        return value;
      }
      return `[${value}]`;
    },
    tcp: (value, restMa) => {
      const tailProto = restMa.pop();
      if (tailProto == null) {
        throw new Error("Unexpected end of multiaddr");
      }
      return `tcp://${interpretNext(tailProto[0], tailProto[1] ?? "", restMa)}:${value}`;
    },
    udp: (value, restMa) => {
      const tailProto = restMa.pop();
      if (tailProto == null) {
        throw new Error("Unexpected end of multiaddr");
      }
      return `udp://${interpretNext(tailProto[0], tailProto[1] ?? "", restMa)}:${value}`;
    },
    dnsaddr: (value, restMa) => value,
    dns4: (value, restMa) => value,
    dns6: (value, restMa) => value,
    dns: (value, restMa) => value,
    ipfs: (value, restMa) => {
      const tailProto = restMa.pop();
      if (tailProto == null) {
        throw new Error("Unexpected end of multiaddr");
      }
      return `${interpretNext(tailProto[0], tailProto[1] ?? "", restMa)}`;
    },
    p2p: (value, restMa) => {
      const tailProto = restMa.pop();
      if (tailProto == null) {
        throw new Error("Unexpected end of multiaddr");
      }
      return `${interpretNext(tailProto[0], tailProto[1] ?? "", restMa)}`;
    },
    http: (value, restMa) => {
      const maHasTLS = hasTLS(restMa);
      const sni = extractSNI(restMa);
      const port = extractPort(restMa);
      if (maHasTLS && sni != null) {
        return `https://${sni}${port}`;
      }
      const protocol = maHasTLS ? "https://" : "http://";
      const tailProto = restMa.pop();
      if (tailProto == null) {
        throw new Error("Unexpected end of multiaddr");
      }
      let baseVal = interpretNext(tailProto[0], tailProto[1] ?? "", restMa);
      baseVal = baseVal.replace("tcp://", "");
      return `${protocol}${baseVal}`;
    },
    "http-path": (value, restMa) => {
      const tailProto = restMa.pop();
      if (tailProto == null) {
        throw new Error("Unexpected end of multiaddr");
      }
      const baseVal = interpretNext(tailProto[0], tailProto[1] ?? "", restMa);
      const decodedValue = decodeURIComponent(value);
      return `${baseVal}/${decodedValue}`;
    },
    tls: (value, restMa) => {
      const tailProto = restMa.pop();
      if (tailProto == null) {
        throw new Error("Unexpected end of multiaddr");
      }
      return interpretNext(tailProto[0], tailProto[1] ?? "", restMa);
    },
    sni: (value, restMa) => {
      const tailProto = restMa.pop();
      if (tailProto == null) {
        throw new Error("Unexpected end of multiaddr");
      }
      return interpretNext(tailProto[0], tailProto[1] ?? "", restMa);
    },
    https: (value, restMa) => {
      const tailProto = restMa.pop();
      if (tailProto == null) {
        throw new Error("Unexpected end of multiaddr");
      }
      let baseVal = interpretNext(tailProto[0], tailProto[1] ?? "", restMa);
      baseVal = baseVal.replace("tcp://", "");
      return `https://${baseVal}`;
    },
    ws: (value, restMa) => {
      const maHasTLS = hasTLS(restMa);
      const sni = extractSNI(restMa);
      const port = extractPort(restMa);
      if (maHasTLS && sni != null) {
        return `wss://${sni}${port}`;
      }
      const protocol = maHasTLS ? "wss://" : "ws://";
      const tailProto = restMa.pop();
      if (tailProto == null) {
        throw new Error("Unexpected end of multiaddr");
      }
      let baseVal = interpretNext(tailProto[0], tailProto[1] ?? "", restMa);
      baseVal = baseVal.replace("tcp://", "");
      return `${protocol}${baseVal}`;
    },
    wss: (value, restMa) => {
      const tailProto = restMa.pop();
      if (tailProto == null) {
        throw new Error("Unexpected end of multiaddr");
      }
      let baseVal = interpretNext(tailProto[0], tailProto[1] ?? "", restMa);
      baseVal = baseVal.replace("tcp://", "");
      return `wss://${baseVal}`;
    }
  };
  function multiaddrToUri(input, opts) {
    const ma = multiaddr(input);
    const parts = ma.stringTuples();
    const head = parts.pop();
    if (head == null) {
      throw new Error("Unexpected end of multiaddr");
    }
    const protocol = getProtocol(head[0]);
    const interpreter = interpreters[protocol.name];
    if (interpreter == null) {
      throw new Error(`No interpreter found for ${protocol.name}`);
    }
    let uri = interpreter(head[1] ?? "", parts);
    if ((opts == null ? void 0 : opts.assumeHttp) !== false && ASSUME_HTTP_CODES.includes(head[0])) {
      uri = uri.replace(/^.*:\/\//, "");
      if (head[1] === "443") {
        uri = `https://${uri}`;
      } else {
        uri = `http://${uri}`;
      }
    }
    if (uri.startsWith("http://") || uri.startsWith("https://") || uri.startsWith("ws://") || uri.startsWith("wss://")) {
      uri = new URL(uri).toString();
      if (uri.endsWith("/")) {
        uri = uri.substring(0, uri.length - 1);
      }
    }
    return uri;
  }

  // node_modules/it-ws/dist/src/client.js
  var import_browser_shims409 = __toESM(require_browser_shims(), 1);

  // node_modules/it-ws/dist/src/duplex.js
  var import_browser_shims406 = __toESM(require_browser_shims(), 1);

  // node_modules/it-ws/dist/src/sink.js
  var import_browser_shims404 = __toESM(require_browser_shims(), 1);

  // node_modules/it-ws/dist/src/ready.js
  var import_browser_shims403 = __toESM(require_browser_shims(), 1);
  var ready_default = async (socket) => {
    if (socket.readyState >= 2) {
      throw new Error("socket closed");
    }
    if (socket.readyState === 1) {
      return;
    }
    await new Promise((resolve, reject) => {
      function cleanup() {
        socket.removeEventListener("open", handleOpen);
        socket.removeEventListener("error", handleErr);
      }
      function handleOpen() {
        cleanup();
        resolve();
      }
      function handleErr(event) {
        cleanup();
        reject(event.error ?? new Error(`connect ECONNREFUSED ${socket.url}`));
      }
      socket.addEventListener("open", handleOpen);
      socket.addEventListener("error", handleErr);
    });
  };

  // node_modules/it-ws/dist/src/sink.js
  var sink_default = (socket, options) => {
    options = options ?? {};
    options.closeOnEnd = options.closeOnEnd !== false;
    const sink = async (source) => {
      for await (const data of source) {
        try {
          await ready_default(socket);
        } catch (err) {
          if (err.message === "socket closed")
            break;
          throw err;
        }
        if (socket.readyState === socket.CLOSING || socket.readyState === socket.CLOSED) {
          break;
        }
        socket.send(data);
      }
      if (options.closeOnEnd != null && socket.readyState <= 1) {
        await new Promise((resolve, reject) => {
          socket.addEventListener("close", (event) => {
            if (event.wasClean || event.code === 1006) {
              resolve();
            } else {
              const err = Object.assign(new Error("ws error"), { event });
              reject(err);
            }
          });
          setTimeout(() => {
            socket.close();
          });
        });
      }
    };
    return sink;
  };

  // node_modules/it-ws/dist/src/source.js
  var import_browser_shims405 = __toESM(require_browser_shims(), 1);
  var import_event_iterator = __toESM(require_dom(), 1);
  function isArrayBuffer(obj) {
    var _a2;
    return obj instanceof ArrayBuffer || ((_a2 = obj == null ? void 0 : obj.constructor) == null ? void 0 : _a2.name) === "ArrayBuffer" && typeof (obj == null ? void 0 : obj.byteLength) === "number";
  }
  var source_default = (socket) => {
    socket.binaryType = "arraybuffer";
    const connected = async () => {
      await new Promise((resolve, reject) => {
        if (isConnected) {
          resolve();
          return;
        }
        if (connError != null) {
          reject(connError);
          return;
        }
        const cleanUp = (cont) => {
          socket.removeEventListener("open", onOpen);
          socket.removeEventListener("error", onError);
          cont();
        };
        const onOpen = () => {
          cleanUp(resolve);
        };
        const onError = (event) => {
          cleanUp(() => {
            reject(event.error ?? new Error(`connect ECONNREFUSED ${socket.url}`));
          });
        };
        socket.addEventListener("open", onOpen);
        socket.addEventListener("error", onError);
      });
    };
    const source = async function* () {
      const messages2 = new import_event_iterator.EventIterator(({ push, stop: stop2, fail }) => {
        const onMessage = (event) => {
          let data = null;
          if (typeof event.data === "string") {
            data = fromString2(event.data);
          }
          if (isArrayBuffer(event.data)) {
            data = new Uint8Array(event.data);
          }
          if (event.data instanceof Uint8Array) {
            data = event.data;
          }
          if (data == null) {
            return;
          }
          push(data);
        };
        const onError = (event) => {
          fail(event.error ?? new Error("Socket error"));
        };
        socket.addEventListener("message", onMessage);
        socket.addEventListener("error", onError);
        socket.addEventListener("close", stop2);
        return () => {
          socket.removeEventListener("message", onMessage);
          socket.removeEventListener("error", onError);
          socket.removeEventListener("close", stop2);
        };
      }, { highWaterMark: Infinity });
      await connected();
      for await (const chunk of messages2) {
        yield isArrayBuffer(chunk) ? new Uint8Array(chunk) : chunk;
      }
    }();
    let isConnected = socket.readyState === 1;
    let connError;
    socket.addEventListener("open", () => {
      isConnected = true;
      connError = null;
    });
    socket.addEventListener("close", () => {
      isConnected = false;
      connError = null;
    });
    socket.addEventListener("error", (event) => {
      if (!isConnected) {
        connError = event.error ?? new Error(`connect ECONNREFUSED ${socket.url}`);
      }
    });
    return Object.assign(source, {
      connected
    });
  };

  // node_modules/it-ws/dist/src/duplex.js
  var duplex_default = (socket, options) => {
    options = options ?? {};
    const connectedSource = source_default(socket);
    let remoteAddress = options.remoteAddress;
    let remotePort = options.remotePort;
    if (socket.url != null) {
      try {
        const url = new URL(socket.url);
        remoteAddress = url.hostname;
        remotePort = parseInt(url.port, 10);
      } catch {
      }
    }
    if (remoteAddress == null || remotePort == null) {
      throw new Error("Remote connection did not have address and/or port");
    }
    const duplex = {
      sink: sink_default(socket, options),
      source: connectedSource,
      connected: async () => {
        await connectedSource.connected();
      },
      close: async () => {
        if (socket.readyState === socket.CONNECTING || socket.readyState === socket.OPEN) {
          await new Promise((resolve) => {
            socket.addEventListener("close", () => {
              resolve();
            });
            socket.close();
          });
        }
      },
      destroy: () => {
        if (socket.terminate != null) {
          socket.terminate();
        } else {
          socket.close();
        }
      },
      remoteAddress,
      remotePort,
      socket
    };
    return duplex;
  };

  // node_modules/it-ws/dist/src/web-socket.browser.js
  var import_browser_shims407 = __toESM(require_browser_shims(), 1);
  var web_socket_browser_default = WebSocket;

  // node_modules/it-ws/dist/src/ws-url.js
  var import_browser_shims408 = __toESM(require_browser_shims(), 1);
  var map2 = { "http:": "ws:", "https:": "wss:" };
  var defaultProtocol = "ws:";
  var ws_url_default = (url, location) => {
    if (url.startsWith("//")) {
      url = `${(location == null ? void 0 : location.protocol) ?? defaultProtocol}${url}`;
    }
    if (url.startsWith("/") && location != null) {
      const proto = location.protocol ?? defaultProtocol;
      const host = location.host;
      const port = location.port != null && (host == null ? void 0 : host.endsWith(`:${location.port}`)) !== true ? `:${location.port}` : "";
      url = `${proto}//${host}${port}${url}`;
    }
    const wsUrl = new URL(url);
    for (const [httpProto, wsProto] of Object.entries(map2)) {
      if (wsUrl.protocol === httpProto) {
        wsUrl.protocol = wsProto;
      }
    }
    return wsUrl;
  };

  // node_modules/it-ws/dist/src/client.js
  function connect(addr, opts) {
    const location = typeof window === "undefined" ? void 0 : window.location;
    opts = opts ?? {};
    const url = ws_url_default(addr, location);
    const socket = new web_socket_browser_default(url.toString(), opts.websocket);
    return duplex_default(socket, opts);
  }

  // node_modules/@libp2p/websockets/dist/src/filters.js
  var import_browser_shims410 = __toESM(require_browser_shims(), 1);
  function all2(multiaddrs) {
    return multiaddrs.filter((ma) => {
      return WebSocketsSecure.exactMatch(ma) || WebSockets.exactMatch(ma);
    });
  }

  // node_modules/@libp2p/websockets/dist/src/listener.browser.js
  var import_browser_shims411 = __toESM(require_browser_shims(), 1);
  function createListener() {
    throw new Error("WebSocket Servers can not be created in the browser!");
  }

  // node_modules/@libp2p/websockets/dist/src/socket-to-conn.js
  var import_browser_shims413 = __toESM(require_browser_shims(), 1);

  // node_modules/@libp2p/websockets/dist/src/constants.js
  var import_browser_shims412 = __toESM(require_browser_shims(), 1);
  var CLOSE_TIMEOUT3 = 500;

  // node_modules/@libp2p/websockets/dist/src/socket-to-conn.js
  function socketToMaConn(stream, remoteAddr, options) {
    const log2 = options.logger.forComponent("libp2p:websockets:maconn");
    const metrics = options.metrics;
    const metricPrefix = options.metricPrefix ?? "";
    const maConn = {
      log: log2,
      async sink(source) {
        try {
          await stream.sink(async function* () {
            for await (const buf of source) {
              if (buf instanceof Uint8Array) {
                yield buf;
              } else {
                yield buf.subarray();
              }
            }
          }());
        } catch (err) {
          if (err.type !== "aborted") {
            log2.error(err);
          }
        }
      },
      source: stream.source,
      remoteAddr,
      timeline: { open: Date.now() },
      async close(options2 = {}) {
        var _a2, _b2;
        const start2 = Date.now();
        if (options2.signal == null) {
          const signal = AbortSignal.timeout(CLOSE_TIMEOUT3);
          options2 = {
            ...options2,
            signal
          };
        }
        const listener = () => {
          const { host, port } = maConn.remoteAddr.toOptions();
          log2("timeout closing stream to %s:%s after %dms, destroying it manually", host, port, Date.now() - start2);
          this.abort(new AbortError("Socket close timeout"));
        };
        (_a2 = options2.signal) == null ? void 0 : _a2.addEventListener("abort", listener);
        try {
          await stream.close();
        } catch (err) {
          log2.error("error closing WebSocket gracefully", err);
          this.abort(err);
        } finally {
          (_b2 = options2.signal) == null ? void 0 : _b2.removeEventListener("abort", listener);
          maConn.timeline.close = Date.now();
        }
      },
      abort(err) {
        const { host, port } = maConn.remoteAddr.toOptions();
        log2("timeout closing stream to %s:%s due to error", host, port, err);
        stream.destroy();
        maConn.timeline.close = Date.now();
        metrics == null ? void 0 : metrics.increment({ [`${metricPrefix}error`]: true });
      }
    };
    stream.socket.addEventListener("close", () => {
      metrics == null ? void 0 : metrics.increment({ [`${metricPrefix}close`]: true });
      if (maConn.timeline.close == null) {
        maConn.timeline.close = Date.now();
      }
    }, { once: true });
    return maConn;
  }

  // node_modules/@libp2p/websockets/dist/src/index.js
  var WebSockets2 = class {
    log;
    init;
    logger;
    metrics;
    components;
    constructor(components, init = {}) {
      this.log = components.logger.forComponent("libp2p:websockets");
      this.logger = components.logger;
      this.components = components;
      this.init = init;
      if (components.metrics != null) {
        this.metrics = {
          dialerEvents: components.metrics.registerCounterGroup("libp2p_websockets_dialer_events_total", {
            label: "event",
            help: "Total count of WebSockets dialer events by type"
          })
        };
      }
    }
    [transportSymbol] = true;
    [Symbol.toStringTag] = "@libp2p/websockets";
    [serviceCapabilities] = [
      "@libp2p/transport"
    ];
    async dial(ma, options) {
      var _a2;
      this.log("dialing %s", ma);
      options = options ?? {};
      const socket = await this._connect(ma, options);
      const maConn = socketToMaConn(socket, ma, {
        logger: this.logger,
        metrics: (_a2 = this.metrics) == null ? void 0 : _a2.dialerEvents
      });
      this.log("new outbound connection %s", maConn.remoteAddr);
      const conn = await options.upgrader.upgradeOutbound(maConn, options);
      this.log("outbound connection %s upgraded", maConn.remoteAddr);
      return conn;
    }
    async _connect(ma, options) {
      var _a2, _b2, _c, _d, _e;
      (_a2 = options == null ? void 0 : options.signal) == null ? void 0 : _a2.throwIfAborted();
      const cOpts = ma.toOptions();
      this.log("dialing %s:%s", cOpts.host, cOpts.port);
      const errorPromise = pDefer();
      const rawSocket = connect(multiaddrToUri(ma), this.init);
      rawSocket.socket.addEventListener("error", () => {
        var _a3;
        const err = new ConnectionFailedError(`Could not connect to ${ma.toString()}`);
        this.log.error("connection error:", err);
        (_a3 = this.metrics) == null ? void 0 : _a3.dialerEvents.increment({ error: true });
        errorPromise.reject(err);
      });
      try {
        (_b2 = options.onProgress) == null ? void 0 : _b2.call(options, new CustomProgressEvent("websockets:open-connection"));
        await raceSignal(Promise.race([rawSocket.connected(), errorPromise.promise]), options.signal);
      } catch (err) {
        if ((_c = options.signal) == null ? void 0 : _c.aborted) {
          (_d = this.metrics) == null ? void 0 : _d.dialerEvents.increment({ abort: true });
        }
        rawSocket.close().catch((err2) => {
          this.log.error("error closing raw socket", err2);
        });
        throw err;
      }
      this.log("connected %s", ma);
      (_e = this.metrics) == null ? void 0 : _e.dialerEvents.increment({ connect: true });
      return rawSocket;
    }
    /**
     * Creates a WebSockets listener. The provided `handler` function will be called
     * anytime a new incoming Connection has been successfully upgraded via
     * `upgrader.upgradeInbound`
     */
    createListener(options) {
      return createListener({
        logger: this.logger,
        events: this.components.events,
        metrics: this.components.metrics
      }, {
        ...this.init,
        ...options
      });
    }
    /**
     * Takes a list of `Multiaddr`s and returns only valid WebSockets addresses.
     * By default, in a browser environment only DNS+WSS multiaddr is accepted,
     * while in a Node.js environment DNS+{WS, WSS} multiaddrs are accepted.
     */
    listenFilter(multiaddrs) {
      var _a2, _b2;
      multiaddrs = Array.isArray(multiaddrs) ? multiaddrs : [multiaddrs];
      if (((_a2 = this.init) == null ? void 0 : _a2.filter) != null) {
        return (_b2 = this.init) == null ? void 0 : _b2.filter(multiaddrs);
      }
      return all2(multiaddrs);
    }
    /**
     * Filter check for all Multiaddrs that this transport can dial
     */
    dialFilter(multiaddrs) {
      return this.listenFilter(multiaddrs);
    }
  };
  function webSockets(init = {}) {
    return (components) => {
      return new WebSockets2(components, init);
    };
  }

  // node_modules/@libp2p/webrtc/dist/src/index.js
  var import_browser_shims436 = __toESM(require_browser_shims(), 1);

  // node_modules/@libp2p/webrtc/dist/src/private-to-private/transport.js
  var import_browser_shims435 = __toESM(require_browser_shims(), 1);

  // node_modules/@libp2p/webrtc/dist/src/constants.js
  var import_browser_shims416 = __toESM(require_browser_shims(), 1);

  // node_modules/@libp2p/webrtc/dist/src/private-to-public/pb/message.js
  var import_browser_shims415 = __toESM(require_browser_shims(), 1);
  var Message2;
  (function(Message4) {
    let Flag2;
    (function(Flag3) {
      Flag3["FIN"] = "FIN";
      Flag3["STOP_SENDING"] = "STOP_SENDING";
      Flag3["RESET"] = "RESET";
      Flag3["FIN_ACK"] = "FIN_ACK";
    })(Flag2 = Message4.Flag || (Message4.Flag = {}));
    let __FlagValues;
    (function(__FlagValues2) {
      __FlagValues2[__FlagValues2["FIN"] = 0] = "FIN";
      __FlagValues2[__FlagValues2["STOP_SENDING"] = 1] = "STOP_SENDING";
      __FlagValues2[__FlagValues2["RESET"] = 2] = "RESET";
      __FlagValues2[__FlagValues2["FIN_ACK"] = 3] = "FIN_ACK";
    })(__FlagValues || (__FlagValues = {}));
    (function(Flag3) {
      Flag3.codec = () => {
        return enumeration(__FlagValues);
      };
    })(Flag2 = Message4.Flag || (Message4.Flag = {}));
    let _codec;
    Message4.codec = () => {
      if (_codec == null) {
        _codec = message((obj, w2, opts = {}) => {
          if (opts.lengthDelimited !== false) {
            w2.fork();
          }
          if (obj.flag != null) {
            w2.uint32(8);
            Message4.Flag.codec().encode(obj.flag, w2);
          }
          if (obj.message != null) {
            w2.uint32(18);
            w2.bytes(obj.message);
          }
          if (opts.lengthDelimited !== false) {
            w2.ldelim();
          }
        }, (reader, length4, opts = {}) => {
          const obj = {};
          const end = length4 == null ? reader.len : reader.pos + length4;
          while (reader.pos < end) {
            const tag = reader.uint32();
            switch (tag >>> 3) {
              case 1: {
                obj.flag = Message4.Flag.codec().decode(reader);
                break;
              }
              case 2: {
                obj.message = reader.bytes();
                break;
              }
              default: {
                reader.skipType(tag & 7);
                break;
              }
            }
          }
          return obj;
        });
      }
      return _codec;
    };
    Message4.encode = (obj) => {
      return encodeMessage(obj, Message4.codec());
    };
    Message4.decode = (buf, opts) => {
      return decodeMessage(buf, Message4.codec(), opts);
    };
  })(Message2 || (Message2 = {}));

  // node_modules/@libp2p/webrtc/dist/src/constants.js
  var DEFAULT_ICE_SERVERS = [
    "stun:stun.l.google.com:19302",
    "stun:global.stun.twilio.com:3478",
    "stun:stun.cloudflare.com:3478",
    "stun:stun.services.mozilla.com:3478"
  ];
  var UFRAG_ALPHABET = Array.from("abcdefghijklmnopqrstuvwxyzABCDEFGHIJKLMNOPQRSTUVWXYZ1234567890");
  var MAX_BUFFERED_AMOUNT = 2 * 1024 * 1024;
  var BUFFERED_AMOUNT_LOW_TIMEOUT = 30 * 1e3;
  var MAX_MESSAGE_SIZE = 16 * 1024;
  function calculateProtobufOverhead(maxMessageSize = MAX_MESSAGE_SIZE) {
    const messageLength = encodingLength2(maxMessageSize - encodingLength2(maxMessageSize));
    const flagField = 1 + encodingLength2(Object.keys(Message2.Flag).length - 1);
    const messageFieldIdType = 1;
    const available = maxMessageSize - messageLength - flagField - messageFieldIdType;
    const messageFieldLengthLength = encodingLength2(available);
    return messageLength + flagField + messageFieldIdType + messageFieldLengthLength;
  }
  var PROTOBUF_OVERHEAD = calculateProtobufOverhead();
  var FIN_ACK_TIMEOUT = 5e3;
  var OPEN_TIMEOUT = 5e3;
  var DATA_CHANNEL_DRAIN_TIMEOUT = 3e4;
  var MUXER_PROTOCOL = "/webrtc";
  var SIGNALING_PROTOCOL = "/webrtc-signaling/0.0.1";

  // node_modules/@libp2p/webrtc/dist/src/maconn.js
  var import_browser_shims419 = __toESM(require_browser_shims(), 1);

  // node_modules/@libp2p/webrtc/dist/src/util.js
  var import_browser_shims418 = __toESM(require_browser_shims(), 1);

  // node_modules/detect-browser/es/index.js
  var import_browser_shims417 = __toESM(require_browser_shims());
  var __spreadArray = function(to, from3, pack) {
    if (pack || arguments.length === 2) for (var i = 0, l = from3.length, ar; i < l; i++) {
      if (ar || !(i in from3)) {
        if (!ar) ar = Array.prototype.slice.call(from3, 0, i);
        ar[i] = from3[i];
      }
    }
    return to.concat(ar || Array.prototype.slice.call(from3));
  };
  var BrowserInfo = (
    /** @class */
    /* @__PURE__ */ function() {
      function BrowserInfo2(name3, version2, os) {
        this.name = name3;
        this.version = version2;
        this.os = os;
        this.type = "browser";
      }
      return BrowserInfo2;
    }()
  );
  var NodeInfo = (
    /** @class */
    /* @__PURE__ */ function() {
      function NodeInfo2(version2) {
        this.version = version2;
        this.type = "node";
        this.name = "node";
        this.os = process.platform;
      }
      return NodeInfo2;
    }()
  );
  var SearchBotDeviceInfo = (
    /** @class */
    /* @__PURE__ */ function() {
      function SearchBotDeviceInfo2(name3, version2, os, bot) {
        this.name = name3;
        this.version = version2;
        this.os = os;
        this.bot = bot;
        this.type = "bot-device";
      }
      return SearchBotDeviceInfo2;
    }()
  );
  var BotInfo = (
    /** @class */
    /* @__PURE__ */ function() {
      function BotInfo2() {
        this.type = "bot";
        this.bot = true;
        this.name = "bot";
        this.version = null;
        this.os = null;
      }
      return BotInfo2;
    }()
  );
  var ReactNativeInfo = (
    /** @class */
    /* @__PURE__ */ function() {
      function ReactNativeInfo2() {
        this.type = "react-native";
        this.name = "react-native";
        this.version = null;
        this.os = null;
      }
      return ReactNativeInfo2;
    }()
  );
  var SEARCHBOX_UA_REGEX = /alexa|bot|crawl(er|ing)|facebookexternalhit|feedburner|google web preview|nagios|postrank|pingdom|slurp|spider|yahoo!|yandex/;
  var SEARCHBOT_OS_REGEX = /(nuhk|curl|Googlebot|Yammybot|Openbot|Slurp|MSNBot|Ask\ Jeeves\/Teoma|ia_archiver)/;
  var REQUIRED_VERSION_PARTS = 3;
  var userAgentRules = [
    ["aol", /AOLShield\/([0-9\._]+)/],
    ["edge", /Edge\/([0-9\._]+)/],
    ["edge-ios", /EdgiOS\/([0-9\._]+)/],
    ["yandexbrowser", /YaBrowser\/([0-9\._]+)/],
    ["kakaotalk", /KAKAOTALK\s([0-9\.]+)/],
    ["samsung", /SamsungBrowser\/([0-9\.]+)/],
    ["silk", /\bSilk\/([0-9._-]+)\b/],
    ["miui", /MiuiBrowser\/([0-9\.]+)$/],
    ["beaker", /BeakerBrowser\/([0-9\.]+)/],
    ["edge-chromium", /EdgA?\/([0-9\.]+)/],
    [
      "chromium-webview",
      /(?!Chrom.*OPR)wv\).*Chrom(?:e|ium)\/([0-9\.]+)(:?\s|$)/
    ],
    ["chrome", /(?!Chrom.*OPR)Chrom(?:e|ium)\/([0-9\.]+)(:?\s|$)/],
    ["phantomjs", /PhantomJS\/([0-9\.]+)(:?\s|$)/],
    ["crios", /CriOS\/([0-9\.]+)(:?\s|$)/],
    ["firefox", /Firefox\/([0-9\.]+)(?:\s|$)/],
    ["fxios", /FxiOS\/([0-9\.]+)/],
    ["opera-mini", /Opera Mini.*Version\/([0-9\.]+)/],
    ["opera", /Opera\/([0-9\.]+)(?:\s|$)/],
    ["opera", /OPR\/([0-9\.]+)(:?\s|$)/],
    ["pie", /^Microsoft Pocket Internet Explorer\/(\d+\.\d+)$/],
    ["pie", /^Mozilla\/\d\.\d+\s\(compatible;\s(?:MSP?IE|MSInternet Explorer) (\d+\.\d+);.*Windows CE.*\)$/],
    ["netfront", /^Mozilla\/\d\.\d+.*NetFront\/(\d.\d)/],
    ["ie", /Trident\/7\.0.*rv\:([0-9\.]+).*\).*Gecko$/],
    ["ie", /MSIE\s([0-9\.]+);.*Trident\/[4-7].0/],
    ["ie", /MSIE\s(7\.0)/],
    ["bb10", /BB10;\sTouch.*Version\/([0-9\.]+)/],
    ["android", /Android\s([0-9\.]+)/],
    ["ios", /Version\/([0-9\._]+).*Mobile.*Safari.*/],
    ["safari", /Version\/([0-9\._]+).*Safari/],
    ["facebook", /FB[AS]V\/([0-9\.]+)/],
    ["instagram", /Instagram\s([0-9\.]+)/],
    ["ios-webview", /AppleWebKit\/([0-9\.]+).*Mobile/],
    ["ios-webview", /AppleWebKit\/([0-9\.]+).*Gecko\)$/],
    ["curl", /^curl\/([0-9\.]+)$/],
    ["searchbot", SEARCHBOX_UA_REGEX]
  ];
  var operatingSystemRules = [
    ["iOS", /iP(hone|od|ad)/],
    ["Android OS", /Android/],
    ["BlackBerry OS", /BlackBerry|BB10/],
    ["Windows Mobile", /IEMobile/],
    ["Amazon OS", /Kindle/],
    ["Windows 3.11", /Win16/],
    ["Windows 95", /(Windows 95)|(Win95)|(Windows_95)/],
    ["Windows 98", /(Windows 98)|(Win98)/],
    ["Windows 2000", /(Windows NT 5.0)|(Windows 2000)/],
    ["Windows XP", /(Windows NT 5.1)|(Windows XP)/],
    ["Windows Server 2003", /(Windows NT 5.2)/],
    ["Windows Vista", /(Windows NT 6.0)/],
    ["Windows 7", /(Windows NT 6.1)/],
    ["Windows 8", /(Windows NT 6.2)/],
    ["Windows 8.1", /(Windows NT 6.3)/],
    ["Windows 10", /(Windows NT 10.0)/],
    ["Windows ME", /Windows ME/],
    ["Windows CE", /Windows CE|WinCE|Microsoft Pocket Internet Explorer/],
    ["Open BSD", /OpenBSD/],
    ["Sun OS", /SunOS/],
    ["Chrome OS", /CrOS/],
    ["Linux", /(Linux)|(X11)/],
    ["Mac OS", /(Mac_PowerPC)|(Macintosh)/],
    ["QNX", /QNX/],
    ["BeOS", /BeOS/],
    ["OS/2", /OS\/2/]
  ];
  function detect(userAgent2) {
    if (!!userAgent2) {
      return parseUserAgent(userAgent2);
    }
    if (typeof document === "undefined" && typeof navigator !== "undefined" && navigator.product === "ReactNative") {
      return new ReactNativeInfo();
    }
    if (typeof navigator !== "undefined") {
      return parseUserAgent(navigator.userAgent);
    }
    return getNodeVersion();
  }
  function matchUserAgent(ua) {
    return ua !== "" && userAgentRules.reduce(function(matched, _a2) {
      var browser2 = _a2[0], regex = _a2[1];
      if (matched) {
        return matched;
      }
      var uaMatch = regex.exec(ua);
      return !!uaMatch && [browser2, uaMatch];
    }, false);
  }
  function parseUserAgent(ua) {
    var matchedRule = matchUserAgent(ua);
    if (!matchedRule) {
      return null;
    }
    var name3 = matchedRule[0], match = matchedRule[1];
    if (name3 === "searchbot") {
      return new BotInfo();
    }
    var versionParts = match[1] && match[1].split(".").join("_").split("_").slice(0, 3);
    if (versionParts) {
      if (versionParts.length < REQUIRED_VERSION_PARTS) {
        versionParts = __spreadArray(__spreadArray([], versionParts, true), createVersionParts(REQUIRED_VERSION_PARTS - versionParts.length), true);
      }
    } else {
      versionParts = [];
    }
    var version2 = versionParts.join(".");
    var os = detectOS(ua);
    var searchBotMatch = SEARCHBOT_OS_REGEX.exec(ua);
    if (searchBotMatch && searchBotMatch[1]) {
      return new SearchBotDeviceInfo(name3, version2, os, searchBotMatch[1]);
    }
    return new BrowserInfo(name3, version2, os);
  }
  function detectOS(ua) {
    for (var ii = 0, count = operatingSystemRules.length; ii < count; ii++) {
      var _a2 = operatingSystemRules[ii], os = _a2[0], regex = _a2[1];
      var match = regex.exec(ua);
      if (match) {
        return os;
      }
    }
    return null;
  }
  function getNodeVersion() {
    var isNode = typeof process !== "undefined" && process.version;
    return isNode ? new NodeInfo(process.version.slice(1)) : null;
  }
  function createVersionParts(count) {
    var output = [];
    for (var ii = 0; ii < count; ii++) {
      output.push("0");
    }
    return output;
  }

  // node_modules/@libp2p/webrtc/dist/src/util.js
  var browser = detect();
  var isFirefox = browser != null && browser.name === "firefox";
  var nopSource = async function* nop() {
  };
  var nopSink = async (_) => {
  };
  function drainAndClose(channel, direction, drainTimeout = DATA_CHANNEL_DRAIN_TIMEOUT, options) {
    if (channel.readyState !== "open") {
      return;
    }
    void Promise.resolve().then(async () => {
      if (channel.bufferedAmount > 0) {
        options.log("%s drain channel with %d buffered bytes", direction, channel.bufferedAmount);
        const deferred = pDefer();
        let drained = false;
        channel.bufferedAmountLowThreshold = 0;
        const closeListener = () => {
          if (!drained) {
            options.log("%s drain channel closed before drain", direction);
            deferred.resolve();
          }
        };
        channel.addEventListener("close", closeListener, {
          once: true
        });
        channel.addEventListener("bufferedamountlow", () => {
          drained = true;
          channel.removeEventListener("close", closeListener);
          deferred.resolve();
        });
        await pTimeout(deferred.promise, {
          milliseconds: drainTimeout
        });
      }
    }).then(async () => {
      if (channel.readyState === "open") {
        channel.close();
      }
    }).catch((err) => {
      options.log.error("error closing outbound stream", err);
    });
  }
  async function getRtcConfiguration(config) {
    config = config ?? {};
    if (typeof config === "function") {
      config = await config();
    }
    config.iceServers = config.iceServers ?? DEFAULT_ICE_SERVERS.map((url) => ({
      urls: [
        url
      ]
    }));
    return config;
  }

  // node_modules/@libp2p/webrtc/dist/src/maconn.js
  var WebRTCMultiaddrConnection = class {
    log;
    /**
     * WebRTC Peer Connection
     */
    peerConnection;
    /**
     * The multiaddr address used to communicate with the remote peer
     */
    remoteAddr;
    /**
     * Holds the life cycle times of the connection
     */
    timeline;
    /**
     * Optional metrics counter group for this connection
     */
    metrics;
    /**
     * The stream source, a no-op as the transport natively supports multiplexing
     */
    source = nopSource();
    /**
     * The stream destination, a no-op as the transport natively supports multiplexing
     */
    sink = nopSink;
    constructor(components, init) {
      this.log = components.logger.forComponent("libp2p:webrtc:maconn");
      this.remoteAddr = init.remoteAddr;
      this.timeline = init.timeline;
      this.peerConnection = init.peerConnection;
      const peerConnection = this.peerConnection;
      const initialState = peerConnection.connectionState;
      this.peerConnection.onconnectionstatechange = () => {
        this.log.trace("peer connection state change", peerConnection.connectionState, "initial state", initialState);
        if (peerConnection.connectionState === "disconnected" || peerConnection.connectionState === "failed" || peerConnection.connectionState === "closed") {
          this.timeline.close = Date.now();
        }
      };
    }
    async close(options) {
      var _a2;
      this.log.trace("closing connection");
      this.peerConnection.close();
      this.timeline.close = Date.now();
      (_a2 = this.metrics) == null ? void 0 : _a2.increment({ close: true });
    }
    abort(err) {
      var _a2;
      this.log.error("closing connection due to error", err);
      this.peerConnection.close();
      this.timeline.close = Date.now();
      (_a2 = this.metrics) == null ? void 0 : _a2.increment({ abort: true });
    }
  };

  // node_modules/@libp2p/webrtc/dist/src/muxer.js
  var import_browser_shims427 = __toESM(require_browser_shims(), 1);

  // node_modules/@libp2p/webrtc/dist/src/stream.js
  var import_browser_shims426 = __toESM(require_browser_shims(), 1);

  // node_modules/@libp2p/webrtc/node_modules/it-length-prefixed/dist/src/index.js
  var import_browser_shims425 = __toESM(require_browser_shims(), 1);

  // node_modules/@libp2p/webrtc/node_modules/it-length-prefixed/dist/src/encode.js
  var import_browser_shims423 = __toESM(require_browser_shims(), 1);

  // node_modules/@libp2p/webrtc/node_modules/it-length-prefixed/dist/src/constants.js
  var import_browser_shims420 = __toESM(require_browser_shims(), 1);
  var MAX_LENGTH_LENGTH4 = 8;
  var MAX_DATA_LENGTH4 = 1024 * 1024 * 4;

  // node_modules/@libp2p/webrtc/node_modules/it-length-prefixed/dist/src/errors.js
  var import_browser_shims421 = __toESM(require_browser_shims(), 1);
  var InvalidMessageLengthError6 = class extends Error {
    name = "InvalidMessageLengthError";
    code = "ERR_INVALID_MSG_LENGTH";
  };
  var InvalidDataLengthError6 = class extends Error {
    name = "InvalidDataLengthError";
    code = "ERR_MSG_DATA_TOO_LONG";
  };
  var InvalidDataLengthLengthError6 = class extends Error {
    name = "InvalidDataLengthLengthError";
    code = "ERR_MSG_LENGTH_TOO_LONG";
  };
  var UnexpectedEOFError6 = class extends Error {
    name = "UnexpectedEOFError";
    code = "ERR_UNEXPECTED_EOF";
  };

  // node_modules/@libp2p/webrtc/node_modules/it-length-prefixed/dist/src/utils.js
  var import_browser_shims422 = __toESM(require_browser_shims(), 1);
  function isAsyncIterable14(thing) {
    return thing[Symbol.asyncIterator] != null;
  }

  // node_modules/@libp2p/webrtc/node_modules/it-length-prefixed/dist/src/encode.js
  function validateMaxDataLength3(chunk, maxDataLength) {
    if (chunk.byteLength > maxDataLength) {
      throw new InvalidDataLengthError6("Message length too long");
    }
  }
  var defaultEncoder4 = (length4) => {
    const lengthLength = encodingLength2(length4);
    const lengthBuf = allocUnsafe(lengthLength);
    encode5(length4, lengthBuf);
    defaultEncoder4.bytes = lengthLength;
    return lengthBuf;
  };
  defaultEncoder4.bytes = 0;
  function encode9(source, options) {
    options = options ?? {};
    const encodeLength2 = options.lengthEncoder ?? defaultEncoder4;
    const maxDataLength = (options == null ? void 0 : options.maxDataLength) ?? MAX_DATA_LENGTH4;
    function* maybeYield(chunk) {
      validateMaxDataLength3(chunk, maxDataLength);
      const length4 = encodeLength2(chunk.byteLength);
      if (length4 instanceof Uint8Array) {
        yield length4;
      } else {
        yield* length4;
      }
      if (chunk instanceof Uint8Array) {
        yield chunk;
      } else {
        yield* chunk;
      }
    }
    if (isAsyncIterable14(source)) {
      return async function* () {
        for await (const chunk of source) {
          yield* maybeYield(chunk);
        }
      }();
    }
    return function* () {
      for (const chunk of source) {
        yield* maybeYield(chunk);
      }
    }();
  }
  encode9.single = (chunk, options) => {
    options = options ?? {};
    const encodeLength2 = options.lengthEncoder ?? defaultEncoder4;
    const maxDataLength = (options == null ? void 0 : options.maxDataLength) ?? MAX_DATA_LENGTH4;
    validateMaxDataLength3(chunk, maxDataLength);
    return new Uint8ArrayList(encodeLength2(chunk.byteLength), chunk);
  };

  // node_modules/@libp2p/webrtc/node_modules/it-length-prefixed/dist/src/decode.js
  var import_browser_shims424 = __toESM(require_browser_shims(), 1);
  var ReadMode4;
  (function(ReadMode5) {
    ReadMode5[ReadMode5["LENGTH"] = 0] = "LENGTH";
    ReadMode5[ReadMode5["DATA"] = 1] = "DATA";
  })(ReadMode4 || (ReadMode4 = {}));
  var defaultDecoder4 = (buf) => {
    const length4 = decode6(buf);
    defaultDecoder4.bytes = encodingLength2(length4);
    return length4;
  };
  defaultDecoder4.bytes = 0;
  function decode10(source, options) {
    const buffer = new Uint8ArrayList();
    let mode = ReadMode4.LENGTH;
    let dataLength = -1;
    const lengthDecoder = (options == null ? void 0 : options.lengthDecoder) ?? defaultDecoder4;
    const maxLengthLength = (options == null ? void 0 : options.maxLengthLength) ?? MAX_LENGTH_LENGTH4;
    const maxDataLength = (options == null ? void 0 : options.maxDataLength) ?? MAX_DATA_LENGTH4;
    function* maybeYield() {
      while (buffer.byteLength > 0) {
        if (mode === ReadMode4.LENGTH) {
          try {
            dataLength = lengthDecoder(buffer);
            if (dataLength < 0) {
              throw new InvalidMessageLengthError6("Invalid message length");
            }
            if (dataLength > maxDataLength) {
              throw new InvalidDataLengthError6("Message length too long");
            }
            const dataLengthLength = lengthDecoder.bytes;
            buffer.consume(dataLengthLength);
            if ((options == null ? void 0 : options.onLength) != null) {
              options.onLength(dataLength);
            }
            mode = ReadMode4.DATA;
          } catch (err) {
            if (err instanceof RangeError) {
              if (buffer.byteLength > maxLengthLength) {
                throw new InvalidDataLengthLengthError6("Message length length too long");
              }
              break;
            }
            throw err;
          }
        }
        if (mode === ReadMode4.DATA) {
          if (buffer.byteLength < dataLength) {
            break;
          }
          const data = buffer.sublist(0, dataLength);
          buffer.consume(dataLength);
          if ((options == null ? void 0 : options.onData) != null) {
            options.onData(data);
          }
          yield data;
          mode = ReadMode4.LENGTH;
        }
      }
    }
    if (isAsyncIterable14(source)) {
      return async function* () {
        for await (const buf of source) {
          buffer.append(buf);
          yield* maybeYield();
        }
        if (buffer.byteLength > 0) {
          throw new UnexpectedEOFError6("Unexpected end of input");
        }
      }();
    }
    return function* () {
      for (const buf of source) {
        buffer.append(buf);
        yield* maybeYield();
      }
      if (buffer.byteLength > 0) {
        throw new UnexpectedEOFError6("Unexpected end of input");
      }
    }();
  }
  decode10.fromReader = (reader, options) => {
    let byteLength = 1;
    const varByteSource = async function* () {
      while (true) {
        try {
          const { done, value } = await reader.next(byteLength);
          if (done === true) {
            return;
          }
          if (value != null) {
            yield value;
          }
        } catch (err) {
          if (err.code === "ERR_UNDER_READ") {
            return { done: true, value: null };
          }
          throw err;
        } finally {
          byteLength = 1;
        }
      }
    }();
    const onLength = (l) => {
      byteLength = l;
    };
    return decode10(varByteSource, {
      ...options ?? {},
      onLength
    });
  };

  // node_modules/@libp2p/webrtc/dist/src/stream.js
  var WebRTCStream = class extends AbstractStream {
    /**
     * The data channel used to send and receive data
     */
    channel;
    /**
     * push data from the underlying datachannel to the length prefix decoder
     * and then the protobuf decoder.
     */
    incomingData;
    maxBufferedAmount;
    bufferedAmountLowEventTimeout;
    /**
     * The maximum size of a message in bytes
     */
    maxMessageSize;
    /**
     * When this promise is resolved, the remote has sent us a FIN flag
     */
    receiveFinAck;
    finAckTimeout;
    openTimeout;
    closeController;
    constructor(init) {
      const originalOnEnd = init.onEnd;
      init.onEnd = (err) => {
        this.log.trace('readable and writeable ends closed with status "%s"', this.status);
        void Promise.resolve(async () => {
          if (this.timeline.abort != null || this.timeline.reset !== null) {
            return;
          }
          try {
            await pTimeout(this.receiveFinAck.promise, {
              milliseconds: this.finAckTimeout
            });
          } catch (err2) {
            this.log.error("error receiving FIN_ACK", err2);
          }
        }).then(() => {
          this.incomingData.end();
          originalOnEnd == null ? void 0 : originalOnEnd(err);
        }).catch((err2) => {
          this.log.error("error ending stream", err2);
        }).finally(() => {
          this.channel.close();
        });
      };
      super(init);
      this.channel = init.channel;
      this.channel.binaryType = "arraybuffer";
      this.incomingData = pushable();
      this.bufferedAmountLowEventTimeout = init.bufferedAmountLowEventTimeout ?? BUFFERED_AMOUNT_LOW_TIMEOUT;
      this.maxBufferedAmount = init.maxBufferedAmount ?? MAX_BUFFERED_AMOUNT;
      this.maxMessageSize = (init.maxMessageSize ?? MAX_MESSAGE_SIZE) - PROTOBUF_OVERHEAD;
      this.receiveFinAck = pDefer();
      this.finAckTimeout = init.closeTimeout ?? FIN_ACK_TIMEOUT;
      this.openTimeout = init.openTimeout ?? OPEN_TIMEOUT;
      this.closeController = new AbortController();
      switch (this.channel.readyState) {
        case "open":
          this.timeline.open = (/* @__PURE__ */ new Date()).getTime();
          break;
        case "closed":
        case "closing":
          if (this.timeline.close === void 0 || this.timeline.close === 0) {
            this.timeline.close = Date.now();
          }
          break;
        case "connecting":
          break;
        default:
          this.log.error("unknown datachannel state %s", this.channel.readyState);
          throw new StreamStateError("Unknown datachannel state");
      }
      this.channel.onopen = (_evt) => {
        this.timeline.open = (/* @__PURE__ */ new Date()).getTime();
      };
      this.channel.onclose = (_evt) => {
        this.log.trace("received onclose event");
        this.closeController.abort();
        this.receiveFinAck.resolve();
        void this.close().catch((err) => {
          this.log.error("error closing stream after channel closed", err);
        });
      };
      this.channel.onerror = (evt) => {
        this.log.trace("received onerror event");
        this.closeController.abort();
        const err = evt.error;
        this.abort(err);
      };
      this.channel.onmessage = async (event) => {
        const { data } = event;
        if (data === null || data.byteLength === 0) {
          return;
        }
        this.incomingData.push(new Uint8Array(data, 0, data.byteLength));
      };
      const self = this;
      Promise.resolve().then(async () => {
        for await (const buf of decode10(this.incomingData)) {
          const message2 = self.processIncomingProtobuf(buf);
          if (message2 != null) {
            self.sourcePush(new Uint8ArrayList(message2));
          }
        }
      }).catch((err) => {
        this.log.error("error processing incoming data channel messages", err);
      });
    }
    sendNewStream() {
    }
    async _sendMessage(data, checkBuffer = true) {
      if (this.channel.readyState === "closed" || this.channel.readyState === "closing") {
        throw new StreamStateError(`Invalid datachannel state - ${this.channel.readyState}`);
      }
      if (this.channel.readyState !== "open") {
        const timeout = AbortSignal.timeout(this.openTimeout);
        const signal = anySignal([
          this.closeController.signal,
          timeout
        ]);
        try {
          this.log('channel state is "%s" and not "open", waiting for "open" event before sending data', this.channel.readyState);
          await raceEvent(this.channel, "open", signal);
        } finally {
          signal.clear();
        }
        this.log('channel state is now "%s", sending data', this.channel.readyState);
      }
      if (checkBuffer && this.channel.bufferedAmount > this.maxBufferedAmount) {
        const timeout = AbortSignal.timeout(this.bufferedAmountLowEventTimeout);
        const signal = anySignal([
          this.closeController.signal,
          timeout
        ]);
        try {
          this.log('channel buffer is %d, wait for "bufferedamountlow" event', this.channel.bufferedAmount);
          await raceEvent(this.channel, "bufferedamountlow", signal);
        } catch (err) {
          if (timeout.aborted) {
            throw new TimeoutError(`Timed out waiting for DataChannel buffer to clear after ${this.bufferedAmountLowEventTimeout}ms`);
          }
          throw err;
        } finally {
          signal.clear();
        }
      }
      try {
        this.log.trace('sending message, channel state "%s"', this.channel.readyState);
        this.channel.send(data.subarray());
      } catch (err) {
        this.log.error("error while sending message", err);
      }
    }
    async sendData(data) {
      const bytesTotal = data.byteLength;
      data = data.sublist();
      while (data.byteLength > 0) {
        const toSend = Math.min(data.byteLength, this.maxMessageSize);
        const buf = data.subarray(0, toSend);
        const messageBuf = Message2.encode({ message: buf });
        const sendBuf = encode9.single(messageBuf);
        this.log.trace("sending %d/%d bytes on channel", buf.byteLength, bytesTotal);
        await this._sendMessage(sendBuf);
        data.consume(toSend);
      }
      this.log.trace('finished sending data, channel state "%s"', this.channel.readyState);
    }
    async sendReset() {
      try {
        await this._sendFlag(Message2.Flag.RESET);
      } catch (err) {
        this.log.error("failed to send reset - %e", err);
      } finally {
        this.channel.close();
      }
    }
    async sendCloseWrite(options) {
      if (this.channel.readyState !== "open") {
        this.receiveFinAck.resolve();
        return;
      }
      const sent = await this._sendFlag(Message2.Flag.FIN);
      if (sent) {
        this.log.trace("awaiting FIN_ACK");
        try {
          await raceSignal(this.receiveFinAck.promise, options == null ? void 0 : options.signal, {
            errorMessage: "sending close-write was aborted before FIN_ACK was received",
            errorName: "FinAckNotReceivedError"
          });
        } catch (err) {
          this.log.error("failed to await FIN_ACK", err);
        }
      } else {
        this.log.trace("sending FIN failed, not awaiting FIN_ACK");
      }
      this.receiveFinAck.resolve();
    }
    async sendCloseRead() {
      if (this.channel.readyState !== "open") {
        return;
      }
      await this._sendFlag(Message2.Flag.STOP_SENDING);
    }
    /**
     * Handle incoming
     */
    processIncomingProtobuf(buffer) {
      const message2 = Message2.decode(buffer);
      if (message2.flag !== void 0) {
        this.log.trace('incoming flag %s, write status "%s", read status "%s"', message2.flag, this.writeStatus, this.readStatus);
        if (message2.flag === Message2.Flag.FIN) {
          this.remoteCloseWrite();
          this.log.trace("sending FIN_ACK");
          void this._sendFlag(Message2.Flag.FIN_ACK).catch((err) => {
            this.log.error("error sending FIN_ACK immediately", err);
          });
        }
        if (message2.flag === Message2.Flag.RESET) {
          this.reset();
        }
        if (message2.flag === Message2.Flag.STOP_SENDING) {
          this.remoteCloseRead();
        }
        if (message2.flag === Message2.Flag.FIN_ACK) {
          this.log.trace("received FIN_ACK");
          this.receiveFinAck.resolve();
        }
      }
      if (this.readStatus === "ready") {
        return message2.message;
      }
    }
    async _sendFlag(flag) {
      if (this.channel.readyState !== "open") {
        this.log.trace('not sending flag %s because channel is "%s" and not "open"', flag.toString(), this.channel.readyState);
        return false;
      }
      this.log.trace("sending flag %s", flag.toString());
      const messageBuf = Message2.encode({ flag });
      const prefixedBuf = encode9.single(messageBuf);
      try {
        await this._sendMessage(prefixedBuf, false);
        return true;
      } catch (err) {
        this.log.error("could not send flag %s - %e", flag.toString(), err);
      }
      return false;
    }
  };
  function createStream(options) {
    const { channel, direction, handshake } = options;
    return new WebRTCStream({
      id: `${channel.id}`,
      log: options.logger.forComponent(`libp2p:webrtc:stream:${handshake === true ? "handshake" : direction}:${channel.id}`),
      ...options
    });
  }

  // node_modules/@libp2p/webrtc/dist/src/muxer.js
  var DataChannelMuxerFactory = class {
    protocol;
    /**
     * WebRTC Peer Connection
     */
    peerConnection;
    bufferedStreams = [];
    metrics;
    dataChannelOptions;
    components;
    log;
    constructor(components, init) {
      this.components = components;
      this.peerConnection = init.peerConnection;
      this.metrics = init.metrics;
      this.protocol = init.protocol ?? MUXER_PROTOCOL;
      this.dataChannelOptions = init.dataChannelOptions ?? {};
      this.log = components.logger.forComponent("libp2p:webrtc:muxerfactory");
      this.peerConnection.ondatachannel = ({ channel }) => {
        this.log.trace('incoming early datachannel with channel id %d and label "%s"', channel.id);
        if (channel.label === "init") {
          this.log.trace("closing early init channel");
          channel.close();
          return;
        }
        const bufferedStream = {};
        const stream = createStream({
          channel,
          direction: "inbound",
          onEnd: (err) => {
            bufferedStream.onEnd(err);
          },
          logger: components.logger,
          ...this.dataChannelOptions
        });
        bufferedStream.stream = stream;
        bufferedStream.channel = channel;
        bufferedStream.onEnd = () => {
          this.bufferedStreams = this.bufferedStreams.filter((s2) => s2.stream.id !== stream.id);
        };
        this.bufferedStreams.push(bufferedStream);
      };
    }
    createStreamMuxer(init) {
      return new DataChannelMuxer(this.components, {
        ...init,
        peerConnection: this.peerConnection,
        dataChannelOptions: this.dataChannelOptions,
        metrics: this.metrics,
        streams: this.bufferedStreams,
        protocol: this.protocol
      });
    }
  };
  var DataChannelMuxer = class {
    init;
    /**
     * Array of streams in the data channel
     */
    streams;
    protocol;
    log;
    peerConnection;
    dataChannelOptions;
    metrics;
    logger;
    constructor(components, init) {
      this.init = init;
      this.log = components.logger.forComponent("libp2p:webrtc:muxer");
      this.logger = components.logger;
      this.streams = init.streams.map((s2) => s2.stream);
      this.peerConnection = init.peerConnection;
      this.protocol = init.protocol ?? MUXER_PROTOCOL;
      this.metrics = init.metrics;
      this.dataChannelOptions = init.dataChannelOptions ?? {};
      this.peerConnection.ondatachannel = ({ channel }) => {
        var _a2, _b2;
        this.log.trace("incoming datachannel with channel id %d", channel.id);
        if (channel.label === "init") {
          this.log.trace("closing init channel");
          channel.close();
          return;
        }
        const id = channel.id;
        const stream = createStream({
          channel,
          direction: "inbound",
          onEnd: () => {
            this.#onStreamEnd(stream, channel);
            this.log("incoming channel %s ended", id);
          },
          logger: this.logger,
          ...this.dataChannelOptions
        });
        this.streams.push(stream);
        (_a2 = this.metrics) == null ? void 0 : _a2.increment({ incoming_stream: true });
        (_b2 = init == null ? void 0 : init.onIncomingStream) == null ? void 0 : _b2.call(init, stream);
      };
      if (this.init.streams.length > 0) {
        queueMicrotask(() => {
          this.init.streams.forEach((bufferedStream) => {
            var _a2, _b2, _c;
            bufferedStream.onEnd = () => {
              this.log("incoming early channel %s ended with state %s", bufferedStream.channel.id, bufferedStream.channel.readyState);
              this.#onStreamEnd(bufferedStream.stream, bufferedStream.channel);
            };
            (_a2 = this.metrics) == null ? void 0 : _a2.increment({ incoming_stream: true });
            (_c = (_b2 = this.init) == null ? void 0 : _b2.onIncomingStream) == null ? void 0 : _c.call(_b2, bufferedStream.stream);
          });
        });
      }
    }
    #onStreamEnd(stream, channel) {
      var _a2, _b2, _c;
      this.log.trace("stream %s %s %s onEnd", stream.direction, stream.id, stream.protocol);
      drainAndClose(channel, `${stream.direction} ${stream.id} ${stream.protocol}`, this.dataChannelOptions.drainTimeout, {
        log: this.log
      });
      this.streams = this.streams.filter((s2) => s2.id !== stream.id);
      (_a2 = this.metrics) == null ? void 0 : _a2.increment({ stream_end: true });
      (_c = (_b2 = this.init) == null ? void 0 : _b2.onStreamEnd) == null ? void 0 : _c.call(_b2, stream);
    }
    /**
     * Gracefully close all tracked streams and stop the muxer
     */
    async close(options) {
      try {
        await Promise.all(this.streams.map(async (stream) => stream.close(options)));
      } catch (err) {
        this.abort(err);
      }
    }
    /**
     * Abort all tracked streams and stop the muxer
     */
    abort(err) {
      for (const stream of this.streams) {
        stream.abort(err);
      }
    }
    /**
     * The stream source, a no-op as the transport natively supports multiplexing
     */
    source = nopSource();
    /**
     * The stream destination, a no-op as the transport natively supports multiplexing
     */
    sink = nopSink;
    newStream() {
      var _a2;
      const channel = this.peerConnection.createDataChannel("");
      const id = channel.id;
      this.log.trace("opened outgoing datachannel with channel id %s", id);
      const stream = createStream({
        channel,
        direction: "outbound",
        onEnd: () => {
          this.#onStreamEnd(stream, channel);
          this.log("outgoing channel %s ended", id);
        },
        logger: this.logger,
        ...this.dataChannelOptions
      });
      this.streams.push(stream);
      (_a2 = this.metrics) == null ? void 0 : _a2.increment({ outgoing_stream: true });
      return stream;
    }
  };

  // node_modules/@libp2p/webrtc/dist/src/webrtc/index.browser.js
  var import_browser_shims428 = __toESM(require_browser_shims(), 1);
  var RTCPeerConnection = globalThis.RTCPeerConnection;
  var RTCSessionDescription = globalThis.RTCSessionDescription;
  var RTCIceCandidate = globalThis.RTCIceCandidate;

  // node_modules/@libp2p/webrtc/dist/src/private-to-private/initiate-connection.js
  var import_browser_shims432 = __toESM(require_browser_shims(), 1);

  // node_modules/@libp2p/webrtc/dist/src/error.js
  var import_browser_shims429 = __toESM(require_browser_shims(), 1);
  var WebRTCTransportError = class extends Error {
    constructor(msg) {
      super(`WebRTC transport error: ${msg}`);
      this.name = "WebRTCTransportError";
    }
  };
  var SDPHandshakeFailedError = class extends WebRTCTransportError {
    constructor(message2 = "SDP handshake failed") {
      super(message2);
      this.name = "SDPHandshakeFailedError";
    }
  };

  // node_modules/@libp2p/webrtc/dist/src/private-to-private/pb/message.js
  var import_browser_shims430 = __toESM(require_browser_shims(), 1);
  var Message3;
  (function(Message4) {
    let Type;
    (function(Type2) {
      Type2["SDP_OFFER"] = "SDP_OFFER";
      Type2["SDP_ANSWER"] = "SDP_ANSWER";
      Type2["ICE_CANDIDATE"] = "ICE_CANDIDATE";
    })(Type = Message4.Type || (Message4.Type = {}));
    let __TypeValues;
    (function(__TypeValues2) {
      __TypeValues2[__TypeValues2["SDP_OFFER"] = 0] = "SDP_OFFER";
      __TypeValues2[__TypeValues2["SDP_ANSWER"] = 1] = "SDP_ANSWER";
      __TypeValues2[__TypeValues2["ICE_CANDIDATE"] = 2] = "ICE_CANDIDATE";
    })(__TypeValues || (__TypeValues = {}));
    (function(Type2) {
      Type2.codec = () => {
        return enumeration(__TypeValues);
      };
    })(Type = Message4.Type || (Message4.Type = {}));
    let _codec;
    Message4.codec = () => {
      if (_codec == null) {
        _codec = message((obj, w2, opts = {}) => {
          if (opts.lengthDelimited !== false) {
            w2.fork();
          }
          if (obj.type != null) {
            w2.uint32(8);
            Message4.Type.codec().encode(obj.type, w2);
          }
          if (obj.data != null) {
            w2.uint32(18);
            w2.string(obj.data);
          }
          if (opts.lengthDelimited !== false) {
            w2.ldelim();
          }
        }, (reader, length4, opts = {}) => {
          const obj = {};
          const end = length4 == null ? reader.len : reader.pos + length4;
          while (reader.pos < end) {
            const tag = reader.uint32();
            switch (tag >>> 3) {
              case 1: {
                obj.type = Message4.Type.codec().decode(reader);
                break;
              }
              case 2: {
                obj.data = reader.string();
                break;
              }
              default: {
                reader.skipType(tag & 7);
                break;
              }
            }
          }
          return obj;
        });
      }
      return _codec;
    };
    Message4.encode = (obj) => {
      return encodeMessage(obj, Message4.codec());
    };
    Message4.decode = (buf, opts) => {
      return decodeMessage(buf, Message4.codec(), opts);
    };
  })(Message3 || (Message3 = {}));

  // node_modules/@libp2p/webrtc/dist/src/private-to-private/util.js
  var import_browser_shims431 = __toESM(require_browser_shims(), 1);
  var readCandidatesUntilConnected = async (pc, stream, options) => {
    var _a2, _b2, _c, _d;
    try {
      const connectedPromise = pDefer();
      resolveOnConnected(pc, connectedPromise);
      while (true) {
        const message2 = await Promise.race([
          connectedPromise.promise,
          stream.read({
            signal: options.signal
          }).catch(() => {
          })
        ]);
        if (message2 == null) {
          (_a2 = options.signal) == null ? void 0 : _a2.throwIfAborted();
          break;
        }
        if (message2.type !== Message3.Type.ICE_CANDIDATE) {
          throw new InvalidMessageError("ICE candidate message expected");
        }
        const candidateInit = JSON.parse(message2.data ?? "null");
        if (candidateInit === "" || candidateInit === null) {
          (_b2 = options.onProgress) == null ? void 0 : _b2.call(options, new CustomProgressEvent("webrtc:end-of-ice-candidates"));
          options.log.trace("end-of-candidates received");
          continue;
        }
        const candidate = new RTCIceCandidate(candidateInit);
        options.log.trace("%s received new ICE candidate %o", options.direction, candidateInit);
        try {
          (_c = options.onProgress) == null ? void 0 : _c.call(options, new CustomProgressEvent("webrtc:add-ice-candidate", candidate.candidate));
          await pc.addIceCandidate(candidate);
        } catch (err) {
          options.log.error("%s bad candidate received", options.direction, candidateInit, err);
        }
      }
    } catch (err) {
      options.log.error("%s error parsing ICE candidate", options.direction, err);
      if (((_d = options.signal) == null ? void 0 : _d.aborted) === true && getConnectionState(pc) !== "connected") {
        throw err;
      }
    }
  };
  function getConnectionState(pc) {
    return isFirefox ? pc.iceConnectionState : pc.connectionState;
  }
  function resolveOnConnected(pc, promise) {
    pc[isFirefox ? "oniceconnectionstatechange" : "onconnectionstatechange"] = (_) => {
      switch (getConnectionState(pc)) {
        case "connected":
          promise.resolve();
          break;
        case "failed":
        case "disconnected":
        case "closed":
          promise.reject(new ConnectionFailedError("RTCPeerConnection was closed"));
          break;
        default:
          break;
      }
    };
  }

  // node_modules/@libp2p/webrtc/dist/src/private-to-private/initiate-connection.js
  async function initiateConnection({ rtcConfiguration, dataChannel, signal, metrics, multiaddr: ma, connectionManager, transportManager, log: log2, logger: logger2, onProgress }) {
    const { baseAddr } = splitAddr(ma);
    metrics == null ? void 0 : metrics.dialerEvents.increment({ open: true });
    log2.trace("dialing base address: %a", baseAddr);
    const relayPeer = baseAddr.getPeerId();
    if (relayPeer == null) {
      throw new InvalidParametersError("Relay peer was missing");
    }
    const connections = connectionManager.getConnections(peerIdFromString(relayPeer));
    let connection;
    let shouldCloseConnection = false;
    if (connections.length === 0) {
      onProgress == null ? void 0 : onProgress(new CustomProgressEvent("webrtc:dial-relay"));
      connection = await transportManager.dial(baseAddr, {
        signal,
        onProgress
      });
      shouldCloseConnection = true;
    } else {
      onProgress == null ? void 0 : onProgress(new CustomProgressEvent("webrtc:reuse-relay-connection"));
      connection = connections[0];
    }
    try {
      onProgress == null ? void 0 : onProgress(new CustomProgressEvent("webrtc:open-signaling-stream"));
      const stream = await connection.newStream(SIGNALING_PROTOCOL, {
        signal,
        runOnLimitedConnection: true
      });
      const messageStream = pbStream(stream).pb(Message3);
      const peerConnection = new RTCPeerConnection(rtcConfiguration);
      const muxerFactory = new DataChannelMuxerFactory({
        logger: logger2
      }, {
        peerConnection,
        dataChannelOptions: dataChannel
      });
      try {
        const channel = peerConnection.createDataChannel("init");
        peerConnection.onicecandidate = ({ candidate }) => {
          const data = JSON.stringify((candidate == null ? void 0 : candidate.toJSON()) ?? null);
          log2.trace("initiator sending ICE candidate %o", candidate);
          void messageStream.write({
            type: Message3.Type.ICE_CANDIDATE,
            data
          }, {
            signal
          }).catch((err) => {
            log2.error("error sending ICE candidate", err);
          });
        };
        peerConnection.onicecandidateerror = (event) => {
          log2.error("initiator ICE candidate error", event);
        };
        const offerSdp = await peerConnection.createOffer().catch((err) => {
          log2.error("could not execute createOffer", err);
          throw new SDPHandshakeFailedError("Failed to set createOffer");
        });
        log2.trace("initiator send SDP offer %s", offerSdp.sdp);
        onProgress == null ? void 0 : onProgress(new CustomProgressEvent("webrtc:send-sdp-offer"));
        await messageStream.write({ type: Message3.Type.SDP_OFFER, data: offerSdp.sdp }, {
          signal
        });
        await peerConnection.setLocalDescription(offerSdp).catch((err) => {
          log2.error("could not execute setLocalDescription", err);
          throw new SDPHandshakeFailedError("Failed to set localDescription");
        });
        onProgress == null ? void 0 : onProgress(new CustomProgressEvent("webrtc:read-sdp-answer"));
        log2.trace("initiator read SDP answer");
        const answerMessage = await messageStream.read({
          signal
        });
        if (answerMessage.type !== Message3.Type.SDP_ANSWER) {
          throw new SDPHandshakeFailedError("Remote should send an SDP answer");
        }
        log2.trace("initiator received SDP answer %s", answerMessage.data);
        const answerSdp = new RTCSessionDescription({ type: "answer", sdp: answerMessage.data });
        await peerConnection.setRemoteDescription(answerSdp).catch((err) => {
          log2.error("could not execute setRemoteDescription", err);
          throw new SDPHandshakeFailedError("Failed to set remoteDescription");
        });
        log2.trace("initiator read candidates until connected");
        onProgress == null ? void 0 : onProgress(new CustomProgressEvent("webrtc:read-ice-candidates"));
        await readCandidatesUntilConnected(peerConnection, messageStream, {
          direction: "initiator",
          signal,
          log: log2,
          onProgress
        });
        log2.trace("initiator connected, closing init channel");
        channel.close();
        onProgress == null ? void 0 : onProgress(new CustomProgressEvent("webrtc:close-signaling-stream"));
        log2.trace("closing signaling channel");
        await stream.close({
          signal
        });
        log2.trace("initiator connected to remote address %s", ma);
        return {
          remoteAddress: ma,
          peerConnection,
          muxerFactory
        };
      } catch (err) {
        log2.error("outgoing signaling error", err);
        peerConnection.close();
        stream.abort(err);
        throw err;
      } finally {
        peerConnection.onicecandidate = null;
        peerConnection.onicecandidateerror = null;
      }
    } finally {
      if (shouldCloseConnection) {
        try {
          await connection.close({
            signal
          });
        } catch (err) {
          connection.abort(err);
        }
      }
    }
  }

  // node_modules/@libp2p/webrtc/dist/src/private-to-private/listener.js
  var import_browser_shims433 = __toESM(require_browser_shims(), 1);
  var Circuit2 = fmt(P2P.matchers[0], literal("p2p-circuit"));
  var WebRTCPeerListener = class _WebRTCPeerListener extends TypedEventEmitter {
    transportManager;
    shutdownController;
    events;
    constructor(components, init) {
      super();
      this.transportManager = components.transportManager;
      this.events = components.events;
      this.shutdownController = init.shutdownController;
      this.onTransportListening = this.onTransportListening.bind(this);
    }
    async listen() {
      this.events.addEventListener("transport:listening", this.onTransportListening);
    }
    onTransportListening(event) {
      const circuitAddresses = event.detail.getAddrs().filter((ma) => Circuit2.exactMatch(ma)).map((ma) => {
        return ma.encapsulate("/webrtc");
      });
      if (circuitAddresses.length > 0) {
        this.safeDispatchEvent("listening");
      }
    }
    getAddrs() {
      return this.transportManager.getListeners().filter((l) => !(l instanceof _WebRTCPeerListener)).map((l) => l.getAddrs().filter((ma) => Circuit2.exactMatch(ma)).map((ma) => {
        return ma.encapsulate("/webrtc");
      })).flat();
    }
    updateAnnounceAddrs() {
    }
    async close() {
      this.events.removeEventListener("transport:listening", this.onTransportListening);
      this.shutdownController.abort();
      queueMicrotask(() => {
        this.safeDispatchEvent("close");
      });
    }
  };

  // node_modules/@libp2p/webrtc/dist/src/private-to-private/signaling-stream-handler.js
  var import_browser_shims434 = __toESM(require_browser_shims(), 1);
  async function handleIncomingStream({ peerConnection, stream, signal, connection, log: log2 }) {
    log2.trace("new inbound signaling stream");
    const messageStream = pbStream(stream).pb(Message3);
    try {
      peerConnection.onicecandidate = ({ candidate }) => {
        const data = JSON.stringify((candidate == null ? void 0 : candidate.toJSON()) ?? null);
        log2.trace("recipient sending ICE candidate %s", data);
        messageStream.write({
          type: Message3.Type.ICE_CANDIDATE,
          data
        }, {
          signal
        }).catch((err) => {
          log2.error("error sending ICE candidate", err);
        });
      };
      log2.trace("recipient read SDP offer");
      const pbOffer = await messageStream.read({
        signal
      });
      if (pbOffer.type !== Message3.Type.SDP_OFFER) {
        throw new SDPHandshakeFailedError(`expected message type SDP_OFFER, received: ${pbOffer.type ?? "undefined"} `);
      }
      log2.trace("recipient received SDP offer %s", pbOffer.data);
      const offer = new RTCSessionDescription({
        type: "offer",
        sdp: pbOffer.data
      });
      await peerConnection.setRemoteDescription(offer).catch((err) => {
        log2.error("could not execute setRemoteDescription", err);
        throw new SDPHandshakeFailedError("Failed to set remoteDescription");
      });
      const answer = await peerConnection.createAnswer().catch((err) => {
        log2.error("could not execute createAnswer", err);
        throw new SDPHandshakeFailedError("Failed to create answer");
      });
      log2.trace("recipient send SDP answer %s", answer.sdp);
      await messageStream.write({ type: Message3.Type.SDP_ANSWER, data: answer.sdp }, {
        signal
      });
      await peerConnection.setLocalDescription(answer).catch((err) => {
        log2.error("could not execute setLocalDescription", err);
        throw new SDPHandshakeFailedError("Failed to set localDescription");
      });
      log2.trace("recipient read candidates until connected");
      await readCandidatesUntilConnected(peerConnection, messageStream, {
        direction: "recipient",
        signal,
        log: log2
      });
    } catch (err) {
      if (getConnectionState(peerConnection) !== "connected") {
        log2.error("error while handling signaling stream from peer %a", connection.remoteAddr, err);
        peerConnection.close();
        throw err;
      } else {
        log2("error while handling signaling stream from peer %a, ignoring as the RTCPeerConnection is already connected", connection.remoteAddr, err);
      }
    }
    const remoteAddress = multiaddr(`/webrtc/p2p/${connection.remoteAddr.getPeerId()}`);
    log2.trace("recipient connected to remote address %s", remoteAddress);
    return { remoteAddress };
  }

  // node_modules/@libp2p/webrtc/dist/src/private-to-private/transport.js
  var WebRTCTransport = class {
    components;
    init;
    log;
    _started = false;
    metrics;
    shutdownController;
    constructor(components, init = {}) {
      this.components = components;
      this.init = init;
      this.log = components.logger.forComponent("libp2p:webrtc");
      this.shutdownController = new AbortController();
      setMaxListeners(Infinity, this.shutdownController.signal);
      if (components.metrics != null) {
        this.metrics = {
          dialerEvents: components.metrics.registerCounterGroup("libp2p_webrtc_dialer_events_total", {
            label: "event",
            help: "Total count of WebRTC dialer events by type"
          }),
          listenerEvents: components.metrics.registerCounterGroup("libp2p_webrtc_listener_events_total", {
            label: "event",
            help: "Total count of WebRTC listener events by type"
          })
        };
      }
    }
    [transportSymbol] = true;
    [Symbol.toStringTag] = "@libp2p/webrtc";
    [serviceCapabilities] = [
      "@libp2p/transport"
    ];
    [serviceDependencies] = [
      "@libp2p/identify",
      "@libp2p/circuit-relay-v2-transport"
    ];
    isStarted() {
      return this._started;
    }
    async start() {
      await this.components.registrar.handle(SIGNALING_PROTOCOL, (data) => {
        const signal = this.components.upgrader.createInboundAbortSignal(this.shutdownController.signal);
        this._onProtocol(data, signal).catch((err) => {
          this.log.error("failed to handle incoming connect from %p", data.connection.remotePeer, err);
        }).finally(() => {
          signal.clear();
        });
      }, {
        runOnLimitedConnection: true
      });
      this._started = true;
    }
    async stop() {
      await this.components.registrar.unhandle(SIGNALING_PROTOCOL);
      this._started = false;
    }
    createListener(options) {
      return new WebRTCPeerListener(this.components, {
        shutdownController: this.shutdownController
      });
    }
    /**
     * Filter check for all Multiaddrs that this transport can listen on
     */
    listenFilter(multiaddrs) {
      return multiaddrs.filter(WebRTC.exactMatch);
    }
    /**
     * Filter check for all Multiaddrs that this transport can dial
     */
    dialFilter(multiaddrs) {
      return this.listenFilter(multiaddrs);
    }
    /*
     * dial connects to a remote via the circuit relay or any other protocol
     * and proceeds to upgrade to a webrtc connection.
     * multiaddr of the form: <multiaddr>/webrtc/p2p/<destination-peer>
     * For a circuit relay, this will be of the form
     * <relay address>/p2p/<relay-peer>/p2p-circuit/webrtc/p2p/<destination-peer>
    */
    async dial(ma, options) {
      var _a2;
      this.log.trace("dialing address: %a", ma);
      const { remoteAddress, peerConnection, muxerFactory } = await initiateConnection({
        rtcConfiguration: await getRtcConfiguration(this.init.rtcConfiguration),
        dataChannel: this.init.dataChannel,
        multiaddr: ma,
        dataChannelOptions: this.init.dataChannel,
        signal: options.signal,
        connectionManager: this.components.connectionManager,
        transportManager: this.components.transportManager,
        log: this.log,
        logger: this.components.logger,
        onProgress: options.onProgress
      });
      const webRTCConn = new WebRTCMultiaddrConnection(this.components, {
        peerConnection,
        timeline: { open: Date.now() },
        remoteAddr: remoteAddress,
        metrics: (_a2 = this.metrics) == null ? void 0 : _a2.dialerEvents
      });
      const connection = await options.upgrader.upgradeOutbound(webRTCConn, {
        skipProtection: true,
        skipEncryption: true,
        muxerFactory,
        onProgress: options.onProgress,
        signal: options.signal
      });
      this._closeOnShutdown(peerConnection, webRTCConn);
      return connection;
    }
    async _onProtocol({ connection, stream }, signal) {
      var _a2;
      const peerConnection = new RTCPeerConnection(await getRtcConfiguration(this.init.rtcConfiguration));
      const muxerFactory = new DataChannelMuxerFactory(this.components, {
        peerConnection,
        dataChannelOptions: this.init.dataChannel
      });
      try {
        const { remoteAddress } = await handleIncomingStream({
          peerConnection,
          connection,
          stream,
          signal,
          log: this.log
        });
        await stream.close({
          signal
        });
        const webRTCConn = new WebRTCMultiaddrConnection(this.components, {
          peerConnection,
          timeline: { open: (/* @__PURE__ */ new Date()).getTime() },
          remoteAddr: remoteAddress,
          metrics: (_a2 = this.metrics) == null ? void 0 : _a2.listenerEvents
        });
        await this.components.upgrader.upgradeInbound(webRTCConn, {
          skipEncryption: true,
          skipProtection: true,
          muxerFactory,
          signal
        });
        this._closeOnShutdown(peerConnection, webRTCConn);
      } catch (err) {
        this.log.error("incoming signaling error", err);
        peerConnection.close();
        stream.abort(err);
        throw err;
      }
    }
    _closeOnShutdown(pc, webRTCConn) {
      const shutDownListener = () => {
        webRTCConn.close().catch((err) => {
          this.log.error("could not close WebRTCMultiaddrConnection", err);
        });
      };
      this.shutdownController.signal.addEventListener("abort", shutDownListener);
      pc.addEventListener("close", () => {
        this.shutdownController.signal.removeEventListener("abort", shutDownListener);
      });
    }
  };
  function splitAddr(ma) {
    const addrs = ma.toString().split("/webrtc/");
    if (addrs.length !== 2) {
      throw new InvalidParametersError("webrtc protocol was not present in multiaddr");
    }
    if (!addrs[0].includes("/p2p-circuit")) {
      throw new InvalidParametersError("p2p-circuit protocol was not present in multiaddr");
    }
    let remoteAddr = multiaddr(addrs[0]);
    const destination = multiaddr("/" + addrs[1]);
    const destinationIdString = destination.getPeerId();
    if (destinationIdString == null) {
      throw new InvalidParametersError("destination peer id was missing");
    }
    const lastProtoInRemote = remoteAddr.protos().pop();
    if (lastProtoInRemote === void 0) {
      throw new InvalidParametersError("invalid multiaddr");
    }
    if (lastProtoInRemote.name !== "p2p") {
      remoteAddr = remoteAddr.encapsulate(`/p2p/${destinationIdString}`);
    }
    return { baseAddr: remoteAddr, peerId: peerIdFromString(destinationIdString) };
  }

  // node_modules/@libp2p/webrtc/dist/src/index.js
  function webRTC(init) {
    return (components) => new WebRTCTransport(components, init);
  }

  // chrome-extension/libp2p-client.js
  var LibP2PClient = class {
    constructor() {
      this.node = null;
      this.isConnected = false;
      this.peerId = null;
      this.roomTopic = null;
      this.messageHandlers = /* @__PURE__ */ new Map();
      this.peers = /* @__PURE__ */ new Map();
    }
    async connect(_, roomId) {
      try {
        this.node = await createLibp2p({
          addresses: {
            listen: [
              // Listen on WebRTC for browser-to-browser connections
              "/webrtc"
            ]
          },
          transports: [
            webSockets({
              filter: all2
            }),
            webRTC()
          ],
          connectionEncryption: [noise()],
          streamMuxers: [yamux()],
          peerDiscovery: [],
          services: {
            identify: identify(),
            dht: kadDHT({
              clientMode: false
              // Run as full DHT node
            }),
            pubsub: gossipsub({
              allowPublishToZeroPeers: true,
              emitSelf: false,
              fallbackToFloodsub: true,
              floodPublish: false,
              doPX: false,
              msgIdFn: (msg) => {
                const decoder = new TextDecoder();
                decoder.decode(msg.data);
                return crypto.subtle.digest("SHA-256", msg.data).then((hash) => {
                  return Array.from(new Uint8Array(hash)).map((b) => b.toString(16).padStart(2, "0")).join("").substring(0, 20);
                });
              }
            })
          }
        });
        this.node.addEventListener("peer:connect", (evt) => {
          const peerId2 = evt.detail.toString();
          console.log("Connected to peer:", peerId2);
          this.handlePeerJoined(peerId2);
        });
        this.node.addEventListener("peer:disconnect", (evt) => {
          const peerId2 = evt.detail.toString();
          console.log("Disconnected from peer:", peerId2);
          this.handlePeerLeft(peerId2);
        });
        await this.node.start();
        this.peerId = this.node.peerId.toString();
        console.log("LibP2P node started with ID:", this.peerId);
        this.roomTopic = `bar123-room-${roomId}`;
        this.node.services.pubsub.subscribe(this.roomTopic);
        console.log("Subscribed to room topic:", this.roomTopic);
        this.node.services.pubsub.subscribe("bar123-history-sync");
        this.node.services.pubsub.addEventListener("message", (evt) => {
          this.handleMessage(evt.detail);
        });
        this.isConnected = true;
        console.log("Connected to libp2p network");
        await this.node.services.dht.refreshRoutingTable();
        console.log("DHT routing table refresh started");
      } catch (error) {
        console.error("Failed to create libp2p node:", error);
        throw error;
      }
    }
    async publish(data) {
      if (!this.node || !this.roomTopic) {
        console.warn("Not connected to a room");
        return;
      }
      try {
        const message2 = new TextEncoder().encode(JSON.stringify(data));
        await this.node.services.pubsub.publish(this.roomTopic, message2);
        console.log("Published message to room");
      } catch (error) {
        console.error("Failed to publish message:", error);
      }
    }
    handleMessage(evt) {
      try {
        if (evt.detail.from === this.peerId) {
          return;
        }
        const decoder = new TextDecoder();
        const data = JSON.parse(decoder.decode(evt.detail.data));
        console.log("Received message from", evt.detail.from, ":", data);
        const handler = this.messageHandlers.get("data");
        if (handler) {
          handler(data, evt.detail.from);
        }
      } catch (error) {
        console.error("Error handling message:", error);
      }
    }
    handlePeerJoined(peerId2) {
      this.peers.set(peerId2, { connected: true });
      const handler = this.messageHandlers.get("peer_joined");
      if (handler) {
        handler(peerId2);
      }
    }
    handlePeerLeft(peerId2) {
      this.peers.delete(peerId2);
      const handler = this.messageHandlers.get("peer_left");
      if (handler) {
        handler(peerId2);
      }
    }
    onPeerJoin(handler) {
      this.messageHandlers.set("peer_joined", handler);
    }
    onPeerLeave(handler) {
      this.messageHandlers.set("peer_left", handler);
    }
    onData(handler) {
      this.messageHandlers.set("data", handler);
    }
    onDisconnected(handler) {
      this.messageHandlers.set("disconnected", handler);
    }
    async disconnect() {
      if (this.node) {
        if (this.roomTopic) {
          this.node.services.pubsub.unsubscribe(this.roomTopic);
        }
        this.node.services.pubsub.unsubscribe("bar123-history-sync");
        await this.node.stop();
        this.node = null;
      }
      this.isConnected = false;
      this.peers.clear();
      const handler = this.messageHandlers.get("disconnected");
      if (handler) {
        handler();
      }
    }
    getPeers() {
      return Array.from(this.peers.keys());
    }
  };
  return __toCommonJS(libp2p_client_exports);
})();
/*! Bundled license information:

@noble/hashes/esm/utils.js:
  (*! noble-hashes - MIT License (c) 2022 Paul Miller (paulmillr.com) *)

@noble/curves/esm/abstract/utils.js:
@noble/curves/esm/abstract/modular.js:
@noble/curves/esm/abstract/curve.js:
@noble/curves/esm/abstract/edwards.js:
@noble/curves/esm/abstract/montgomery.js:
@noble/curves/esm/ed25519.js:
@noble/curves/esm/abstract/weierstrass.js:
@noble/curves/esm/_shortw_utils.js:
@noble/curves/esm/secp256k1.js:
  (*! noble-curves - MIT License (c) 2022 Paul Miller (paulmillr.com) *)

@noble/ciphers/esm/utils.js:
  (*! noble-ciphers - MIT License (c) 2023 Paul Miller (paulmillr.com) *)
*/
